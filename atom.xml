<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-20T08:17:29.694Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[MQTT简介]]></title>
        <id>https://kangjn.github.io/post/mqtt-jian-jie/</id>
        <link href="https://kangjn.github.io/post/mqtt-jian-jie/">
        </link>
        <updated>2021-04-20T07:59:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-简述">1 简述</h2>
<p>MQTT（Message Queuing  Telemetry  Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/59a771.JPEG" alt="img" loading="lazy"></figure>
<h2 id="2-设计规范">2 设计规范</h2>
<p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p>
<ul>
<li>精简，不添加可有可无的功能；</li>
<li>发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li>
<li>允许用户动态创建主题，零运维成本；</li>
<li>把传输量降到最低以提高传输效率；</li>
<li>把低带宽、高延迟、不稳定的网络等因素考虑在内；</li>
<li>支持连续的会话控制；</li>
<li>理解客户端计算能力可能很低；</li>
<li>提供服务质量管理；</li>
<li>假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<h2 id="3-主要特性">3 主要特性</h2>
<p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p>
<ul>
<li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，因为XMPP使用XML格式文本来传递数据。</li>
<li>对负载内容屏蔽的消息传输。</li>
<li>使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</li>
<li>有三种消息发布服务质量QoS (Quality of Service)：
<ul>
<li>At Most Once  至多一次，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</li>
<li>At Least Once 至少一次，确保消息到达，但消息重复可能会发生。</li>
<li>Exactly Once 有且仅有一次，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</li>
</ul>
</li>
<li>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合&quot;在物联网领域，传感器与服务器的通信，信息的收集&quot;，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</li>
<li>使用Last Will和Testament特性通知有关各方客户端异常中断的机制。
<ul>
<li>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</li>
<li>Testament：遗嘱机制，功能类似于Last Will。</li>
</ul>
</li>
</ul>
<h2 id="4-mqtt协议原理">4 MQTT协议原理</h2>
<h3 id="41-mqtt协议实现方式">4.1 MQTT协议实现方式</h3>
<p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（Payload）两部分：</p>
<ul>
<li>Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（Payload）；</li>
<li>Payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h3 id="42-网络传输与应用消息">4.2 网络传输与应用消息</h3>
<p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p>
<p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h3 id="43-mqtt客户端">4.3 MQTT客户端</h3>
<p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>发布其他客户端可能会订阅的信息；</li>
<li>订阅其它客户端发布的消息；</li>
<li>退订或删除应用程序的消息；</li>
<li>断开与服务器连接。</li>
</ul>
<h3 id="44-mqtt服务器">4.4 MQTT服务器</h3>
<p>MQTT服务器以称为&quot;消息代理&quot;（Broker），可以是一个应用程序或一台设备。它位于消息发布者和订阅者之间，它可以：</p>
<ul>
<li>接受来自客户的网络连接；</li>
<li>接受客户发布的应用信息；</li>
<li>处理来自客户端的订阅和退订请求；</li>
<li>向订阅的客户转发应用程序消息。</li>
</ul>
<h3 id="45-mqtt协议中的订阅-主题-会话">4.5 MQTT协议中的订阅、主题、会话</h3>
<h4 id="451-订阅subscription">4.5.1 订阅（Subscription）</h4>
<p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
<h4 id="452-会话session">4.5.2 会话（Session）</h4>
<p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
<h4 id="453-主题名topic-name">4.5.3 主题名（Topic Name）</h4>
<p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
<h4 id="454-主题筛选器topic-filter">4.5.4 主题筛选器（Topic Filter）</h4>
<p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
<h4 id="455-负载payload">4.5.5 负载（Payload）</h4>
<p>消息订阅者所具体接收的内容。</p>
<h3 id="46-mqtt协议中的方法">4.6 MQTT协议中的方法</h3>
<p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ul>
<li>Connect：等待与服务器建立连接。</li>
<li>Disconnect：等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>Subscribe：等待完成订阅。</li>
<li>UnSubscribe：等待服务器取消客户端的一个或多个topics订阅。</li>
<li>Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<h2 id="5-mqtt协议数据包结构">5 MQTT协议数据包结构</h2>
<p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。</p>
<ul>
<li>固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li>
<li>可变头（Variable header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li>
<li>消息体（Payload）：存在于部分MQTT数据包中，表示客户端收到的具体内容。</li>
</ul>
<h3 id="51-mqtt固定头">5.1 MQTT固定头</h3>
<p>固定头存在于所有MQTT数据包中，包含两部分内容：首字节(Byte 1) 和 剩余消息报文长度(1-4字节)</p>
<ul>
<li>Byte 1 首字节：
<ul>
<li>Bit 7 6 5 4 高四位无符号值，用于表示MQTT消息的报文类型(MQTT Control Packet type)，总共可以表示2^4=16种协议类型。</li>
<li>Bit 3 2 1 0 低四位无符号值，用作某些报文的特殊标记(Flags specific to each MQTT Control Packet type)。</li>
</ul>
</li>
<li>Byte 2… Remaining Length 剩余消息报文长度</li>
</ul>
<h4 id="511-mqtt数据包类型-mqtt-control-packet-type">5.1.1 MQTT数据包类型 MQTT Control Packet type</h4>
<p>位于 首字节的高四位，即Byte 1中的 bits 7-4，相于一个4位的无符号值。用于确定报文类型。共有2^4=16种，其中0000和1111是保留字段。具体如下：</p>
<table>
<thead>
<tr>
<th>报文类型</th>
<th>字段值</th>
<th>数据方向</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>保留</td>
<td>0</td>
<td>禁用</td>
<td>保留</td>
</tr>
<tr>
<td>CONNECT</td>
<td>1</td>
<td>Client -&gt; Server</td>
<td>客户端连接到服务器</td>
</tr>
<tr>
<td>CONNACK</td>
<td>2</td>
<td>Server -&gt; Client</td>
<td>连接确认</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>3</td>
<td>Client &lt;-&gt; Server</td>
<td>发布消息</td>
</tr>
<tr>
<td>PUBACK</td>
<td>4</td>
<td>Client &lt;-&gt; Server</td>
<td>发布确认</td>
</tr>
<tr>
<td>PUBREC</td>
<td>5</td>
<td>Client &lt;-&gt; Server</td>
<td>消息已接收(QoS2第一阶段)</td>
</tr>
<tr>
<td>PUBREL</td>
<td>6</td>
<td>Client &lt;-&gt; Server</td>
<td>消息释放(QoS2第二阶段)</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td>7</td>
<td>Client &lt;-&gt; Server</td>
<td>发布结束(QoS2第三阶段)</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td>8</td>
<td>Client -&gt; Server</td>
<td>客户端订阅请求</td>
</tr>
<tr>
<td>SUBACK</td>
<td>9</td>
<td>Server -&gt; Client</td>
<td>服务端订阅确认</td>
</tr>
<tr>
<td>UNSUBACRIBE</td>
<td>10</td>
<td>Client -&gt; Server</td>
<td>客户端取消订阅</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td>11</td>
<td>Server -&gt; Client</td>
<td>服务端取消订阅确认</td>
</tr>
<tr>
<td>PINGREQ</td>
<td>12</td>
<td>Client -&gt; Server</td>
<td>客户端发送心跳</td>
</tr>
<tr>
<td>PINGRESP</td>
<td>13</td>
<td>Server -&gt; Client</td>
<td>服务端回复心跳</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td>14</td>
<td>Client -&gt; Server</td>
<td>客户端断开连接请求</td>
</tr>
<tr>
<td>保留</td>
<td>15</td>
<td>禁用</td>
<td>保留</td>
</tr>
</tbody>
</table>
<h4 id="512-标识位-flags-specific-to-each-mqtt-control-packet-type">5.1.2 标识位 Flags specific to each MQTT Control Packet type</h4>
<p>位于首字节的低四位，即Byte 1中bits 3-0。表示某些报文类型的控制字段，实际上只有少数报文类型有控制位。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<ul>
<li>DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</li>
<li>QoS：发布消息的服务质量，即：保证消息传递的次数。</li>
</ul>
<pre><code>Ø00：最多一次，即：&lt;=1

Ø01：至少一次，即：&gt;=1

Ø10：一次，即：=1

Ø11：预留
</code></pre>
<ul>
<li>RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</li>
</ul>
<p>5.1.3 剩余长度（Remaining Length）</p>
<p>用来保存变长头部(Variable  Header)和消息体(Payload)的总大小。从第二字节(Byte  2)开始，最长可达4字节，所以剩余长度范围是Byte[2-5]。那么怎样确定其长度到底是1字节还是4字节呢？它先用从低位Bit 0到Bit  6来存储，当发现不够时，则将 最高位Bit 7(默认都是高字节在前)置为  1，表示长度不足，需要使用下一个字节继续保存，就继续计算字节长度；如果是0，那么就不再计算字节长度。</p>
<p>消息长度可以简单理解为128进制的数据，4位长度最大可以表示128, 128*,* 128*128Byte=256MB。但是这个长度的计算有些特别，就是低位在前，高位在后(因为正常的表示方法是高位在前，低位在后)，字节最高位Bit7用于标记是否需要继续计算消息长度。以下是消息长度的长度范围：</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>长度最小值</th>
<th>长度最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0(0x00)</td>
<td>127(0x7F)</td>
</tr>
<tr>
<td>2</td>
<td>128 (0x80, 0x01)</td>
<td>16 383 (0xFF, 0x7F)</td>
</tr>
<tr>
<td>3</td>
<td>16 384 (0x80, 0x80, 0x01)</td>
<td>2 097 151 (0xFF, 0xFF, 0x7F)</td>
</tr>
<tr>
<td>4</td>
<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>
<td>268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td>
</tr>
</tbody>
</table>
<h3 id="52-mqtt可变头">5.2 MQTT可变头</h3>
<p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p>
<p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p>
<h3 id="53-payload消息体">5.3 Payload消息体</h3>
<p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p>
<ul>
<li>CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li>
<li>SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li>
<li>SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li>
<li>UNSUBSCRIBE，消息体内容是要订阅的主题。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue2.0 + TypeScript 项目搭建]]></title>
        <id>https://kangjn.github.io/post/vue20-typescript-xiang-mu-da-jian/</id>
        <link href="https://kangjn.github.io/post/vue20-typescript-xiang-mu-da-jian/">
        </link>
        <updated>2021-04-20T07:06:51.000Z</updated>
        <content type="html"><![CDATA[<p>安装 cli</p>
<h1 id="vue-cli-3-可以使用-typescript-生成新工程-创建方式">Vue CLI 3 可以使用 TypeScript 生成新工程。创建方式：</h1>
<p>npm install --global @vue/cli</p>
<h1 id="2-创建一个新工程并选择-manually-select-features-手动选择特性-选项">2. 创建一个新工程，并选择 &quot;Manually select features (手动选择特性)&quot; 选项</h1>
<p>vue create my-project-name</p>
<p>vue create my-project-name</p>
<p>Vue CLI v4.5.12<br>
? Please pick a preset: Manually select features<br>
? Check the features needed for your project: Choose Vue version, Babel, TS, PWA, Router, Vuex, CSS Pre-processors, Linter, Unit<br>
? Choose a version of Vue.js that you want to start the project with 2.x<br>
? Use class-style component syntax? Yes<br>
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes<br>
? Use history mode for router? (Requires proper server setup for index fallback in production) Yes<br>
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less<br>
? Pick a linter / formatter config: Standard<br>
? Pick additional lint features: Lint on save<br>
? Pick a unit testing solution: Mocha<br>
? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files<br>
? Save this as a preset for future projects? No</p>
<p>配置 vue.config.js</p>
<p>根目录新建vue.config.js文件<br>
1、publicPath 项目根路径</p>
<p>module.exports = {<br>
publicPath: '/',//根路径 cli3.0以上使用publicPath<br>
}</p>
<p>2、assetsDir 静态资源目录(js,css,img,fonts)这些文件都可以写里面</p>
<p>module.exports = {<br>
assetsDir: 'static',// 静态资源目录(js,css,img,fonts)这些文件都可以写里面<br>
}</p>
<p>3、outputDir 打包输出目录</p>
<p>module.exports = {<br>
outputDir: 'dist',//打包的时候生成的一个文件名<br>
}</p>
<p>4、lintOnSave 是否开启eslint保存检测 ,它的有效值为 true || false || 'error'</p>
<p>module.exports = {<br>
lintOnSave: 'error',//是否开启eslint保存检测 ,它的有效值为 true || false || 'error'<br>
}</p>
<p>5、biyi-admin 指定对第三方依赖包进行babel-polyfill处理</p>
<p>module.exports = {<br>
transpileDependencies: [<br>
'biyi-admin', // 指定对第三方依赖包进行babel-polyfill处理<br>
],<br>
}</p>
<p>6、productionSourceMap 生产环境是否生成 sourceMap 文件</p>
<p>module.exports = {<br>
productionSourceMap: false, // 生产环境是否生成 sourceMap 文件<br>
}</p>
<p>7、别名配置 '@' './src' ; '@a' './src/assets' ; '@c' './src/components' ; '@p' './src/pages'</p>
<p>const path = require('path');<br>
module.exports = {<br>
chainWebpack: config =&gt; {<br>
// 别名配置<br>
config.resolve.alias<br>
.set('@', path.resolve(__dirname, './src'))<br>
.set('@a', path.resolve(__dirname, './src/assets'))<br>
.set('@c', path.resolve(__dirname, './src/components'))<br>
.set('@p', path.resolve(__dirname, './src/pages'))<br>
},<br>
}</p>
<p>8、解决ie11兼容ES6</p>
<h1 id="安装依赖">安装依赖</h1>
<p>yarn add babel-polyfill</p>
<p>module.exports = {<br>
chainWebpack: config =&gt; {<br>
// 解决ie11兼容ES6<br>
config.entry('main').add('babel-polyfill');<br>
},<br>
}</p>
<p>9、symlinks 符号链接的资源将解析到其实际路径，而不是符号链接的位</p>
<p>module.exports = {<br>
chainWebpack: config =&gt; {<br>
// 修复HMR<br>
config.resolve.symlinks(true);<br>
},<br>
}</p>
<p>10、gzip 压缩</p>
<p>yarn add terser-webpack-plugin --dev<br>
yarn add compression-webpack-plugin --dev</p>
<h1 id="packagejson">package.json</h1>
<p>{<br>
&quot;openGzip&quot;: true,<br>
}</p>
<p>let {version, openGzip} = require('./package.json');</p>
<p>module.exports = {<br>
configureWebpack: config =&gt; {<br>
if (process.env.NODE_ENV === 'production') {<br>
// 为生产环境修改配置...<br>
config.mode = &quot;production&quot;;<br>
if (openGzip) {<br>
config.plugins.push(<br>
new CompressionWebpackPlugin({<br>
filename: '[path].gz[query]',<br>
algorithm: 'gzip',<br>
test: /.js<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\.&#039; in math mode at position 2: |\̲.̲html'>|\.html</span>|.\css/, // 匹配文件名<br>
threshold: 10240, // 只有大小大于该值的资源会被处理 10240<br>
minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理<br>
deleteOriginalAssets: false, // 删除原文件<br>
})<br>
)<br>
}<br>
} else {<br>
// 为开发环境修改配置...<br>
config.mode = &quot;development&quot;;<br>
}<br>
},<br>
}</p>
<p>11、打包文件大小配置</p>
<p>module.exports = {<br>
configureWebpack: config =&gt; {<br>
if (process.env.NODE_ENV === 'production') {<br>
// 为生产环境修改配置...<br>
config.mode = &quot;production&quot;;</p>
<pre><code>        // 打包文件大小配置
        config[&quot;performance&quot;] = {
            hints: &quot;error&quot;,
            maxEntrypointSize: 400000,
            maxAssetSize: 30000000
        };
    } else {
        // 为开发环境修改配置...
        config.mode = &quot;development&quot;;
    }
},
</code></pre>
<p>}</p>
<p>12、将每个依赖包打包成单独的js文件</p>
<p>let {version, openGzip} = require('./package.json');</p>
<p>module.exports = {<br>
configureWebpack: config =&gt; {<br>
if (process.env.NODE_ENV === 'production') {<br>
// 为生产环境修改配置...<br>
config.mode = &quot;production&quot;;</p>
<pre><code>        // 将每个依赖包打包成单独的js文件
        Object.assign(config, {
            output: {
                ...config.output,
                filename: `static/js/[name].[chunkhash].${version}.js`,
                chunkFilename: `static/js/[name].[chunkhash].${version}.js`
            },
        })
    } else {
        // 为开发环境修改配置...
        config.mode = &quot;development&quot;;
    }
},
</code></pre>
<p>}</p>
<p>13、去除线上的 console</p>
<p>module.exports = {<br>
configureWebpack: config =&gt; {<br>
if (process.env.NODE_ENV === 'production') {<br>
// 为生产环境修改配置...<br>
config.mode = &quot;production&quot;;</p>
<pre><code>        Object.assign(config, {
            optimization: {
                minimizer: [
                    new TerserPlugin({
                        cache: true, // 是否缓存
                        // paraller: true, // 是否并行打包
                        sourceMap: true,
                        terserOptions: {
                            compress: {
                                pure_funcs: [&quot;console.log&quot;]
                            }
                        }
                    })
                ],
            }
        })
    } else {
        // 为开发环境修改配置...
        config.mode = &quot;development&quot;;
    }
},
</code></pre>
<p>}</p>
<p>14、css相关配置</p>
<p>根目录创建 postcss.config.js</p>
<p>module.exports = {<br>
plugins: [<br>
// 兼容浏览器，添加前缀<br>
require('autoprefixer')({<br>
overrideBrowserslist: [<br>
&quot;Android 4.1&quot;,<br>
&quot;iOS 7.1&quot;,<br>
&quot;Chrome &gt; 31&quot;,<br>
&quot;ff &gt; 31&quot;,<br>
&quot;ie &gt;= 8&quot;<br>
//'last 10 versions', // 所有主流浏览器最近10版本用<br>
],<br>
grid: true<br>
})</p>
<pre><code>]
</code></pre>
<p>}</p>
<p>module.exports = {<br>
// css相关配置<br>
css: {<br>
extract: false, // 是否使用css分离插件 ExtractTextPlugin<br>
sourceMap: false, // 开启 CSS source maps?<br>
loaderOptions: {<br>
less: {<br>
javascriptEnabled: true<br>
},<br>
css: {}, // 这里的选项会传递给 css-loader<br>
postcss: {} // 这里的选项会传递给 postcss-loader<br>
}, // css预设器配置项 详见https://cli.vuejs.org/zh/config/#css-loaderoptions<br>
requireModuleExtension: true // 启用 CSS requireModuleExtension for all css / pre-processor files.<br>
},<br>
}</p>
<p>15、parallel 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。</p>
<p>module.exports = {<br>
parallel: require('os').cpus().length &gt; 1, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。<br>
}</p>
<p>16、webpack-dev-server 相关配置</p>
<p>module.exports = {<br>
devServer: {<br>
open: true,// 打开谷歌<br>
host: '0.0.0.0', // 允许外部ip访问<br>
port: 8081, // 端口<br>
https: false, // 启用https<br>
overlay: {<br>
warnings: true,<br>
errors: true<br>
}, // 错误、警告在页面弹出<br>
proxy: {<br>
'/api': {<br>
target: <code>${process.env.VUE_APP_BASE_API}/api</code>,<br>
changeOrigin: true, // 允许websockets跨域<br>
// ws: true,<br>
pathRewrite: {<br>
'^/api': ''<br>
}<br>
}<br>
} // 代理转发配置，用于调试环境<br>
},<br>
}</p>
<p>17、环境变量和模式</p>
<p>根目录添加 .env 文件 【默认环境变量】</p>
<p>NODE_ENV = 'production'<br>
VUE_APP_MOCK = false<br>
VUE_APP_CDN = ''<br>
VUE_APP_BASE_API = ''</p>
<p>根目录添加 .env.development 文件 【开发环境变量】</p>
<p>NODE_ENV = 'development'<br>
VUE_APP_MOCK = true</p>
<p>根目录添加 .env.production 文件 【生产环境变量】</p>
<p>NODE_ENV = 'production'<br>
VUE_APP_MOCK = false<br>
VUE_APP_BASE_API = ''<br>
VUE_APP_CDN = ''</p>
<p>最终</p>
<p>vue.config.js</p>
<p>/**</p>
<ul>
<li>
<p>@FileName vue.config.js</p>
</li>
<li>
<p>@Author</p>
</li>
<li>
<p>@Version V 0.0.1</p>
</li>
<li>
<p>@Date</p>
</li>
<li>
<p>@Title Vue配置文件</p>
</li>
<li>
<p>@Desc<br>
**/<br>
const path = require('path');<br>
const TerserPlugin = require('terser-webpack-plugin');<br>
const CompressionWebpackPlugin = require('compression-webpack-plugin');<br>
const isProduction = process.env.NODE_ENV === 'production';<br>
const {version, openGzip} = require('./package.json');<br>
module.exports = {<br>
devServer: {<br>
open: false,<br>
host: '0.0.0.0',<br>
port: 8082,<br>
https: false,<br>
disableHostCheck: true,<br>
overlay: {<br>
warnings: true,<br>
errors: true<br>
},<br>
proxy: {<br>
'/api': {<br>
target: <code>${process.env.VUE_APP_BASE_API}</code>,<br>
changeOrigin: true,<br>
// ws: true,<br>
pathRewrite: {<br>
'^/api': ''<br>
}<br>
}<br>
}<br>
},<br>
chainWebpack: config =&gt; {<br>
config.entry('main').add('babel-polyfill');<br>
config.resolve.symlinks(true);<br>
config.resolve.alias<br>
.set('@', path.resolve(__dirname, './src'))<br>
.set('@a', path.resolve(__dirname, './src/assets'))<br>
.set('@c', path.resolve(__dirname, './src/components'))<br>
.set('@p', path.resolve(__dirname, './src/pages'))<br>
.set('@l', path.resolve(__dirname, './src/layout'));<br>
},<br>
publicPath: '/',<br>
assetsDir: 'static',<br>
outputDir: 'dist',<br>
lintOnSave: 'error',<br>
transpileDependencies: ['biyi-admin'],<br>
productionSourceMap: false,<br>
configureWebpack: config =&gt; {<br>
console.log(isProduction);<br>
if (isProduction) {<br>
config.mode = 'production';</p>
<p>if (openGzip) {<br>
config.plugins.push(<br>
new CompressionWebpackPlugin({<br>
filename: '[path].gz[query]',<br>
algorithm: 'gzip',<br>
test: /.js<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\.&#039; in math mode at position 2: |\̲.̲html'>|\.html</span>|.\css/, // 匹配文件名<br>
threshold: 10240, // 只有大小大于该值的资源会被处理 10240<br>
minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理<br>
deleteOriginalAssets: false // 删除原文件<br>
})<br>
);</p>
<pre><code> // 将每个依赖包打包成单独的js文件
 Object.assign(config, {
   performance: {
     hints: 'error',
     maxEntrypointSize: 10000000,
     maxAssetSize: 30000000
   },
   output: {
     ...config.output,
     filename: `static/js/[name].[chunkhash].${version}.js`,
     chunkFilename: `static/js/[name].[chunkhash].${version}.js`
   },
   optimization: {
     minimizer: [
       new TerserPlugin({
         cache: true, // 是否缓存
         // paraller: true, // 是否并行打包
         sourceMap: true,
         terserOptions: {
           compress: {
             pure_funcs: ['console.log']
           }
         }
       })
     ]
   }
 });
</code></pre>
<p>}<br>
} else {<br>
config.mode = 'development';<br>
}<br>
},<br>
css: {<br>
extract: false,<br>
sourceMap: false,<br>
loaderOptions: {<br>
less: {<br>
javascriptEnabled: true<br>
},<br>
css: {},<br>
postcss: {}<br>
},<br>
requireModuleExtension: true<br>
},<br>
parallel: require('os').cpus().length &gt; 1,<br>
pwa: {},<br>
pluginOptions: {}<br>
};</p>
</li>
</ul>
<p>package.json</p>
<p>{<br>
&quot;name&quot;: &quot;big-data-platform&quot;,<br>
&quot;version&quot;: &quot;0.1.0&quot;,<br>
&quot;private&quot;: true,<br>
&quot;openGzip&quot;: true,<br>
&quot;scripts&quot;: {<br>
&quot;serve&quot;: &quot;vue-cli-service serve&quot;,<br>
&quot;build&quot;: &quot;vue-cli-service build&quot;,<br>
&quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;,<br>
&quot;lint&quot;: &quot;vue-cli-service lint&quot;<br>
},<br>
&quot;dependencies&quot;: {<br>
&quot;axios&quot;: &quot;^0.21.1&quot;,<br>
&quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,<br>
&quot;core-js&quot;: &quot;^3.6.5&quot;,<br>
&quot;localforage&quot;: &quot;^1.9.0&quot;,<br>
&quot;moment&quot;: &quot;^2.29.1&quot;,<br>
&quot;register-service-worker&quot;: &quot;^1.7.1&quot;,<br>
&quot;view-design&quot;: &quot;^4.5.0&quot;,<br>
&quot;vue&quot;: &quot;^2.6.11&quot;,<br>
&quot;vue-class-component&quot;: &quot;^7.2.3&quot;,<br>
&quot;vue-property-decorator&quot;: &quot;^9.1.2&quot;,<br>
&quot;vue-router&quot;: &quot;^3.2.0&quot;,<br>
&quot;vuex&quot;: &quot;^3.4.0&quot;<br>
},<br>
&quot;devDependencies&quot;: {<br>
&quot;@types/chai&quot;: &quot;^4.2.11&quot;,<br>
&quot;@types/mocha&quot;: &quot;^5.2.4&quot;,<br>
&quot;@types/mockjs&quot;: &quot;^1.0.3&quot;,<br>
&quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.18.0&quot;,<br>
&quot;@typescript-eslint/parser&quot;: &quot;^4.18.0&quot;,<br>
&quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-pwa&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-router&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-typescript&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-unit-mocha&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-plugin-vuex&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;,<br>
&quot;@vue/eslint-config-standard&quot;: &quot;^5.1.2&quot;,<br>
&quot;@vue/eslint-config-typescript&quot;: &quot;^7.0.0&quot;,<br>
&quot;@vue/test-utils&quot;: &quot;^1.0.3&quot;,<br>
&quot;chai&quot;: &quot;^4.1.2&quot;,<br>
&quot;compression-webpack-plugin&quot;: &quot;^7.1.2&quot;,<br>
&quot;eslint&quot;: &quot;^6.7.2&quot;,<br>
&quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,<br>
&quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,<br>
&quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;,<br>
&quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;,<br>
&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,<br>
&quot;less&quot;: &quot;^3.0.4&quot;,<br>
&quot;less-loader&quot;: &quot;^5.0.0&quot;,<br>
&quot;mockjs&quot;: &quot;^1.1.0&quot;,<br>
&quot;terser-webpack-plugin&quot;: &quot;^5.1.1&quot;,<br>
&quot;typescript&quot;: &quot;~4.1.5&quot;,<br>
&quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;<br>
}<br>
}</p>
<p>配置eslint</p>
<p>package.json 文件</p>
<p>{<br>
&quot;devDependencies&quot;: {<br>
&quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.18.0&quot;,<br>
&quot;@typescript-eslint/parser&quot;: &quot;^4.18.0&quot;,<br>
&quot;eslint&quot;: &quot;^6.7.2&quot;,<br>
&quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,<br>
&quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,<br>
&quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;,<br>
&quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;,<br>
&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,<br>
},<br>
}</p>
<p>根目录添加 .eslintrc.js 配置文件</p>
<p>module.exports = {<br>
root: true,<br>
env: {<br>
node: true<br>
},<br>
extends: [<br>
'plugin:vue/essential',<br>
'@vue/standard',<br>
'@vue/typescript/recommended'<br>
],<br>
parserOptions: {<br>
ecmaVersion: 2020<br>
},<br>
rules: {<br>
'no-console': 'off',<br>
'indent': ['off', 2],<br>
'semi': [2, 'always'], // 语句强制分号结尾<br>
'quotes': [2, 'single'], // js必须使用单引号<br>
'vue/no-parsing-error': 'off',<br>
'no-irregular-whitespace': 'off',<br>
'no-async-promise-executor': 'off',<br>
'space-before-function-paren': 'off',<br>
'object-curly-spacing': ['error', 'never'],<br>
'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',<br>
'@typescript-eslint/no-this-alias': 'off',<br>
'@typescript-eslint/ban-ts-ignore': 'off',<br>
'@typescript-eslint/no-unused-vars': 'off',<br>
'@typescript-eslint/ban-ts-comment': 'off',<br>
'@typescript-eslint/no-explicit-any': 'off',<br>
'@typescript-eslint/no-empty-function': 'off',<br>
'@typescript-eslint/explicit-module-boundary-types': 'off'<br>
},<br>
overrides: [<br>
{<br>
files: [<br>
'<strong>/<strong>tests</strong>/*.{j,t}s?(x)',<br>
'</strong>/tests/unit/**/*.spec.{j,t}s?(x)'<br>
],<br>
env: {<br>
mocha: true<br>
}<br>
}<br>
]<br>
}</p>
<p>工具类封装<br>
Cookie操作</p>
<p>/**</p>
<ul>
<li>@FileName cookie.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title Cookie操作</li>
<li>@Desc<br>
**/</li>
</ul>
<p>/**</p>
<ul>
<li>设置cookie</li>
<li>@param name</li>
<li>@param value</li>
<li>@param hours</li>
<li>@param path<br>
*/<br>
const setCookie = (name: string, value: any, hours: number, path: string) =&gt; {<br>
const expires = new Date();<br>
expires.setTime(expires.getTime() + hours * 3600000);<br>
const expiresTxt = typeof hours === 'string' ? '' : <code>;expires=${expires.toUTCString()}</code>;<br>
document.cookie = <code>${escape(name)}=${escape(value)}${expiresTxt}${path === '' ? '' :</code>;path=${path}<code>}</code>;<br>
};</li>
</ul>
<p>/**</p>
<ul>
<li>获取cookie值</li>
<li>@param name<br>
*/<br>
const getCookieValue = (name: string) =&gt; {<br>
let nameTxt = escape(name);<br>
// 读cookie属性，这将返回文档的所有cookie<br>
const allCookies = document.cookie;<br>
// 查找名为name的cookie的开始位置<br>
nameTxt += '=';<br>
const pos = allCookies.indexOf(nameTxt);<br>
// 如果找到了具有该名字的cookie，那么提取并使用它的值<br>
if (pos !== -1) {<br>
// 如果pos值为-1则说明搜索'version='失败<br>
const start = pos + nameTxt.length; // cookie值开始的位置<br>
let end = allCookies.indexOf(';', start); // 从cookie值开始的位置起搜索第一个';'的位置,即cookie值结尾的位置<br>
if (end === -1) end = allCookies.length; // 如果end值为-1说明cookie列表里只有一个cookie<br>
// 提取cookie的值<br>
return allCookies.substring(start, end); // 对它解码<br>
}</li>
</ul>
<p>return '';<br>
// 搜索失败，返回空字符串<br>
};</p>
<p>/**</p>
<ul>
<li>删除cookie</li>
<li>@param name</li>
<li>@param path<br>
*/<br>
const deleteCookie = (name: string, path: string) =&gt; {<br>
const expires = new Date(0);<br>
document.cookie = <code>${escape(name)}=;expires=${expires.toUTCString()}${path === '' ? '' :</code>;path=${path}<code>}</code>;<br>
};<br>
export default {<br>
setCookie,<br>
getCookieValue,<br>
deleteCookie<br>
};</li>
</ul>
<p>createRoutes</p>
<p>yarn add view-design</p>
<p>/**</p>
<ul>
<li>@FileName createRoutes.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import Vue from 'vue';<br>
import VueRouter from 'vue-router';<br>
import {LoadingBar} from 'view-design';</li>
</ul>
<p>Vue.use(VueRouter);<br>
const VueRouterPush = VueRouter.prototype.push;</p>
<p>VueRouter.prototype.push = function push(to: any): any {<br>
const a: any = VueRouterPush.call(this, to);<br>
a.catch((err: any) =&gt; err);<br>
return a;<br>
};</p>
<p>LoadingBar.config({<br>
color: '#ff9900',<br>
failedColor: '#ed4014',<br>
height: 3,<br>
duration: 800<br>
});</p>
<p>const createRouter = (baseRoutes: any = [], routes: any = [], base = '', homeName = 'home', mode: any = 'history', title = '', turnTo: any = () =&gt; {<br>
}) =&gt; {<br>
const router = new VueRouter({<br>
mode: mode,<br>
base: base,<br>
routes: [<br>
...routes,<br>
...baseRoutes<br>
]<br>
});</p>
<p>// 全局守卫<br>
router.beforeEach((to: any, from: any, next: any) =&gt; {<br>
LoadingBar.start();<br>
turnTo(to, next, homeName);<br>
});</p>
<p>// 全局后置钩子<br>
router.afterEach((to: any) =&gt; {<br>
if (to.meta.title) {<br>
document.title = title ? to.meta.title + '-' + title : to.meta.title;<br>
}<br>
LoadingBar.finish();<br>
window.scrollTo(0, 0);<br>
});<br>
return router;<br>
};</p>
<p>export default createRouter;</p>
<p>gbk</p>
<p>/**</p>
<ul>
<li>@FileName gbk.js</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title 序列化 反序列化</li>
<li>@Desc<br>
*<em>/<br>
/</em> eslint-disable */<br>
const util = function () {<br>
var data = function (zipData: any) {<br>
return zipData<br>
.replace(/#(\d+)$/g, function (a: any, b: any) {<br>
return Array(+b + 3).join('#');<br>
})<br>
.replace(/#/g, '####')<br>
.replace(/(\w\w)😦[\w#]+)(?:,|<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 115: …     if (a != &#039;#̲#&#039;) {
         …'>)/g, function (a: any, hd: any, dt: any) {
       return dt.replace(/../g, function (a: any) {
         if (a != &#039;##&#039;) {
           return hd + a;
         } else {
           return a;
         }
       });
     });
 }(&#039;4e:020405060f12171f20212326292e2f313335373c40414244464a5155575a5b6263646567686a6b6c6d6e6f727475767778797a7b7c7d7f808182838485878a#909697999c9d9ea3aaafb0b1b4b6b7b8b9bcbdbec8cccfd0d2dadbdce0e2e6e7e9edeeeff1f4f8f9fafcfe,4f:00020304050607080b0c12131415161c1d212328292c2d2e31333537393b3e3f40414244454748494a4b4c525456616266686a6b6d6e7172757778797a7d8081828586878a8c8e909293959698999a9c9e9fa1a2a4abadb0b1b2b3b4b6b7b8b9babbbcbdbec0c1c2c6c7c8c9cbcccdd2d3d4d5d6d9dbe0e2e4e5e7ebecf0f2f4f5f6f7f9fbfcfdff,50:000102030405060708090a#0b0e1011131516171b1d1e20222324272b2f303132333435363738393b3d3f404142444546494a4b4d5051525354565758595b5d5e5f6061626364666768696a6b6d6e6f70717273747578797a7c7d818283848687898a8b8c8e8f909192939495969798999a9b9c9d9e9fa0a1a2a4a6aaabadaeafb0b1b3b4b5b6b7b8b9bcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdced0d1d2d3d4d5d7d8d9dbdcdddedfe0e1e2e3e4e5e8e9eaebeff0f1f2f4f6f7f8f9fafcfdfeff,51:00010203040508#090a0c0d0e0f1011131415161718191a1b1c1d1e1f2022232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e42474a4c4e4f5052535758595b5d5e5f606163646667696a6f727a7e7f838486878a8b8e8f90919394989a9d9e9fa1a3a6a7a8a9aaadaeb4b8b9babebfc1c2c3c5c8cacdced0d2d3d4d5d6d7d8d9dadcdedfe2e3e5e6e7e8e9eaeceef1f2f4f7fe,52:0405090b0c0f101314151c1e1f2122232526272a2c2f313234353c3e4445464748494b4e4f5253555758#595a5b5d5f6062636466686b6c6d6e7071737475767778797a7b7c7e808384858687898a8b8c8d8e8f91929495969798999a9ca4a5a6a7aeafb0b4b5b6b7b8b9babbbcbdc0c1c2c4c5c6c8cacccdcecfd1d3d4d5d7d9dadbdcdddee0e1e2e3e5e6e7e8e9eaebecedeeeff1f2f3f4f5f6f7f8fbfcfd,53:0102030407090a0b0c0e11121314181b1c1e1f2224252728292b2c2d2f3031323334353637383c3d404244464b4c4d505458595b5d65686a6c6d7276797b7c7d7e80818387888a8e8f#90919293949697999b9c9ea0a1a4a7aaabacadafb0b1b2b3b4b5b7b8b9babcbdbec0c3c4c5c6c7cecfd0d2d3d5dadcdddee1e2e7f4fafeff,54:000205070b1418191a1c2224252a303336373a3d3f4142444547494c4d4e4f515a5d5e5f6061636567696a6b6c6d6e6f7074797a7e7f8183858788898a8d919397989c9e9fa0a1a2a5aeb0b2b5b6b7b9babcbec3c5cacbd6d8dbe0e1e2e3e4ebeceff0f1f4f5f6f7f8f9fbfe,55:0002030405080a0b0c0d0e121315161718191a1c1d1e1f212526#28292b2d3234353638393a3b3d40424547484b4c4d4e4f515253545758595a5b5d5e5f60626368696b6f7071727374797a7d7f85868c8d8e9092939596979a9b9ea0a1a2a3a4a5a6a8a9aaabacadaeafb0b2b4b6b8babcbfc0c1c2c3c6c7c8cacbcecfd0d5d7d8d9dadbdee0e2e7e9edeef0f1f4f6f8f9fafbfcff,56:0203040506070a0b0d1011121314151617191a1c1d202122252628292a2b2e2f30333537383a3c3d3e404142434445464748494a4b4f5051525355565a5b5d5e5f6061#636566676d6e6f70727374757778797a7d7e7f80818283848788898a8b8c8d9091929495969798999a9b9c9d9e9fa0a1a2a4a5a6a7a8a9aaabacadaeb0b1b2b3b4b5b6b8b9babbbdbebfc0c1c2c3c4c5c6c7c8c9cbcccdcecfd0d1d2d3d5d6d8d9dce3e5e6e7e8e9eaeceeeff2f3f6f7f8fbfc,57:00010205070b0c0d0e0f101112131415161718191a1b1d1e202122242526272b313234353637383c3d3f414344454648494b52535455565859626365676c6e707172747578797a7d7e7f80#818788898a8d8e8f90919495969798999a9c9d9e9fa5a8aaacafb0b1b3b5b6b7b9babbbcbdbebfc0c1c4c5c6c7c8c9cacccdd0d1d3d6d7dbdcdee1e2e3e5e6e7e8e9eaebeceef0f1f2f3f5f6f7fbfcfeff,58:0103040508090a0c0e0f101213141617181a1b1c1d1f222325262728292b2c2d2e2f31323334363738393a3b3c3d3e3f4041424345464748494a4b4e4f505253555657595a5b5c5d5f6061626364666768696a6d6e6f707172737475767778797a7b7c7d7f82848687888a8b8c#8d8e8f909194959697989b9c9da0a1a2a3a4a5a6a7aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbdbebfc0c2c3c4c6c7c8c9cacbcccdcecfd0d2d3d4d6d7d8d9dadbdcdddedfe0e1e2e3e5e6e7e8e9eaedeff1f2f4f5f7f8fafbfcfdfeff,59:000103050608090a0b0c0e1011121317181b1d1e2021222326282c30323335363b3d3e3f404345464a4c4d505253595b5c5d5e5f616364666768696a6b6c6d6e6f70717275777a7b7c7e7f8085898b8c8e8f90919495989a9b9c9d9fa0a1a2a6#a7acadb0b1b3b4b5b6b7b8babcbdbfc0c1c2c3c4c5c7c8c9cccdcecfd5d6d9dbdedfe0e1e2e4e6e7e9eaebedeeeff0f1f2f3f4f5f6f7f8fafcfdfe,5a:00020a0b0d0e0f101214151617191a1b1d1e2122242627282a2b2c2d2e2f3033353738393a3b3d3e3f414243444547484b4c4d4e4f5051525354565758595b5c5d5e5f60616364656668696b6c6d6e6f7071727378797b7c7d7e808182838485868788898a8b8c8d8e8f9091939495969798999c9d9e9fa0a1a2a3a4a5a6a7a8a9abac#adaeafb0b1b4b6b7b9babbbcbdbfc0c3c4c5c6c7c8cacbcdcecfd0d1d3d5d7d9dadbdddedfe2e4e5e7e8eaecedeeeff0f2f3f4f5f6f7f8f9fafbfcfdfeff,5b:0001020304050607080a0b0c0d0e0f10111213141518191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303133353638393a3b3c3d3e3f4142434445464748494a4b4c4d4e4f52565e606167686b6d6e6f7274767778797b7c7e7f82868a8d8e90919294969fa7a8a9acadaeafb1b2b7babbbcc0c1c3c8c9cacbcdcecf#d1d4d5d6d7d8d9dadbdce0e2e3e6e7e9eaebecedeff1f2f3f4f5f6f7fdfe,5c:0002030507080b0c0d0e10121317191b1e1f2021232628292a2b2d2e2f303233353637434446474c4d5253545657585a5b5c5d5f62646768696a6b6c6d70727374757677787b7c7d7e808384858687898a8b8e8f9293959d9e9fa0a1a4a5a6a7a8aaaeafb0b2b4b6b9babbbcbec0c2c3c5c6c7c8c9cacccdcecfd0d1d3d4d5d6d7d8dadbdcdddedfe0e2e3e7e9ebeceeeff1f2f3f4f5f6f7f8f9fafcfdfeff,5d:00#01040508090a0b0c0d0f10111213151718191a1c1d1f2021222325282a2b2c2f3031323335363738393a3b3c3f4041424344454648494d4e4f5051525354555657595a5c5e5f6061626364656667686a6d6e7071727375767778797a7b7c7d7e7f8081838485868788898a8b8c8d8e8f9091929394959697989a9b9c9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b8b9babbbcbdbebfc0c1c2c3c4c6c7c8c9cacbcccecfd0d1d2d3d4d5d6d7d8d9dadcdfe0e3e4eaeced#f0f5f6f8f9fafbfcff,5e:000407090a0b0d0e1213171e1f20212223242528292a2b2c2f303233343536393a3e3f404143464748494a4b4d4e4f50515253565758595a5c5d5f60636465666768696a6b6c6d6e6f70717577797e8182838588898c8d8e92989b9da1a2a3a4a8a9aaabacaeafb0b1b2b4babbbcbdbfc0c1c2c3c4c5c6c7c8cbcccdcecfd0d4d5d7d8d9dadcdddedfe0e1e2e3e4e5e6e7e9ebecedeeeff0f1f2f3f5f8f9fbfcfd,5f:050607090c0d0e10121416191a1c1d1e21222324#282b2c2e30323334353637383b3d3e3f4142434445464748494a4b4c4d4e4f5154595a5b5c5e5f60636567686b6e6f72747576787a7d7e7f83868d8e8f919394969a9b9d9e9fa0a2a3a4a5a6a7a9abacafb0b1b2b3b4b6b8b9babbbebfc0c1c2c7c8cacbced3d4d5dadbdcdedfe2e3e5e6e8e9eceff0f2f3f4f6f7f9fafc,60:0708090b0c10111317181a1e1f2223242c2d2e3031323334363738393a3d3e404445464748494a4c4e4f5153545657585b5c5e5f606165666e71727475777e80#8182858687888a8b8e8f909193959798999c9ea1a2a4a5a7a9aaaeb0b3b5b6b7b9babdbebfc0c1c2c3c4c7c8c9cccdcecfd0d2d3d4d6d7d9dbdee1e2e3e4e5eaf1f2f5f7f8fbfcfdfeff,61:02030405070a0b0c1011121314161718191b1c1d1e21222528292a2c2d2e2f303132333435363738393a3b3c3d3e4041424344454647494b4d4f50525354565758595a5b5c5e5f606163646566696a6b6c6d6e6f717273747678797a7b7c7d7e7f808182838485868788898a8c8d8f9091929395#969798999a9b9c9e9fa0a1a2a3a4a5a6aaabadaeafb0b1b2b3b4b5b6b8b9babbbcbdbfc0c1c3c4c5c6c7c9cccdcecfd0d3d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e7e8e9eaebecedeeeff0f1f2f3f4f6f7f8f9fafbfcfdfe,62:00010203040507091314191c1d1e2023262728292b2d2f303132353638393a3b3c424445464a4f50555657595a5c5d5e5f6061626465687172747577787a7b7d818283858687888b8c8d8e8f9094999c9d9ea3a6a7a9aaadaeafb0b2b3b4b6b7b8babec0c1#c3cbcfd1d5dddee0e1e4eaebf0f2f5f8f9fafb,63:00030405060a0b0c0d0f10121314151718191c2627292c2d2e30313334353637383b3c3e3f40414447484a51525354565758595a5b5c5d60646566686a6b6c6f707273747578797c7d7e7f81838485868b8d9193949597999a9b9c9d9e9fa1a4a6abafb1b2b5b6b9bbbdbfc0c1c2c3c5c7c8cacbccd1d3d4d5d7d8d9dadbdcdddfe2e4e5e6e7e8ebeceeeff0f1f3f5f7f9fafbfcfe,64:0304060708090a0d0e111215161718191a1d1f222324#252728292b2e2f3031323335363738393b3c3e404243494b4c4d4e4f505153555657595a5b5c5d5f60616263646566686a6b6c6e6f70717273747576777b7c7d7e7f8081838688898a8b8c8d8e8f90939497989a9b9c9d9fa0a1a2a3a5a6a7a8aaabafb1b2b3b4b6b9bbbdbebfc1c3c4c6c7c8c9cacbcccfd1d3d4d5d6d9dadbdcdddfe0e1e3e5e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,65:01020304050607080a0b0c0d0e0f10111314151617191a1b1c1d1e1f2021#222324262728292a2c2d30313233373a3c3d404142434446474a4b4d4e5052535457585a5c5f606164656768696a6d6e6f7173757678797a7b7c7d7e7f8081828384858688898a8d8e8f92949596989a9d9ea0a2a3a6a8aaacaeb1b2b3b4b5b6b7b8babbbebfc0c2c7c8c9cacdd0d1d3d4d5d8d9dadbdcdddedfe1e3e4eaebf2f3f4f5f8f9fbfcfdfeff,66:0104050708090b0d1011121617181a1b1c1e2122232426292a2b2c2e3032333738393a3b3d3f40424445464748494a4d4e505158#595b5c5d5e6062636567696a6b6c6d7172737578797b7c7d7f808183858688898a8b8d8e8f909293949598999a9b9c9e9fa0a1a2a3a4a5a6a9aaabacadafb0b1b2b3b5b6b7b8babbbcbdbfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8dadedfe0e1e2e3e4e5e7e8eaebecedeeeff1f5f6f8fafbfd,67:010203040506070c0e0f1112131618191a1c1e20212223242527292e303233363738393b3c3e3f414445474a4b4d5254555758595a5b5d62636466676b6c6e717476#78797a7b7d8082838586888a8c8d8e8f9192939496999b9fa0a1a4a6a9acaeb1b2b4b9babbbcbdbebfc0c2c5c6c7c8c9cacbcccdced5d6d7dbdfe1e3e4e6e7e8eaebedeef2f5f6f7f8f9fafbfcfe,68:01020304060d1012141518191a1b1c1e1f20222324252627282b2c2d2e2f30313435363a3b3f474b4d4f52565758595a5b5c5d5e5f6a6c6d6e6f707172737578797a7b7c7d7e7f8082848788898a8b8c8d8e90919294959698999a9b9c9d9e9fa0a1a3a4a5a9aaabacaeb1b2b4b6b7b8#b9babbbcbdbebfc1c3c4c5c6c7c8cacccecfd0d1d3d4d6d7d9dbdcdddedfe1e2e4e5e6e7e8e9eaebecedeff2f3f4f6f7f8fbfdfeff,69:00020304060708090a0c0f11131415161718191a1b1c1d1e21222325262728292a2b2c2e2f313233353637383a3b3c3e4041434445464748494a4b4c4d4e4f50515253555658595b5c5f616264656768696a6c6d6f7072737475767a7b7d7e7f8183858a8b8c8e8f909192939697999a9d9e9fa0a1a2a3a4a5a6a9aaacaeafb0b2b3b5b6b8b9babcbd#bebfc0c2c3c4c5c6c7c8c9cbcdcfd1d2d3d5d6d7d8d9dadcdddee1e2e3e4e5e6e7e8e9eaebeceeeff0f1f3f4f5f6f7f8f9fafbfcfe,6a:000102030405060708090b0c0d0e0f10111213141516191a1b1c1d1e20222324252627292b2c2d2e30323334363738393a3b3c3f40414243454648494a4b4c4d4e4f515253545556575a5c5d5e5f60626364666768696a6b6c6d6e6f70727374757677787a7b7d7e7f81828385868788898a8b8c8d8f929394959698999a9b9c9d9e9fa1a2a3a4a5a6#a7a8aaadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,6b:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f252628292a2b2c2d2e2f303133343536383b3c3d3f4041424445484a4b4d4e4f5051525354555657585a5b5c5d5e5f606168696b6c6d6e6f7071727374757677787a7d7e7f808588#8c8e8f909194959798999c9d9e9fa0a2a3a4a5a6a7a8a9abacadaeafb0b1b2b6b8b9babbbcbdbec0c3c4c6c7c8c9caccced0d1d8dadcdddedfe0e2e3e4e5e6e7e8e9ecedeef0f1f2f4f6f7f8fafbfcfeff,6c:000102030408090a0b0c0e12171c1d1e2023252b2c2d31333637393a3b3c3e3f434445484b4c4d4e4f5152535658595a62636566676b6c6d6e6f71737577787a7b7c7f8084878a8b8d8e9192959697989a9c9d9ea0a2a8acafb0b4b5b6b7bac0c1c2c3c6c7c8cbcdcecfd1d2d8#d9dadcdddfe4e6e7e9ecedf2f4f9ff,6d:000203050608090a0d0f101113141516181c1d1f20212223242628292c2d2f30343637383a3f404244494c50555657585b5d5f6162646567686b6c6d707172737576797a7b7d7e7f8081838486878a8b8d8f9092969798999a9ca2a5acadb0b1b3b4b6b7b9babbbcbdbec1c2c3c8c9cacdcecfd0d2d3d4d5d7dadbdcdfe2e3e5e7e8e9eaedeff0f2f4f5f6f8fafdfeff,6e:0001020304060708090b0f12131518191b1c1e1f222627282a2c2e30313335#3637393b3c3d3e3f40414245464748494a4b4c4f5051525557595a5c5d5e606162636465666768696a6c6d6f707172737475767778797a7b7c7d8081828487888a8b8c8d8e91929394959697999a9b9d9ea0a1a3a4a6a8a9abacadaeb0b3b5b8b9bcbebfc0c3c4c5c6c8c9cacccdced0d2d6d8d9dbdcdde3e7eaebecedeeeff0f1f2f3f5f6f7f8fafbfcfdfeff,6f:000103040507080a0b0c0d0e101112161718191a1b1c1d1e1f212223252627282c2e303234353738393a3b3c3d3f404142#43444548494a4c4e4f5051525354555657595a5b5d5f60616364656768696a6b6c6f707173757677797b7d7e7f808182838586878a8b8f909192939495969798999a9b9d9e9fa0a2a3a4a5a6a8a9aaabacadaeafb0b1b2b4b5b7b8babbbcbdbebfc1c3c4c5c6c7c8cacbcccdcecfd0d3d4d5d6d7d8d9dadbdcdddfe2e3e4e5e6e7e8e9eaebecedf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,70:000102030405060708090a0b0c0d0e0f1012131415161718191c1d1e1f2021222425262728292a#2b2c2d2e2f30313233343637383a3b3c3d3e3f404142434445464748494a4b4d4e505152535455565758595a5b5c5d5f606162636465666768696a6e7172737477797a7b7d818283848687888b8c8d8f90919397989a9b9e9fa0a1a2a3a4a5a6a7a8a9aab0b2b4b5b6babebfc4c5c6c7c9cbcccdcecfd0d1d2d3d4d5d6d7dadcdddee0e1e2e3e5eaeef0f1f2f3f4f5f6f8fafbfcfeff,71:0001020304050607080b0c0d0e0f111214171b1c1d1e1f2021222324252728292a2b2c2d2e323334#353738393a3b3c3d3e3f4041424344464748494b4d4f505152535455565758595a5b5d5f6061626365696a6b6c6d6f707174757677797b7c7e7f8081828385868788898b8c8d8e909192939596979a9b9c9d9ea1a2a3a4a5a6a7a9aaabadaeafb0b1b2b4b6b7b8babbbcbdbebfc0c1c2c4c5c6c7c8c9cacbcccdcfd0d1d2d3d6d7d8d9dadbdcdddedfe1e2e3e4e6e8e9eaebecedeff0f1f2f3f4f5f6f7f8fafbfcfdfeff,72:0001020304050708090a0b0c0d0e0f101112131415161718191a#1b1c1e1f2021222324252627292b2d2e2f3233343a3c3e40414243444546494a4b4e4f505153545557585a5c5e60636465686a6b6c6d707173747677787b7c7d828385868788898c8e9091939495969798999a9b9c9d9ea0a1a2a3a4a5a6a7a8a9aaabaeb1b2b3b5babbbcbdbebfc0c5c6c7c9cacbcccfd1d3d4d5d6d8dadb#95</span>,30:000102,00b702:c9c7,00a830:0305,2014ff5e20:162618191c1d,30:141508090a0b0c0d0e0f16171011,00:b1d7f7,22:362728110f2a2908371aa52520,231222:992b2e614c483d1d606e6f64651e3534,26:4240,00b020:3233,2103ff0400a4ff:e0e1,203000a7211626:0605,25:cbcfcec7c6a1a0b3b2,203b21:92909193,30:13#95<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 25: …273747576777879#̲4'>,21:70717273747576777879#4</span>,24:88898a8b8c8d8e8f909192939495969798999a9b7475767778797a7b7c7d7e7f808182838485868760616263646566676869##,32:20212223242526272829##,21:606162636465666768696a6b#97<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 193: …758595a5b5c5de3#̲95'>,ff:010203e505060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5de3#95</span>,30:4142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f90919293#106<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 173: …ff0f1f2f3f4f5f6#̲103'>a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6#103</span>,03:9192939495969798999a9b9c9d9e9fa0a1a3a4a5a6a7a8a9#6<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 49: …1c3c4c5c6c7c8c9#̲5'>b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c3c4c5c6c7c8c9#5</span>,fe:3536393a3f403d3e41424344##3b3c373831#3334#104$,04:10111213141501161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f#13<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 67: …8494a4b4c4d4e4f#̲11'>30313233343551363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f#11</span>,02:cacbd9,20:13152535,21:050996979899,22:151f23526667bf,25:505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f7071727381828384858687#88898a8b8c8d8e8f939495bcbde2e3e4e5,2609229530:121d1e#9<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …:4448,e7c802:61#̲2'>,010100e101ce00e0011300e9011b00e8012b00ed01d000ec014d00f301d200f2016b00fa01d400f901:d6d8dadc,00:fcea,0251e7c701:4448,e7c802:61#2</span>,31:05060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223242526272829#19<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 65: …2d5,fe30ff:e2e4#̲,212132:31#,20:…'>,30:212223242526272829,32a333:8e8f9c9d9ea1c4ced1d2d5,fe30ff:e2e4#,212132:31#,20:10#1</span>,30:fc9b9cfdfe069d9e,fe:494a4b4c4d4e4f50515254555657595a5b5c5d5e5f6061#626364656668696a6b,e7:e7e8e9eaebecedeeeff0f1f2f3,30:07#11<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 157: …445464748494a4b#̲13'>,25:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b#13</span>,72:dcdddfe2e3e4e5e6e7eaebf5f6f9fdfeff,73:00020405060708090b0c0d0f1011121418191a1f2023242627282d2f30323335363a3b3c3d404142434445464748#494a4b4c4e4f515354555658595a5b5c5d5e5f6162636465666768696a6b6e7071#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …ebfc1c3c4c5c6c7#̲cbccced2d3d4d5d…'>72737475767778797a7b7c7d7f808182838586888a8c8d8f90929394959798999a9c9d9ea0a1a3a4a5a6a7a8aaacadb1b4b5b6b8b9bcbdbebfc1c3c4c5c6c7#cbccced2d3d4d5d6d7d8dadbdcdddfe1e2e3e4e6e8eaebeceeeff0f1f3f4f5f6f7#92</span>f8f9fafbfcfdfeff,74:0001020407080b0c0d0e1112131415161718191c1d1e1f2021232427292b2d2f31323738393a3b3d3e3f4042434445464748494a4b4c4d#4e4f505152535456585d606162636465666768696a6b6c6e6f717273747578797a#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …0c1c2c3c4c5c6c7#̲c8c9cacbcccdcec…'>7b7c7d7f8284858688898a8c8d8f9192939495969798999a9b9d9fa0a1a2a3a4a5a6aaabacadaeafb0b1b2b3b4b5b6b7b8b9bbbcbdbebfc0c1c2c3c4c5c6c7#c8c9cacbcccdcecfd0d1d3d4d5d6d7d8d9dadbdddfe1e5e7e8e9eaebecedf0f1f2#92</span>f3f5f8f9fafbfcfdfe,75:0001020305060708090a0b0c0e1012141516171b1d1e202122232426272a2e3436393c3d3f414243444647494a4d5051525355565758#5d5e5f60616263646768696b6c6d6e6f7071737576777a7b7c7d7e808182848587#92$88898a8c8d8e909395989b9c9ea2a6a7a8a9aaadb6b7babbbfc0c1c6cbcccecfd0d1d3d7d9dadcdddfe0e1e5e9ecedeeeff2f3f5f6f7f8fafbfdfe,76:02040607#08090b0d0e0f11121314161a1c1d1e212327282c2e2f31323637393a3b3d414244#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …092949597989a9b#̲9c9d9e9fa0a1a2a…'>45464748494a4b4e4f50515253555758595a5b5d5f6061626465666768696a6c6d6e7071727374757677797a7c7f80818385898a8c8d8f9092949597989a9b#9c9d9e9fa0a1a2a3a5a6a7a8a9aaabacadafb0b3b5b6b7b8b9babbbcbdbec0c1c3,554a963f57c3632854ce550954c076:914c,853c77ee827e788d72319698978d6c285b894ffa630966975cb880fa684880ae660276ce51f9655671ac7ff1888450b2596561ca6fb382ad634c625253ed54277b06516b75a45df462d48dcb9776628a8019575d97387f627238767d67cf767e64464f708d2562dc7a17659173ed642c6273822c9881677f724862:6ecc,4f3474e3534a529e7eca90a65e2e6886699c81807ed168d278c5868c9551508d8c2482de80de53058912526576:c4c7c9cbccd3d5d9dadcdddee0e1e2e3e4e6e7e8e9eaebecedf0f3f5f6f7fafbfdff,77:00020305060a0c0e0f1011121314151617181b1c1d1e21232425272a2b#2c2e3031323334393b3d3e3f4244454648494a4b4c4d4e4f52535455565758595c,858496f94fdd582199715b9d62:b1a5,66b48c799c8d7206676f789160b253:5117,8f8880cc8d1d94a1500d72c8590760eb711988ab595482ef672c7b285d297ef7752d6cf58e668ff8903c9f3b6bd491197b145f7c78a784d6853d6b:d5d9d6,5e:0187,75f995ed655d5f:0ac5,8f9f58c181c2907f965b97ad8fb97f168d2c62414fbf53:d85e,8f:a8a9ab,904d68075f6a819888689cd6618b522b762a5f6c658c6fd26ee85bbe644851:75b0,67c44e1979c9997c70b377:5d5e5f606467696a6d6e6f7071727374757677787a7b7c818283868788898a8b8f90939495969798999a9b9c9d9ea1a3a4a6a8abadaeafb1b2b4b6b7b8b9ba#bcbec0c1c2c3c4c5c6c7c8c9cacbcccecfd0d1d2d3d4d5d6d8d9dadddedfe0e1e4,75c55e7673bb83e064ad62e894b56ce2535a52c3640f94c27b944f2f5e1b823681:168a,6e246cca9a736355535c54fa886557e04e0d5e036b657c3f90e8601664e6731c88c16750624d8d22776c8e2991c75f6983dc8521991053c286956b8b60:ede8,707f82:cd31,4ed36ca785cf64cd7cd969fd66f9834953957b564fa7518c6d4b5c428e6d63d253c983:2c36,67e578b4643d5bdf5c945dee8be762c667f48c7a640063ba8749998b8c177f2094f24ea7961098a4660c731677:e6e8eaeff0f1f2f4f5f7f9fafbfc,78:0304050607080a0b0e0f101315191b1e20212224282a2b2e2f31323335363d3f414243444648494a4b4d4f51535458595a#5b5c5e5f606162636465666768696f7071727374757678797a7b7d7e7f80818283,573a5c1d5e38957f507f80a05382655e7545553150218d856284949e671d56326f6e5de2543570928f66626f64a463a35f7b6f8890f481e38fb05c1866685ff16c8996488d81886c649179f057ce6a59621054484e587a0b60e96f848bda627f901e9a8b79e4540375f4630153196c608fdf5f1b9a70803b9f7f4f885c3a8d647fc565a570bd51:45b2,866b5d075ba062bd916c75748e0c7a2061017b794ec77ef877854e1181ed521d51fa6a7153a88e87950496cf6ec19664695a78:848586888a8b8f9092949596999d9ea0a2a4a6a8a9aaabacadaeafb5b6b7b8babbbcbdbfc0c2c3c4c6c7c8cccdcecfd1d2d3d6d7d8dadbdcdddedfe0e1e2e3#e4e5e6e7e9eaebedeeeff0f1f3f5f6f8f9fbfcfdfeff,79:00020304060708090a0b0c,784050a877d7641089e6590463e35ddd7a7f693d4f20823955984e3275ae7a975e:628a,95ef521b5439708a6376952457826625693f918755076df37eaf882262337ef075b5832878c196cc8f9e614874f78bcd6b64523a8d506b21806a847156f153064e:ce1b,51d17c97918b7c074fc38e7f7be17a9c64675d1450ac810676017cb96dec7fe067515b:58f8,78cb64:ae13,63:aa2b,9519642d8fbe7b5476296253592754466b7950a362345e266b864ee38d37888b5f85902e79:0d0e0f1011121415161718191a1b1c1d1f2021222325262728292a2b2c2d2e2f3031323335363738393d3f42434445474a4b4c4d4e4f505152545558596163#6466696a6b6c6e70717273747576797b7c7d7e7f8283868788898b8c8d8e909192,6020803d62c54e39535590f863b880c665e66c2e4f4660ee6de18bde5f3986cb5f536321515a83616863520063638e4850125c9b79775bfc52307a3b60bc905376d75f:b797,76848e6c706f767b7b4977aa51f3909358244f4e6ef48fea654c7b1b72c46da47fdf5ae162b55e95573084827b2c5e1d5f1f90127f1498a063826ec7789870b95178975b57ab75354f4375385e9760e659606dc06bbf788953fc96d551cb52016389540a94938c038dcc7239789f87768fed8c0d53e079:939495969798999b9c9d9e9fa0a1a2a3a4a5a6a8a9aaabacadaeafb0b1b2b4b5b6b7b8bcbfc2c4c5c7c8cacccecfd0d3d4d6d7d9dadbdcdddee0e1e2e5e8ea#eceef1f2f3f4f5f6f7f9fafcfeff,7a:0104050708090a0c0f10111213151618191b1c,4e0176ef53ee948998769f0e952d5b9a8ba24e:221c,51ac846361c252a8680b4f97606b51bb6d1e515c6296659796618c46901775d890fd77636bd272:8aec,8bfb583577798d4c675c9540809a5ea66e2159927aef77ed953b6bb565ad7f0e58065151961f5bf958a954288e726566987f56e4949d76fe9041638754c659:1a3a,579b8eb267358dfa8235524160f0581586fe5ce89e454fc4989d8bb95a2560765384627c904f9102997f6069800c513f80335c1499756d314e8c7a:1d1f21222425262728292a2b2c2d2e2f303132343536383a3e4041424344454748494a4b4c4d4e4f50525354555658595a5b5c5d5e5f606162636465666768#696a6b6c6d6e6f717273757b7c7d7e828587898a8b8c8e8f909394999a9b9ea1a2,8d3053d17f5a7b4f4f104e4f96006cd573d085e95e06756a7ffb6a0a77fe94927e4151e170e653cd8fd483038d2972af996d6cdb574a82b365b980aa623f963259a84eff8bbf7eba653e83f2975e556198de80a5532a8bfd542080ba5e9f6cb88d3982ac915a54296c1b52067eb7575f711a6c7e7c89594b4efd5fff61247caa4e305c0167ab87025cf0950b98ce75af70fd902251af7f1d8bbd594951e44f5b5426592b657780a45b7562:76c2,8f905e456c1f7b264f:0fd8,670d7a:a3a4a7a9aaabaeafb0b1b2b4b5b6b7b8b9babbbcbdbec0c1c2c3c4c5c6c7c8c9cacccdcecfd0d1d2d3d4d5d7d8dadbdcdde1e2e4e7e8e9eaebeceef0f1f2f3#f4f5f6f7f8fbfcfe,7b:0001020507090c0d0e1012131617181a1c1d1f21222327292d,6d:6eaa,798f88b15f17752b629a8f854fef91dc65a781:2f51,5e9c81508d74526f89868d4b590d50854ed8961c723681798d1f5bcc8ba3964459877f1a549056:760e,8be565396982949976d66e895e72751867:46d1,7aff809d8d76611f79c665628d635188521a94a27f38809b7eb25c976e2f67607bd9768b9ad8818f7f947cd5641e95507a3f54:4ae5,6b4c640162089e3d80f3759952729769845b683c86e496:0194,94ec4e2a54047ed968398ddf801566f45e9a7fb97b:2f303234353637393b3d3f404142434446484a4d4e535557595c5e5f61636465666768696a6b6c6d6f70737476787a7c7d7f81828384868788898a8b8c8e8f#9192939698999a9b9e9fa0a3a4a5aeafb0b2b3b5b6b7b9babbbcbdbebfc0c2c3c4,57c2803f68975de5653b529f606d9f9a4f9b8eac516c5bab5f135de96c5e62f18d21517194a952fe6c9f82df72d757a267848d2d591f8f9c83c754957b8d4f306cbd5b6459d19f1353e486ca9aa88c3780a16545987e56fa96c7522e74dc52505be1630289024e5662d0602a68fa51735b9851a089c27ba199867f5060ef704c8d2f51495e7f901b747089c4572d78455f529f9f95fa8f689b3c8be17678684267dc8d:ea35,523d8f8a6eda68cd950590ed56fd679c88f98fc754c87b:c5c8c9cacbcdcecfd0d2d4d5d6d7d8dbdcdedfe0e2e3e4e7e8e9ebecedeff0f2f3f4f5f6f8f9fafbfdff,7c:0001020304050608090a0d0e101112131415171819#1a1b1c1d1e20212223242528292b2c2d2e2f3031323334353637393a3b3c3d3e42,9ab85b696d776c264ea55bb39a87916361a890af97e9542b6db55bd251fd558a7f:55f0,64bc634d65f161be608d710a6c:5749,592f676d822a58d5568e8c6a6beb90dd597d801753f76d695475559d83:77cf,683879be548c4f55540876d28c8996026cb36db88d6b89109e648d3a563f9ed175d55f8872e0606854fc4ea86a2a886160528f7054c470d886799e3f6d2a5b8f5f187ea255894faf7334543c539a501954:0e7c,4e4e5ffd745a58f6846b80e1877472d07cca6e567c:434445464748494a4b4c4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f70717275767778797a7e7f8081828384858687#888a8b8c8d8e8f90939496999a9ba0a1a3a6a7a8a9abacadafb0b4b5b6b7b8babb,5f27864e552c62a44e926caa623782b154d7534e733e6ed1753b521253168bdd69d05f8a60006dee574f6b2273af68538fd87f13636260a3552475ea8c6271156da35ba65e7b8352614c9ec478fa87577c27768751f060f6714c66435e4c604d8c0e707063258f895fbd606286d456de6bc160946167534960e066668d3f79fd4f1a70e96c478b:b3f2,7ed88364660f5a5a9b426d:51f7,8c416d3b4f19706b83b7621660d1970d8d27797851fb57:3efa,673a75787a3d79ef7b957c:bfc0c2c3c4c6c9cbcecfd0d1d2d3d4d8dadbdddee1e2e3e4e5e6e7e9eaebecedeef0f1f2f3f4f5f6f7f9fafcfdfeff,7d:000102030405060708090b0c0d0e0f10#1112131415161718191a1b1c1d1e1f212324252628292a2c2d2e30313233343536,808c99658ff96fc08ba59e2159ec7ee97f095409678168d88f917c4d96c653ca602575be6c7253735ac97ea7632451e0810a5df184df628051805b634f0e796d524260b86d4e5b:c4c2,8b:a1b0,65e25fcc964559937e:e7aa,560967b759394f735bb652a0835a988a8d3e753294be50477a3c4ef767b69a7e5ac16b7c76d1575a5c167b3a95f4714e517c80a9827059787f04832768c067ec78:b177,62e363617b804fed526a51cf835069db92748d:f531,89c1952e7bad4ef67d:3738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6f70717273747576#78797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798,506582305251996f6e:1085,6da75efa50f559dc5c066d466c5f7586848b686859568bb253209171964d854969127901712680f64ea490ca6d479a845a0756bc640594f077eb4fa5811a72e189d2997a7f347ede527f655991758f:7f83,53eb7a9663:eda5,768679f888579636622a52ab8282685467706377776b7aed6d017ed389e359d0621285c982a5754c501f4ecb75a58beb5c4a5dfe7b4b65a491d14eca6d25895f7d2795264ec58c288fdb9773664b79818fd170ec6d787d:999a9b9c9d9e9fa0a1a2a3a4a5a7a8a9aaabacadafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9#dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fa,5c3d52b283465162830e775b66769cb84eac60ca7c:beb3,7ecf4e958b66666f988897595883656c955c5f8475c997567a:dfde,51c070af7a9863ea7a767ea0739697ed4e4570784e5d915253a965:51e7,81fc8205548e5c31759a97a062d872d975bd5c459a7983ca5c40548077e94e3e6cae805a62d2636e5de851778ddd8e1e952f4ff153e560e770ac526763509e435a1f5026773753777ee26485652b628963985014723589c951b38bc07edd574783cc94a7519b541b5cfb7d:fbfcfdfeff,7e:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233343536373839#3a3c3d3e3f40424344454648494a4b4c4d4e4f505152535455565758595a5b5c5d,4fca7ae36d5a90e19a8f55805496536154af5f0063e9697751ef6168520a582a52d8574e780d770b5eb761777ce062:5b97,4ea27095800362f770e49760577782db67ef68f578d5989779d158f354b353ef6e34514b523b5ba28bfe80af554357a660735751542d7a7a60505b5463a762a053e362635bc767af54ed7a9f82e691775e9388e4593857ae630e8de880ef57577b774fa95feb5bbd6b3e53217b5072c2684677:ff36,65f751b54e8f76d45cbf7aa58475594e9b4150807e:5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f8081838485868788898a8b8c8d8e8f909192939495969798999a9c9d9e#aeb4bbbcd6e4ecf9,7f:0a101e37393b3c3d3e3f404143464748494a4b4c4d4e4f5253,998861276e8357646606634656f062:ec69,5ed39614578362c955878721814a8fa3556683b167658d5684dd5a6a680f62e67bee961151706f9c8c3063fd89c861d27f0670c26ee57405699472fc5eca90ce67176d6a635e52b3726280014f6c59e5916a70d96d9d52d24e5096f7956d857e78ca7d2f5121579264c2808b7c7b6cea68f1695e51b7539868a872819ece7bf172f879bb6f137406674e91cc9ca4793c83:8954,540f68174e3d538952b1783e5386522950884f:8bd0,7f:56595b5c5d5e6063646566676b6c6d6f7073757677787a7b7c7d7f8082838485868788898b8d8f9091929395969798999b9ca0a2a3a5a6a8a9aaabacadaeb1#b3b4b5b6b7babbbec0c2c3c4c6c7c8c9cbcdcfd0d1d2d3d6d7d9dadbdcdddee2e3,75e27acb7c926ca596b6529b748354e94fe9805483b28fde95705ec9601c6d9f5e18655b813894fe604b70bc7ec37cae51c968817cb1826f4e248f8691cf667e4eae8c0564a9804a50da759771ce5be58fbd6f664e86648295635ed66599521788c270c852a3730e7433679778f797164e3490bb9cde6dcb51db8d41541d62ce73b283f196f69f8494c34f367f9a51cc707596755cad988653e64ee46e9c740969b4786b998f7559521876246d4167f3516d9f99804b54997b3c7abf7f:e4e7e8eaebecedeff2f4f5f6f7f8f9fafdfeff,80:020708090a0e0f11131a1b1d1e1f2123242b2c2d2e2f303234393a3c3e404144454748494e4f505153555657#595b5c5d5e5f6061626364656667686b6c6d6e6f7072737475767778797a7b7c7d,9686578462e29647697c5a0464027bd36f0f964b82a6536298855e90708963b35364864f9c819e93788c97328d:ef42,9e7f6f5e79845f559646622e9a74541594dd4fa365c55c:6561,7f1586516c2f5f8b73876ee47eff5ce6631b5b6a6ee653754e7163a0756562a18f6e4f264ed16ca67eb68bba841d87ba7f57903b95237ba99aa188f8843d6d1b9a867edc59889ebb739b780186829a:6c82,561b541757cb4e709ea653568fc881097792999286ee6ee1851366fc61626f2b80:7e818285888a8d8e8f909192949597999ea3a6a7a8acb0b3b5b6b8b9bbc5c7c8c9cacbcfd0d1d2d3d4d5d8dfe0e2e3e6eef5f7f9fbfeff,81:000103040507080b#0c1517191b1c1d1f202122232425262728292a2b2d2e3033343537393a3b3c3d3f,8c298292832b76f26c135fd983bd732b8305951a6bdb77db94c6536f830251925e3d8c8c8d384e4873ab679a68859176970971646ca177095a9295416bcf7f8e66275bd059b95a9a95:e8f7,4eec84:0c99,6aac76df9530731b68a65b5f772f919a97617cdc8ff78c1c5f257c7379d889c56ccc871c5bc65e4268c977207ef551:954d,52c95a297f05976282d763cf778485d079d26e3a5e9959998511706d6c1162bf76bf654f60af95fd660e879f9e2394ed54:0d7d,8c2c647881:40414243444547494d4e4f525657585b5c5d5e5f6162636466686a6b6c6f727375767778818384858687898b8c8d8e90929394959697999a9e9fa0a1a2a4a5#a7a9abacadaeafb0b1b2b4b5b6b7b8b9bcbdbebfc4c5c7c8c9cbcdcecfd0d1d2d3,647986116a21819c78e864699b5462b9672b83ab58a89ed86cab6f205bde964c8c0b725f67d062c772614ea959c66bcd589366ae5e5552df6155672876ee776672677a4662ff54:ea50,94a090a35a1c7eb36c164e435976801059485357753796be56ca63208111607c95f96dd65462998151855ae980fd59ae9713502a6ce55c3c62df4f60533f817b90066eba852b62c85e7478be64b5637b5ff55a18917f9e1f5c3f634f80425b7d556e95:4a4d,6d8560a867e072de51dd5b8181:d4d5d6d7d8d9dadbdcdddedfe0e1e2e4e5e6e8e9ebeeeff0f1f2f5f6f7f8f9fafdff,82:030708090a0b0e0f111315161718191a1d2024252627292e323a3c3d3f#404142434546484a4c4d4e5051525354555657595b5c5d5e606162636465666769,62e76cde725b626d94ae7ebd81136d53519c5f04597452aa6012597366968650759f632a61e67cef8bfa54e66b279e256bb485d5545550766ca4556a8db4722c5e156015743662cd6392724c5f986e436d3e65006f5876d878d076fc7554522453db4e535e9e65c180:2ad6,629b5486522870ae888d8dd16ce1547880da57f988f48d54966a914d4f696c9b55b776c6783062a870f96f8e5f6d84ec68da787c7bf781a8670b9e4f636778b0576f7812973962:79ab,528874356bd782:6a6b6c6d71757677787b7c808183858687898c90939495969a9b9ea0a2a3a7b2b5b6babbbcbfc0c2c3c5c6c9d0d6d9dadde2e7e8e9eaecedeef0f2f3f5f6f8#fafcfdfeff,83:000a0b0d1012131618191d1e1f20212223242526292a2e3032373b3d,5564813e75b276ae533975de50fb5c418b6c7bc7504f72479a9798d86f0274e27968648777a562fc98918d2b54c180584e52576a82f9840d5e7351ed74f68bc45c4f57616cfc98875a4678349b448feb7c955256625194fa4ec68386846183e984b257d467345703666e6d668c3166dd7011671f6b3a6816621a59bb4e0351c46f0667d26c8f517668cb59476b6775665d0e81109f5065d779:4841,9a918d775c824e5e4f01542f5951780c56686c148fc45f036c:7de3,8bab639083:3e3f41424445484a4b4c4d4e5355565758595d6270717273747576797a7e7f808182838487888a8b8c8d8f909194959697999a9d9fa1a2a3a4a5a6a7acadae#afb5bbbebfc2c3c4c6c8c9cbcdced0d1d2d3d5d7d9dadbdee2e3e4e6e7e8ebeced,60706d3d7275626694:8ec5,53438fc17b7e4edf8c264e7e9ed494:b1b3,524d6f5c90636d458c3458115d4c6b:2049,67aa545b81547f8c589985375f3a62a26a47953965726084686577a74e544fa85de7979864ac7fd85ced4fcf7a8d520783044e14602f7a8394a64fb54eb279e6743452e482b964d279bd5bdd6c8197528f7b6c22503e537f6e0564ce66746c3060c598778bf75e86743c7a7779cb4e1890b174036c4256da914b6cc58d8b533a86c666f28eaf5c489a716e2083:eeeff3f4f5f6f7fafbfcfeff,84:0002050708090a10121314151617191a1b1e1f20212223292a2b2c2d2e2f30323334353637393a3b3e3f404142434445474849#4a4b4c4d4e4f505253545556585d5e5f606264656667686a6e6f70727477797b7c,53d65a369f8b8da353bb570898a76743919b6cc9516875ca62f372ac52:389d,7f3a7094763853749e4a69b7786e96c088d97fa471:36c3,518967d374e458e4651856b78ba9997662707ed560f970ed58ec4e:c1ba,5fcd97e74efb8ba45203598a7eab62544ecd65e5620e833884c98363878d71946eb65bb97ed2519763c967d480898339881551125b7a59828fb14e736c5d516589258f6f962e854a745e95:10f0,6da682e55f3164926d128428816e9cc3585e8d5b4e0953c184:7d7e7f8081838485868a8d8f90919293949596989a9b9d9e9fa0a2a3a4a5a6a7a8a9aaabacadaeb0b1b3b5b6b7bbbcbec0c2c3c5c6c7c8cbcccecfd2d4d5d7#d8d9dadbdcdee1e2e4e7e8e9eaebedeeeff1f2f3f4f5f6f7f8f9fafbfdfe,85:000102,4f1e6563685155d34e2764149a9a626b5ac2745f82726da968ee50e7838e7802674052396c997eb150bb5565715e7b5b665273ca82eb67495c715220717d886b95ea965564c58d6181b355846c5562477f2e58924f2455468d4f664c4e0a5c1a88f368a2634e7a0d70e7828d52fa97f65c1154e890b57ecd59628d4a86c782:0c0d,8d6664445c0461516d89793e8bbe78377533547b4f388eab6df15a207ec5795e6c885ba15a76751a80be614e6e1758f075:1f25,727253477ef385:030405060708090a0b0d0e0f101214151618191b1c1d1e2022232425262728292a2d2e2f303132333435363e3f404142444546474b4c4d4e4f505152535455#57585a5b5c5d5f60616263656667696a6b6c6d6e6f707173757677787c7d7f8081,770176db526980dc57235e08593172ee65bd6e7f8bd75c388671534177f362fe65f64ec098df86805b9e8bc653f277e24f7f5c4e9a7659cb5f0f793a58eb4e1667ff4e8b62ed8a93901d52bf662f55dc566c90024ed54f8d91ca99706c0f5e0260435ba489c68bd56536624b99965b:88ff,6388552e53d77626517d852c67a268b36b8a62928f9353d482126dd1758f4e668d4e5b70719f85af66:91d9,7f7287009ecd9f205c5e672f8ff06811675f620d7ad658855eb665706f3185:82838688898a8b8c8d8e909192939495969798999a9d9e9fa0a1a2a3a5a6a7a9abacadb1b2b3b4b5b6b8babbbcbdbebfc0c2c3c4c5c6c7c8cacbcccdced1d2#d4d6d7d8d9dadbdddedfe0e1e2e3e5e6e7e8eaebecedeeeff0f1f2f3f4f5f6f7f8,60555237800d6454887075295e05681362f4971c53cc723d8c016c3477617a0e542e77ac987a821c8bf47855671470c165af64955636601d79c153f84e1d6b7b80865bfa55e356db4f:3a3c,99725df3677e80386002988290015b8b8b:bcf5,641c825864de55fd82cf91654fd77d20901f7c9f50f358516eaf5bbf8bc980839178849c7b97867d96:8b8f,7ee59ad3788e5c817a57904296a7795f5b59635f7b0b84d168ad55067f2974107d2295016240584c4ed65b835979585485:f9fafcfdfe,86:0001020304060708090a0b0c0d0e0f10121314151718191a1b1c1d1e1f20212223242526282a2b2c2d2e2f3031323334353637393a3b3d3e3f40#4142434445464748494a4b4c525355565758595b5c5d5f6061636465666768696a,736d631e8e:4b0f,80ce82d462ac53f06cf0915e592a60016c70574d644a8d2a762b6ee9575b6a8075f06f6d8c:2d08,57666bef889278b363a253f970ad6c645858642a580268e0819b55107cd650188eba6dcc8d9f70eb638f6d9b6ed47ee68404684390036dd896768ba85957727985e4817e75bc8a8a68af52548e22951163d098988e44557c4f5366ff568f60d56d9552435c4959296dfb586b75:301c,606c82148146631167618fe2773a8d:f334,94c15e165385542c70c386:6d6f7072737475767778838485868788898e8f90919294969798999a9b9e9fa0a1a2a5a6abadaeb2b3b7b8b9bbbcbdbebfc1c2c3c5c8cccdd2d3d5d6d7dadc#dde0e1e2e3e5e6e7e8eaebeceff5f6f7fafbfcfdff,87:010405060b0c0e0f10111416,6c405ef7505c4ead5ead633a8247901a6850916e77b3540c94dc5f647ae5687663457b527edf75db507762955934900f51f879c37a8156fe5f9290146d825c60571f541051546e4d56e263a89893817f8715892a9000541e5c6f81c062:d658,81319e3596409a:6e7c,692d59a562d3553e631654c786d96d3c5a0374e6889c6b6a59168c4c5f2f6e7e73a9987d4e3870f75b8c7897633d665a769660cb5b9b5a494e0781556c6a738b4ea167897f515f8065fa671b5fd859845a0187:191b1d1f20242627282a2b2c2d2f303233353638393a3c3d404142434445464a4b4d4f505152545556585a5b5c5d5e5f6162666768696a6b6c6d6f71727375#7778797a7f8081848687898a8c8e8f90919294959698999a9b9c9d9ea0a1a2a3a4,5dcd5fae537197e68fdd684556f4552f60df4e3a6f4d7ef482c7840e59d44f:1f2a,5c3e7eac672a851a5473754f80c355829b4f4f4d6e2d8c135c096170536b761f6e29868a658795fb7eb9543b7a337d0a95ee55e17fc174ee631d87176da17a9d621165a1536763e16c835deb545c94a84e4c6c618bec5c4b65e0829c68a754:3e34,6b:cb66,4e9463425348821e4f:0dae,575e620a96fe6664726952:ffa1,609f8bef661471996790897f785277fd6670563b54389521727a87:a5a6a7a9aaaeb0b1b2b4b6b7b8b9bbbcbebfc1c2c3c4c5c7c8c9cccdcecfd0d4d5d6d7d8d9dadcdddedfe1e2e3e4e6e7e8e9ebecedeff0f1f2f3f4f5f6f7f8#fafbfcfdff,88:0001020405060708090b0c0d0e0f101112141718191a1c1d1e1f2023,7a00606f5e0c6089819d591560dc718470ef6eaa6c5072806a8488ad5e2d4e605ab3559c94e36d177cfb9699620f7ec6778e867e5323971e8f9666875ce14fa072ed4e0b53a6590f54136380952851484ed99c9c7ea454b88d248854823795f26d8e5f265acc663e966973:b02e,53bf817a99857fa15baa96:7750,7ebf76f853a2957699997bb189446e584e617fd479658be660f354cd4eab98795df76a6150cf54118c618427785d9704524a54ee56a395006d885bb56dc6665388:2425262728292a2b2c2d2e2f30313334353637383a3b3d3e3f414243464748494a4b4e4f505152535556585a5b5c5d5e5f6066676a6d6f717374757678797a#7b7c80838687898a8c8e8f90919394959798999a9b9d9e9fa0a1a3a5a6a7a8a9aa,5c0f5b5d6821809655787b11654869544e9b6b47874e978b534f631f643a90aa659c80c18c10519968b0537887f961c86c:c4fb,8c225c5185aa82af950c6b238f9b65b05f:fbc3,4fe18845661f8165732960fa51745211578b5f6290a2884c91925e78674f602759d351:44f6,80f853086c7996c4718a4f:11ee,7f9e673d55c5950879c088967ee3589f620c9700865a5618987b5f908bb884c4915753d965ed5e8f755c60647d6e5a7f7e:eaed,8f6955a75ba360ac65cb738488:acaeafb0b2b3b4b5b6b8b9babbbdbebfc0c3c4c7c8cacbcccdcfd0d1d3d6d7dadbdcdddee0e1e6e7e9eaebecedeeeff2f5f6f7fafbfdff,89:0001030405060708#090b0c0d0e0f1114151617181c1d1e1f20222324262728292c2d2e2f3132333537,9009766377297eda9774859b5b667a7496ea884052cb718f5faa65ec8be25bfb9a6f5de16b896c5b8b:adaf,900a8fc5538b62bc9e:262d,54404e2b82bd7259869c5d1688596daf96c554d14e9a8bb6710954bd960970df6df976d04e25781487125ca95ef68a00989c960e708e6cbf594463a9773c884d6f148273583071d5538c781a96c155015f6671305bb48c1a9a8c6b83592e9e2f79e76768626c4f6f75a17f8a6d0b96336c274ef075d2517b68376f3e908081705996747689:38393a3b3c3d3e3f40424345464748494a4b4c4d4e4f505152535455565758595a5b5c5d6061626364656768696a6b6c6d6e6f707172737475767778797a7c#7d7e808284858788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1,64475c2790657a918c2359da54ac8200836f898180006930564e8036723791ce51b64e5f987563964e1a53f666f3814b591c6db24e0058f9533b63d694f14f:9d0a,886398905937905779fb4eea80f075916c825b9c59e85f5d69058681501a5df24e5977e34ee5827a6291661390915c794ebf5f7981c69038808475ab4ea688d4610f6bc55fc64e4976ca6ea28b:e3ae,8c0a8bd15f027f:fccc,7ece83:356b,56e06bb797f3963459fb541f94f66deb5bc5996e5c395f15969089:a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c3cdd3d4d5d7d8d9dbdddfe0e1e2e4e7e8e9eaecedeef0f1f2f4f5f6f7f8f9fa#fbfcfdfeff,8a:01020304050608090a0b0c0d0e0f101112131415161718191a1b1c1d,537082f16a315a749e705e947f2883b984:2425,836787478fce8d6276c85f719896786c662054df62e54f6381c375c85eb896cd8e0a86f9548f6cf36d8c6c38607f52c775285e7d4f1860a05fe75c24753190ae94c072b96cb96e389149670953:cbf3,4f5191c98bf153c85e7c8fc26de44e8e76c26986865e611a82064f:59de,903e9c7c61096e:1d14,96854e885a3196e84e0e5c7f79b95b878bed7fbd738957df828b90c15401904755bb5cea5fa161086b3272f180b28a:891e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3f4041424344454647494a4b4c4d4e4f505152535455565758595a5b5c5d5e#5f606162636465666768696a6b6c6d6e6f7071727374757677787a7b7c7d7e7f80,6d745bd388d598848c6b9a6d9e336e0a51:a443,57a38881539f63f48f9556ed54585706733f6e907f188fdc82d1613f6028966266f07ea68d:8ac3,94a55cb37ca4670860a6960580184e9190e75300966851418fd08574915d665597f55b55531d78386742683d54c9707e5bb08f7d518d572854b1651266828d:5e43,810f846c906d7cdf51ff85fb67a365e96fa186a48e81566a90207682707671e58d2362e952196cfd8d3c600e589e618e66fe8d60624e55b36e23672d8f678a:81828384858687888b8c8d8e8f9091929495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2#c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3,94e195f87728680569a8548b4e4d70b88bc86458658b5b857a84503a5be877bb6be18a797c986cbe76cf65a98f975d2d5c5586386808536062187ad96e5b7efd6a1f7ae05f706f335f20638c6da867564e085e108d264ed780c07634969c62db662d627e6cbc8d7571677f695146808753ec906e629854f286f08f998005951785178fd96d5973cd659f771f7504782781fb8d1e94884fa6679575b98bca9707632f9547963584b8632377415f8172f04e896014657462ef6b63653f8a:e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8b:0001020304050608090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223#24252728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445,5e2775c790d18bc1829d679d652f5431871877e580a281026c414e4b7ec7804c76f4690d6b966267503c4f84574063076b628dbe53ea65e87eb85fd763:1ab7,81:f3f4,7f6e5e1c5cd95236667a79e97a1a8d28709975d46ede6cbb7a924e2d76c55fe0949f88777ec879cd80bf91cd4ef24f17821f54685dde6d328bcc7ca58f7480985e1a549276b15b99663c9aa473e0682a86db6731732a8b:f8db,90107af970db716e62c477a956314e3b845767f152a986c08d2e94f87b518b:464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364656768696a6b6d6e6f707172737475767778797a7b7c7d7e7f80818283848586#8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9facb1bbc7d0ea,8c:091e,4f4f6ce8795d9a7b6293722a62fd4e1378168f6c64b08d5a7bc668695e8488c55986649e58ee72b6690e95258ffd8d5857607f008c0651c6634962d95353684c74228301914c55447740707c6d4a517954a88d4459ff6ecb6dc45b5c7d2b4ed47c7d6ed35b5081ea6e0d5b579b0368d58e2a5b977efc603b7eb590b98d70594f63cd79df8db3535265cf79568bc5963b7ec494bb7e825634918967007f6a5c0a907566285de64f5067de505a4f5c57505e:a7#3</span>,8c:38393a3b3c3d3e3f4042434445484a4b4d4e4f5051525354565758595b5c5d5e5f60636465666768696c6d6e6f707172747576777b7c7d7e7f808183848687#888b8d8e8f90919293959697999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacad,4e:8d0c,51404e105eff53454e:15981e,9b325b6c56694e2879ba4e3f53154e47592d723b536e6c1056df80e499976bd3777e9f174e:369f,9f104e:5c6993,82885b5b556c560f4ec453:8d9da3a5ae,97658d5d53:1af5262e3e,8d5c53:6663,52:02080e2d333f404c5e615c,84af52:7d82819093,51827f544e:bbc3c9c2e8e1ebde,4f1b4ef34f:2264,4ef54f:2527092b5e67,65384f:5a5d,8c:aeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebec#edeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8d:000102030405060708090a0b0c0d,4f:5f57323d76749189838f7e7baa7cac94e6e8eac5dae3dcd1dff8,50:294c,4ff350:2c0f2e2d,4ffe50:1c0c25287e4355484e6c7ba5a7a9bad6,510650:edece6ee,51:070b,4edd6c3d4f:5865ce,9fa06c467c74516e5dfd9ec999985181591452f9530d8a07531051eb591951554ea051564eb388:6ea4,4eb5811488d279805b3488037fb851:abb1bdbc,8d:0e0f101112131415161718191a1b1c205152575f6568696a6c6e6f717278797a7b7c7d7e7f808283868788898c8d8e8f90929395969798999a9b9c9d9ea0a1#a2a4a5a6a7a8a9aaabacadaeafb0b2b6b7b9bbbdc0c1c2c5c7c8c9cacdd0d2d3d4,51:c796a2a5,8b:a0a6a7aab4b5b7c2c3cbcfced2d3d4d6d8d9dcdfe0e4e8e9eef0f3f6f9fcff,8c:000204070c0f1112141516191b181d1f202125272a2b2e2f32333536,53:697a,96:1d2221312a3d3c4249545f676c7274888d97b0,90:979b9d99aca1b4b3b6ba,8d:d5d8d9dce0e1e2e5e6e7e9edeef0f1f2f4f6fcfeff,8e:00010203040607080b0d0e1011121315161718191a1b1c202124252627282b2d303233343637383b3c3e#3f4345464c4d4e4f505354555657585a5b5c5d5e5f60616263646567686a6b6e71,90:b8b0cfc5bed0c4c7d3e6e2dcd7dbebeffe,91:04221e23312f394346,520d594252:a2acadbe,54ff52:d0d6f0,53df71ee77cd5ef451:f5fc,9b2f53b65f01755a5def57:4ca9a1,58:7ebcc5d1,57:292c2a33392e2f5c3b4269856b867c7b686d7673ada48cb2cfa7b493a0d5d8dad9d2b8f4eff8e4dd,8e:73757778797a7b7d7e808283848688898a8b8c8d8e91929395969798999a9b9d9fa0a1a2a3a4a5a6a7a8a9aaadaeb0b1b3b4b5b6b7b8b9bbbcbdbebfc0c1c2#c3c4c5c6c7c8c9cacbcccdcfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4,58:0b0d,57:fded,58:001e194420656c81899a80,99a89f1961ff82:797d7f8f8aa8848e919799abb8beb0c8cae398b7aecbccc1a9b4a1aa9fc4cea4e1,830982:f7e4,83:0f07,82:dcf4d2d8,830c82:fbd3,83:111a061415,82:e0d5,83:1c515b5c08923c34319b5e2f4f47435f4017602d3a336665,8e:e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8f:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223#2425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f4041424344,83:681b696c6a6d6eb078b3b4a0aa939c857cb6a97db87b989ea8babcc1,840183:e5d8,580784:180b,83:ddfdd6,84:1c381106,83:d4df,84:0f03,83:f8f9eac5c0,842683:f0e1,84:5c515a597387887a89783c4669768c8e316dc1cdd0e6bdd3cabfbae0a1b9b497e5e3,850c750d853884f085:391f3a,8f:45464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364656a808c929da0a1a2a4a5a6a7aaacadaeafb2b3b4b5b7b8babbbcbfc0c3c6#c9cacbcccdcfd2d6d7dae0e1e3e7eceff1f2f4f5f6fafbfcfeff,90:07080c0e131518,85:563b,84:fffc,85:594868645e7a,77a285:43727ba4a8878f79ae9c85b9b7b0d3c1dcff,86:270529163c,5efe5f0859:3c41,803759:555a58,530f5c:22252c34,62:4c6a9fbbcadad7ee,632262f663:394b43adf6717a8eb46dac8a69aebcf2f8e0ffc4dece,645263:c6be,64:45410b1b200c26215e846d96,90:191c2324252728292a2b2c303132333437393a3d3f4043454648494a4b4c4e545556595a5c5d5e5f6061646667696a6b6c6f70717273767778797a7b7c7e81#84858687898a8c8d8e8f90929496989a9c9e9fa0a4a5a7a8a9abadb2b7bcbdbfc0,64:7ab7b899bac0d0d7e4e2,65:09252e,5f:0bd2,75195f1153:5ff1fde9e8fb,54:1216064b5253545643215759233282947771649a9b8476669dd0adc2b4d2a7a6d3d472a3d5bbbfccd9dadca9aaa4ddcfde,551b54e7552054fd551454f355:22230f11272a678fb5496d41553f503c,90:c2c3c6c8c9cbcccdd2d4d5d6d8d9dadedfe0e3e4e5e9eaeceef0f1f2f3f5f6f7f9fafbfcff,91:00010305060708090a0b0c0d0e0f1011121314151617181a1b1c#1d1f20212425262728292a2b2c2d2e30323334353637383a3b3c3d3e3f40414244,55:375675767733305c8bd283b1b988819f7ed6917bdfbdbe9499eaf7c9,561f55:d1ebecd4e6ddc4efe5f2f3cccde8f5e4,8f9456:1e080c012423,55fe56:00272d5839572c4d62595c4c548664716b7b7c8593afd4d7dde1f5ebf9ff,57:040a091c,5e:0f191411313b3c,91:454748515354555658595b5c5f606667686b6d737a7b7c808182838486888a8e8f939495969798999c9d9e9fa0a1a4a5a6a7a8a9abacb0b1b2b3b6b7b8b9bb#bcbdbebfc0c1c2c3c4c5c6c8cbd0d2d3d4d5d6d7d8d9dadbdddedfe0e1e2e3e4e5,5e:3744545b5e61,5c:8c7a8d9096889899919a9cb5a2bdacabb1a3c1b7c4d2e4cbe5,5d:020327262e241e061b583e343d6c5b6f5d6b4b4a697482999d,8c735d:b7c5,5f:73778287898c95999ca8adb5bc,88625f6172:adb0b4b7b8c3c1cecdd2e8efe9f2f4f7,730172f3730372fa91:e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,92:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021222324#25262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445,72fb73:1713210a1e1d152239252c3831504d57606c6f7e,821b592598e759:2402,99:636768696a6b6c74777d8084878a8d9091939495,5e:80918b96a5a0b9b5beb3,8d535e:d2d1dbe8ea,81ba5f:c4c9d6cf,60035fee60045f:e1e4fe,60:0506,5f:eaedf8,60:1935261b0f0d292b0a3f2178797b7a42,92:464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f7071727375767778797a7b7c7d7e7f808182838485#868788898a8b8c8d8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7,60:6a7d969aad9d83928c9becbbb1ddd8c6dab4,61:20261523,60f461:000e2b4a75ac94a7b7d4f5,5fdd96b395:e9ebf1f3f5f6fcfe,96:030406080a0b0c0d0f12151617191a,4e2c723f62156c:35545c4aa38590948c6869747686a9d0d4adf7f8f1d7b2e0d6faebeeb1d3effe,92:a8a9aaabacadafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8#e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,93:00010203040506070809,6d:39270c43480704190e2b4d2e351a4f525433916f9ea05e93945c607c63,6e1a6d:c7c5de,6e0e6d:bfe0,6e116d:e6ddd9,6e166dab6e0c6dae6e:2b6e4e6bb25f865354322544dfb198e0,6f2d6e:e2a5a7bdbbb7d7b4cf8fc29f,6f:6246472415,6ef96f:2f364b742a0929898d8c78727c7ad1,93:0a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3f40414243444546474849#4a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696b,6f:c9a7b9b6c2e1eedee0ef,70:1a231b39354f5e,5b:80849593a5b8,752f9a9e64345b:e4ee,89305bf08e478b078f:b6d3d5e5eee4e9e6f3e8,90:05040b26110d162135362d2f445152506858625b,66b990:747d8288838b,5f:50575658,5c3b54ab5c:5059,5b715c:6366,7fbc5f:2a292d,82745f3c9b3b5c6e59:81838da9aaa3,93:6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaab#acadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cbcccd,59:97caab9ea4d2b2afd7be,5a:0506,59dd5a0859:e3d8f9,5a:0c09323411231340674a553c6275,80ec5a:aa9b777abeebb2d2d4b8e0e3f1d6e6d8dc,5b:091716323740,5c:151c,5b:5a6573515362,9a:7577787a7f7d808185888a90929396989b9c9d9fa0a2a3a5a7,7e:9fa1a3a5a8a9,93:cecfd0d1d2d3d4d5d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,94:000102030405060708090a0b0c0d#0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e,7e:adb0bec0c1c2c9cbccd0d4d7dbe0e1e8ebeeeff1f2,7f0d7e:f6fafbfe,7f:01020307080b0c0f111217191c1b1f212223242526272a2b2c2d2f3031323335,5e7a757f5ddb753e909573:8e91aea29fcfc2d1b7b3c0c9c8e5d9,987c740a73:e9e7debaf2,74:0f2a5b262528302e2c,94:2f303132333435363738393a3b3c3d3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6c6d6e6f#707172737475767778797a7b7c7d7e7f8081828384919698c7cfd3d4dae6fb,95:1c20,74:1b1a415c575559776d7e9c8e8081878b9ea8a990a7d2ba,97:eaebec,67:4c535e4869a5876a7398a775a89ead8b777cf0,680967d8680a67:e9b0,680c67:d9b5dab3dd,680067:c3b8e2,680e67:c1fd,68:323360614e624464831d55664167403e4a4929b58f7477936bc2,696e68fc69:1f20,68f995:27333d43484b555a606e74757778797a7b7c7d7e808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aa#abacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacb,692468f069:0b0157,68e369:10713960425d846b80987834cc8788ce896663799ba7bbabadd4b1c1cadf95e08dff,6a2f69ed6a:171865,69f26a:443ea0505b358e793d28587c9190a997ab,73:3752,6b:8182878492938d9a9ba1aa,8f:6b6d71727375767877797a7c7e818284878b,95:cccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7ecff,96:0713181b1e20232425262728292b2c2d2f303738393a3e41434a4e4f5152535657#58595a5c5d5e606365666b6d6e6f70717378797a7b7c7d7e7f808182838487898a,8f:8d8e8f989a,8ece62:0b171b1f222125242c,81e774:eff4ff,75:0f1113,65:34eeeff0,66:0a19,677266:031500,708566:f71d34313635,800666:5f54414f56615777848ca79dbedbdce6e9,8d:3233363b3d4045464849474d5559,89:c7cacbcccecfd0d1,72:6e9f5d666f7e7f848b8d8f92,63:0832b0,96:8c8e91929395969a9b9d9e9fa0a1a2a3a4a5a6a8a9aaabacadaeafb1b2b4b5b7b8babbbfc2c3c8cacbd0d1d3d4d6d7d8d9dadbdcdddedfe1e2e3e4e5e6e7eb#ecedeef0f1f2f4f5f8fafbfcfdff,97:0203050a0b0c10111214151718191a1b1d1f20,64:3fd8,80046b:eaf3fdf5f9,6c:0507060d1518191a2129242a32,65:35556b,72:4d525630,8662521680:9f9c93bc,670a80:bdb1abadb4b7e7e8e9eadbc2c4d9cdd7,671080:ddebf1f4ed,81:0d0e,80:f2fc,671581128c5a81:361e2c1832484c5374595a7160697c7d6d67,584d5ab581:888291,6ed581:a3aacc,672681:cabb,97:2122232425262728292b2c2e2f3133343536373a3b3c3d3f404142434445464748494a4b4c4d4e4f5051545557585a5c5d5f63646667686a6b6c6d6e6f7071#72757778797a7b7d7e7f8081828384868788898a8c8e8f9093959697999a9b9c9d,81:c1a6,6b:243739434659,98:d1d2d3d5d9da,6bb35f406bc289f365909f5165:93bcc6c4c3ccced2d6,70:809c969dbbc0b7abb1e8ca,71:1013162f31735c6845724a787a98b3b5a8a0e0d4e7f9,72:1d28,706c71:1866b9,62:3e3d434849,79:3b4046495b5c535a6257606f677a858a9aa7b3,5f:d1d0,97:9e9fa1a2a4a5a6a7a8a9aaacaeb0b1b3b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3#e4e5e8eeeff0f1f2f4f7f8f9fafbfcfdfeff,98:000102030405060708090a0b0c0d0e,60:3c5d5a67415963ab,61:060d5da99dcbd1,620680:807f,6c:93f6,6dfc77:f6f8,78:0009171811,65ab78:2d1c1d393a3b1f3c252c23294e6d56572650474c6a9b939a879ca1a3b2b9a5d4d9c9ecf2,790578f479:13241e34,9f9b9e:f9fbfc,76f177:040d,76f977:07081a22192d263538505147435a68,98:0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d#4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e,77:62657f8d7d808c919fa0b0b5bd,75:3a404e4b485b727983,7f:58615f,8a487f:68747179817e,76:cde5,883294:8586878b8a8c8d8f909497959a9b9ca3a4abaaadacafb0b2b4b6b7b8b9babcbdbfc4c8c9cacbcccdced0d1d2d5d6d7d9d8dbdedfe0e2e4e5e7e8ea,98:6f70717273748b8e929599a3a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcfd0d4d6d7dbdcdde0e1e2e3e4#e5e6e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,99:0001020304050607,94:e9ebeeeff3f4f5f7f9fcfdff,95:03020607090a0d0e0f1213141516181b1d1e1f222a2b292c3132343637383c3e3f4235444546494c4e4f525354565758595b5e5f5d61626465666768696a6b6c6f7172733a,77:e7ec,96c979:d5ede3eb,7a065d477a:03021e14,99:08090a0b0c0e0f1112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2f303132333435363738393a3b3c3d3e3f40414243444546474849#4a4b4c4d4e4f50515253565758595a5b5c5d5e5f60616264667378797b7e828389,7a:393751,9ecf99a57a7076:888e9399a4,74:dee0,752c9e:202228292a2b2c3231363837393a3e414244464748494b4c4e5155575a5b5c5e63666768696a6b6c716d73,75:929496a09daca3b3b4b8c4b1b0c3c2d6cde3e8e6e4ebe7,760375:f1fcff,76:1000050c170a25181519,99:8c8e9a9b9c9d9e9fa0a1a2a3a4a6a7a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8#d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9,76:1b3c2220402d303f35433e334d5e545c566b6f,7fca7a:e6787980868895a6a0aca8adb3,88:6469727d7f82a2c6b7bcc9e2cee3e5f1,891a88:fce8fef0,89:2119131b0a342b3641667b,758b80e576:b2b4,77dc80:1214161c20222526272928310b3543464d526971,898398:788083,99:fafbfcfdfeff,9a:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738#393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f50515253545556575859,98:898c8d8f949a9b9e9fa1a2a5a6,86:4d546c6e7f7a7c7ba88d8bac9da7a3aa93a9b6c4b5ceb0bab1afc9cfb4e9f1f2edf3d0,871386:def4dfd8d1,87:0307,86f887:080a0d09233b1e252e1a3e48343129373f82227d7e7b60704c6e8b53637c64596593afa8d2,9a:5a5b5c5d5e5f606162636465666768696a6b7283898d8e949599a6a9aaabacadaeafb2b3b4b5b9bbbdbebfc3c4c6c7c8c9cacdcecfd0d2d4d5d6d7d9dadbdc#dddee0e2e3e4e5e7e8e9eaeceef0f1f2f3f4f5f6f7f8fafcfdfeff,9b:000102040506,87:c68885ad9783abe5acb5b3cbd3bdd1c0cadbeae0ee,88:1613,87fe88:0a1b21393c,7f:36424445,82107a:fafd,7b:080304150a2b0f47382a192e31202524333e1e585a45754c5d606e7b62727190a6a7b8ac9da885aa9ca2abb4d1c1ccdddae5e6ea,7c0c7b:fefc,7c:0f160b,9b:07090a0b0c0d0e1011121415161718191a1b1c1d1e2021222425262728292a2b2c2d2e3031333435363738393a3d3e3f40464a4b4c4e50525355565758595a#5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b,7c:1f2a26384140,81fe82:010204,81ec884482:2122232d2f282b383b33343e44494b4f5a5f68,88:7e8588d8df,895e7f:9d9fa7afb0b2,7c7c65497c:919d9c9ea2b2bcbdc1c7cccdc8c5d7e8,826e66a87f:bfced5e5e1e6e9eef3,7cf87d:77a6ae,7e:479b,9e:b8b4,8d:73849491b1676d,8c:4749,91:4a504e4f64,9b:7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9ba#bbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadb,91:626170696f7d7e7274798c85908d91a2a3aaadaeafb5b4ba,8c559e7e8d:b8eb,8e:055969,8d:b5bfbcbac4d6d7dadececfdbc6ecf7f8e3f9fbe4,8e098dfd8e:141d1f2c2e232f3a4039353d3149414251524a70767c6f74858f94909c9e,8c:78828a859894,659b89:d6dedadc,9b:dcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9c:000102030405060708090a0b0c0d0e0f101112131415161718191a#1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b,89:e5ebef,8a3e8b26975396:e9f3ef,97:0601080f0e2a2d303e,9f:808385868788898a8c,9efe9f:0b0d,96:b9bcbdced2,77bf96e092:8eaec8,93:3e6aca8f,94:3e6b,9c:7f8285868788,7a239c:8b8e90919294959a9b9e9fa0a1a2a3a5a6a7a8a9abadaeb0b1b2b3b4b5b6b7babbbcbdc4c5c6c7cacb3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a#7b7d7e808384898a8c8f93969798999daaacafb9bebfc0c1c2c8c9d1d2dadbe0e1cccdcecfd0d3d4d5d7d8d9dcdddfe2,97:7c85919294afaba3b2b4,9a:b1b0b7,9e589a:b6babcc1c0c5c2cbccd1,9b:45434749484d51,98e899:0d2e5554,9a:dfe1e6efebfbedf9,9b:080f131f23,9e:bdbe,7e3b9e:8287888b92,93d69e:9d9fdbdcdde0dfe2e9e7e5eaef,9f:222c2f39373d3e44,9c:e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9d:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021#22232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …a7b7c7d7e7f8081#̲828384858687888…'>434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f8081#82838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2#92</span>a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1#e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9e:000102#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …778797a7b7c7d80#̲8183848586898a8…'>030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e24272e30343b3c404d5052535456595d5f606162656e6f727475767778797a7b7c7d80#8183848586898a8c8d8e8f90919495969798999a9b9c9ea0a1a2a3a4a5a7a8a9aa#92</span>abacadaeafb0b1b2b3b5b6b7b9babcbfc0c1c2c3c5c6c7c8cacbccd0d2d3d5d6d7d9dadee1e3e4e6e8ebecedeef0f1f2f3f4f5f6f7f8fafdff,9f:000102030405#060708090a0c0f1112141516181a1b1c1d1e1f21232425262728292a2b2d2e3031#92<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 127: …172737475767778#̲797a7b7c7d7e818…'>3233343536383a3c3f4041424345464748494a4b4c4d4e4f52535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778#797a7b7c7d7e81828d8e8f9091929394959697989c9d9ea1a2a3a4a5,f9:2c7995e7f1#92</span>,fa:0c0d0e0f111314181f20212324272829,e8:15161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40414243#4445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364'),<br>
U2Ghash: any = {},<br>
G2Uhash: any = {};<br>
// @ts-ignore<br>
!function (data: any) {<br>
let k = 0;<br>
data = data.match(/..../g);<br>
for (let i = 0x81; i &lt;= 0xfe; i += 1) {<br>
for (let j = 0x40; j &lt;= 0xFE; j += 1) {<br>
U2Ghash[data[k += 1]] = (<code>%${i.toString(16)}%${j.toString(16)}</code>)<br>
.toUpperCase();<br>
}<br>
}<br>
for (const key in U2Ghash) {<br>
G2Uhash[U2Ghash[key]] = key;<br>
}<br>
}(data);</li>
</ul>
<p>function isAscii(unicode: any) {<br>
return ((unicode === 0x20AC) || (unicode &lt;= 0x007F &amp;&amp; unicode &gt;= 0x0000));<br>
}</p>
<p>return {<br>
encode: function (str: any) {<br>
return str.replace(/./g, (a: any) =&gt; {<br>
const code = a.charCodeAt(0);<br>
if (isAscii(code)) {<br>
return encodeURIComponent(a);<br>
}<br>
const key = code.toString(16);<br>
// @ts-ignore<br>
if (key.length !== 4) key = (<code>000${key}</code>).match(/....<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 48: …y] || a;
      }̲);
    },
    d…'>/)[0];
        return U2Ghash[key] || a;
      });
    },
    decode: function (str: any) {
      return str.replace(/%[0-9A-F]{2}%[0-9A-F]{2}/g, (a: any) =&gt; {
        if (a in G2Uhash) {
          // @ts-ignore
          return String.fromCharCode(`0x</span>{G2Uhash[a]}`);<br>
}<br>
return a;<br>
}).replace(/%[\w]{2}/g, (a: any) =&gt; decodeURIComponent(a));<br>
}<br>
};<br>
}();</p>
<p>export default util;</p>
<p>存储localStorage</p>
<p>/**</p>
<ul>
<li>@FileName lStorage.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title 存储localStorage</li>
<li>@Desc<br>
**/</li>
</ul>
<p>const isNull = (obj: any) =&gt; typeof obj === 'undefined' || obj === null;<br>
const trim = (str: any) =&gt; isNull(str) ? '' : (<code>${str}</code>).replace(/<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>+|[\s\uFEFF\xA0]+$/g, '');</p>
<p>const getAll = () =&gt; {<br>
const len = localStorage.length; // 获取长度<br>
// console.log(len); // 输出5<br>
const arr: Array<any> = []; // 定义数据集<br>
for (let i = 0; i &lt; len; i += 1) {<br>
// 获取key 索引从0开始<br>
const getKey = localStorage.key(i) || '';<br>
// 获取key对应的值<br>
const getVal = localStorage.getItem(getKey);<br>
// 放进数组<br>
arr[i] = {<br>
key: getKey,<br>
val: getVal<br>
};<br>
}<br>
return arr;<br>
};<br>
const removeItem = (key: string) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return;<br>
window.localStorage.removeItem(key);<br>
};<br>
const setItem = (key: string, content: any) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return;<br>
let contentTxt = content;<br>
if (typeof content !== 'string') {<br>
contentTxt = JSON.stringify(content);<br>
}<br>
window.localStorage.setItem(key, contentTxt);<br>
};<br>
const getItem = (key: string) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return '';<br>
return window.localStorage.getItem(key) || '';<br>
};<br>
const removeDataFromKey = (key = '') =&gt; {<br>
const all: any = getAll();<br>
for (let i = 0, len = all.length; i &lt; len; i += 1) {<br>
if (trim(all[i].key).indexOf(key) !== -1) {<br>
removeItem(all[i].key);<br>
}<br>
}<br>
};</p>
<p>export default {<br>
// 存储localStorage<br>
setItem,<br>
// 获取localStorage<br>
getItem,<br>
// 删除localStorage<br>
removeItem,<br>
// 从localStorage删除所有保存的数据<br>
clear: () =&gt; window.localStorage.clear(),<br>
// 获取所有的 缓存数据<br>
getAll,<br>
// 删除指定 key匹配的数据<br>
removeDataFromKey<br>
};</p>
<p>sessionStorage操作</p>
<p>/**</p>
<ul>
<li>@FileName sStorage.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title sessionStorage操作</li>
<li>@Desc<br>
**/<br>
const setItem = (key: string, content: any) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return;<br>
sessionStorage.setItem(key, JSON.stringify(content));<br>
};<br>
const getItem = (key: string) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return;<br>
return JSON.parse(sessionStorage.getItem(key) || '');<br>
};<br>
const removeItem = (key: string) =&gt; {<br>
if (!key &amp;&amp; typeof window === 'undefined') return;<br>
sessionStorage.removeItem(key);<br>
};<br>
const clear = () =&gt; {<br>
sessionStorage.clear();<br>
};<br>
export default {<br>
setItem,<br>
getItem,<br>
removeItem,<br>
clear<br>
};</li>
</ul>
<p>mockjs 动态模拟数据</p>
<p>yarn add mockjs --dev</p>
<p>/**</p>
<ul>
<li>@FileName mock.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title 动态模拟数据</li>
<li>@Desc<br>
**/<br>
import Mock from 'mockjs';</li>
</ul>
<p>class MockJs {<br>
private baseUrl: string;</p>
<p>constructor(baseUrl = '') {<br>
this.baseUrl = baseUrl;<br>
}</p>
<p>/**</p>
<ul>
<li>基础方法</li>
<li>@param path 拦截的路径</li>
<li>@param params 返回的模拟数据</li>
<li>@param method 拦截的method<br>
*/<br>
action(path: string, params: any, method = 'post') {<br>
Mock.mock(new RegExp(<code>^${this.baseUrl + path}</code>), method, params);<br>
}</li>
</ul>
<p>get(path: string, params: any) {<br>
return this.action(path, params, 'get');<br>
}</p>
<p>post(path: string, params: any) {<br>
return this.action(path, params, 'post');<br>
}</p>
<p>put(path: string, params: any) {<br>
return this.action(path, params, 'put');<br>
}</p>
<p>patch(path: string, params: any) {<br>
return this.action(path, params, 'patch');<br>
}</p>
<p>delete(path: string, params: any) {<br>
return this.action(path, params, 'delete');<br>
}</p>
<p>head(path: string, params: any) {<br>
return this.action(path, params, 'head');<br>
}</p>
<p>options(path: string, params: any) {<br>
return this.action(path, params, 'options');<br>
}</p>
<p>tpl(data: any = '', msg = '成功', status = 200) {<br>
return {msg, data, status};<br>
}<br>
}</p>
<p>export default MockJs;</p>
<p>Tools 通用工具类</p>
<p>/**</p>
<ul>
<li>@FileName tools.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title 通用工具类</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import ViewUI from 'view-design';<br>
/* eslint-disable <em>/<br>
const utils = {<br>
getUUID(len: number, radix: number) {<br>
const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');<br>
const uuid = [];<br>
let i;<br>
radix = radix || chars.length;<br>
if (len) {<br>
for (i = 0; i &lt; len; i += 1) uuid[i] = chars[0 | Math.random() * radix];<br>
} else {<br>
let r;<br>
uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';<br>
uuid[14] = '4';<br>
for (i = 0; i &lt; 36; i += 1) {<br>
if (!uuid[i]) {<br>
r = 0 | Math.random() * 16;<br>
uuid[i] = chars[(i === 19) ? (r &amp; 0x3) | 0x8 : r];<br>
}<br>
}<br>
}<br>
return uuid.join('');<br>
},<br>
getResult(arr = [], id = '', find = 'id', result = 'value') {<br>
let value = '';<br>
if (id === undefined || id === null || !find || !result) {<br>
return '';<br>
}<br>
arr.map((e) =&gt; {<br>
if (e[find] === id) {<br>
value = e[result];<br>
}<br>
return e;<br>
});<br>
return value;<br>
},<br>
object: {<br>
isObject(obj: any) {<br>
return typeof obj === 'object';<br>
},<br>
isFunction(obj: any) {<br>
return typeof obj === 'function';<br>
},<br>
isArray(obj: any) {<br>
return this.isNotNull(obj) &amp;&amp; obj.constructor === Array;<br>
},<br>
isNull(obj: any) {<br>
return typeof obj === 'undefined' || obj === null || this.length(obj) === 0;<br>
},<br>
isNotNull(obj: any) {<br>
return !this.isNull(obj);<br>
},<br>
length(obj: any) {<br>
let count = 0;<br>
for (const i in obj) {<br>
// 如果包含除它的原型本身之外的属性<br>
if (Object.prototype.hasOwnProperty.call(obj, i)) {<br>
count += 1;<br>
}<br>
}<br>
return count;<br>
},<br>
getChildrenPath(obj: any, c: any, k: any): any {<br>
if (this.isNull(obj)) {<br>
return null;<br>
}<br>
if (obj === c) {<br>
return k;<br>
}<br>
if (this.isObject(obj)) {<br>
let v;<br>
for (const key in obj) {<br>
if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;<br>
v = this.getChildrenPath(obj[key], c, key);<br>
if (utils.string.isNotBlank(v)) {<br>
return <code>${utils.string.isNotBlank(k) ?</code><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 11: {k}.` : &#039;&#039;}̲'>{k}.` : &#039;&#039;}</span>{v}<code>; } } } return null; }, merge(t: any, s: any, mergeArray = false) { for (const k in s) { if (!Object.prototype.hasOwnProperty.call(s, k) || typeof s[k] === 'undefined' || s[k] === null) continue; const item = s[k]; switch (item.constructor) { case Object: { if (t[k] &amp;&amp; t[k].constructor === Object) { this.merge(t[k], item); } else { t[k] = item; } break; } case Array: { if (item.length &lt; 1) { break; } if (mergeArray &amp;&amp; t[k] &amp;&amp; t[k].constructor === Array) { t[k] = [...t[k], ...item]; } else { t[k] = item; } break; } case String: { if (item.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '').length &gt; 0) { t[k] = item; } break; } default: { t[k] = item; } } } return t; } }, string: { trim(str: any) { return utils.object.isNull(str) ? '' : (</code><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \s at position 20: …}`).replace(/^[\̲s̲\uFEFF\xA0]+|[\…'>{str}`).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+</span>/g, '');<br>
},<br>
isBlank(str: any) {<br>
return utils.object.isNull(str) || this.trim(str).length === 0;<br>
},<br>
isNotBlank(str: any) {<br>
return !this.isBlank(str);<br>
},<br>
isEmpty(str: any) {<br>
return utils.object.isNull(str) || (<code>${str}</code>).length === 0;<br>
},<br>
isNotEmpty(str: any) {<br>
return !this.isEmpty(str);<br>
},<br>
equalsIgnoreCase(a: any, b: any) {<br>
if (utils.object.isNull(a) || utils.object.isNull(b)) {<br>
return false;<br>
}<br>
return (<code>${a}</code>).toLowerCase() === (<code>${b}</code>).toLowerCase();<br>
}<br>
},<br>
list: {<br>
isEmpty(l: any) {<br>
return utils.object.isNull(l) || l.length &lt; 1;<br>
},<br>
isNotEmpty(l: any) {<br>
return !utils.list.isEmpty(l);<br>
},<br>
stringToList(s: any) {<br>
const txt = typeof s === 'string' ? s.split(',') : s;<br>
return s &amp;&amp; s.length &gt; 0 ? txt : [];<br>
},<br>
find(l: any, k: any, v: any, j: any) {<br>
const n = [];<br>
if (utils.list.isNotEmpty(l)) {<br>
for (let i = 0, len = l.length, r = l[i]; i &lt; len; i += 1) {<br>
if (j ? r[k] === v : <code>${r[k]}</code> === <code>${v}</code>) n.push(r);<br>
}<br>
}<br>
return n;<br>
},<br>
indexOf(l: any, k: any, v: any, b: any, j: any) {<br>
let n = -1;<br>
if (utils.list.isNotEmpty(l)) {<br>
for (let i = b || 0, len = l.length, r = l[i]; i &lt; len; i += 1) {<br>
if (j ? r[k] === v : <code>${r[k]}</code> === <code>${v}</code>) {<br>
n = i;<br>
break;<br>
}<br>
}<br>
}<br>
return n;<br>
}<br>
},<br>
map: {<br>
mapsExtVal(maps: any, key: any) {<br>
const list = [];<br>
for (let i = 0, len = maps.length; i &lt; len; i += 1) {<br>
list.push(maps[i][key]);<br>
}<br>
return list;<br>
},<br>
listToMap(list: any, key: any) {<br>
if (utils.object.isNull(list) || utils.string.isEmpty(key)) {<br>
return null;<br>
}<br>
const map: any = {};<br>
for (let i = 0, len = list.length; i &lt; len; i += 1) {<br>
const row = list[i];<br>
map[row[key]] = row;<br>
}<br>
return map;<br>
},<br>
isEqualForString(a: any, b: any) {<br>
return utils.map.isEqual(a, b, null, true);<br>
},<br>
isEmpty(m: any) {<br>
return utils.object.isNull(m) || this.keys(m).length &lt; 1;<br>
},<br>
isNotEmpty(m: any) {<br>
return !this.isEmpty(m);<br>
},<br>
isEqual(a: any, b: any, isWeak: any, isString: any) {<br>
if (utils.object.isNull(a) &amp;&amp; utils.object.isNull(b)) {<br>
return true;<br>
}<br>
if (utils.object.isNull(a) || utils.object.isNull(b)) {<br>
return false;<br>
}<br>
const aks: any = this.keys(a);<br>
const bks: any = this.keys(b);<br>
const aksl: number = aks.length;<br>
const bksl: number = bks.length;<br>
if (aksl !== bksl) {<br>
return false;<br>
}<br>
for (let i = 0; i &lt; aksl; i += 1) {<br>
if (isWeak || isString ? <code>${a[aks[i]]}</code> !== <code>${b[aks[i]]}</code> : a[aks[i]] !== b[aks[i]]) {<br>
return false;<br>
}<br>
}<br>
return true;<br>
},<br>
keys(m: any): any[] {<br>
const keys: any[] = [];<br>
for (const key in m) {<br>
if (Object.prototype.hasOwnProperty.call(m, key)) {<br>
keys.push(key);<br>
}<br>
}<br>
return keys;<br>
},<br>
vals(m: any) {<br>
const l = [];<br>
const keys = utils.map.keys(m);<br>
for (let i = 0, len = keys.length; i &lt; len; i += 1) {<br>
l.push(m[keys[i]]);<br>
}<br>
return l;<br>
}<br>
},<br>
// 格式化手机号  隐藏中间数据<br>
formatPhoneNumber(phone: string) {<br>
if (!phone) return '';<br>
return <code>${String(phone).slice(0, 3)}****${String(phone).slice(-4)}</code>;<br>
},<br>
// 数组转 百分比<br>
numberToPercentage(percentage: any) {<br>
if (percentage == null) return '--';<br>
const num: any = (Math.round(percentage * 10000) / 100).toFixed(2);<br>
return Number(percentage) === 0 ? '0%' : <code>${Math.abs(num)}%</code>;<br>
},<br>
/</em>*</p>
<ul>
<li>@param {Array} target 目标数组</li>
<li>@param {Array} arr 需要查询的数组</li>
<li>@description 判断要查询的数组是否至少有一个元素包含在目标数组中<br>
<em>/<br>
hasOneOf: (targetarr: any, arr: any) =&gt; {<br>
return targetarr.some((<em>: any) =&gt; arr.indexOf(</em>) &gt; -1);<br>
},<br>
onMsg: (callback: any) =&gt; {<br>
window.onmessage = (res: any) =&gt; {<br>
callback(res);<br>
};<br>
},<br>
/</em>*</li>
<li>快捷键注册</li>
<li>@param kes</li>
<li>@param fun<br>
*/<br>
compositeKey: (kes: string, fun: any) =&gt; {<br>
const k = kes || '';<br>
const fn = fun || function () {<br>
};</li>
</ul>
<pre><code>const ks = k.split('+');
if (ks.length &lt; 2) {
  console.info('not composite key');
  return;
}

document.addEventListener('keydown', function (e) {
  const ctrl = e.ctrlKey,
    shift = e.shiftKey,
    alt = e.altKey;
  // @ts-ignore
  let keyIdent = e.keyIdentifier;

  if (ctrl &amp;&amp; (ks.indexOf('ctrl') === -1)) {
    return;
  }

  if (shift &amp;&amp; (ks.indexOf('shift') === -1)) {
    return;
  }

  if (alt &amp;&amp; (ks.indexOf('alt') === -1)) {
    return;
  }

  if (e.keyCode &gt; 47 &amp;&amp; e.keyCode &lt; 91) {
    keyIdent = String.fromCharCode(e.keyCode);
  }

  if (keyIdent &amp;&amp; keyIdent.toLowerCase() === ks[ks.length - 1]) {
    fn(e);
  }
});
</code></pre>
<p>},<br>
/**</p>
<ul>
<li>消息通用模板</li>
<li>@param type</li>
<li>@param content</li>
<li>@param duration<br>
<em>/<br>
message: (type: string, content: string, duration = 6) =&gt; {<br>
// @ts-ignore<br>
ViewUI.Message[type]({<br>
background: true,<br>
closable: true,<br>
content,<br>
duration<br>
});<br>
},<br>
/</em>*</li>
<li>弹窗通用模板</li>
<li>@param type</li>
<li>@param title</li>
<li>@param content</li>
<li>@param okCallBack</li>
<li>@param cancelCallBack<br>
<em>/<br>
modal: (type = 'info', title: string, content = '', okCallBack = () =&gt; {<br>
}, cancelCallBack = () =&gt; {<br>
}) =&gt; {<br>
// @ts-ignore<br>
ViewUI.Modal[type]({<br>
title: title,<br>
content: content,<br>
onOk: () =&gt; {<br>
okCallBack();<br>
},<br>
onCancel: () =&gt; {<br>
cancelCallBack();<br>
}<br>
});<br>
},<br>
/</em>*</li>
<li>通知通用模板</li>
<li>@param type</li>
<li>@param title</li>
<li>@param desc</li>
<li>@param duration<br>
<em>/<br>
notice: (type: string, title: string, desc: string, duration = 6) =&gt; {<br>
// @ts-ignore<br>
ViewUI.Notice[type]({<br>
title,<br>
desc,<br>
duration<br>
});<br>
},<br>
/</em>*</li>
<li>遍历对象 返回 key value</li>
<li>@param obj</li>
<li>@param callback<br>
*/<br>
forIn: (obj: any, callback: any) =&gt; {<br>
Object.entries(obj).forEach(entry =&gt; {<br>
callback(...entry);<br>
});<br>
}<br>
};<br>
export default utils;</li>
</ul>
<p>vueTools</p>
<p>/**</p>
<ul>
<li>@FileName vueTools.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import createRoutes from './createRoutes';</p>
<p>/**</p>
<ul>
<li>路由权限判断处</li>
<li>@param to</li>
<li>@param next</li>
<li>@param homeName<br>
<em>/<br>
const turnTo = (to: any, next: any, homeName = 'home') =&gt; {<br>
next();<br>
};<br>
/</em>*</li>
<li>创建路由</li>
<li>@param title 模板通用标题</li>
<li>@param baseRoutes 基础路由</li>
<li>@param routes 模板路由</li>
<li>@param base 路由根地址，线上统一  /</li>
<li>@param homeName 主界面路由名</li>
<li>@param mode 路由模式 默认 history<br>
*/<br>
const createRoute = (baseRoutes: any = [], routes: any = [], base = '', homeName = 'home', mode: any = 'history') =&gt; {<br>
if (process.env.NODE_ENV === 'production') base = '';<br>
const title = '';<br>
// @ts-ignore<br>
return createRoutes(baseRoutes, routes, base, homeName, mode, title, turnTo);<br>
};</li>
</ul>
<p>export default {createRoute};</p>
<p>log</p>
<p>/**</p>
<ul>
<li>@FileName log.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import moment from './moment';<br>
import lStorage from './lStorage';<br>
import fStorage from 'localforage';</p>
<p>const maxLog = 50;</p>
<p>const setErrorLog = (key: string, info: any) =&gt; {<br>
if (typeof window !== 'undefined') {<br>
lStorage.setItem(key, info);<br>
} else {<br>
console.log('[ ERROR ]', info);<br>
}<br>
};<br>
const setApiLog = (key: string, info: any) =&gt; {<br>
if (typeof window !== 'undefined') {<br>
// @ts-ignore<br>
info.time = moment.format();<br>
const storage = fStorage.createInstance({name: key});</p>
<pre><code>storage.keys().then((keys: any) =&gt; {
  if (keys.length &gt; maxLog) {
    const num = keys.length - maxLog;
    const newArr = keys.slice(0, num);
    newArr.forEach((item: any) =&gt; {
      storage.removeItem(item).then(() =&gt; {
        // 当值被移除后，此处代码运行
      }).catch((err: any) =&gt; {
        console.log(err);
      });
    });
  }
}).catch((err: any) =&gt; {
  console.error(err);
});

// @ts-ignore
if (info.status !== 200) {
  setErrorLog('errorMSG', info);
}
storage.setItem(moment.format(new Date(), 'x'), JSON.stringify(info));
</code></pre>
<p>} else {<br>
// @ts-ignore<br>
info.time = moment.format();<br>
console.log('[ API ]', info);<br>
}<br>
};</p>
<p>const setConsoleLog = (key: string, info: any) =&gt; {<br>
if (typeof window !== 'undefined') {<br>
// @ts-ignore<br>
info.time = moment.format();<br>
const storage = fStorage.createInstance({name: key});</p>
<pre><code>storage.keys().then((keys: any) =&gt; {
  if (keys.length &gt; maxLog) {
    const num = keys.length - maxLog;
    const newArr = keys.slice(0, num);
    newArr.forEach((item: any) =&gt; {
      storage.removeItem(item).then(() =&gt; {
        // 当值被移除后，此处代码运行
      }).catch((err: any) =&gt; {
        console.log(err);
      });
    });
  }
}).catch((err: any) =&gt; {
  console.error(err);
});

storage.setItem(moment.format(new Date(), 'x'), JSON.stringify(info));
</code></pre>
<p>} else {<br>
// @ts-ignore<br>
info.time = moment.format();<br>
console.log('[ API ]', info);<br>
}<br>
};</p>
<p>const consoleMSG = (type: string, title: string, args: any) =&gt; {<br>
if (type === 'table') {<br>
// @ts-ignore<br>
console.log(<code>[ ${type} ] =&gt; ${title}</code>);<br>
console.table([...args]);<br>
}<br>
// @ts-ignore<br>
console[type](<code>[ ${type} ] =&gt; ${title}</code>, args);<br>
const consoleInfo = {<br>
title: title,<br>
type,<br>
url: location.pathname + location.search,<br>
data: args<br>
};<br>
setConsoleLog('logStorage', consoleInfo);<br>
};</p>
<p>export default {<br>
setConsoleLog,<br>
setErrorLog,<br>
setApiLog,<br>
info: (title: string, args: any) =&gt; consoleMSG('info', title, args),<br>
error: (title: string, args: any) =&gt; consoleMSG('error', title, args),<br>
debug: (title: string, args: any) =&gt; consoleMSG('debug', title, args),<br>
warn: (title: string, args: any) =&gt; consoleMSG('warn', title, args),<br>
table: (title: string, args: any) =&gt; consoleMSG('table', title, args)<br>
};</p>
<p>Axios</p>
<p>/**</p>
<ul>
<li>@FileName axios.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import lStorage from './lStorage';<br>
import ViewUI from 'view-design';<br>
import tools from './tools';<br>
import log from './log';<br>
import axios from 'axios';</p>
<p>class HttpRequest {<br>
private baseUrl: string;<br>
private queue = {};</p>
<p>constructor(baseUrl = '') {<br>
this.baseUrl = baseUrl;<br>
this.queue = {};<br>
}</p>
<p>private static apiMsgTemplate(apiInfo: any) {<br>
return <code>&lt;div style=&quot;font-size: 14px;&quot;&gt;&lt;p style=&quot;color: red;font-size: 14px;&quot;&gt;请截图给管理员，以便快捷修复错误！&lt;/p&gt;&lt;p&gt;错误: ${apiInfo.statusText}&lt;/p&gt;&lt;p&gt;method: ${apiInfo.request.method}&lt;/p&gt;&lt;p style=&quot;margin: 5px 0;&quot;&gt;URL:&lt;br&gt; ${apiInfo.request.url}&lt;/p&gt;&lt;p&gt;参数：&lt;br&gt;${apiInfo.request.data.toString()}&lt;/p&gt;&lt;/div&gt;</code>;<br>
}</p>
<p>private getInsideConfig() {<br>
return {<br>
baseURL: this.baseUrl,<br>
timeout: 10000,<br>
responseType: 'json',<br>
headers: {<br>
'If-Modified-Since': 0,<br>
'Cache-Control': 'no-cache'<br>
}<br>
};<br>
}</p>
<p>private destroy(url: string) {<br>
// @ts-ignore<br>
delete this.queue[url];<br>
if (!Object.keys(this.queue).length) {<br>
// @ts-ignore<br>
ViewUI.LoadingBar.finish();<br>
}<br>
}</p>
<p>private unusualStatus(code: number, apiInfo: any) {<br>
switch (code) {<br>
case 0:<br>
tools.message('info', <code>${apiInfo.statusText}</code>, 10);<br>
break;<br>
case 400:<br>
tools.notice('warning', <code>请求参数错误: ${apiInfo.status}</code>, HttpRequest.apiMsgTemplate(apiInfo), 15);<br>
break;<br>
case 401:<br>
// this.notice('warning', '登录信息', '登录超时或未登录，请重新登录！');<br>
tools.modal('warning', '登录信息', '登录超时或未登录，请重新登录！', () =&gt; {<br>
lStorage.setItem('userInfo', '');<br>
lStorage.setItem('isLogin', false);<br>
lStorage.setItem('Authorization', '');<br>
lStorage.setItem('errorMSG', '');<br>
location.href = '/login?done=' + location.href;<br>
});<br>
break;<br>
case 404:<br>
tools.notice('info', <code>资源未找到: ${apiInfo.status}</code>, HttpRequest.apiMsgTemplate(apiInfo), 15);<br>
break;<br>
case 405:<br>
tools.notice('warning', <code>请求类型错误: ${apiInfo.status}</code>, HttpRequest.apiMsgTemplate(apiInfo), 15);<br>
break;<br>
case 500:<br>
tools.notice('error', <code>服务器错误: ${apiInfo.status}</code>, HttpRequest.apiMsgTemplate(apiInfo), 15);<br>
break;<br>
case 503:<br>
tools.notice('info', <code>服务器错误: ${apiInfo.status}</code>, '服务器维护中，请稍后再试！', 15);<br>
break;<br>
default:<br>
tools.message('error', <code>${apiInfo.status} : ${apiInfo.statusText}</code>);<br>
break;<br>
}<br>
}</p>
<p>interceptors(instance: any, url: string) {<br>
// 请求拦截<br>
instance.interceptors.request.use(<br>
(config: any) =&gt; {<br>
// 添加全局的loading...<br>
if (!Object.keys(this.queue).length) {<br>
// @ts-ignore<br>
ViewUI.LoadingBar.start();<br>
}<br>
// @ts-ignore<br>
this.queue[url] = true;<br>
return config;<br>
},<br>
(error: any) =&gt; Promise.reject(error)<br>
);</p>
<pre><code>// axios 响应拦截
instance.interceptors.response.use(
  (res: any) =&gt; {
    this.destroy(url);
    const {data: {data}, config, request: {responseURL}} = res;
    const response = res.request;

    const apiInfo = {
      status: response.status,
      statusText: (data &amp;&amp; data.msg) || response.statusText,
      request: {
        url: responseURL,
        api: config.baseURL + config.url || '',
        method: config.method,
        data: config.data || ''
      },
      response: {
        data: data || ''
      }
    };

    log.setApiLog('apiLogStorage', apiInfo);
    return data || '';
  },
  (error: any) =&gt; {
    this.destroy(url);
    let apiInfo: any;

    if (error.response) {
      const {response: {status, statusText, data, config, request: {responseURL}}} = error;
      apiInfo = {
        status,
        statusText: (data &amp;&amp; data.msg) || statusText,
        request: {
          url: responseURL,
          api: config.baseURL + config.url || '',
          method: config.method,
          data: config.data || ''
        },
        response: {
          data: data || ''
        }
      };
    } else {
      const {config, message} = JSON.parse(JSON.stringify(error));
      const {request} = error;
      apiInfo = {
        status: request.status,
        statusText: message || request.statusText || '',
        request: {
          url: '',
          api: config.baseURL + config.url || '',
          method: config.method,
          data: config.data || ''
        },
        response: {
          data: ''
        }
      };
    }

    log.setApiLog('apiLogStorage', apiInfo);
    this.unusualStatus(apiInfo.status, apiInfo);
    if (apiInfo.response &amp;&amp; apiInfo.response.data) {
      return Promise.reject(apiInfo.response.data);
    }
    return Promise.reject(error);
  }
);
</code></pre>
<p>}</p>
<p>request(options: any) {<br>
const instance = axios.create();<br>
options = Object.assign(this.getInsideConfig(), options);<br>
this.interceptors(instance, options.url);<br>
return instance(options);<br>
}<br>
}</p>
<p>export default HttpRequest;</p>
<p>API request</p>
<p>/**</p>
<ul>
<li>@FileName api.request.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import HttpRequest from './axios';<br>
import lStorage from './lStorage';</li>
</ul>
<p>const getTokenToLocalStorage = () =&gt; {<br>
return lStorage.getItem('Authorization') || '';<br>
};</p>
<p>class API {<br>
private baseUrl: string;<br>
private axios: any;</p>
<p>constructor(baseUrl = '') {<br>
this.baseUrl = baseUrl;<br>
this.axios = new HttpRequest(baseUrl);<br>
}</p>
<p>/**</p>
<ul>
<li>post 请求</li>
<li>@param url 接口url</li>
<li>@param data 参数</li>
<li>@param method<br>
*/<br>
post(url: string, data: any, method = 'post') {<br>
return this.axios.request({<br>
url,<br>
// data: qs.stringify(data), from 标点传参<br>
data,<br>
method,<br>
headers: {<br>
Authorization: getTokenToLocalStorage()<br>
}<br>
});<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>put 请求</li>
<li>@param url 接口url</li>
<li>@param data 参数<br>
*/<br>
put(url: string, data: any) {<br>
return this.post(url, data, 'put');<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>patch 请求</li>
<li>@param url 接口url</li>
<li>@param data 参数<br>
*/<br>
patch(url: string, data: any) {<br>
return this.post(url, data, 'patch');<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>get 请求</li>
<li>@param url 接口url</li>
<li>@param params 参数</li>
<li>@param method<br>
*/<br>
get(url: string, params: any, method = 'get') {<br>
return this.axios.request({<br>
url,<br>
params,<br>
method,<br>
headers: {<br>
Authorization: getTokenToLocalStorage()<br>
}<br>
});<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>delete 请求</li>
<li>@param url 接口url</li>
<li>@param params 参数<br>
*/<br>
delete(url: string, params: any) {<br>
return this.get(url, params, 'delete');<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>head 请求</li>
<li>@param url 接口url</li>
<li>@param params 参数<br>
*/<br>
head(url: string, params: any) {<br>
return this.get(url, params, 'head');<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>options 请求</li>
<li>@param url 接口url</li>
<li>@param params 参数<br>
*/<br>
options(url: string, params: any) {<br>
return this.get(url, params, 'options');<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>axios本版本不支持jsonp 自己拓展一个</li>
<li>@param url<br>
*/<br>
jsonp(url: string) {<br>
if (!url) {<br>
console.error('Axios.JSONP 至少需要一个url参数!');<br>
return;<br>
}<br>
return new Promise((resolve: any) =&gt; {<br>
// @ts-ignore<br>
window.jsonCallBack = (result: any) =&gt; {<br>
resolve(result);<br>
};<br>
const JSONP = document.createElement('script');<br>
JSONP.type = 'text/javascript';<br>
JSONP.src = <code>${url}&amp;callback=jsonCallBack</code>;<br>
document.getElementsByTagName('head')[0].appendChild(JSONP);<br>
setTimeout(() =&gt; {<br>
document.getElementsByTagName('head')[0].removeChild(JSONP);<br>
}, 500);<br>
});<br>
}<br>
}</li>
</ul>
<p>export default API;</p>
<p>工具类统一导出</p>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import moment from './moment';<br>
import log from './log';<br>
import API from './api.request';<br>
import cookie from './cookie';<br>
import gbk from './gbk';<br>
import lStorage from './lStorage';<br>
import sStorage from './sStorage';<br>
import tools from './tools';<br>
import MockJs from './mock';<br>
import createRoutes from './createRoutes';</li>
</ul>
<p>export default {<br>
...tools,<br>
moment,<br>
cookie,<br>
log,<br>
API,<br>
gbk,<br>
lStorage,<br>
sStorage,<br>
MockJs,<br>
createRoutes<br>
};</p>
<p>API &amp; Mock<br>
相关文件目录</p>
<p>├─node_modules<br>
├─public<br>
│  └─img<br>
│      └─icons<br>
├─src<br>
│  ├─assets<br>
│  ├─components<br>
│  │  └─log<br>
│  ├─data<br>
│  │  ├─api<br>
│  │  │  └─test<br>
│  │  └─mock<br>
│  │      └─test<br>
│  ├─layout<br>
│  ├─libs<br>
│  ├─router<br>
│  ├─store<br>
│  └─views<br>
└─tests<br>
└─unit</p>
<p>api</p>
<pre><code>1、新建 /src/data/api 目录
2、新建 /src/data/api/test/index.ts 文件 接口调用配置
</code></pre>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import tools from '@/libs/index';</li>
</ul>
<p>const baseUrl = '/api';<br>
const api = new tools.API(baseUrl);</p>
<p>export default {<br>
// 获取用户信息  http://192.192.192.201:9001/app/mock/1/user/info<br>
getUserInfoData: () =&gt; api.get('/user/info', {})<br>
};</p>
<pre><code>3、新建 /src/data/api/index.ts 文件 导出接口，
</code></pre>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import test from './test';</li>
</ul>
<p>export default {test};</p>
<pre><code>4、新建 /src/index.ts 文件 所有通用引用配置，方便以后做多入口项目
</code></pre>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import Vue from 'vue';<br>
import ViewUI from 'view-design';<br>
import tools from '@/libs/index';<br>
import api from '@/data/api';<br>
import 'view-design/dist/styles/iview.css';</p>
<p>Vue.use(ViewUI);</p>
<p>declare module 'vue/types/vue' {<br>
interface Vue {<br>
api: any;<br>
log: any;<br>
CDN: any;<br>
tool: any;<br>
config: any;<br>
}<br>
}<br>
console.log(process.env);<br>
Vue.prototype.config = process.env;<br>
Vue.prototype.log = tools.log;<br>
Vue.prototype.tool = tools;<br>
Vue.prototype.api = api;<br>
Vue.prototype.CDN = (path: string) =&gt; <code>${process.env.VUE_APP_CDN || ''}${path}</code>;<br>
Vue.config.productionTip = false;</p>
<pre><code>5、 /src/main.ts 导入/src/index.ts
</code></pre>
<p>import Vue from 'vue';<br>
import App from './App.vue';<br>
import router from './router';<br>
import store from './store';</p>
<p>import '@/index';</p>
<p>new Vue({<br>
router,<br>
store,<br>
render: h =&gt; h(App)<br>
}).$mount('#app');</p>
<pre><code>6、页面调用 api 接口 /src/views/Home.vue
</code></pre>
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png">
    <HelloWorld msg="Welcome to Your Vue.js + TypeScript App"/>
  </div>
</template>
<script lang="ts">
  import {Component, Vue} from 'vue-property-decorator';
  import HelloWorld from '@/components/HelloWorld.vue'; // @ is an alias to /src

  @Component({
    components: {
      HelloWorld
    }
  })
  export default class Home extends Vue {
    mounted() {
      this.getUserInfoAction();
    }

    async getUserInfoAction() {
      try {
        const idCard = '33082219510203094X';
        const data = await this.api.test.getUserInfoData(idCard);
        this.log.info('接口测试信息 - get', data);
        return data;
      } catch (e) {
        this.log.error('接口测试信息 - get', e);
      }
    }
  }
</script>
<p>Mock</p>
<pre><code>1、新建 /src/data/mock 目录
2、新建 /src/data/mock/test/index.ts 文件 mock配置，目录结构和api保持一致，方便后期维护
</code></pre>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/<br>
import tools from '@/libs/index';</li>
</ul>
<p>const baseUrl = '/api';<br>
const mock = new tools.MockJs(baseUrl);<br>
mock.get('/user/info', mock.tpl({title: '@title'}));</p>
<pre><code>3、根目录 .env 文件配置mock开关
</code></pre>
<p>NODE_ENV = 'development'<br>
VUE_APP_MOCK = true</p>
<pre><code>4、/src/index.ts 导入mock
</code></pre>
<p>/**</p>
<ul>
<li>@FileName index.ts</li>
<li>@Author</li>
<li>@Version V 0.0.1</li>
<li>@Date</li>
<li>@Title</li>
<li>@Desc<br>
**/</li>
</ul>
<p>import Vue from 'vue';<br>
import ViewUI from 'view-design';<br>
import tools from '@/libs/index';<br>
import api from '@/data/api';<br>
import 'view-design/dist/styles/iview.css';</p>
<p>/* eslint-disable */<br>
if (process.env.VUE_APP_MOCK === 'true') require('./data/mock');</p>
<p>Vue.use(ViewUI);</p>
<p>declare module 'vue/types/vue' {<br>
interface Vue {<br>
api: any;<br>
log: any;<br>
CDN: any;<br>
tool: any;<br>
config: any;<br>
}<br>
}<br>
console.log(process.env);<br>
Vue.prototype.config = process.env;<br>
Vue.prototype.log = tools.log;<br>
Vue.prototype.tool = tools;<br>
Vue.prototype.api = api;<br>
Vue.prototype.CDN = (path: string) =&gt; <code>${process.env.VUE_APP_CDN || ''}${path}</code>;<br>
Vue.config.productionTip = false;</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>\s\uFEFF\xA0 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(七)：深入操作系统，一文读懂进程、线程、协程]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-qi-shen-ru-cao-zuo-xi-tong-yi-wen-du-dong-jin-cheng-xian-cheng-xie-cheng/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-qi-shen-ru-cao-zuo-xi-tong-yi-wen-du-dong-jin-cheng-xian-cheng-xie-cheng/">
        </link>
        <updated>2021-04-20T05:39:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-什么是进程">1、什么是进程？</h1>
<h3 id="11-基本常识">1.1 基本常识</h3>
<p><strong>我们需要明确一下几个常识：</strong></p>
<ul>
<li>1）计算机的核心是CPU，它承担了所有的计算任务；</li>
<li>2）操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；</li>
<li>3）应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。</li>
</ul>
<p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p>
<p><strong>进程一般由程序、数据集合和进程控制块三部分组成：</strong></p>
<ul>
<li>1）程序用于描述进程要完成的功能，是控制进程执行的指令集；</li>
<li>2）数据集合是程序在执行时所需要的数据和工作区；</li>
<li>3）程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li>
</ul>
<p><strong>进程具有的特征：</strong></p>
<ul>
<li>1）动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>2）并发性：任何进程都可以同其他进程一起并发执行；</li>
<li>3）独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>4）结构性：进程由程序、数据和进程控制块三部分组成。</li>
</ul>
<h3 id="12-为什么要有多进程">1.2 为什么要有多进程？</h3>
<p>多进程目的：提高cpu的使用率。</p>
<p>**一个例子：**一个用户现在既想使用打印机，又想玩游戏。</p>
<p>*<strong>假设只有一个进程（先不谈多线程）：*</strong></p>
<p><strong>从操作系统的层面看，我们使用打印机的步骤有如下：</strong></p>
<ul>
<li>1）使用CPU执行程序，去硬盘读取需要打印的文件，然后CPU会长时间的等待，直到硬盘读写完成；</li>
<li>2）使用CPU执行程序，让打印机打印这些内容，然后CPU会长时间的等待，等待打印结束。</li>
</ul>
<p>**在这样的情况下：**其实CPU的使用率其实非常的低。</p>
<p>打印一个文件从头到尾需要的时间可能是1分钟，而cpu使用的时间总和可能加起来只有几秒钟。而后面如果单进程执行游戏的程序的时候，CPU也同样会有大量的空闲时间。</p>
<p>*<strong>使用多进程后：*</strong></p>
<p>当CPU在等待硬盘读写文件，或者在等待打印机打印的时候，CPU可以去执行游戏的程序，这样CPU就能尽可能高的提高使用率。</p>
<p>再具体一点说，其实也提高了效率。因为在等待打印机的时候，这时候显卡也是闲置的，如果用多进程并行的话，游戏进程完全可以并行使用显卡，并且与打印机之间也不会互相影响。</p>
<h3 id="13-小结一下">1.3 小结一下</h3>
<p>**进程，直观点说：**保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。</p>
<p>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>
<h1 id="2-什么是线程">2、什么是线程？</h1>
<h3 id="21-基本常识">2.1 基本常识</h3>
<p>早期：操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
<p>后来：随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。</p>
<p><strong>线程是程序执行中一个单一的顺序控制流程：</strong></p>
<ul>
<li>1）是程序执行流的最小单元；</li>
<li>2）是处理器调度和分派的基本单位。</li>
</ul>
<p>一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/c67e75.png" alt="img" loading="lazy"></figure>
<p>**如上图所示：**在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。</p>
<h3 id="22-任务调度">2.2 任务调度</h3>
<p>线程是什么？要理解这个概念，需要先了解一下操作系统的一些相关概念。</p>
<p>大部分操作系统（如Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式。</p>
<p>**在一个进程中：**当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p>
<p>**上述过程中：**任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p>
<p>这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发（别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行）。</p>
<p><strong>多任务运行过程的示意图如下：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0e56f7.png" alt="img" loading="lazy"></figure>
<p>▲ 操作系统中的任务调度</p>
<h3 id="23-进程与线程的区别">2.3 进程与线程的区别</h3>
<p>前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系。</p>
<p><strong>下面就让我们一起来理一理：</strong></p>
<ul>
<li>1）线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li>
<li>2）一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>3）进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其它进程不可见；</li>
<li>4）线程上下文切换比进程上下文切换要快得多。</li>
</ul>
<p>以下线程与进程关系的示意图。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0027827.png" alt="img" loading="lazy"></figure>
<p>▲ 进程与线程的资源共享关系</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0491ed.png" alt="img" loading="lazy"></figure>
<p>▲ 单线程与多线程的关系</p>
<p>**总之：**线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。</p>
<p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程（Lightweight Process，LWP）。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/8702f4.png" alt="img" loading="lazy"></figure>
<p>▲ 早期的操作系统只有进程，没有线程</p>
<p>后来：随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个（也可以是一个）线程。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/9b19c5.png" alt="img" loading="lazy"></figure>
<p>▲ 线程的出现，使得一个进程可以有多个线程</p>
<h3 id="24-多线程与多核">2.4 多线程与多核</h3>
<p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。</p>
<p>那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p>
<p><strong>其实：</strong>“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。</p>
<p>***多核(心)处理器是指：***在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。</p>
<p>内核线程（Kernel Thread，KLT）：就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p>
<p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器 -&gt; 性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/c110644.png" alt="img" loading="lazy"></figure>
<p>▲ 双核四线程在Windows8下查看的结果</p>
<p>超线程技术：就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术（如双核四线程）由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。</p>
<p>由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。</p>
<p><strong>用户线程与内核线程的对应关系有三种模型：</strong></p>
<ul>
<li>1）一对一模型；</li>
<li>2）多对一模型；</li>
<li>3）多对多模型。</li>
</ul>
<p>在下面的文字中，将以4个内核线程、3个用户线程为例对三种模型进行说明。</p>
<h3 id="25-一对一模型">2.5 一对一模型</h3>
<p>**对于一对一模型来说：**一个用户线程就唯一地对应一个内核线程（反过来不一定成立，一个内核线程不一定有对应的用户线程）。</p>
<p>**这样：**如果CPU没有采用超线程技术（如四核四线程的计算机），一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。</p>
<p>一对一模型使用户线程具有与内核线程一样的优点：一个线程因某种原因阻塞时其他线程的执行不受影响（此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现）。</p>
<p><strong>但一对一模型也有两个缺点：</strong></p>
<ul>
<li>1）许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；</li>
<li>2）许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/b1e1d7.png" alt="img" loading="lazy"></figure>
<p>▲ 一对一模型</p>
<h3 id="26-多对一模型">2.6 多对一模型</h3>
<p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。</p>
<p><strong>因此，相对一对一模型：</strong></p>
<ul>
<li>1）多对一模型的线程上下文切换速度要快许多；</li>
<li>2）多对一模型对用户线程的数量几乎无限制。</li>
</ul>
<p><strong>但多对一模型也有两个缺点：</strong></p>
<ul>
<li>1）如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；</li>
<li>2）在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/52a2a8.png" alt="img" loading="lazy"></figure>
<p>▲ 多对一模型</p>
<h3 id="27-多对多模型">2.7 多对多模型</h3>
<p>多对多模型结合了一对一模型和多对一模型的优点：将多个用户线程映射到多个内核线程上，由线程库负责在可用的可调度实体上调度用户线程。</p>
<p>这使得线程的上下文切换非常快：因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。</p>
<p><strong>多对多模型的优点有：</strong></p>
<ul>
<li>1）一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；</li>
<li>2）多对多模型对用户线程的数量没有限制；</li>
<li>3）在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/e78399.png" alt="img" loading="lazy"></figure>
<p>▲ 多对多模型</p>
<p>在现在流行的操作系统中，大都采用多对多的模型。</p>
<h3 id="28-查看进程与线程">2.8 查看进程与线程</h3>
<p>一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？</p>
<p>在Windows下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按“<em>Ctrl+Alt+Del</em>”或右键快捷工具栏打开任务管理器。</p>
<p><strong>查看进程数和线程数：</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/224aae2.png" alt="img" loading="lazy"></figure>
<p>在“进程”选项卡下，我们可以看到一个应用程序包含的线程数。</p>
<p>如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google的Chrome浏览器就有多个进程。</p>
<p>同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个cmd窗口，就有两个cmd进程。如果看不到线程数这一列，可以再点击“查看 -&gt; 选择列”菜单，增加监听的列。</p>
<p>查看CPU和内存的使用率：在性能选项卡中，我们可以查看CPU和内存的使用率，根据CPU使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/dd1123cc.png" alt="img" loading="lazy"></figure>
<p>▲ 查看CPU和内存的使用率</p>
<h3 id="29-线程的生命周期">2.9 线程的生命周期</h3>
<p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。</p>
<p>但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。</p>
<p>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。</p>
<p>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/47098e.png" alt="img" loading="lazy"></figure>
<p>▲ 早期进程的生命周期</p>
<p>进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。</p>
<p><strong>早期进程的生命周期详细说明如下：</strong></p>
<blockquote>
<ul>
<li>创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；</li>
<li>就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；</li>
<li>运行：此线程正在执行，正在占用时间片；</li>
<li>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；</li>
<li>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/17539e.png" alt="img" loading="lazy"></figure>
<p>▲ 线程的生命周期</p>
<p><strong>线程的生命周期跟进程很类似：</strong></p>
<blockquote>
<ul>
<li>创建：一个新的线程被创建，等待该线程被调用执行；</li>
<li>就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；</li>
<li>运行：此线程正在执行，正在占用时间片；</li>
<li>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；</li>
<li>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。</li>
</ul>
</blockquote>
<h1 id="3-什么是协程">3、什么是协程？</h1>
<h3 id="31-基本常识">3.1 基本常识</h3>
<p>协程：英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做“用户空间线程”，具有对内核来说不可见的特性。</p>
<p>因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。</p>
<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cd5225.png" alt="img" loading="lazy"></figure>
<h3 id="32-协程的目的">3.2 协程的目的</h3>
<p>对于Java程序员来说，在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。</p>
<p>如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。</p>
<p>最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。</p>
<p>对于上述问题：现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是 [node.js]以及 Java 里的新秀 [Vert.x]。</p>
<p>而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。</p>
<h3 id="33-协程的特点">3.3 协程的特点</h3>
<p><strong>协程的特点总结一下就是：</strong></p>
<ul>
<li>1）线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率；</li>
<li>2）线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程；</li>
<li>3）由于在同一个线程上，因此可以避免竞争关系而使用锁；</li>
<li>4）适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li>
</ul>
<h3 id="34-协程的原理">3.4 协程的原理</h3>
<p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑。</p>
<p>这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如：Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。</p>
<p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。</p>
<p>**因此：**协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。</p>
<h3 id="35-协程和线程的比较">3.5 协程和线程的比较</h3>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/5e7ad5.png" alt="img" loading="lazy"></figure>
<h1 id="4-总结一下">4、总结一下</h1>
<p>我们总结一下。</p>
<p><strong>进程和线程的区别就是：</strong></p>
<ul>
<li>1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>
<li>3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li>
</ul>
<p><strong>进程和线程之间的联系就是：</strong></p>
<ul>
<li>1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li>
<li>2）资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>3）处理机分给线程，即真正在处理机上运行的是线程；</li>
<li>4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<p>*<strong>那么，既然有了线程，为啥还要有协程？*</strong></p>
<p><strong>考虑这一样一种场景：</strong></p>
<p>开发者在每个线程中只做非常轻量的操作，比如访问一个极小的文件，下载一张极小的图片，加载一段极小的文本等。但是，这样”轻量的操作“的量却非常多。</p>
<p>在有大量这样的轻量操作的场景下，即使可以通过使用线程池来避免创建与销毁的开销，但是线程切换的开销也会非常大，甚至于接近操作本身的开销。</p>
<p>对于这些场景，就非常需要一种可以减少这些开销的方式。于是，协程就应景而出，非常适合这样的场景。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-liu-tong-su-yi-dong-gao-xing-neng-fu-wu-qi-dao-di-shi-ru-he-shi-xian-de/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-liu-tong-su-yi-dong-gao-xing-neng-fu-wu-qi-dao-di-shi-ru-he-shi-xian-de/">
        </link>
        <updated>2021-04-20T05:21:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-多进程">1、多进程</h1>
<p>历史上最早出现也是最简单的一种并行处理多个请求的方法就是利用[多进程]。</p>
<p>比如在Linux世界中，我们可以使用fork、exec等系统调用创建多个进程，我们可以在父进程中接收用户的连接请求，然后创建子进程去处理用户请求。</p>
<p><strong>就像这样：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/2b7161.png" alt="img" loading="lazy"></figure>
<p><strong>这种方法的优点就在于：</strong></p>
<ul>
<li>1）编程简单，非常容易理解；</li>
<li>2）由于各个进程的地址空间是相互隔离的，因此一个进程崩溃后并不会影响其它进程；</li>
<li>3）充分利用多核资源。</li>
</ul>
<p><strong>多进程并行处理的优点很明显，但是缺点同样明显：</strong></p>
<ul>
<li>1）各个进程地址空间相互隔离，这一优点也会变成缺点，那就是进程间要想通信就会变得比较困难，你需要借助进程间通信（IPC，interprocess  communications）机制，想一想你现在知道哪些进程间通信机制，然后让你用代码实现呢？显然，进程间通信编程相对复杂，而且性能也是一大问题；</li>
<li>2）我们知道创建进程开销是比线程要大的，频繁的创建销毁进程无疑会加重系统负担。</li>
</ul>
<h1 id="2-多线程">2、多线程</h1>
<p>不是创建进程开销大吗？不是进程间通信困难吗？这些对于线程来说统统不是问题。</p>
<p>由于线程共享进程地址空间，因此线程间通信天然不需要借助任何通信机制，直接读取内存就好了。</p>
<p>线程创建销毁的开销也变小了，要知道线程就像寄居蟹一样，房子（地址空间）都是进程的，自己只是一个租客，因此非常的轻量级，创建销毁的开销也非常小。</p>
<p>我们可以为每个请求创建一个线程，即使一个线程因执行I/O操作——比如读取数据库等——被阻塞暂停运行也不会影响到其它线程。</p>
<p><strong>就像这样：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/ac9097.png" alt="img" loading="lazy"></figure>
<p>但线程就是完美的、包治百病的吗，显然，计算机世界从来没有那么简单。</p>
<p>由于线程共享进程地址空间，这在为线程间通信带来便利的同时也带来了无尽的麻烦。</p>
<p>正是由于线程间共享地址空间，因此一个线程崩溃会导致整个进程崩溃退出，同时线程间通信简直太简单了，简单到线程间通信只需要直接读取内存就可以了，也简单到出现问题也极其容易，死锁、线程间的同步互斥、等等，这些极容易产生bug，无数程序员宝贵的时间就有相当一部分用来解决多线程带来的无尽问题。</p>
<p>虽然线程也有缺点，但是相比多进程来说，线程更有优势，但想单纯的利用多线程就能解决高并发问题也是不切实际的。</p>
<p>因为虽然线程创建开销相比进程小，但依然也是有开销的，对于动辄数万数十万的链接的高并发服务器来说，创建数万个线程会有性能问题，这包括内存占用、线程间切换，也就是调度的开销。</p>
<h1 id="3-事件驱动event-loop">3、事件驱动：Event Loop</h1>
<p>到目前为止，我们提到“并行”二字就会想到进程、线程。</p>
<p>**但是：**并行编程只能依赖这两项技术吗？并不是这样的！</p>
<p>还有另一项并行技术广泛应用在GUI编程以及服务器编程中，这就是近几年非常流行的事件驱动编程：event-based concurrency。实际上事件驱动编程原理上非常简单。</p>
<p><strong>这一技术需要两种原料：</strong></p>
<ul>
<li>1）event；</li>
<li>2）处理event的函数，这一函数通常被称为event handler；</li>
</ul>
<p>剩下的就简单了：你只需要安静的等待event到来就好，当event到来之后，检查一下event的类型，并根据该类型找到对应的event处理函数，也就是event handler，然后直接调用该event handler就好了。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0669a2.png" alt="img" loading="lazy"></figure>
<p>**从上面可以看到：**我们需要不断的接收event然后处理event，因此我们需要一个循环（用while或者for循环都可以），这个循环被称为Event loop。</p>
<p><strong>使用伪代码表示就是这样：</strong></p>
<blockquote>
<p>while(true) {</p>
<p>event = getEvent();</p>
<p>handler(event);</p>
<p>}</p>
</blockquote>
<p>Event loop中要做的事情其实是非常简单的，只需要等待event的带来，然后调用相应的event处理函数即可。</p>
<p>**注意：**这段代码只需要运行在一个线程或者进程中，只需要这一个event loop就可以同时处理多个用户请求。</p>
<p>**有的可以依然不明白：**为什么这样一个event loop可以同时处理多个请求呢？</p>
<p>**原因很简单：**对于网络通信服务器来说，处理一个用户请求时大部分时间其实都用在了I/O操作上，像数据库读写、文件读写、网络读写等。当一个请求到来，简单处理之后可能就需要查询数据库等I/O操作，我们知道I/O是非常慢的，当发起I/O后我们大可以不用等待该I/O操作完成就可以继续处理接下来的用户请求。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/05c919.png" alt="img" loading="lazy"></figure>
<p>**现在你应该明白了吧：**虽然上一个用户请求还没有处理完我们其实就可以处理下一个用户请求了，这也是并行，这种并行就可以用事件驱动编程来处理。</p>
<p>**这就好比餐厅服务员一样：**一个服务员不可能一直等上一个顾客下单、上菜、吃饭、买单之后才接待下一个顾客，服务员是怎么做的呢？当一个顾客下完单后直接处理下一个顾客，当顾客吃完饭后会自己回来买单结账的。</p>
<p>**看到了吧：**同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event loop只运行在一个线程(进程)中也可以同时处理多个用户请求。</p>
<p>相信你已经对事件驱动编程有一个清晰的认知了，那么接下来的问题就是，这个事件也就是event该怎么获取呢？</p>
<h1 id="4-事件来源io多路复用">4、事件来源：IO多路复用</h1>
<p>在Linux/Unix世界中一切皆文件，而我们的程序都是通过文件描述符来进行I/O操作的，当然对于网络编程中的socket也不例外。</p>
<p>那我们该如何同时处理多个文件描述符呢？</p>
<p>**IO多路复用技术正是用来解决这一问题的：**通过IO多路复用技术，我们一次可以监控多个文件描述，当某个“文件”（实际可能是im网络通信中socket）可读或者可写的时候我们就能得到通知啦。</p>
<p>这样IO多路复用技术就成了event loop的原材料供应商，源源不断的给我们提供各种event，这样关于event来源的问题就解决了。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/aebd72.png" alt="img" loading="lazy"></figure>
<p>**至此：**关于利用事件驱动来实现并发编程的所有问题都解决了吗？event的来源问题解决了，当得到event后调用相应的handler，看上去大功告成了。</p>
<h1 id="5-问题阻塞式io">5、问题：阻塞式IO</h1>
<p>**现在：**我们可以使用一个线程（进程）就能基于事件驱动进行并行编程，再也没有了多线程中让人恼火的各种锁、同步互斥、死锁等问题了。</p>
<p>**但是：**计算机科学中从来没有出现过一种能解决所有问题的技术，现在没有，在可预期的将来也不会有。</p>
<p>那上述方法有什么问题吗？</p>
<p>不要忘了，我们event loop是运行在一个线程（进程），这虽然解决了多线程问题，但是如果在处理某个event时需要进行IO操作会怎么样呢？</p>
<p>我们讲解了最常用的文件读取在底层是如何实现的，程序员最常用的这种IO方式被称为阻塞式IO。</p>
<p>**也就是说：**当我们进行IO操作，比如读取文件时，如果文件没有读取完成，那么我们的程序（线程）会被阻塞而暂停执行，这在多线程中不是问题，因为操作系统还可以调度其它线程。</p>
<p>**但是：**在单线程的event loop中是有问题的，原因就在于当我们在event loop中执行阻塞式IO操作时整个线程（event  loop）会被暂停运行，这时操作系统将没有其它线程可以调度，因为系统中只有一个event loop在处理用户请求，这样当event  loop线程被阻塞暂停运行时所有用户请求都没有办法被处理。你能想象当服务器在处理其它用户请求读取数据库导致你的请求被暂停吗？</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/35a7da.png" alt="img" loading="lazy"></figure>
<p>**因此：**在基于事件驱动编程时有一条注意事项，那就是不允许发起阻塞式IO。</p>
<p>有的可能会问，如果不能发起阻塞式IO的话，那么该怎样进行IO操作呢？</p>
<p>**PS：**有阻塞式IO，就有非阻塞式IO。</p>
<h1 id="6-解决方法非阻塞式io">6、解决方法：非阻塞式IO</h1>
<p>为克服阻塞式IO所带来的问题，现代操作系统开始提供一种新的发起IO请求的方法，这种方法就是异步IO。对应的，阻塞式IO就是同步IO。</p>
<p>异步IO时，假设调用aio_read函数（具体的异步IO  API请参考具体的操作系统平台），也就是异步读取，当我们调用该函数后可以立即返回，并继续其它事情，虽然此时该文件可能还没有被读取，这样就不会阻塞调用线程了。此外，操作系统还会提供其它方法供调用线程来检测IO操作是否完成。</p>
<p>就这样，在操作系统的帮助下IO的阻塞调用问题也解决了。</p>
<h1 id="7-基于事件驱动并行编程的难点">7、基于事件驱动并行编程的难点</h1>
<p>虽然有异步IO来解决event loop可能被阻塞的问题，但是基于事件编程依然是困难的。</p>
<p>**首先：**我们提到，event loop是运行在一个线程中的，显然一个线程是没有办法充分利用多核资源的，有的同学可能会说那就创建多个event loop实例不就可以了，这样就有多个event loop线程了，但是这样一来多线程问题又会出现。</p>
<p>另一点在于编程方面，异步编程需要结合回调函数（这种编程方式需要把处理逻辑分为两部分：一部分调用方自己处理，另一部分在回调函数中处理），这一编程方式的改变加重了程序员在理解上的负担，基于事件编程的项目后期会很难扩展以及维护。</p>
<h1 id="8-更好的方法">8、更好的方法</h1>
<p>为什么我们要使用异步这种难以理解的方式编程呢？</p>
<p>**是因为：**阻塞式编程虽然容易理解但会导致线程被阻塞而暂停运行。</p>
<p>**那么你一定会问了：**有没有一种方法既能结合同步IO的简单理解又不会因同步调用导致线程被阻塞呢？</p>
<p>**答案是肯定的：**这就是用户态线程（user level thread），也就是协程。</p>
<p>虽然基于事件编程有这样那样的缺点，但是在当今的高性能高并发服务器上基于事件编程方式依然非常流行，但已经不是纯粹的基于单一线程的事件驱动了，而是 event loop + multi thread + user level thread。</p>
<h1 id="9-本文小结">9、本文小结</h1>
<p>高并发技术从最开始的多进程一路演进到当前的事件驱动，计算机技术就像生物一样也在不断演变进化，但不管怎样，了解历史才能更深刻的理解当下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(五)：深入操作系统，理解高并发中的协程]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-wu-shen-ru-cao-zuo-xi-tong-li-jie-gao-bing-fa-zhong-de-xie-cheng/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-wu-shen-ru-cao-zuo-xi-tong-li-jie-gao-bing-fa-zhong-de-xie-cheng/">
        </link>
        <updated>2021-04-20T03:59:23.000Z</updated>
        <content type="html"><![CDATA[<p>应该如何彻底理解协程。</p>
<h1 id="1-普通的函数">1、普通的函数</h1>
<p><strong>我们先来看一个普通的函数，这个函数非常简单：</strong></p>
<pre><code class="language-python">def func():
   print(&quot;a&quot;)
   print(&quot;b&quot;)
   print(&quot;c&quot;)
</code></pre>
<p><strong>这是一个简单的普通函数，当我们调用这个函数时会发生什么？</strong></p>
<ul>
<li>1）调用func；</li>
<li>2）func开始执行，直到return；</li>
<li>3）func执行完成，返回函数A。</li>
</ul>
<p><strong>是不是很简单，函数func执行直到返回，并打印出：</strong></p>
<pre><code class="language-python">a
b
c
</code></pre>
<p>注意这段代码是用python写的，但本篇关于协程的讨论适用于任何一门语言，因为协程并不是某种语言特有的。而我们只不过恰好使用了python来用作示例，因其足够简单。</p>
<p>那么协程是什么呢？</p>
<h1 id="2-从普通函数到协程">2、从普通函数到协程</h1>
<p>接下来，我们就要从普通函数过渡到协程了。和普通函数只有一个返回点不同，协程可以有多个返回点。</p>
<p><strong>这是什么意思呢？</strong></p>
<pre><code class="language-python">void func() {
  print(&quot;a&quot;)
  暂停并返回
  print(&quot;b&quot;)
  暂停并返回
  print(&quot;c&quot;)
}
</code></pre>
<p>普通函数下，只有当执行完print(&quot;c&quot;)这句话后函数才会返回，但是在协程下当执行完print(&quot;a&quot;)后func就会因“暂停并返回”这段代码返回到调用函数。</p>
<p>有的可能会一脸懵，这有什么神奇的吗？</p>
<p><strong>我写一个return也能返回，就像这样：</strong></p>
<pre><code class="language-python">void func() {
  print(&quot;a&quot;)
  return
  print(&quot;b&quot;)
  暂停并返回
  print(&quot;c&quot;)
}
</code></pre>
<p>直接写一个return语句确实也能返回，但这样写的话return后面的代码都不会被执行到了。</p>
<p>协程之所以神奇就神奇在当我们从协程返回后还能继续调用该协程，并且是从该协程的上一个返回点后继续执行。</p>
<p><strong>就好比孙悟空说一声“定”，函数就被暂停了：</strong></p>
<pre><code class="language-python">void func() {
  print(&quot;a&quot;)
  定
  print(&quot;b&quot;)
  定
  print(&quot;c&quot;)
}
</code></pre>
<p>这时我们就可以返回到调用函数，当调用函数什么时候想起该协程后可以再次调用该协程，该协程会从上一个返回点继续执行。在编程语言中一般叫做yield（其它语言中可能会有不同的实现，但本质都是一样的）。</p>
<p>需要注意的是：当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的。</p>
<p>接下来，我们就用实际的代码看一看协程。</p>
<h1 id="3-talk-is-cheapshow-me-the-code">3、“Talk is cheap，show me the code”</h1>
<p>下面我们使用一个真实的例子来讲解，语言采用python.</p>
<p>在python语言中，这个“定”字同样使用关键词yield。</p>
<p><strong>这样我们的func函数就变成了：</strong></p>
<pre><code class="language-python">void func() {
  print(&quot;a&quot;)
  yield
  print(&quot;b&quot;)
  yield
  print(&quot;c&quot;)
}
</code></pre>
<p>**注意：**这时我们的func就不再是简简单单的函数了，而是升级成为了协程，那么我们该怎么使用呢？</p>
<p><strong>很简单：</strong></p>
<pre><code class="language-python">def A():
  co =func() # 得到该协程
  next(co)    # 调用协程
  print(&quot;in function A&quot;) # do something
  next(co)    # 再次调用该协程
</code></pre>
<p>我们看到虽然func函数没有return语句，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了。</p>
<p><strong>接下来我们调用该协程，使用next(co)，运行函数A看看执行到第3行的结果是什么：</strong></p>
<pre><code class="language-apache">a
</code></pre>
<p>显然，和我们的预期一样，协程func在print(&quot;a&quot;)后因执行yield而暂停并返回函数A。</p>
<p><strong>接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印：</strong></p>
<pre><code class="language-apache">a
in function A
</code></pre>
<p>接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢？</p>
<p>如果func是普通函数，那么会执行func的第一行代码，也就是打印a。</p>
<p>但func不是普通函数，而是协程，我们之前说过，协程会在上一个返回点继续运行，因此这里应该执行的是func函数第一个yield之后的代码，也就是 <em>print(&quot;b&quot;)</em>。</p>
<pre><code class="language-apache">a
in function A
b
</code></pre>
<p>看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行。</p>
<h1 id="4-图形化解释">4、图形化解释</h1>
<p>为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍。</p>
<p><strong>首先是普通的函数调用：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/fff298.png" alt="img" loading="lazy"></figure>
<p>**在该图中：**方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向。</p>
<p>**从上图中我们可以看到：**我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行。这是普通的函数调用。</p>
<p><strong>接下来是协程：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/135931.png" alt="img" loading="lazy"></figure>
<p>**在这里：**我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程。</p>
<p>**注意：**协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是从上一次的挂起点开始执行，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/2b9ee.png" alt="img" loading="lazy"></figure>
<h1 id="5-函数只是协程的一种特例">5、函数只是协程的一种特例</h1>
<p>和普通函数不同的是，协程能知道自己上一次执行到了哪里。</p>
<p>现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。</p>
<p>很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。</p>
<p>只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。</p>
<p>这就是为什么有的人说可以把协程理解为用户态线程的原因。</p>
<p>也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。</p>
<p>在协程这件事儿上，调度你说了算。</p>
<p>当你在协程中写下 yield 的时候就是想要暂停该协程，当使用 <em>next()</em> 时就是要再次运行该协程。</p>
<p>现在你应该理解为什么说函数只是协程的一种特例了吧，函数其实只是没有挂起点的协程而已。</p>
<h1 id="6-协程的历史">6、协程的历史</h1>
<p>有的可能认为协程是一种比较新的技术，然而其实协程这种概念早在1958年就已经提出来了，要知道这时线程的概念都还没有提出来。</p>
<p>到了1972年，终于有编程语言实现了这个概念，这两门编程语言就是Simula 67 以及Scheme。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0ea45a.png" alt="img" loading="lazy"></figure>
<p>但协程这个概念始终没有流行起来，甚至在1993年还有人考古一样专门写论文挖出协程这种古老的技术。</p>
<p>因为这一时期还没有线程，如果你想在操作系统写出并发程序那么你将不得不使用类似协程这样的技术，后来线程开始出现，操作系统终于开始原生支持程序的并发执行，就这样，协程逐渐淡出了程序员的视线。</p>
<p>直到近些年，随着互联网的发展，尤其是移动互联网时代的到来，服务端对高并发的要求越来越高，协程再一次重回技术主流，各大编程语言都已经支持或计划开始支持协程。</p>
<p>那么协程到底是如何实现的呢？</p>
<h1 id="7-协程到底是如何实现的">7、协程到底是如何实现的？</h1>
<p>**让我们从问题的本质出发来思考这个问题：**协程的本质是什么呢？</p>
<p>其实就是可以被暂停以及可以被恢复运行的函数。那么可以被暂停以及可以被恢复意味着什么呢？</p>
<p>看过篮球比赛的同学想必都知道（没看过的也能知道），篮球比赛也是可以被随时暂停的，暂停时大家需要记住球在哪一方，各自的站位是什么，等到比赛继续的时候大家回到各自的位置，裁判哨子一响比赛继续，就像比赛没有被暂停过一样。</p>
<p>**看到问题的关键了吗：**比赛之所以可以被暂停也可以继续是因为比赛状态被记录下来了（站位、球在哪一方），这里的状态就是计算机科学中常说的上下文（context）。</p>
<p>回到协程。</p>
<p>协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文（状态）另外：函数运行时所有的状态信息都位于函数运行时栈中。</p>
<p>函数运行时栈就是我们需要保存的状态，也就是所谓的上下文。</p>
<p><strong>如图所示：</strong></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/16c42a.png" alt="img" loading="lazy"></figure>
<p>**从上图中我们可以看出：**该进程中只有一个线程，栈区中有四个栈帧，main函数调用A函数，A函数调用B函数，B函数调用C函数，当C函数在运行时整个进程的状态就如图所示。</p>
<p>**现在：**我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦。</p>
<p>既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？</p>
<p>**想一想这个问题：**整个进程的内存区中哪一块是专门用来长时间(进程生命周期)存储数据的？</p>
<p>**很显然：**这就是堆区啊（heap），我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new。</p>
<p>**我们需要做的就是：**在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态。</p>
<p>再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？</p>
<p>**实际上：**我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如下图所示。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1ee4ae.png" alt="img" loading="lazy"></figure>
<p>**从上图中我们可以看到：**该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了。</p>
<p>有的可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？</p>
<p>**答案是：**这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的。</p>
<p><strong>现在你应该看到了吧，在上图中实际上共有3个执行流：</strong></p>
<ul>
<li>1）一个普通线程；</li>
<li>2）两个协程。</li>
</ul>
<p>虽然有3个执行流但我们创建了几个线程呢？</p>
<p>**答案是：**一个线程。</p>
<p>**现在你应该明白为什么要使用协程了吧：**使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在。</p>
<p>因此：即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的。</p>
<p>这也许是为什么协程这个概念比线程提出的要早的原因，可能是写普通应用的程序员比写操作系统的程序员最先遇到需要多个并行流的需求，那时可能都还没有操作系统的概念，或者操作系统没有并行这种需求，所以非操作系统程序员只能自己动手实现执行流，也就是协程。</p>
<h1 id="8-协程技术概念小结">8、协程技术概念小结</h1>
<p>到底什么是协程呢？</p>
<h3 id="81-协程是比线程更小的执行单元">8.1 协程是比线程更小的执行单元</h3>
<p>协程是比线程更小的一种执行单元，你可以认为是轻量级的线程。</p>
<p>**之所以说轻：**其中一方面的原因是协程所持有的栈比线程要小很多，java当中会为每个线程分配1M左右的栈空间，而协程可能只有几十或者几百K，栈主要用来保存函数参数、局部变量和返回地址等信息。</p>
<p>**我们知道：**而线程的调度是在操作系统中进行的，而协程调度则是在用户空间进行的，是开发人员通过调用系统底层的执行上下文相关api来完成的。有些语言，比如nodejs、go在语言层面支持了协程，而有些语言，比如C，需要使用第三方库才可以拥有协程的能力（比如微信开源的Libco库就是这样的）。</p>
<p>由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的。</p>
<p>使用协程是因为线程的切换成本比较高，而协程在这方面很有优势。</p>
<h3 id="82-协程的切换到底为什么很廉价">8.2 协程的切换到底为什么很廉价？</h3>
<p><strong>关于这个问题，我们回顾一下线程切换的过程：</strong></p>
<ul>
<li>1）线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读入另外一个线程的数据，这个会花费一些时间；</li>
<li>2）CPU的高速缓存中的数据，也可能失效，需要重新加载；</li>
<li>3）线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都需要执行上千条指令，很耗时。</li>
</ul>
<p><strong>实际上协程的切换之所以快的原因我认为主要是：</strong></p>
<ul>
<li>1）在切换的时候，寄存器需要保存和加载的数据量比较小；</li>
<li>2）高速缓存可以有效利用；</li>
<li>3）没有用户模式到内核模式的切换操作；</li>
<li>4）更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的切换（为了尽量让用户感知不到某个线程卡）。</li>
</ul>
<h1 id="9-写在最后">9、写在最后</h1>
<p>写到这里，相信你已经理解协程到底是怎么一回事了，关于协程更系统的知识可以自行查阅相关资料。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(四)：深入操作系统，理解同步与异步]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-si-shen-ru-cao-zuo-xi-tong-li-jie-tong-bu-yu-yi-bu/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-si-shen-ru-cao-zuo-xi-tong-li-jie-tong-bu-yu-yi-bu/">
        </link>
        <updated>2021-04-20T03:44:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-编程中的同步调用">1、编程中的同步调用</h1>
<p>我们先说同步调用，这是程序员最熟悉的场景。</p>
<p><strong>一般的函数调用都是同步的，就像这样：</strong></p>
<blockquote>
<p>funcA() {</p>
<p>// 等待函数funcB执行完成</p>
<p>funcB();</p>
<p>// 继续接下来的流程</p>
<p>}</p>
</blockquote>
<p>funcA调用funcB，那么在funcB执行完前，funcA中的后续代码都不会被执行，也就是说funcA必须等待funcB执行完成。</p>
<p><strong>就像下图这样：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1105631014.png" alt="img" loading="lazy"><br>
从上图中我们可以看到，在funcB运行期间funcA什么都做不了，这就是典型的同步。</p>
<p>注意：一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的，这是最为常见的情况。</p>
<p>**但值得注意的是：**即使运行在两个不能线程中的函数也可以进行同步调用，像我们进行IO操作时实际上底层是通过系统调用的方式向操作系统发出请求的，比如磁盘文件读取：</p>
<blockquote>
<p>read(file, buf);</p>
</blockquote>
<p>这就是我们在《深入操作系统，理解I/O与零拷贝技术》中描述的阻塞式I/O，在read函数返回前程序是无法继续向前推进的：</p>
<blockquote>
<p>read(file, buf);</p>
<p>// 程序暂停运行，</p>
<p>// 等待文件读取完成后继续运行</p>
</blockquote>
<p><strong>如下图所示：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1671658766.png" alt="img" loading="lazy"><br>
只有当read函数返回后程序才可以被继续执行。</p>
<p>**注意：**和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。</p>
<p>**因此：**我们可以得出结论，同步调用和函数与被调函数是否运行在同一个线程是没有关系的。</p>
<p>在这里我们还要再次强调：同步方式下函数和被调函数无法同时进行。</p>
<p>同步编程对程序员来说是最自然最容易理解的。</p>
<p>但容易理解的代价就是在一些场景下，同步并不是高效的，原因很简单，因为任务没有办法同时进行。</p>
<p>接下来我们看异步调用。</p>
<h1 id="2-编程中的异步调用">2、编程中的异步调用</h1>
<p>有同步调用就有异步调用。</p>
<p>如果你真的理解了本节到目前为止的内容的话，那么异步调用对你来说不是问题。</p>
<p>**一般来说：**异步调用总是和I/O操作等耗时较高的任务如影随形，像磁盘文件读写、网络数据的收发、数据库操作等。</p>
<p>我们还是以磁盘文件读取为例。</p>
<p>在read函数的同步调用方式下，文件读取完之前调用方是无法继续向前推进的，但如果read函数可以异步调用情况就不一样了。</p>
<p>假如read函数可以异步调用的话，即使文件还没有读取完成，read函数也可以立即返回。</p>
<blockquote>
<p>read(file, buff);</p>
<p>// read函数立即返回</p>
<p>// 不会阻塞当前程序</p>
</blockquote>
<p><strong>就像下图这样：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/933885230.png" alt="img" loading="lazy"></p>
<p>**可以看到：**在异步这种调用方式下，调用方不会被阻塞，函数调用完成后可以立即执行接下来的程序。</p>
<p>这时异步的重点就在于：调用方接下来的程序执行可以和文件读取同时进行，从上图中我们也能看出这一点，这就是异步的高效之处。</p>
<p>**但是：**请注意，异步调用对于程序员来说在理解上是一种负担，代码编写上更是一种负担，总的来说，上帝在为你打开一扇门的时候会适当的关上一扇窗户。</p>
<p>有的可能会问，在同步调用下，调用方不再继续执行而是暂停等待，被调函数执行完后很自然的就是调用方继续执行，那么异步调用下调用方怎知道被调函数是否执行完成呢？</p>
<p><strong>这就分为了两种情况：</strong></p>
<ul>
<li>1）调用方根本就不关心执行结果；</li>
<li>2）调用方需要知道执行结果。</li>
</ul>
<p>第一种情况比较简单，无需讨论。</p>
<p><strong>第二种情况下就比较有趣了，通常有两种实现方式：</strong></p>
<ul>
<li>1）一种是通知机制：当任务执行完成后发送信号来通知调用方任务完成（这里的信号有很多实现方式：Linux中的signal，或使用信号量等机制都可实现）；</li>
<li>2）一种是回调机制：也就是我们常说的callback（关于回调我们将在下一篇文章中重点讲解，本篇会有简短的讨论）。</li>
</ul>
<p>接下来我们用一个具体的例子讲解一下同步调用与异步调用。</p>
<h1 id="3-具体的编程例子中理解同步和异步">3、具体的编程例子中理解同步和异步</h1>
<h3 id="31-一个具体的示例">3.1 一个具体的示例</h3>
<p>我们以常见的Web服务来举例说明这一问题。</p>
<p>一般来说Web  Server接收到用户请求后会有一些典型的处理逻辑，最常见的就是数据库查询（当然，你也可以把这里的数据库查询换成其它I/O操作，比如磁盘读取、网络通信等），在这里我们假定处理一次用户请求需要经过步骤A、B、C，然后读取数据库，数据库读取完成后需要经过步骤D、E、F。</p>
<p><strong>就像这样：</strong></p>
<blockquote>
<p># 处理一次用户请求需要经过的步骤：</p>
<p>A;</p>
<p>B;</p>
<p>C;</p>
<p>数据库读取;</p>
<p>D；</p>
<p>E；</p>
<p>F；</p>
</blockquote>
<p>**其中：**步骤A、B、C和D、E、F不需要任何I/O，也就是说这六个步骤不需要读取文件、网络通信等，涉及到I/O操作的只有数据库查询这一步。</p>
<p>**一般来说：**这样的Web Server有两个典型的线程：主线程和数据库处理线程（注意：这讨论的只是典型的场景，具体业务实际上可会有差别，但这并不影响我们用两个线程来说明问题）。</p>
<p>首先我们来看下最简单的实现方式，也就是同步。</p>
<p><strong>这种方式最为自然也最为容易理解：</strong></p>
<blockquote>
<p>// 主线程</p>
<p>main_thread() {</p>
<p>A;</p>
<p>B;</p>
<p>C;</p>
<p>发送数据库查询请求;</p>
<p>D;</p>
<p>E;</p>
<p>F;</p>
<p>}</p>
<p>// 数据库线程</p>
<p>DataBase_thread() {</p>
<p>while(1) {</p>
<p>​    处理数据库读取请求;</p>
<p>​    返回结果;</p>
<p>}</p>
<p>}</p>
</blockquote>
<p>这就是最为典型的同步方法：主线程在发出数据库查询请求后就会被阻塞而暂停运行，直到数据库查询完毕后面的D、E、F才可以继续运行。</p>
<p><strong>就像下图这样：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/2106811704.png" alt="img" loading="lazy"></p>
<p>**从上图中我们可以看到：**主线程中会有“空隙”，这个空隙就是主线程的“休闲时光”，主线程在这段休闲时光中需要等待数据库查询完成才能继续后续处理流程。</p>
<p>在这里主线程就好比监工的老板，数据库线程就好比苦逼搬砖的程序员，在搬完砖前老板什么都不做只是紧紧的盯着你，等你搬完砖后才去忙其它事情。</p>
<p>**显然：**高效的程序员是不能容忍主线程偷懒的。</p>
<p>是时候祭出大杀器了，这就是异步：</p>
<p>在异步这种实现方案下主线程根本不去等待数据库是否查询完成，而是发送完数据库读写请求后直接处理下一个请求。</p>
<p>**有的同学可能会有疑问：**一个请求需要经过A、B、C、数据库查询、D、E、F这七个步骤，如果主线程在完成A、B、C、数据库查询后直接进行处理接下来的请求，那么上一个请求中剩下的D、E、F几个步骤怎么办呢？</p>
<p>如果大家还没有忘记上一小节内容的话应该知道，这有两种情况，我们来分别讨论。</p>
<h3 id="32-异步情况1主线程不关心数据库操作结果">3.2 异步情况1：主线程不关心数据库操作结果</h3>
<p>在这种情况下，主线程根本就不关心数据库是否查询完毕，数据库查询完毕后自行处理接下来的D、E、F三个步骤。</p>
<p><strong>就像下图这样：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/437487319.png" alt="img" loading="lazy"></p>
<p>我们说过一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？</p>
<p>这时，我们的另一个主角回调函数就开始登场啦。</p>
<p>没错，回调函数就是用来解决这一问题的。</p>
<p>我们可以将处理D、E、F这几个步骤封装到一个函数中，假定将该函数命名为handle_DEF_after_DB_query。</p>
<p><strong>伪码如下：</strong></p>
<blockquote>
<p>void handle_DEF_after_DB_query () {</p>
<p>D;</p>
<p>E;</p>
<p>F;</p>
<p>}</p>
</blockquote>
<p><strong>这样主线程在发送数据库查询请求的同时将该函数一并当做参数传递过去：</strong></p>
<blockquote>
<p>DB_query(request, handle_DEF_after_DB_query);</p>
</blockquote>
<p>数据库线程处理完后直接调用handle_DEF_after_DB_query就可以了，这就是回调函数的作用。</p>
<p>也有的同学可能会有疑问，为什么这个函数要传递给数据库线程而不是数据库线程自己定义自己调用呢？</p>
<p>因为从软件组织结构上讲，这不是数据库线程该做的工作。</p>
<p>数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心。</p>
<p>**你可以传入各种各样的回调函数：**也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。</p>
<p>**而从软件开发的角度看：**假设数据库线程逻辑封装为了库提供给其它团队，当数据库团队在研发时怎么可能知道数据库查询后该做什么呢？</p>
<p>显**然：**只有使用方才知道查询完数据库后该做些什么，因此使用方在使用时简单的传入这个回调函数就可以了。</p>
<p>这样复杂数据库的团队就和使用方团队实现了所谓的解耦。</p>
<p>现在你应该明白回调函数的作用了吧。</p>
<p>**另外：**仔细观察上面两张图，你能看出为什么异步比同步高效吗？</p>
<p>原因很简单，这也是我们在本篇提到过的，异步天然就无需等待，无依赖。</p>
<p>主线程处理请求和数据库处理查询请求可以同时进行，因此从系统性能上看，这样的设计能更加充分的利用系统资源，更加快速的处理请求；从用户的角度看，系统的响应也会更加迅速。</p>
<p>这就是异步的高效之处。</p>
<p>**但我们应该也可以看出：**异步编程并不如同步来的容易理解，系统可维护性上也不如同步模式。</p>
<p>那么有没有一种方法既能结合同步模式的容易理解又能结合异步模式的高效呢？答案是肯定的。</p>
<p>接下来我们看第二种情况，那就是主线程需要关心数据库查询结果。</p>
<h3 id="33-异步情况2主线程关心数据库操作结果">3.3 异步情况2：主线程关心数据库操作结果</h3>
<p>在这种情况下，数据库线程需要将查询结果利用通知机制发送给主线程，主线程在接收到消息后继续处理上一个请求的后半部分。</p>
<p><strong>就像下图这样：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1240741043.png" alt="img" loading="lazy"></p>
<p>**从这里我们可以看到：**ABCDEF几个步骤全部在主线中处理，同时主线程同样也没有了“休闲时光”，只不过在这种情况下数据库线程是比较清闲的，从这里并没有上一种方法高效，但是依然要比同步模式下要高效。</p>
<p>**最后需要注意的是：**并不是所有的情况下异步都一定比同步高效，还需要结合具体业务以及IO的复杂度具体情况具体分析。</p>
<h1 id="4-本文小结">4、本文小结</h1>
<p>在这篇文章中我们从各种场景分析了同步与异步这两个概念，但是不管在什么场景下，同步往往意味着双方要相互等待、相互依赖，而异步意味着双方相互独立、各行其是。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(三)：深入操作系统，彻底理解I/O多路复用]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-san-shen-ru-cao-zuo-xi-tong-che-di-li-jie-io-duo-lu-fu-yong/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-san-shen-ru-cao-zuo-xi-tong-che-di-li-jie-io-duo-lu-fu-yong/">
        </link>
        <updated>2021-04-20T03:35:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-什么是文件">1、什么是文件？</h1>
<p>在正式展开本文的内容之前，我们需要先预习一下文件以及文件描述符的概念。</p>
<p>程序员使用I/O最终都逃不过文件这个概念。</p>
<p>在Linux世界中文件是一个很简单的概念，作为程序员我们只需要将其理解为一个N byte的序列就可以了：</p>
<blockquote>
<p>b1, b2, b3, b4, ....... bN</p>
</blockquote>
<p>实际上所有的I/O设备都被抽象为了文件这个概念，一切皆文件（Everything is File），磁盘、网络数据、终端，甚至进程间通信工具管道pipe等都被当做文件对待。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1044806017.png" alt="img" loading="lazy"></p>
<p>所有的I/O操作也都可以通过文件读写来实现，这一非常优雅的抽象可以让程序员使用一套接口就能对所有外设I/O操作。</p>
<p><strong>常用的I/O操作接口一般有以下几类：</strong></p>
<ul>
<li>1）打开文件，open；</li>
<li>2）改变读写位置，seek；</li>
<li>3）文件读写，read、write；</li>
<li>4）关闭文件，close。</li>
</ul>
<p>程序员通过这几个接口几乎可以实现所有I/O操作，这就是文件这个概念的强大之处。</p>
<h1 id="2-什么是文件描述符">2、什么是文件描述符？</h1>
<p>在上一篇《<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.52im.net%2Fthread-3280-1-1.html">深入操作系统，理解I/O与零拷贝技术</a>》中我们讲到：要想进行I/O读操作，像磁盘数据，我们需要指定一个buff用来装入数据。</p>
<p><strong>一般都是这样写的：</strong></p>
<blockquote>
<p>read(buff);</p>
</blockquote>
<p>但是这里我们忽略了一个关键问题：那就是，虽然我们指定了往哪里写数据，但是我们该从哪里读数据呢？</p>
<p>从上一节中我们知道，通过文件这个概念我们能实现几乎所有I/O操作，因此这里少的一个主角就是文件。</p>
<p>那么我们一般都怎样使用文件呢？</p>
<p>**举个例子：**如果周末你去比较火的餐厅吃饭应该会有体会，一般周末人气高的餐厅都会排队，然后服务员会给你一个排队序号，通过这个序号服务员就能找到你，这里的好处就是服务员无需记住你是谁、你的名字是什么、来自哪里、喜好是什么、是不是保护环境爱护小动物等等，这里的关键点就是：服务员对你一无所知，但依然可以通过一个号码就能找到你。</p>
<p>**同样的：**在Linux世界要想使用文件，我们也需要借助一个号码，根据“<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.52im.net%2Fthread-3280-1-1.html">弄不懂原则</a>”，这个号码就被称为了文件描述符（file descriptors），在Linux世界中鼎鼎大名，其道理和上面那个排队号码一样。</p>
<p>**因此：**文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/201177950.png" alt="img" loading="lazy"></p>
<p>有了文件描述符，进程可以对文件一无所知，比如文件在磁盘的什么位置、加载到内存中又是怎样管理的等等，这些信息统统交由操作系统打理，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。</p>
<p><strong>因此我们来完善上述程序：</strong></p>
<blockquote>
<p>int fd = open(file_name); // 获取文件描述符</p>
<p>read(fd, buff);</p>
</blockquote>
<p>怎么样，是不是非常简单。</p>
<h1 id="3-文件描述符太多了怎么办">3、文件描述符太多了怎么办？</h1>
<p>经过了这么多的铺垫，终于要到高性能、高并发这一主题了。</p>
<p>从前几节我们知道，所有I/O操作都可以通过文件样的概念来进行，这当然包括网络通信。</p>
<p>如果你有一个IM服务器，当三次握手建议长连接成功以后，我们会调用accept来获取一个链接，调用该函数我们同样会得到一个文件描述符，通过这个文件描述符就可以处理客户端发送的聊天消息并且把消息转发给接收者。</p>
<p>也就是说，通过这个描述符我们就可以和客户端进行通信了：</p>
<blockquote>
<p>// 通过accept获取客户端的文件描述符</p>
<p>int conn_fd = accept(...);</p>
</blockquote>
<p>Server端的处理逻辑通常是接收客户端消息数据，然后执行转发（给接收者）逻辑：</p>
<blockquote>
<p>if(read(conn_fd, msg_buff) &gt; 0) {</p>
<p>do_transfer(msg_buff);</p>
<p>}</p>
</blockquote>
<p>是不是非常简单，然而世界终归是复杂的，当然也不是这么简单的。</p>
<p>接下来就是比较复杂的了。</p>
<p>既然我们的主题是高并发，那么Server端就不可能只和一个客户端通信，而是可能会同时和成千上万个客户端进行通信。这时你需要处理不再是一个描述符这么简单，而是有可能要处理成千上万个描述符。</p>
<p>为了不让问题一上来就过于复杂，我们先简单化，假设只同时处理两个客户端的请求。</p>
<p><strong>有的同学可能会说，这还不简单，这样写不就行了：</strong></p>
<blockquote>
<p>if(read(socket_fd1, buff) &gt; 0) { // 处理第一个</p>
<p>do_transfer();</p>
<p>}</p>
<p>if(read(socket_fd2, buff) &gt; 0) { // 处理第二个</p>
<p>do_transfer();</p>
</blockquote>
<p>在《[深入操作系统，理解I/O与零拷贝技术]》中我们讨论过，这是非常典型的阻塞式I/O，如果此时没有数据可读那么进程会被阻塞而暂停运行。这时我们就无法处理第二个请求了，即使第二个请求的数据已经就位，这也就意味着处理某一个客户端时由于进程被阻塞导致剩下的所有其它客户端必须等待，在同时处理几万客户端的server上。这显然是不能容忍的。</p>
<p>聪明的你一定会想到使用多线程：为每个客户端请求开启一个线程，这样一个客户端被阻塞就不会影响到处理其它客户端的线程了。注意：既然是高并发，那么我们要为成千上万个请求开启成千上万个线程吗，大量创建销毁线程会严重影响系统性能。</p>
<p>那么这个问题该怎么解决呢？</p>
<p>**这里的关键点在于：**我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。</p>
<p>因此要优雅的解决这个问题，就要从其它角度来思考这个问题了。</p>
<h1 id="4-不要打电话给我有需要我会打给你">4、“不要打电话给我，有需要我会打给你”</h1>
<p>大家生活中肯定会接到过推销电话，而且不止一个，一天下来接上十个八个推销电话你的身体会被掏空的。</p>
<p>这个场景的关键点在于：打电话的人并不知道你是不是要买东西，只能来一遍遍问你。因此一种更好的策略是不要让他们打电话给你，记下他们的电话，有需要的话打给他们，这样推销员就不会一遍一遍的来烦你了（虽然现实生活中这并不可能）。</p>
<p>**在这个例子中：**你，就好比内核，推销者就好比应用程序，电话号码就好比文件描述符，和你用电话沟通就好比I/O。</p>
<p>现在你应该明白了吧，处理多个文件描述符的更好方法其实就存在于推销电话中。</p>
<p>因此相比上一节中：我们通过I/O接口主动问内核这些文件描述符对应的外设是不是已经就绪了，一种更好的方法是，我们把这些感兴趣的文件描述符一股脑扔给内核，并霸气的告诉内核：“我这里有1万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？。。。”</p>
<p>**这样：**应用程序就从“繁忙”的主动变为了清闲的被动，反正文件描述可读可写了内核会通知我，能偷懒我才不要那么勤奋。</p>
<p>这是一种更加高效的I/O处理机制，现在我们可以一次处理多路I/O了，为这种机制起一个名字吧，就叫I/O多路复用吧，这就是 I/O multiplexing。</p>
<h1 id="5-io多路复用io-multiplexing">5、I/O多路复用（I/O multiplexing）</h1>
<p>multiplexing一词其实多用于通信领域，为了充分利用通信线路，希望在一个信道中传输多路信号，要想在一个信道中传输多路信号就需要把这多路信号结合为一路，将多路信号组合成一个信号的设备被称为Multiplexer（多路复用器），显然接收方接收到这一路组合后的信号后要恢复原先的多路信号，这个设备被称为Demultiplexer（多路分用器）。</p>
<p><strong>如下图所示：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/793876181.png" alt="img" loading="lazy"></p>
<p>回到我们的主题。</p>
<p><strong>所谓I/O多路复用指的是这样一个过程：</strong></p>
<ul>
<li>1）我们拿到了一堆文件描述符（不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以）；</li>
<li>2）通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回”；</li>
<li>3）当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。</li>
</ul>
<p>也就是说通过I/O多路复用我们可以同时处理多路I/O。那么有哪些函数可以用来进行I/O多路复用呢？</p>
<p><strong>以Linux为例，有这样三种机制可以用来进行I/O多路复用：</strong></p>
<ul>
<li>1）select；</li>
<li>2）poll；</li>
<li>3）epoll。</li>
</ul>
<p>接下来我们就来介绍一下I/O多路复用三剑客。</p>
<h1 id="6-io多路复用三剑客">6、I/O多路复用三剑客</h1>
<p>**本质上：**Linux上的select、poll、epoll都是阻塞式I/O，也就是我们常说的同步I/O。</p>
<p>原因在于：调用这些I/O多路复用函数时如果任何一个需要监视的文件描述符都不可读或者可写那么进程会被阻塞暂停执行，直到有文件描述符可读或者可写才继续运行。</p>
<h3 id="61-select初出茅庐">6.1 select：初出茅庐</h3>
<p>在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中。</p>
<p>我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个。因此程序员必须再遍历一边找到具体是哪个文件描述符可以读写了。</p>
<p><strong>因此，总结下来select有这样几个特点：</strong></p>
<ul>
<li>1）我能照看的文件描述符数量有限，不能超过1024个；</li>
<li>2）用户给我的文件描述符需要拷贝的内核中；</li>
<li>3）我只能告诉你有文件描述符满足要求了，但是我不知道是哪个，你自己一个一个去找吧（遍历）。</li>
</ul>
<p>因此我们可以看到，select机制的这些特性在高并发网络服务器动辄几万几十万并发链接的场景下无疑是低效的。</p>
<h3 id="62-poll小有所成">6.2 poll：小有所成</h3>
<p>poll和select是非常相似的。</p>
<p>poll相对于select的优化仅仅在于解决了文件描述符不能超过1024个的限制，select和poll都会随着监控的文件描述数量增加而性能下降，因此不适合高并发场景。</p>
<h3 id="63-epoll独步天下">6.3 epoll：独步天下</h3>
<p>在select面临的三个问题中，文件描述数量限制已经在poll中解决了，剩下的两个问题呢？</p>
<p>针对拷贝问题：epoll使用的策略是各个击破与共享内存。</p>
<p>**实际上：**文件描述符集合的变化频率比较低，select和poll频繁的拷贝整个集合，内核都快被烦死了，epoll通过引入epoll_ctl很体贴的做到了只操作那些有变化的文件描述符。同时epoll和内核还成为了好朋友，共享了同一块内存，这块内存中保存的就是那些已经可读或者可写的的文件描述符集合，这样就减少了内核和程序的拷贝开销。</p>
<p>针对需要遍历文件描述符才能知道哪个可读可写这一问题，epoll使用的策略是“当小弟”。</p>
<p>在select和poll机制下：进程要亲自下场去各个文件描述符上等待，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。</p>
<p>但epoll就懂事多了，主动找到进程。</p>
<p>**在这种机制下：**进程不需要亲自下场了，进程只要等待在epoll上，epoll代替进程去各个文件描述符上等待，当哪个文件描述符可读或者可写的时候就告诉epoll，epoll用小本本认真记录下来然后唤醒大哥：“进程大哥，快醒醒，你要处理的文件描述符我都记下来了”，这样进程被唤醒后就无需自己从头到尾检查一遍，因为epoll小弟都已经记下来了。</p>
<p>因此我们可以看到：在epoll这种机制下，实际上利用的就是“不要打电话给我，有需要我会打给你”这种策略，进程不需要一遍一遍麻烦的问各个文件描述符，而是翻身做主人了——“你们这些文件描述符有哪个可读或者可写了主动报上来”。</p>
<p>这种机制实际上就是大名鼎鼎的事件驱动——Event-driven，这也是我们下一篇的主题。</p>
<p>**实际上：**在Linux平台，epoll基本上就是高并发的代名词。</p>
<h1 id="7-本文小结">7、本文小结</h1>
<p>基于一切皆文件的设计哲学，I/O也可以通过文件的形式实现，高并发场景下要与多个文件交互，这就离不开高效的I/O多路复用技术。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(二)：深入操作系统，理解I/O与零拷贝技术]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-er-shen-ru-cao-zuo-xi-tong-li-jie-io-yu-ling-kao-bei-ji-zhu/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-er-shen-ru-cao-zuo-xi-tong-li-jie-io-yu-ling-kao-bei-ji-zhu/">
        </link>
        <updated>2021-04-20T03:24:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-不能执行io的计算机是什么">1、不能执行I/O的计算机是什么？</h2>
<p><strong>相信对于程序员来说I/O操作是最为熟悉不过的了，比如：</strong></p>
<ul>
<li>1）当我们使用C语言中的printf、C++中的&quot;&lt;&lt;&quot;，Python中的print，Java中的System.out.println等时；</li>
<li>2）当我们使用各种语言读写文件时；</li>
<li>3）当我们通过TCP/IP进行网络通信时；</li>
<li>4）当我们使用鼠标龙飞凤舞时；</li>
<li>5）当我们拿起键盘在评论区指点江山亦或是埋头苦干努力制造bug时；</li>
<li>6）当我们能看到屏幕上的漂亮的图形界面时等等。</li>
</ul>
<p>以上这一切，都是I/O！</p>
<p>**想一想：**如果没有I/O计算机该是一种多么枯燥的设备，不能看电影、不能玩游戏，也不能上网，这样的计算机最多就是一个大号的计算器。</p>
<p>既然I/O这么重要，那么到底什么才是I/O呢？</p>
<h2 id="2-什么是io">2、什么是I/O？</h2>
<p>I/O就是简单的数据Copy，仅此而已！</p>
<p>这一点很重要！</p>
<p>既然是copy数据，那么又是从哪里copy到哪里呢？</p>
<p>如果数据是从外部设备copy到内存中，这就是Input。</p>
<p>如果数据是从内存copy到外部设备，这就是Output。</p>
<p>内存与外部设备之间不嫌麻烦的来回copy数据就是Input and Output，简称I/O（Input/Output），仅此而已。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/e5hfe9.jpg" alt="" loading="lazy"></figure>
<h2 id="3-io与cpu">3、I/O与CPU</h2>
<p>现在我们知道了什么是I/O，接下来就是重点部分了。</p>
<p>我们知道现在的CPU其主频都是数GHz起步，这是什么意思呢？</p>
<p>**简单说就是：**CPU执行机器指令的速度是纳秒级别的，而通常的I/O比如磁盘操作，一次磁盘seek大概在毫秒级别，因此如果我们把CPU的速度比作战斗机的话，那么I/O操作的速度就是肯德鸡。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/jionur.jpg" alt="" loading="lazy"></figure>
<p>也就是说当我们的程序跑起来时（CPU执行机器指令），其速度是要远远快于I/O速度的。那么接下来的问题就是二者速度相差这么大，那么我们该如何设计、该如何更加合理的高效利用系统资源呢？</p>
<p>既然有速度差异，而且进程在执行完I/O操作前不能继续向前推进，那么显然只有一个办法，那就是<strong>等待</strong>（wait）。</p>
<p>同样是等待，有聪明的等待，也有傻傻的等待，简称傻等，那么是选择聪明的等待呢还是选择傻等呢？</p>
<p>假设你是一个急性子（CPU），需要等待一个重要的文件，不巧的是这个文件只能快递过来（I/O），那么这时你是选择什么事情都不干了，深情的注视着门口就像盼望着你的哈尼一样专心等待这个快递呢？还是暂时先不要管快递了，玩个游戏看个电影刷会儿短视频等快递来了再说呢？</p>
<p>很显然，更好的方法就是先去干其它事情，快递来了再说。</p>
<p>**因此：**这里的关键点就是快递没到前手头上的事情可以先暂停，切换到其它任务，等快递过来了再切换回来。</p>
<p>理解了这一点你就能明白执行I/O操作时底层都发生了什么。</p>
<p>接下来让我们以读取磁盘文件为例来讲解这一过程。</p>
<h2 id="4-执行io时底层都发生了什么">4、执行I/O时底层都发生了什么</h2>
<p>在支持线程的操作系统中，实际上被调度的是线程而不是进程，为了更加清晰的理解I/O过程，我们暂时假设操作系统只有进程这样的概念，先不去考虑线程，这并不会影响我们的讨论。</p>
<p>现在内存中有两个进程，进程A和进程B，当前进程A正在运行。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/hmyji1gy.png" alt="" loading="lazy"></figure>
<p>进程A中有一段读取文件的代码，不管在什么语言中通常我们定义一个用来装数据的buff，然后调用read之类的函数。</p>
<p><strong>就像这样：</strong></p>
<pre><code>read(buff);
</code></pre>
<p>这就是一种典型的I/O操作，当CPU执行到这段代码的时候会向磁盘发送读取请求。</p>
<p>**注意：**与CPU执行指令的速度相比，I/O操作操作是非常慢的，因此操作系统是不可能把宝贵的CPU计算资源浪费在无谓的等待上的，这时重点来了，注意接下来是重点哦。</p>
<p>由于外部设备执行I/O操作是相当慢的，因此在I/O操作完成之前进程是无法继续向前推进的，这就是所谓的阻塞，即通常所说的block。</p>
<p>操作系统检测到进程向I/O设备发起请求后就暂停进程的运行，怎么暂停运行呢？**很简单：**只需要记录下当前进程的运行状态并把CPU的PC寄存器指向其它进程的指令就可以了。</p>
<p>进程有暂停就会有继续执行，因此操作系统必须保存被暂停的进程以备后续继续执行，显然我们可以用队列来保存被暂停执行的进程。</p>
<p>如下图所示，进程A被暂停执行并被放到阻塞队列中（**注意：**不同的操作系统会有不同的实现，可能每个I/O设备都有一个对应的阻塞队列，但这种实现细节上的差异不影响我们的讨论）。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/xbyo7ew.png" alt="" loading="lazy"></figure>
<p>这时操作系统已经向磁盘发送了I/O请求，因此磁盘driver开始将磁盘中的数据copy到进程A的buff中。虽然这时进程A已经被暂停执行了，但这并不妨碍磁盘向内存中copy数据。</p>
<p>**注意：**现代磁盘向内存copy数据时无需借助CPU的帮助，这就是所谓的DMA（Direct Memory Access）。</p>
<p><strong>这个过程如下图所示：</strong></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/jrmg7.png" alt="" loading="lazy"></figure>
<p>让磁盘先copy着数据，我们接着聊。</p>
<p>**实际上：**操作系统中除了有阻塞队列之外也有就绪队列，所谓就绪队列是指队列里的进程准备就绪可以被CPU执行了。</p>
<p>你可能会问为什么不直接执行非要有个就绪队列呢？**答案很简单：**那就是僧多粥少，在即使只有1个核的机器上也可以创建出成千上万个进程，CPU不可能同时执行这么多的进程，因此必然存在这样的进程，即使其一切准备就绪也不能被分配到计算资源，这样的进程就被放到了就绪队列。</p>
<p>现在进程B就位于就绪队列，万事俱备只欠CPU。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/474nmc.png" alt="" loading="lazy"></figure>
<p>当进程A被暂停执行后CPU是不可以闲下来的，因为就绪队列中还有嗷嗷待哺的进程B，这时操作系统开始在就绪队列中找下一个可以执行的进程，也就是这里的进程B。</p>
<p>此时操作系统将进程B从就绪队列中取出，找出进程B被暂停时执行到的机器指令的位置，然后将CPU的PC寄存器指向该位置，这样进程B就开始运行啦。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/vnkc1g.png" alt="" loading="lazy"></figure>
<p>**注意：**接下来的这段是重点中的重点！</p>
<p>**注意观察上图：**此时进程B在被CPU执行，磁盘在向进程A的内存空间中copy数据，看出来了吗——大家都在忙，谁都没有闲着，数据copy和指令执行在同时进行，在操作系统的调度下，CPU、磁盘都得到了充分的利用，这就是程序员的智慧所在。</p>
<p>现在你应该理解为什么操作系统这么重要了吧。</p>
<p>此后磁盘终于将全部数据都copy到了进程A的内存中，这时磁盘通知操作系统任务完成啦，你可能会问怎么通知呢？这就是<strong>中断</strong>。</p>
<p>操作系统接收到磁盘中断后发现数据copy完毕，进程A重新获得继续运行的资格，这时操作系统小心翼翼的把进程A从阻塞队列放到了就绪队列当中。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/wekgvjh.png" alt="" loading="lazy"></figure>
<p>**注意：**从前面关于就绪状态的讨论中我们知道，操作系统是不会直接运行进程A的，进程A必须被放到就绪队列中等待，这样对大家都公平。</p>
<p>此后进程B继续执行，进程A继续等待，进程B执行了一会儿后操作系统认为进程B执行的时间够长了，因此把进程B放到就绪队列，把进程A取出并继续执行。</p>
<p>**注意：**操作系统把进程B放到的是就绪队列，因此进程B被暂停运行仅仅是因为时间片到了而不是因为发起I/O请求被阻塞。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/hjwjazzm.png" alt="" loading="lazy"></figure>
<p>进程A继续执行，此时buff中已经装满了想要的数据，进程A就这样愉快的运行下去了，就好像从来没有被暂停过一样，进程对于自己被暂停一事一无所知，这就是操作系统的魔法。</p>
<p>现在你应该明白了I/O是一个怎样的过程了吧。</p>
<p>这种进程执行I/O操作被阻塞暂停执行的方式被称为阻塞式I/O，blocking I/O，这也是最常见最容易理解的I/O方式，有阻塞式I/O就有非阻塞式I/O，在这里我们暂时先不考虑这种方式。</p>
<p>在本节开头我们说过暂时只考虑进程而不考虑线程，现在我们放宽这个条件，实际上也非常简单，只需要把前图中调度的进程改为线程就可以了，这里的讨论对于线程一样成立。</p>
<h2 id="5-零拷贝zero-copy">5、零拷贝（Zero-copy）</h2>
<p>**最后需要注意的一点就是：**上面的讲解中我们直接把磁盘数据copy到了进程空间中，但实际上一般情况下I/O数据是要首先copy到操作系统内部，然后操作系统再copy到进程空间中。</p>
<p>因此我们可以看到这里其实还有一层经过操作系统的copy，对于性能要求很高的场景其实也是可以绕过操作系统直接进行数据copy的，这也是本文描述的场景，这种绕过操作系统直接进行数据copy的技术被称为Zero-copy，也就零拷贝，高并发、高性能场景下常用的一种技术，原理上很简单吧。</p>
<h2 id="6-本文小结">6、本文小结</h2>
<p>本文讲解的是程序员常用的I/O（包括所谓的网络I/O），一般来说作为程序员我们无需关心，但是理解I/O背后的底层原理对于设计比如IM这种高性能、高并发系统是极为有益的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解高性能、高并发(一)：深入计算机底层，理解线程与线程池]]></title>
        <id>https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-yi-shen-ru-ji-suan-ji-di-ceng-li-jie-xian-cheng-yu-xian-cheng-chi/</id>
        <link href="https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-yi-shen-ru-ji-suan-ji-di-ceng-li-jie-xian-cheng-yu-xian-cheng-chi/">
        </link>
        <updated>2021-04-20T03:11:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-一切要从cpu说起">1、一切要从CPU说起</h1>
<p>你可能会有疑问，讲多线程为什么要从CPU说起呢？原因很简单，在这里没有那些时髦的概念，你可以更加清晰的看清问题的本质。</p>
<p>实际情况是：CPU并不知道线程、进程之类的概念。</p>
<p><strong>CPU只知道两件事：</strong></p>
<ul>
<li>1）从内存中取出指令；</li>
<li>2）执行指令，然后回到 1）。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/121426477.png" alt="img" loading="lazy"></figure>
<p>你看，在这里CPU确实是不知道什么进程、线程之类的概念。</p>
<p>接下来的问题就是CPU从哪里取出指令呢？答案是来自一个被称为Program Counter（简称PC）的寄存器，也就是我们熟知的程序计数器，在这里大家不要把寄存器想的太神秘，你可以简单的把寄存器理解为内存，只不过存取速度更快而已。</p>
<p>PC寄存器中存放的是什么呢？这里存放的是指令在内存中的地址，什么指令呢？是CPU将要执行的下一条指令。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1600014873.png" alt="img" loading="lazy"></p>
<p>那么是谁来设置PC寄存器中的指令地址呢？</p>
<p>原来PC寄存器中的地址默认是自动加1的，这当然是有道理的，因为大部分情况下CPU都是一条接一条顺序执行，当遇到if、else时，这种顺序执行就被打破了，CPU在执行这类指令时会根据计算结果来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。</p>
<p>聪明的你一定会问，那么PC中的初始值是怎么被设置的呢？</p>
<p>在回答这个问题之前我们需要知道CPU执行的指令来自哪里？是来自内存，废话，内存中的指令是从磁盘中保存的可执行程序加载过来的，磁盘中可执行程序是编译器生成的，编译器又是从哪里生成的机器指令呢？答案就是我们定义的函数。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/472137863.png" alt="img" loading="lazy"></p>
<p>注意是函数，函数被编译后才会形成CPU执行的指令，那么很自然的，我们该如何让CPU执行一个函数呢？显然我们只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。</p>
<p>现在你应该知道了吧，我们想要CPU执行一个函数，那么只需要把该函数对应的第一条机器指令的地址写入PC寄存器就可以了，这样我们写的函数就开始被CPU执行起来啦。</p>
<p>你可能会有疑问，这和线程有什么关系呢？</p>
<h1 id="2-从cpu到操作系统">2、从CPU到操作系统</h1>
<p>上一小节中我们明白了CPU的工作原理，我们想让CPU执行某个函数，那么只需要把函数对应的第一条机器执行装入PC寄存器就可以了，这样即使没有操作系统我们也可以让CPU执行程序，虽然可行但这是一个非常繁琐的过程。</p>
<p><strong>我们需要：</strong></p>
<ul>
<li>1）在内存中找到一块大小合适的区域装入程序；</li>
<li>2）找到函数入口，设置好PC寄存器让CPU开始执行程序。</li>
</ul>
<p>这两个步骤绝不是那么容易的事情，如果每次在执行程序时程序员自己手动实现上述两个过程会疯掉的，因此聪明的程序员就会想干脆直接写个程序来自动完成上面两个步骤吧。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1035563985.png" alt="img" loading="lazy"></figure>
<p>机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地址并写到PC寄存器中，想一想这是不是需要一个数据结构来记录下这些信息。</p>
<p><strong>数据结构大致如下：</strong></p>
<blockquote>
<p>struct *** {</p>
<p>void* start_addr;</p>
<p>intlen;</p>
<p>void* start_point;</p>
<p>...</p>
<p>};</p>
</blockquote>
<p>接下来就是起名字时刻。</p>
<p>这个数据结构总要有个名字吧，这个结构体用来记录什么信息呢？记录的是程序在被加载到内存中的运行状态，程序从磁盘加载到内存跑起来叫什么好呢？干脆就叫进程（Process）好了，我们的指导原则就是一定要听上去比较神秘，总之大家都不容易弄懂就对了，我将其称为“弄不懂原则”。</p>
<p>就这样进程诞生了。</p>
<p>CPU执行的第一个函数也起个名字，第一个要被执行的函数听起来比较重要，干脆就叫main函数吧。</p>
<p>完成上述两个步骤的程序也要起个名字，根据“弄不懂原则”这个“简单”的程序就叫操作系统（Operating System）好啦。</p>
<p>就这样操作系统诞生了，程序员要想运行程序再也不用自己手动加载一遍了。</p>
<p>现在进程和操作系统都有了，一切看上去都很完美。</p>
<h1 id="3-从单核到多核如何充分利用多核">3、从单核到多核，如何充分利用多核</h1>
<p>人类的一大特点就是生命不息折腾不止，从单核折腾到了多核。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/386511984.jpg" alt="img" loading="lazy"></p>
<p>这时，假设我们想写一个程序并且要分利用多核该怎么办呢？</p>
<p>有的同学可能会说不是有进程吗，多开几个进程不就可以了？</p>
<p><strong>听上去似乎很有道理，但是主要存在这样几个问题：</strong></p>
<ul>
<li>1）进程是需要占用内存空间的(从上一节能看到这一点)，如果多个进程基于同一个可执行程序，那么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费；</li>
<li>2）计算机处理的任务可能是比较复杂的，这就涉及到了进程间通信，由于各个进程处于不同的内存地址空间，进程间通信天然需要借助操作系统，这就在增大编程难度的同时也增加了系统开销。</li>
</ul>
<p>该怎么办呢？</p>
<h1 id="4-从进程到线程">4、从进程到线程</h1>
<p>让我再来仔细的想一想这个问题，所谓进程无非就是内存中的一段区域，这段区域中保存了CPU执行的机器指令以及函数运行时的堆栈信息，要想让进程运行，就把main函数的第一条机器指令地址写入PC寄存器，这样进程就运行起来了。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/175856179.png" alt="img" loading="lazy"></p>
<p>进程的缺点在于只有一个入口函数，也就是main函数，因此进程中的机器指令只能被一个CPU执行，那么有没有办法让多个CPU来执行同一个进程中的机器指令呢？</p>
<p>聪明的你应该能想到，既然我们可以把main函数的第一条指令地址写入PC寄存器，那么其它函数和main函数又有什么区别呢？</p>
<p>答案是没什么区别，main函数的特殊之处无非就在于是CPU执行的第一个函数，除此之外再无特别之处，我们可以把PC寄存器指向main函数，就可以把PC寄存器指向任何一个函数。</p>
<p>当我们把PC寄存器指向非main函数时，线程就诞生了。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/206310381.png" alt="img" loading="lazy"></p>
<p>至此我们解放了思想，一个进程内可以有多个入口函数，也就是说属于同一个进程中的机器指令可以被多个CPU同时执行。</p>
<p>**注意：**这是一个和进程不同的概念，创建进程时我们需要在内存中找到一块合适的区域以装入进程，然后把CPU的PC寄存器指向main函数，也就是说进程中只有一个执行流。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/906340191.png" alt="img" loading="lazy"></p>
<p>但是现在不一样了，多个CPU可以在同一个屋檐下(进程占用的内存区域)同时执行属于该进程的多个入口函数，也就是说现在一个进程内可以有多个执行流了。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/495009593.png" alt="img" loading="lazy"></p>
<p>总是叫执行流好像有点太容易理解了，再次祭出”弄不懂原则“，起个不容易懂的名字，就叫线程吧。</p>
<p>这就是线程的由来。</p>
<p>操作系统为每个进程维护了一堆信息，用来记录进程所处的内存空间等，这堆信息记为数据集A。</p>
<p>同样的，操作系统也需要为线程维护一堆信息，用来记录线程的入口函数或者栈信息等，这堆数据记为数据集B。</p>
<p>显然数据集B要比数据A的量要少，同时不像进程，创建一个线程时无需去内存中找一段内存空间，因为线程是运行在所处进程的地址空间的，这块地址空间在程序启动时已经创建完毕，同时线程是程序在运行期间创建的（进程启动后），因此当线程开始运行的时候这块地址空间就已经存在了，线程可以直接使用。这就是为什么各种教材上提的创建线程要比创建进程快的原因（当然还有其它原因）。</p>
<p>值得注意的是，有了线程这个概念后，我们只需要进程开启后创建多个线程就可以让所有CPU都忙起来，这就是所谓高性能、高并发的根本所在。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/2073679658.png" alt="img" loading="lazy"></p>
<p>很简单，只需要创建出数量合适的线程就可以了。</p>
<p>另外值得注意的一点是：由于各个线程共享进程的内存地址空间，因此线程之间的通信无需借助操作系统，这给程序员带来极大方便的同时也带来了无尽的麻烦，多线程遇到的多数问题都出自于线程间通信简直太方便了以至于非常容易出错。出错的根源在于CPU执行指令时根本没有线程的概念，多线程编程面临的互斥与同步问题需要程序员自己解决，关于互斥与同步问题限于篇幅就不详细展开了，大部分的操作系统资料都有详细讲解。</p>
<p>最后需要提醒的是：虽然前面关于线程讲解使用的图中用了多个CPU，但不是说一定要有多核才能使用多线程，在单核的情况下一样可以创建出多个线程，原因在于线程是操作系统层面的实现，和有多少个核心是没有关系的，CPU在执行机器指令时也意识不到执行的机器指令属于哪个线程。即使在只有一个CPU的情况下，操作系统也可以通过线程调度让各个线程“同时”向前推进，方法就是将CPU的时间片在各个线程之间来回分配，这样多个线程看起来就是“同时”运行了，但实际上任意时刻还是只有一个线程在运行。</p>
<h1 id="5-线程与内存">5、线程与内存</h1>
<p>在前面的讨论中我们知道了线程和CPU的关系，也就是把CPU的PC寄存器指向线程的入口函数，这样线程就可以运行起来了，这就是为什么我们创建线程时必须指定一个入口函数的原因。</p>
<p><strong>无论使用任何编程语言，创建一个线程大体相同：</strong></p>
<blockquote>
<p>// 设置线程入口函数DoSomething</p>
<p>thread = CreateThread(DoSomething);</p>
<p>// 让线程运行起来</p>
<p>thread.Run();</p>
</blockquote>
<p>那么线程和内存又有什么关联呢？</p>
<p>我们知道函数在被执行的时产生的数据包括：函数参数、局部变量、返回地址等信息。这些信息是保存在栈中的，线程这个概念还没有出现时进程中只有一个执行流，因此只有一个栈，这个栈的栈底就是进程的入口函数，也就是main函数。</p>
<p><strong>假设main函数调用了funA，funcA又调用了funcB，如图所示：</strong></p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/575895556.png" alt="img" loading="lazy"></p>
<p>那么有了线程以后了呢？</p>
<p>有了线程以后一个进程中就存在多个执行入口，即同时存在多个执行流，那么只有一个执行流的进程需要一个栈来保存运行时信息，那么很显然有多个执行流时就需要有多个栈来保存各个执行流的信息，也就是说操作系统要为每个线程在进程的地址空间中分配一个栈，即每个线程都有独属于自己的栈，能意识到这一点是极其关键的。</p>
<p>​    <img src="https://img2020.cnblogs.com/blog/848699/202012/848699-20201223155557045-512078555.png" alt="img" loading="lazy"></p>
<p>同时我们也可以看到，创建线程是要消耗进程内存空间的，这一点也值得注意。</p>
<h1 id="6-线程的使用">6、线程的使用</h1>
<p>现在有了线程的概念，那么接下来作为程序员我们该如何使用线程呢？</p>
<p>从生命周期的角度讲，线程要处理的任务有两类：长任务和短任务。</p>
<p>*<strong>1）长任务（long-lived tasks）：*</strong></p>
<p>顾名思义，就是任务存活的时间很长，比如以我们常用的word为例，我们在word中编辑的文字需要保存在磁盘上，往磁盘上写数据就是一个任务，那么这时一个比较好的方法就是专门创建一个写磁盘的线程，该写线程的生命周期和word进程是一样的，只要打开word就要创建出该写线程，当用户关闭word时该线程才会被销毁，这就是长任务。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1772188508.png" alt="img" loading="lazy"></p>
<p>这种场景非常适合创建专用的线程来处理某些特定任务，这种情况比较简单。</p>
<p>有长任务，相应的就有短任务。</p>
<p>*<strong>2）短任务（short-lived tasks）：*</strong></p>
<p>这个概念也很简单，那就是任务的处理时间很短，比如一次网络请求、一次数据库查询等，这种任务可以在短时间内快速处理完成。因此短任务多见于各种Server，像web server、database server、file server、mail  server等，这也是互联网行业的同学最常见的场景，这种场景是我们要重点讨论的。</p>
<p>**这种场景有两个特点：**一个是任务处理所需时间短；另一个是任务数量巨大。</p>
<p>如果让你来处理这种类型的任务该怎么办呢？</p>
<p>你可能会想，这很简单啊，当server接收到一个请求后就创建一个线程来处理任务，处理完成后销毁该线程即可，So easy。</p>
<p>这种方法通常被称为thread-per-request，也就是说来一个请求就创建一个线程：</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1419829538.png" alt="img" loading="lazy"></p>
<p>如果是长任务，那么这种方法可以工作的很好，但是对于大量的短任务这种方法虽然实现简单但是有缺点。</p>
<p><strong>具体是以下这样的缺点：</strong></p>
<ul>
<li>1）从前几节我们能看到，线程是操作系统中的概念(这里不讨论用户态线程实现、协程之类)，因此创建线程天然需要借助操作系统来完成，操作系统创建和销毁线程是需要消耗时间的；</li>
<li>2）每个线程需要有自己独立的栈，因此当创建大量线程时会消耗过多的内存等系统资源。</li>
</ul>
<p>这就好比你是一个工厂老板（想想都很开心有没有），手里有很多订单，每来一批订单就要招一批工人，生产的产品非常简单，工人们很快就能处理完，处理完这批订单后就把这些千辛万苦招过来的工人辞退掉，当有新的订单时你再千辛万苦的招一遍工人，干活儿5分钟招人10小时，如果你不是励志要让企业倒闭的话大概是不会这么做到的。</p>
<p>因此一个更好的策略就是招一批人后就地养着，有订单时处理订单，没有订单时大家可以闲呆着。</p>
<p>这就是线程池的由来。</p>
<h1 id="7-从多线程到线程池">7、从多线程到线程池</h1>
<p>线程池的概念是非常简单的，无非就是创建一批线程，之后就不再释放了，有任务就提交给这些线程处理，因此无需频繁的创建、销毁线程，同时由于线程池中的线程个数通常是固定的，也不会消耗过多的内存，因此这里的思想就是复用、可控。</p>
<h1 id="8-线程池是如何工作的">8、线程池是如何工作的</h1>
<p>可能有的同学会问，该怎么给线程池提交任务呢？这些任务又是怎么给到线程池中线程呢？</p>
<p>很显然，数据结构中的队列天然适合这种场景，提交任务的就是生产者，消费任务的线程就是消费者，实际上这就是经典的生产者-消费者问题。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1620124523.png" alt="img" loading="lazy"></p>
<p>现在你应该知道为什么操作系统课程要讲、面试要问这个问题了吧，因为如果你对生产者-消费者问题不理解的话，本质上你是无法正确的写出线程池的。</p>
<p>限于篇幅在这里不打算详细的讲解生产者消费者问题，参考操作系统相关资料就能获取答案。这里我打算讲一讲一般提交给线程池的任务是什么样子的。</p>
<p><strong>一般来说提交给线程池的任务包含两部分：</strong></p>
<ul>
<li>
<ol>
<li>需要被处理的数据；</li>
</ol>
</li>
<li>
<ol start="2">
<li>处理数据的函数。</li>
</ol>
</li>
</ul>
<p><strong>伪码描述一下：</strong></p>
<blockquote>
<p>struct task {</p>
<p>void* data;   // 任务所携带的数据</p>
<p>handler handle; // 处理数据的方法</p>
<p>}</p>
</blockquote>
<p>（注意：你也可以把代码中的struct理解成class，也就是对象)</p>
<p>线程池中的线程会阻塞在队列上，当生产者向队列中写入数据后，线程池中的某个线程会被唤醒，该线程从队列中取出上述结构体(或者对象)，以结构体(或者对象)中的数据为参数并调用处理函数。</p>
<p><strong>伪码如下：</strong></p>
<blockquote>
<p>while(true) {</p>
<p>struct task = GetFromQueue(); // 从队列中取出数据</p>
<p>task-&gt;handle(task-&gt;data);   // 处理数据</p>
<p>}</p>
</blockquote>
<p>以上就是线程池最核心的部分。</p>
<p>理解这些你就能明白线程池是如何工作的了。</p>
<h1 id="9-线程池中线程的数量">9、线程池中线程的数量</h1>
<p>现在线程池有了，那么线程池中线程的数量该是多少呢？</p>
<p>在接着往下看前先自己想一想这个问题。如果你能看到这里说明还没有睡着。</p>
<p>要知道线程池的线程过少就不能充分利用CPU，线程创建的过多反而会造成系统性能下降，内存占用过多，线程切换造成的消耗等等。因此线程的数量既不能太多也不能太少，那到底该是多少呢？</p>
<p>回答这个问题，你需要知道线程池处理的任务有哪几类，有的同学可能会说你不是说有两类吗？长任务和短任务，这个是从生命周期的角度来看的，那么从处理任务所需要的资源角度看也有两种类型，这就是没事儿找抽型。。。啊不，是CPU密集型和I/O密集型。</p>
<p>*<strong>1）CPU密集型：*</strong></p>
<p>所谓CPU密集型就是说处理任务不需要依赖外部I/O，比如科学计算、矩阵运算等等。在这种情况下只要线程的数量和核数基本相同就可以充分利用CPU资源。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/544473276.png" alt="img" loading="lazy"></p>
<p>*<strong>2）I/O密集型：*</strong></p>
<p>这一类任务可能计算部分所占用时间不多，大部分时间都用在了比如磁盘I/O、网络I/O等。</p>
<p>​    <img src="https://gitee.com/kangjun/MyBlogImage/raw/master/712702173.png" alt="img" loading="lazy"></p>
<p>这种情况下就稍微复杂一些了，你需要利用性能测试工具评估出用在I/O等待上的时间，这里记为WT(wait time)，以及CPU计算所需要的时间，这里记为CT（computing time），那么对于一个N核的系统，合适的线程数大概是 <em>N * (1 + WT/CT)</em> ，假设I/O等待时间和计算时间相同，那么你大概需要2N个线程才能充分利用CPU资源，注意这只是一个理论值，具体设置多少需要根据真实的业务场景进行测试。</p>
<p>当然充分利用CPU不是唯一需要考虑的点，随着线程数量的增多，内存占用、系统调度、打开的文件数量、打开的socker数量以及打开的数据库链接等等是都需要考虑的。</p>
<p>因此这里没有万能公式，要具体情况具体分析。</p>
<h1 id="10-线程池不是万能的">10、线程池不是万能的</h1>
<p>线程池仅仅是多线程的一种使用形式，因此多线程面临的问题线程池同样不能避免，像死锁问题、race condition问题等等，关于这一部分同样可以参考操作系统相关资料就能得到答案。</p>
<h1 id="11-线程池使用的最佳实践">11、线程池使用的最佳实践</h1>
<p>线程池是程序员手中强大的武器，互联网公司的各个server上几乎都能见到线程池的身影。</p>
<p><strong>但使用线程池前你需要考虑：</strong></p>
<ul>
<li>1）充分理解你的任务，是长任务还是短任务、是CPU密集型还是I/O密集型，如果两种都有，那么一种可能更好的办法是把这两类任务放到不同的线程池中，这样也许可以更好的确定线程数量；</li>
<li>2）如果线程池中的任务有I/O操作，那么务必对此任务设置超时，否则处理该任务的线程可能会一直阻塞下去；</li>
<li>3）线程池中的任务最好不要同步等待其它任务的结果。</li>
</ul>
<h1 id="12-本文小结">12、本文小结</h1>
<p>本文我们从CPU开始一路来到常用的线程池，从底层到上层、从硬件到软件。</p>
<p>注意：这里通篇没有出现任何特定的编程语言，线程不是语言层面的概念（依然不考虑用户态线程），但是当你真正理解了线程后，相信你可以在任何一门语言下用好多线程，你需要理解的是道，此后才是术。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node–异步I/O解析]]></title>
        <id>https://kangjn.github.io/post/node-yi-bu-io-jie-xi/</id>
        <link href="https://kangjn.github.io/post/node-yi-bu-io-jie-xi/">
        </link>
        <updated>2021-04-19T02:58:55.000Z</updated>
        <content type="html"><![CDATA[<p>“异步”这个名词其实在Node之前就已经诞生了。但是在绝大多数高级编程语言中，异步并不多见。在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。</p>
<p>异步I/O、事件驱动和单线程构成了Node的基调，而Nginx与Node的事件驱动、异步I/O设计理念比较相近。Nginx采用纯C编写，性能表现非常优异，具备面向客户端管理连接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。</p>
<h2 id="为什么要异步io">为什么要异步I/O</h2>
<p>为什么异步I/O在Node中如此重要，这是因为Node面向网络设计，在跨网络的结构下，并发已经是现代编程中的标准配备了。</p>
<h3 id="用户体验">用户体验</h3>
<p>《高性能JavaScript》中提到过，如果脚本的执行时间超过100毫秒，用户就会感到页面卡顿，以为页面停止响应。而在B/S模型中，网络速度的限制给网页的实时体验造成很大的麻烦。</p>
<p>如果网页临时需要获取一个资源，通过同步的方式获取，那么JavaScript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI停顿，不响应用户的交互行为。这样用户体验将会极差。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>同理，前端通过异步可以消除掉UI阻塞现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源消耗M毫秒，第二个资源消耗N毫秒。如果采用同步的方式，获取两个资源消耗的的时间为M+N毫秒。而采用异步的方式，第一个资源的获取并不会阻塞第二个资源的获取，消耗的时间为max(M,N)。</p>
<p>随着网站或应用不断膨胀，M与N的值会线性增长，那么异步的性能将比同步更加优越。</p>
<h3 id="资源分配">资源分配</h3>
<p>假设业务场景中有一组互不相关的任务需要完成，有以下两种主流的方法：</p>
<ul>
<li>单线程串行一次执行</li>
<li>多线程并行完成</li>
</ul>
<p>如果创建多线程的开销小于并行执行，那么多线程是首选的，但是多线程在创建线程和执行期线程上下文切换的开销较大，而且多线程编程经常面临锁、状态同步等问题。</p>
<p>单线程顺序执行任务的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行执行的，但是同步的编程模型导致I/O的进行会让后续任务等待，造成资源不能被更好的利用。</p>
<p>Node利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，更好的利用CPU。</p>
<h2 id="异步io实现">异步I/O实现</h2>
<p>异步I/O在Node中应用最为广泛，但是它并不是Node的原创。</p>
<h3 id="异步io与非阻塞io">异步I/O与非阻塞I/O</h3>
<p>对于计算机内核I/O而言，异步/同步和阻塞/非阻塞是两码事。</p>
<p>操作系统对于I/O只有两种方式：阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。</p>
<p>阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。</p>
<p>为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回，非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时提升性能是明显的，但是由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前的调用状态。</p>
<p>为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做<strong>轮询</strong>。</p>
<p>现存的轮询技术主要有read、select、poll、epoll和kqueue。这里只讲一下epoll的轮询原理。</p>
<p>epoll是Linux下效率最高的I/O事件通知机制，在进入轮询的时候，如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件的通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/k3u1fbpfcp1.png" alt="image.png" loading="lazy"></figure>
<p>轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于程序而言，它仍然算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间等待。等待期间，CPU要么用于遍历文件描述符，要么用于休眠等待时间发生。</p>
<h3 id="现实的异步io">现实的异步I/O</h3>
<p>通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（虽然这是模拟的）</p>
<p>但是最初，Node在*nix 平台下采用了libeio配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O。</p>
<p>而Windows下的IOCP在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。但是它的内部其实依然是线程池原理，不同之处在于这些线程池有系统内核接手管理。</p>
<p>由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间个字独立。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/k3u1fbpfcp2.png" alt="image.png" loading="lazy"></figure>
<p>我们时常提到Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。</p>
<h2 id="node的异步io">Node的异步I/O</h2>
<p>完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>
<h3 id="事件循环">事件循环</h3>
<p>事件循环是Node自身的执行模型，正式它使得回调函数十分普遍。</p>
<p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下个循环，如果不再有事件处理，就退出进程。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJll9.png" alt="coJll9.png" loading="lazy"></figure>
<h3 id="观察者">观察者</h3>
<p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>在Node中，事件主要来源于网络请求、文件I/O等，这些时间对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。</p>
<p>事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<h3 id="请求对象">请求对象</h3>
<p>对于Node的异步I/O调用而言，回调函数不由开发者来调用。从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种产物，叫做<strong>请求对象</strong></p>
<p>下面用fs.open()方法作为一个小小的例子。</p>
<pre><code class="language-js">fs.open = function(path,flags,mode,callback){
    //...
    binding.open(pathModule._makeLong(path),
                    stringToFlags(flags),
                    mode,
                    callback);
}
 
</code></pre>
<p>fs.open()的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初试操作。JavaScript层面的代码通过调用C++核心模块进行下层的操作。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJ3O1.png" alt="coJ3O1.png" loading="lazy"></figure>
<p>从事JavaScript调用Node的核心模块，核心模块调用C++模块，内建模块通过libuv进行系统调用，这里是Node里经典的调用方式。这里libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uv_fs_open()的调用过程中，将从JavaScript层传入的参数和当前方法都封装在一个请求对象中，回调函数则被设置在这个对象的属性上。对象包装完毕后，将对象推入线程池等待执行。</p>
<p>至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。</p>
<p>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</p>
<h3 id="执行回调">执行回调</h3>
<p>组装好请求对象、送入I/O线程池等待执行，只是完成一部I/O的第一部分，回调通知是第二部分。</p>
<p>线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueueCompletionStatus()通知IOCP，告知当前对象操作已经完成。</p>
<p>至此，整个异步I/O的流程完全结束。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJYTK.png" alt="coJYTK.png" loading="lazy"></figure>
<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
<h3 id="小结">小结</h3>
<p>整理下来，我们可以提取异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。单线程和线程池看起来有些悖论的样子。因为JavaScript是单线程的，所以很容易理解为它不能充分利用多核CPU。实际上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。还有就是除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）都是可以并行起来的。</p>
]]></content>
    </entry>
</feed>