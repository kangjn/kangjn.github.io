<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-25T06:09:55.134Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[mysql开发规则]]></title>
        <id>https://kangjn.github.io/post/mysql-kai-fa-gui-ze/</id>
        <link href="https://kangjn.github.io/post/mysql-kai-fa-gui-ze/">
        </link>
        <updated>2021-04-25T05:47:49.000Z</updated>
        <content type="html"><![CDATA[<p>(一)核心规则</p>
<p>(1)不在数据库做运算</p>
<p>cpu计算务必移至业务层；</p>
<p>(2)控制单表数据量</p>
<p>int型不超过1000w，含char则不超过500w；</p>
<p>合理分表；</p>
<p>限制单库表数量在300以内；</p>
<p>(3)控制列数量</p>
<p>字段少而精，字段数建议在20以内；</p>
<p>(4)平衡范式与冗余</p>
<p>效率优先；</p>
<p>往往牺牲范式；</p>
<p>(5)拒绝3B</p>
<p>拒绝大sql语句：big sql</p>
<p>拒绝大事物：big transaction</p>
<p>拒绝大批量：big batch</p>
<p>(二)字段类规则</p>
<p>(6)用好数值类型</p>
<p>tinyint(1Byte)</p>
<p>smallint(2Byte)</p>
<p>mediumint(3Byte)</p>
<p>int(4Byte)</p>
<p>bigint(8Byte)</p>
<p>bad case：int(1)/int(11)</p>
<p>(7)字符转化为数字</p>
<p>用int而不是char(15)存储ip</p>
<p>(8)优先使用enum或set</p>
<p>例如：<code>sex</code> enum (‘F’, ‘M’)</p>
<p>(9)避免使用NULL字段</p>
<p>NULL字段很难查询优化；</p>
<p>NULL字段的索引需要额外空间；</p>
<p>NULL字段的复合索引无效；</p>
<p>bad case：</p>
<p><code>name</code> char(32) default null</p>
<p><code>age</code> int not null</p>
<p>good case：</p>
<p><code>age</code> int not null default 0</p>
<p>(10)少用text/blob</p>
<p>varchar的性能会比text高很多；</p>
<p>实在避免不了blob，请拆表；</p>
<p>(11)不在数据库里存图片</p>
<p>(三)索引类规则</p>
<p>(12)谨慎合理使用索引</p>
<p>改善查询、减慢更新；</p>
<p>索引一定不是越多越好(能不加就不加，要加的一定得加)；</p>
<p>覆盖记录条数过多不适合建索引，例如“性别”；</p>
<p>(13)字符字段必须建前缀索引</p>
<p>(14)不在索引做列运算</p>
<p>！！！不只是索引，都不能做列运算吧！！！</p>
<p>bad case：</p>
<p>select id where age +1 = 10;</p>
<p>(15)innodb主键推荐使用自增列；</p>
<p>主键建立聚簇索引；</p>
<p>主键不应该被修改；</p>
<p>字符串不应该做主键；</p>
<p>如果不指定主键，innodb会使用唯一且非空值索引代替；</p>
<p>(16)不用外键</p>
<p>请由程序保证约束；</p>
<p>(四)sql类规则</p>
<p>(17)sql语句尽可能简单</p>
<p>一条sql只能在一个cpu运算；</p>
<p>大语句拆小语句，减少锁时间；</p>
<p>一条大sql可以堵死整个库；</p>
<p>(18)简单的事务</p>
<p>事务时间尽可能短；</p>
<p>bad case：</p>
<p>上传图片事务</p>
<p>(19)避免使用trig/func</p>
<p>触发器、函数不用；</p>
<p>客户端程序取而代之；</p>
<p>(20)不用select *</p>
<p>消耗cpu，io，内存，带宽；</p>
<p>这种程序不具有扩展性；</p>
<p>(21)OR改写为IN()</p>
<p>or的效率是n级别；</p>
<p>in的消息时log(n)级别；</p>
<p>in的个数建议控制在200以内；</p>
<p>select id from t where phone=’159′ or phone=’136′;</p>
<p>=&gt;</p>
<p>select id from t where phone in (’159′, ’136′);</p>
<p>(22)OR改写为UNION</p>
<p>mysql的索引合并很弱智</p>
<p>select id from t where phone = ’159′ or name = ‘john’;</p>
<p>=&gt;</p>
<p>select id from t where phone=’159′</p>
<p>union</p>
<p>select id from t where name=’jonh’</p>
<p>(23)避免负向%</p>
<p>(24)慎用count(*)</p>
<p>(25)同上</p>
<p>(26)limit高效分页</p>
<p>limit越大，效率越低</p>
<p>select id from t limit 10000, 10;</p>
<p>=&gt;</p>
<p>select id from t where id &gt; 10000 limit 10;</p>
<p>(27)使用union all替代union</p>
<p>union有去重开销</p>
<p>(28)少用连接join</p>
<p>(29)使用group by</p>
<p>分组；</p>
<p>自动排序；</p>
<p>(30)请使用同类型比较</p>
<p>(31)使用load data导数据</p>
<p>load data比insert快约20倍；</p>
<p>(32)打散批量更新</p>
<p>(33)新能分析工具</p>
<p>show profile;</p>
<p>mysqlsla;</p>
<p>mysqldumpslow;</p>
<p>explain;</p>
<p>show slow log;</p>
<p>show processlist;</p>
<p>show query_response_time(percona);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[国外程序员整理的Java资源大全 ]]></title>
        <id>https://kangjn.github.io/post/guo-wai-cheng-xu-yuan-zheng-li-de-java-zi-yuan-da-quan/</id>
        <link href="https://kangjn.github.io/post/guo-wai-cheng-xu-yuan-zheng-li-de-java-zi-yuan-da-quan/">
        </link>
        <updated>2021-04-25T05:40:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="构建">构建</h2>
<p>这里搜集了用来构建应用程序的工具。</p>
<ul>
<li><a href="http://maven.apache.org/">Apache Maven</a>：Maven使用声明进行构建并进行依赖管理，偏向于使用约定而不是配置进行构建。Maven优于Apache Ant。后者采用了一种过程化的方式进行配置，所以维护起来相当困难。</li>
<li><a href="http://www.gradle.org/">Gradle</a>：Gradle采用增量构建。Gradle通过Groovy编程而不是传统的XML声明进行配置。Gradle可以很好地配合Maven进行依赖管理，并且把Ant脚本当作头等公民。</li>
</ul>
<h2 id="字节码操作">字节码操作</h2>
<p>编程操作Java字节码的函数库。</p>
<ul>
<li><a href="http://asm.ow2.org/">ASM</a>：通用底层字节码操作及分析。</li>
<li><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/">Javassist</a>：尝试简化字节码编辑。</li>
<li><a href="http://bytebuddy.net/">Byte Buddy</a>：使用“流式API”进一步简化字节码生成。</li>
</ul>
<h2 id="代码分析">代码分析</h2>
<p>软件度量和质量评估工具。</p>
<ul>
<li><a href="http://checkstyle.sourceforge.net/">Checkstyle</a>：对编程规范和标准进行静态分析。</li>
<li><a href="http://findbugs.sourceforge.net/">FindBugs</a>：通过字节码静态分析找出潜在Bug。</li>
<li><a href="http://pmd.sourceforge.net/">PMD</a>：对源代码中不良编程习惯进行分析。</li>
<li><a href="http://www.sonarqube.org/">SonarQube</a>：通过插件集成其它分析组件，提供评估最终结果报告。</li>
</ul>
<h2 id="编译器">编译器</h2>
<p>创建分析器、解释器和编译器的框架。</p>
<ul>
<li><a href="http://www.antlr.org/">ANTLR</a>：功能完备的自顶向下分析复杂框架。</li>
<li><a href="https://javacc.java.net/">JavaCC</a>：相对ANTLR更具体，上手略为简单。支持语法语法超前预测（syntactic lookahead）。</li>
</ul>
<h2 id="持续集成">持续集成</h2>
<p>支持持续集成、测试和应用发布的工具。</p>
<ul>
<li><a href="https://www.atlassian.com/software/bamboo">Bamboo</a>：Atlassian的持续集成（CI）解决方案，包含很多其它产品。</li>
<li><a href="https://circleci.com/">CircleCI</a>：提供托管服务，可免费试用。</li>
<li><a href="https://www.codeship.io/features">Codeship</a>：提供托管服务，提供有限免费计划。</li>
<li><a href="http://www.thoughtworks.com/products/go-continuous-delivery">Go</a>：ThoughtWork开源持续集成解决方案。</li>
<li><a href="http://jenkins-ci.org/">Jenkins</a>：提供基于服务器的部署服务。</li>
<li><a href="http://www.jetbrains.com/teamcity/">TeamCity</a>：JetBrain持续集成方案，提供免费版。</li>
<li><a href="https://travis-ci.org/">Travis</a>：提供托管服务，常用于开源项目。</li>
</ul>
<h2 id="数据库">数据库</h2>
<p>简化数据库交互的工具、库。</p>
<ul>
<li><a href="http://flywaydb.org/">Flyway</a>：使用Java API轻松完成数据库迁移。</li>
<li><a href="http://h2database.com/">H2</a>：小型SQL数据库，以内存操作著称。</li>
<li><a href="http://jdbi.org/">JDBI</a>：便捷的JDBC抽象。</li>
<li><a href="http://www.jooq.org/">jOOQ</a>：基于SQL schema生成类型安全代码。</li>
<li><a href="https://github.com/facebook/presto">Presto</a>：针对大数据的分布式SQL查询引擎。</li>
<li><a href="http://www.querydsl.com/">Querydsl</a>：针对Java的类型安全统一查询。</li>
</ul>
<h2 id="日期和时间">日期和时间</h2>
<p>处理日期和时间的函数库。</p>
<ul>
<li><a href="http://www.joda.org/joda-time/">Joda-Time</a>：Java 8出现之前，它是日期、时间处理的标准函数库。</li>
<li><a href="https://github.com/MenoData/Time4J">Time4J</a>：Java高级日期、时间函数库。</li>
</ul>
<h2 id="依赖注入">依赖注入</h2>
<p>帮助代码实现<a href="http://en.wikipedia.org/wiki/Inversion_of_control">控制反转</a>模式的函数库。</p>
<ul>
<li><a href="http://square.github.io/dagger/">Dagger</a> ：编译期的注入框架，没有使用反射，主要用于Android开发。</li>
<li><a href="https://github.com/google/guice">Guice</a>：轻量级注入框架，功能强大可与Dagger媲美。</li>
</ul>
<h2 id="开发库">开发库</h2>
<p>从基础层次上改进开发流程。</p>
<ul>
<li><a href="https://eclipse.org/aspectj/">AspectJ</a>：面向切面编程扩展，与程序无缝连接。</li>
<li><a href="https://github.com/google/auto">Auto</a>：源代码生成器集合。</li>
<li><a href="http://ssw.jku.at/dcevm/">DCEVM</a>：通过修改JVM，在运行时可无限次重定义已加载的类。OpenJDK 7、8已提供支持，详情可查看<a href="http://dcevm.github.io/">这个分支（fork）</a>。</li>
<li><a href="http://zeroturnaround.com/software/jrebel/">JRebel</a>：商用软件，无需重新部署可即时重新加载代码及配置。</li>
<li><a href="http://projectlombok.org/">Lombok</a>：代码生成器，旨在减少Java冗余代码。</li>
<li><a href="https://github.com/Netflix/RxJava">RxJava</a>：使用JVM中可观察序列，创建异步、基于事件应用程序的函数库。</li>
<li><a href="https://github.com/spring-projects/spring-loaded">Spring Loaded</a>：另一个JVM类重载代理。</li>
<li><a href="http://vertx.io/">vert.x</a>：JVM多语言事件驱动应用框架。</li>
</ul>
<h2 id="分布式应用">分布式应用</h2>
<p>用来开发分布式、具有容错性应用程序的函数库和框架。</p>
<ul>
<li><a href="http://akka.io/">Akka</a>：构建并发、分布式和具有容错功能的事件驱动应用程序所需的工具包和运行时。</li>
<li><a href="http://storm.incubator.apache.org/">Apache Storm</a>：分布式实时计算系统。</li>
<li><a href="http://zookeeper.apache.org/">Apache ZooKeeper</a>：为大型分布式系统，使用分布式配置、同步和命名注册提供协调服务。</li>
<li><a href="http://hazelcast.org/">Hazelcast</a>：分布式、高可扩展性内存网格。</li>
<li><a href="https://github.com/Netflix/Hystrix">Hystrix</a>：为分布式系统提供延迟和容错处理。</li>
<li><a href="http://www.jgroups.org/">JGroups</a>：一组提供可靠消息传输的工具包，可用来创建集群。集群中的节点可互相发送消息。</li>
<li><a href="http://www.paralleluniverse.co/quasar/">Quasar</a>：为JVM提供轻量级线程和Actor。</li>
</ul>
<h2 id="发布">发布</h2>
<p>使用本机格式分发Java应用程序的工具。</p>
<ul>
<li><a href="https://bintray.com/">Bintray</a>：对二进制发布进行版本控制，可与Maven或Gradle配合使用。</li>
<li><a href="http://izpack.org/">IzPack</a>：为跨平台部署建立授权工具。</li>
<li><a href="http://launch4j.sourceforge.net/">Launch4j</a>：将JAR包装为小巧的Windows可执行文件。</li>
<li><a href="https://github.com/libgdx/packr#packr">packr</a>：将程序JAR、资源和JVM打包成Windows、Linux和Mac OS X的本机文件。</li>
</ul>
<h2 id="文档处理">文档处理</h2>
<p>用来处理Office格式文档的函数库。</p>
<ul>
<li><a href="http://poi.apache.org/">Apache POI</a>：支持OOXML （XLSX、DOCX、PPTX）以及 OLE2 （XLS, DOC or PPT）格式的文档。</li>
<li><a href="http://www.jopendocument.org/">jOpenDocument</a>：处理OpenDocument格式文档。</li>
</ul>
<h2 id="游戏开发">游戏开发</h2>
<p>游戏开发框架。</p>
<ul>
<li><a href="http://jmonkeyengine.org/">jMonkeyEngine</a>：支持现代3D开发的游戏引擎。</li>
<li><a href="http://libgdx.badlogicgames.com/">libGDX</a>：全面的跨平台高级开发框架。</li>
<li><a href="http://lwjgl.org/">LWJGL</a>：抽象了OpenGL、CL、AL等函数库的健壮框架。</li>
</ul>
<h2 id="gui">GUI</h2>
<p>用来创建现代图形用户界面的函数库。</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">JavaFX</a>：Swing的继承者。</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/javafxscenebuilder-info-2157684.html">Scene Builder</a>：JavaFX虚拟布局工具。</li>
</ul>
<h2 id="高性能">高性能</h2>
<p>与高性能计算有关的资源，包括集合以及很多具体功能的函数库。</p>
<ul>
<li><a href="http://lmax-exchange.github.io/disruptor/">Disruptor</a>：线程间消息函数库。</li>
<li><a href="http://fastutil.di.unimi.it/">fastutil</a>：快速紧凑的Java类型安全集合。</li>
<li><a href="https://github.com/goldmansachs/gs-collections">GS Collections</a>：受Smalltalk启发的集合框架。</li>
<li><a href="https://github.com/OpenHFT/hftc">hftc</a>：Hash set和hash map。</li>
<li><a href="http://labs.carrotsearch.com/hppc.html">HPPC</a>：基本类型集合。</li>
<li><a href="http://javolution.org/">Javolution</a>：针对实时嵌入式系统的函数库。</li>
<li><a href="http://trove.starlight-systems.com/">Trove</a>：基本类型集合。</li>
</ul>
<h2 id="ide">IDE</h2>
<p>视图简化开发的集成开发环境。</p>
<ul>
<li><a href="http://www.eclipse.org/">Eclipse</a>：后台做了很多工作，以其丰富插件著称。</li>
<li><a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>：支持很多JVM语言，为Android开发提供了很多不错的选项。其商业版本主要面向企业用户。</li>
<li><a href="https://netbeans.org/">NetBeans</a>：集成了很多Java SE和Java EE特性，包括数据库访问、服务器、HTML5以及AngularJS。</li>
</ul>
<h2 id="图像处理">图像处理</h2>
<p>用来帮助创建、评估或操作图形的函数库。</p>
<ul>
<li><a href="http://square.github.io/picasso/">Picasso</a>：Android下载图像和图像缓存函数库。</li>
<li><a href="https://github.com/zxing/zxing">ZXing</a>：多种格式的一维、二维条形码处理函数库。</li>
</ul>
<h2 id="json">JSON</h2>
<p>简化JSON处理的函数库。</p>
<ul>
<li><a href="https://code.google.com/p/google-gson/">Gson</a>：将Java对象序列化为JSON及反向操作。使用时提供了很好的性能。</li>
<li><a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a>：与GSON类似，但如果需要频繁初始化Jackson库会带来性能问题。</li>
</ul>
<h2 id="jvm和jdk">JVM和JDK</h2>
<p>目前的JVM、JDK实现。</p>
<ul>
<li><a href="https://jdk9.java.net/">JDK 9</a>：JDK 9早期访问版本。</li>
<li><a href="http://openjdk.java.net/">OpenJDK</a>：开源实现。</li>
</ul>
<h2 id="日志">日志</h2>
<p>记录应用程序的日志函数库。</p>
<ul>
<li><a href="http://logging.apache.org/log4j/">Apache Log4j 2</a>：对之前版本进行了完全重写。现在的版本具备一个强大的插件和配置架构。</li>
<li><a href="http://www.elasticsearch.org/overview/kibana/">kibana</a>：对日志进行分析并进行可视化。</li>
<li><a href="http://logback.qos.ch/">Logback</a>：Log4j原班人马作品。被证明是一个强健的日志函数库，通过Groovy提供了很多有意思的配置选项。</li>
<li><a href="http://logstash.net/">logstash</a>：日志文件管理工具。</li>
<li><a href="http://www.slf4j.org/">SLF4J</a>：日志抽象层，需要与某个具体日志框架配合使用。</li>
</ul>
<h2 id="机器学习">机器学习</h2>
<p>提供具体统计算法的工具。其算法可从数据中学习。</p>
<ul>
<li><a href="http://hadoop.apache.org/">Apache Hadoop</a>：对商用硬件集群上大规模数据存储和处理的开源软件框架。</li>
<li><a href="https://mahout.apache.org/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。</li>
<li><a href="http://spark.apache.org/">Apache Spark</a>：开源数据分析集群计算框架。</li>
<li><a href="http://0xdata.github.io/h2o/">h2o</a>：用作大数据统计的分析引擎。</li>
<li><a href="http://www.cs.waikato.ac.nz/ml/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。</li>
</ul>
<h2 id="消息">消息</h2>
<p>在客户端之间进行消息传递，确保协议独立性的工具。</p>
<ul>
<li><a href="http://activemq.apache.org/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。</li>
<li><a href="http://kafka.apache.org/">Apache Kafka</a>：高吞吐量分布式消息系统。</li>
<li><a href="http://hornetq.jboss.org/">JBoss HornetQ</a>：清晰、准确、模块化且方便嵌入的消息工具。</li>
<li><a href="https://github.com/zeromq/jeromq">JeroMQ</a>：ZeroMQ的纯Java实现。</li>
</ul>
<h2 id="其它">其它</h2>
<p>其它资源。</p>
<ul>
<li><a href="https://github.com/iluwatar/java-design-patterns">Design Patterns</a>：实现并解释了最常见的<a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8">设计模式</a>。</li>
<li><a href="https://github.com/google/jimfs">Jimfs</a>：内存文件系统。</li>
<li><a href="https://code.google.com/p/lanterna/">Lanterna</a>：类似curses的简单console文本GUI函数库。</li>
<li><a href="http://lightadmin.org/">LightAdmin</a>：可插入式CRUD UI函数库，可用于快速应用开发。</li>
<li><a href="http://metrics.codahale.com/">Metrics</a>：创建自己的软件度量或者为支持框架添加度量信息，通过JMX或HTTP进行发布或者发送到数据库。</li>
<li><a href="http://openrefine.org/">OpenRefine</a>：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。</li>
<li><a href="http://www.robovm.org/">RoboVM</a>：Java编写原生iOS应用。</li>
</ul>
<h2 id="自然语言处理">自然语言处理</h2>
<p>用来专门处理文本的函数库。</p>
<ul>
<li><a href="https://opennlp.apache.org/">Apache OpenNL</a>：处理类似分词等常见任务的工具。</li>
<li><a href="http://nlp.stanford.edu/software/corenlp.shtml">CoreNLP</a>：斯坦佛的CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。</li>
<li><a href="http://alias-i.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。</li>
<li><a href="http://mallet.cs.umass.edu/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。</li>
</ul>
<h2 id="网络">网络</h2>
<p>网络编程函数库。</p>
<ul>
<li><a href="http://netty.io/">Netty</a>：构建高性能网络应用程序开发框架。</li>
<li><a href="http://square.github.io/okhttp/">OkHttp</a> ：一个Android和Java应用的HTTP+SPDY客户端。</li>
</ul>
<h2 id="orm">ORM</h2>
<p>处理对象持久化的API。</p>
<ul>
<li><a href="https://www.eclipse.org/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。</li>
<li><a href="http://hibernate.org/orm/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。</li>
<li><a href="http://ebean-orm.github.io/">Ebean</a>：支持快速数据访问和编码的ORM框架。</li>
</ul>
<h2 id="pdf">PDF</h2>
<p>用来帮助创建PDF文件的资源。</p>
<ul>
<li><a href="http://xmlgraphics.apache.org/fop/">Apache FOP</a>：从XSL-FO创建PDF。</li>
<li><a href="http://pdfbox.apache.org/">Apache PDFBox</a>：用来创建和操作PDF的工具集。</li>
<li><a href="http://dynamicreports.org/">DynamicReports</a>：JasperReports的精简版。</li>
<li><a href="http://itextpdf.com/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。</li>
<li><a href="http://community.jaspersoft.com/project/jasperreports-library">JasperReports</a>：一个复杂的报表引擎。</li>
</ul>
<h2 id="rest框架">REST框架</h2>
<p>用来创建RESTful 服务的框架。</p>
<ul>
<li><a href="https://dropwizard.github.io/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。</li>
<li><a href="https://jersey.java.net/">Jersey</a>：JAX-RS参考实现。</li>
<li><a href="http://resteasy.jboss.org/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。</li>
<li><a href="http://square.github.io/retrofit/">Retrofit</a>：一个Java类型安全的REST客户端。</li>
<li><a href="http://www.sparkjava.com/">Spark</a>：受到Sinatra启发的Java REST框架。</li>
<li><a href="https://helloreverb.com/developers/swagger">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。</li>
</ul>
<h2 id="科学">科学</h2>
<p>用于科学计算和分析的函数库。</p>
<ul>
<li><a href="http://jwork.org/scavis/">SCaVis</a>：用于科学计算、数据分析和数据可视化环境。</li>
</ul>
<h2 id="搜索">搜索</h2>
<p>文档索引引擎，用于搜索和分析。</p>
<ul>
<li><a href="http://lucene.apache.org/solr/">Apache Solr</a> ：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。</li>
<li><a href="http://www.elasticsearch.org/">Elasticsearch</a>：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。</li>
</ul>
<h2 id="安全">安全</h2>
<p>用于处理安全、认证、授权或会话管理的函数库。</p>
<ul>
<li><a href="http://shiro.apache.org/">Apache Shiro</a>：执行认证、授权、加密和会话管理。</li>
<li><a href="http://cryptomator.org/">Cryptomator</a>：在云上进行客户端跨平台透明加密。</li>
<li><a href="http://keycloak.jboss.org/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。</li>
<li><a href="http://picketlink.org/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。</li>
<li><a href="http://projects.spring.io/spring-security/">Spring Security</a>：专注认证、授权和多维度攻击防护框架。</li>
</ul>
<h2 id="序列化">序列化</h2>
<p>用来高效处理序列化的函数库。</p>
<ul>
<li><a href="https://github.com/google/flatbuffers">FlatBuffers</a>：序列化函数库，高效利用内存，无需解包和解析即可高效访问序列化数据。</li>
<li><a href="https://github.com/EsotericSoftware/kryo">Kryo</a>：快速和高效的对象图形序列化框架。</li>
<li><a href="https://github.com/msgpack/msgpack-java">MessagePack</a>：一种高效的二进制序列化格式。</li>
</ul>
<h2 id="服务器">服务器</h2>
<p>用来部署应用程序的服务器。</p>
<ul>
<li><a href="http://tomcat.apache.org/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。</li>
<li><a href="http://tomee.apache.org/">Apache TomEE</a>：Tomcat加Java EE。</li>
<li><a href="https://glassfish.java.net/">GlassFish</a>：Java EE开源参考实现，由Oracle资助开发。</li>
<li><a href="http://www.eclipse.org/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。</li>
<li><a href="http://www.wildfly.org/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。</li>
</ul>
<h2 id="模版引擎">模版引擎</h2>
<p>对模板中表达式进行替换的工具。</p>
<ul>
<li><a href="http://velocity.apache.org/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。</li>
<li><a href="http://freemarker.org/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。</li>
<li><a href="http://jknack.github.io/handlebars.java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。</li>
<li><a href="https://jsp.java.net/">JavaServer Pages</a>：通用网站模板，支持自定义标签库。</li>
<li><a href="http://www.thymeleaf.org/">Thymeleaf</a>：旨在替换JSP，支持XML文件。</li>
</ul>
<h2 id="测试">测试</h2>
<p>测试内容从对象到接口，涵盖性能测试和基准测试工具。</p>
<ul>
<li><a href="http://jmeter.apache.org/">Apache JMeter</a>：功能性测试和性能评测。</li>
<li><a href="http://arquillian.org/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。</li>
<li><a href="http://joel-costigliola.github.io/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。</li>
<li><a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>：JVM微基准测试工具。</li>
<li><a href="http://junit.org/">JUnit</a>：通用测试框架。</li>
<li><a href="http://code.google.com/p/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。</li>
<li><a href="http://docs.seleniumhq.org/">Selenium</a>：为Web应用程序提供可移植软件测试框架。</li>
<li><a href="http://selenide.org/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。</li>
<li><a href="http://testng.org/">TestNG</a> ：测试框架。</li>
<li><a href="http://visualvm.java.net/">VisualVM</a>：提供可视化方式查看运行中的应用程序信息。</li>
</ul>
<h2 id="工具类">工具类</h2>
<p>通用工具类函数库。</p>
<ul>
<li><a href="http://commons.apache.org/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。</li>
<li><a href="http://code.google.com/p/guava-libraries/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。</li>
<li><a href="http://www.javatuples.org/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。</li>
</ul>
<h2 id="网络爬虫">网络爬虫</h2>
<p>用于分析网站内容的函数库。</p>
<ul>
<li><a href="http://nutch.apache.org/">Apache Nutch</a> ：可用于生产环境的高度可扩展、可伸缩的网络爬虫。</li>
<li><a href="https://code.google.com/p/crawler4j/">Crawler4j</a>：简单的轻量级爬虫。</li>
<li><a href="http://jsoup.org/">JSoup</a> ：刮取、解析、操作和清理HTML。</li>
</ul>
<h2 id="web框架">Web框架</h2>
<p>用于处理Web应用程序不同层次间通讯的框架。</p>
<ul>
<li><a href="http://tapestry.apache.org/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。</li>
<li><a href="http://wicket.apache.org/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。</li>
<li><a href="http://www.gwtproject.org/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP API、JUnit集成、国际化支持和GUI控件。</li>
<li><a href="https://grails.org/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。</li>
<li><a href="http://www.playframework.com/">Play</a>： 使用约定而非配置，支持代码热加载并在浏览器中显示错误。</li>
<li><a href="http://primefaces.org/">PrimeFaces</a>：JSF框架，提供免费版和带技术支持的商业版。包含一些前端组件。</li>
<li><a href="http://projects.spring.io/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。</li>
<li><a href="http://projects.spring.io/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。</li>
<li><a href="https://vaadin.com/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。</li>
<li><a href="http://www.ninjaframework.org/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。</li>
<li><a href="http://www.ratpack.io/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。</li>
</ul>
<h2 id="资源">资源</h2>
<h2 id="社区">社区</h2>
<p>活跃的讨论区。</p>
<ul>
<li><a href="http://www.reddit.com/r/java">r/java</a>：Java社区的Subreddit。</li>
<li><a href="http://stackoverflow.com/questions/tagged/java">stackoverflow</a>：问答平台。</li>
</ul>
<h2 id="有影响的书籍">有影响的书籍</h2>
<p>具有广泛影响且值得阅读的Java经典书籍。</p>
<ul>
<li><a href="http://www.amazon.cn/gp/product/0321356683/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0321356683&amp;linkCode=as2&amp;tag=vastwork-23">Effective Java (2nd Edition)</a></li>
<li><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency in Practice</a> | <a href="http://www.amazon.cn/gp/product/B0077K9XHW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0077K9XHW&amp;linkCode=as2&amp;tag=vastwork-23">Java并发编程实战</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011C3CVA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011C3CVA&amp;linkCode=as2&amp;tag=vastwork-23">Thinking in Java</a> | <a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=vastwork-23">中文版</a></li>
</ul>
<h2 id="播客">播客</h2>
<p>可以一边编程一边听的东西。</p>
<ul>
<li><a href="http://www.javaposse.com/">The Java Posse</a></li>
</ul>
<h2 id="twitter">Twitter</h2>
<p>值得关注的帐号。</p>
<ul>
<li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li>
<li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。</li>
<li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li>
<li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li>
<li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li>
<li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li>
<li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li>
<li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li>
<li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li>
<li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li>
<li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li>
<li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li>
<li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li>
<li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li>
<li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li>
<li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li>
<li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li>
<li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li>
<li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li>
<li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li>
<li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li>
<li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li>
</ul>
<h2 id="网站">网站</h2>
<p>值得阅读的网站。</p>
<ul>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a></li>
<li><a href="http://www.infoq.com/">InfoQ</a></li>
<li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li>
<li><a href="http://java.net/">Java.net</a></li>
<li><a href="http://java.dzone.com/">Javalobby</a></li>
<li><a href="http://www.javaworld.com/">JavaWorld</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li>
<li><a href="http://www.javaspecialists.eu/archive/archive.jsp">The Java Specialist’ Newsletter</a></li>
<li><a href="http://www.theserverside.com/">TheServerSide.com</a></li>
<li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li>
<li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在自己的应用中加入支付功能]]></title>
        <id>https://kangjn.github.io/post/zai-zi-ji-de-ying-yong-zhong-jia-ru-zhi-fu-gong-neng/</id>
        <link href="https://kangjn.github.io/post/zai-zi-ji-de-ying-yong-zhong-jia-ru-zhi-fu-gong-neng/">
        </link>
        <updated>2021-04-25T05:31:20.000Z</updated>
        <content type="html"><![CDATA[<p>在自己的应用中如何加入对支付功能的支持。</p>
<p><strong>1、项目名称：龙果支付系统 roncoo-pay</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/047554.jpg" alt="1561286741806047554" loading="lazy"></figure>
<p>**项目简介：**龙果支付系统核心目标是汇聚所有主流支付渠道，打造一款轻量、便捷、易用，且集支付、资金对账、资金清结算于一体的支付系统，满足互联网业务系统的收款和业务资金管理需求。</p>
<p>主要特点：</p>
<ul>
<li>具备支付系统通用的支付、对账、清算、资金账户管理、支付订单管理等功能；</li>
<li>目前已接通“支付宝即时到账”和“微信扫码支付”通道；</li>
<li>支持直连和间连两种支付模式，任君选择；</li>
<li>通过支付网关，业务系统可以轻松实现统一支付接入；</li>
<li>搭配运营后台，支付数据的监控和管理可以兼得；</li>
<li>配套完善的系统使用文档，可轻松嵌入任何需要支付的场景；</li>
</ul>
<p>**项目地址：**https://gitee.com/roncoocom/roncoo-pay</p>
<p><strong>2、项目名称：聚合支付系统 XxPay</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/025826.jpg" alt="" loading="lazy"></figure>
<p>**项目简介：**XxPay 聚合支付使用 Java 开发，包括spring-cloud、dubbo、spring-boot三个架构版本，已接入微信、支付宝等主流支付渠道，可直接用于生产环境。</p>
<p>目前已经接入支付渠道：微信(公众号支付、扫码支付、APP支付、H5支付)、支付宝(电脑网站支付、手机网站支付、APP支付、当面付)。</p>
<p>**项目地址：**https://gitee.com/jmdhappy/xxpay-master</p>
<p><strong>3、项目名称：常用支付接口 IJPay</strong></p>
<p>**项目简介：**IJPay 封装了微信支付、支付宝支付、银联支付常用的支付方式以及各种常用的接口。不依赖任何第三方 mvc 框架，仅仅作为工具使用简单快速完成支付模块的开发，可轻松嵌入到任何系统里。</p>
<p><strong>项目地址：https://gitee.com/javen205/IJPay</strong></p>
<p><strong>4、项目名称：基于 Java 的支付开发工具包</strong></p>
<p>**项目简介：**优雅的轻量级支付模块，集成微信支付、支付宝、银联、友店、富友、跨境支付等。付与业务完全剥离，简单几行代码即可实现支付，简单快速完成支付模块的开发，可轻松嵌入到任何系统里。</p>
<p>目前仅是一个开发工具包（即SDK），只提供简单 Web 实现，建议使用 maven 或 gradle 引用本项目即可使用本 SDK 提供的各种支付相关的功能。</p>
<p>**项目地址：**https://gitee.com/egzosn/pay-java-parent</p>
<p><strong>5、项目名称：轻量级支付系统 Fastpay</strong></p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/087807.jpg" alt="" loading="lazy"></figure>
<p>**项目简介：**Fastpay 的目标是打造一款开源的、轻量级的、微服务化的、可共私有云部署的、可定制化的集成聚合支付和资金清结算于一体的统一支付系统，满足互联网企业业务系统的收款和资金处理等需求。</p>
<ul>
<li>在支付系统上实施微服务架构，使用最流行的Spring Cloud做服务化。</li>
<li>设计天生可伸缩的数据存储，直接使用分库分表。</li>
<li>使用缓存进行加速交易过程，提高用户体验。</li>
<li>将回调通知、入账等异步化，提高用户响应能力。</li>
<li>使用分布式定时任务系统将任务调度与交易隔离。</li>
<li>使用当前最先进的单元化架构实现可水平伸缩。</li>
</ul>
<p>**项目地址：**https://gitee.com/robertleepeak/fastpay</p>
<p><strong>6、项目名称：支付 SDK 扩展包 easyPay</strong></p>
<p>**项目简介：**本项目根据支付宝、微信最新 API 开发而成，高度抽象的类，免去各种拼 json 与 xml 的痛苦；符合 PSR  标准，你可以各种方便的与你的框架集成；文件结构清晰易理解，可以随心所欲添加本项目中没有的支付网关；方法使用更优雅，不必再去研究那些奇怪的的方法名或者类名是做啥用的。</p>
<p>**项目地址：**https://gitee.com/yansongda/pay</p>
<p><strong>7、项目名称：互联网金融支付系统 aaden-pay</strong></p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/024867.jpg" alt="" loading="lazy"></figure>
<p>**项目简介：**基于互联网金融理财环境下产生的支付系统，特点为：</p>
<ul>
<li>同卡进出，用户先实名绑定银行卡，后交易，不支持手机扫码交易。</li>
<li>提供统一的支付框架，只需少量代码就可快速接入新渠道，提供一个稳定的支付解决方法，节约程序员时间。</li>
</ul>
<p>**项目地址：**https://gitee.com/aaden/aaden-pay</p>
<p><strong>8、项目名称：基于 PHP 的支付 SDK</strong></p>
<p>**项目简介：**Payment 是一个 PHP 版本的支付聚合第三方 SDK，集成了微信支付、支付宝支付、招商一网通支付。提供统一的调用接口，方便快速接入各种支付、查询、退款、转账能力。</p>
<p>**项目地址：**https://gitee.com/helei112g/payment</p>
<p><strong>9、项目名称：基于 .NET Core 的支付 SDK 集</strong></p>
<p>**项目简介：**本项目是基于 .NET Core / ASP.NET Core 开发的跨平台支付 SDK 集，简化了 API 调用及相关通知的处理流程。</p>
<p>目前支持：支付宝(Alipay)、微信支付(WeChatPay)、QQ钱包(QPay)、京东支付(JDPay)、连连支付(LianLianPay)、银联支付(UnionPay)。</p>
<p>**项目地址：**https://gitee.com/Essensoft/Payment</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VS code中提交项目到码云]]></title>
        <id>https://kangjn.github.io/post/zai-vs-code-zhong-ti-jiao-xiang-mu-dao-ma-yun/</id>
        <link href="https://kangjn.github.io/post/zai-vs-code-zhong-ti-jiao-xiang-mu-dao-ma-yun/">
        </link>
        <updated>2021-04-23T05:23:04.000Z</updated>
        <content type="html"><![CDATA[<p>在VS code中提交项目</p>
<p>首先在VS code中进入到要上传的项目内，比如我的是Angular项目，就是这个样子：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/408314.png" alt="" loading="lazy"></figure>
<p>然后依次执行如下语句：<br>
初始化：<br>
git init<br>
定向到你的代码仓库：<br>
git remote add origin https://gitee.com/用户个性地址/HelloGitee.git<br>
上传并添加评论：<br>
git add .<br>
git commit -m &quot;第一次提交&quot;<br>
git push origin master ——这里注意，如果你项目中有redme文件而且在码云网站上创建仓库时也生成了redme文件话要加上 -f</p>
<p>将代码放到码云<br>
到码云里新建一个仓库，完成后码云会有一个命令教程按上面的来就行了<br>
码云中的使用教程：</p>
<p>Git 全局设置:<br>
git config --global user.name &quot;ASxx&quot;<br>
git config --global user.email &quot;123456789@qq.com&quot;</p>
<p>创建 git 仓库:</p>
<p>mkdir wap // 项目在本地的路径<br>
cd wap<br>
git init<br>
touch README.md<br>
git add README.md<br>
git commit -m &quot;first commit&quot;<br>
git remote add origin https://git.oschina.net/name/package.git  // 远程仓库地址<br>
git push -u origin master</p>
<p>已有项目：<br>
cd existing_git_repo<br>
git remote add origin https://git.oschina.net/name/package.git<br>
git push -u origin master<br>
下面说下详细的本地操作步骤：</p>
<p><strong>1、用vs打开你的项目文件夹</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/980552.png" alt="" loading="lazy"></figure>
<p><strong>2、配置git</strong></p>
<p>打开Git Bash输入以下命令</p>
<p>如果还没输入全局配置就先把这个全局配置输入上去</p>
<p>Git 全局设置:</p>
<p>git config --global user.name &quot;ASxx&quot;<br>
git config --global user.email &quot;123456789@qq.com&quot;</p>
<p>然后开始做提交代码到码云的配置<br>
cd d:/wamp/www/mall360/wap              //首先指定到你的项目目录下<br>
git init<br>
touch README.md<br>
git add README.md<br>
git commit -m &quot;first commit&quot;<br>
git remote add origin https://git.oschina.net/name/package.git   //用你仓库的url<br>
git push -u origin master  //提交到你的仓库<br>
正常情况下上面的命令执行完成后，本地文件夹会有一个隐藏的.git文件夹，云端你的仓库里应该会有一个README.md文件。</p>
<ul>
<li><strong>3、在vscode中提交代码到仓库</strong></li>
</ul>
<p>回到vs code打开git工作区就会看到所有代码显示在这里</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/939768.png" alt="img" loading="lazy"></figure>
<p>点击+号，把所有文件提交到暂存区。</p>
<p>然后打开菜单选择--提交已暂存的</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/104252.png" alt="img" loading="lazy"></figure>
<p>然后按提示随便在消息框里输入一个消息，再按ctrl+enter提交</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/778020.png" alt="img" loading="lazy"></figure>
<p>然后把所有暂存的代码push云端，</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/866213.png" alt="img" loading="lazy"></figure>
<p>点击后，会弹出让你输入账号密码，把你托管平台的账号密码输入上去就行了。。。</p>
<p>不出问题的话你整个项目就会提交到云端上了。</p>
<p>在vs中每次更新代码都会要输入账号密码，方便起见，可以配置一下让GIT记住密码账号。</p>
<pre><code>git config --global credential.helper store   //在Git Bash输入这个命令就可以了
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[刻在骨子里的“教养”]]></title>
        <id>https://kangjn.github.io/post/ke-zai-gu-zi-li-de-jiao-yang/</id>
        <link href="https://kangjn.github.io/post/ke-zai-gu-zi-li-de-jiao-yang/">
        </link>
        <updated>2021-04-22T09:24:25.000Z</updated>
        <content type="html"><![CDATA[<p>不责人小过，不发人阴私，不念人旧恶。<br>
前苏联教育家苏霍姆林斯基曾说：</p>
<p>“在人类心灵的花园中，最质朴、最美丽和最平凡的花朵，是人的教养。”</p>
<p>那什么是教养？</p>
<p>教养是一个人文化品德的修养，是一个人从小就习得的一种规矩，是待人接物处事的一种敬重态度。</p>
<p>丰一吟在《回忆父亲丰子恺》中说：<br>
“生而养之，养而教之。教养，是一个家庭传承给孩子的最好礼物。”</p>
<p>【01】教养，是教育和养成。</p>
<p>教养，是教育和养成，是文化的传承和后天学习的规范。</p>
<p>一个人的教养，不是先天就拥有的，而是后天的学习教育和周身氛围所养成的良好品质和行为习惯，是经过人生历练和修行所沉淀下的德性。</p>
<p>当我们呱呱坠地，生而一张白纸，往后一生的精彩都由自己去涂鸦，而一个人的教养则以自身的学习和规范养成的。</p>
<p>人都说父母是孩子的第一任老师，而家庭是孩子成长的摇篮。</p>
<p>家庭环境是孩子健康成长的基本因素，而父母的品行更是影响孩子的教养。</p>
<p>《三字经》中言，养不教，父之过；教不严，师之惰，人若没有教养，便是父母老师的不称职。</p>
<p>“昔孟母，择邻处”只为孩子远离那些不良因素，为其创造一个良好的教育环境。</p>
<p>胡适先生回忆母亲时曾说：“如果我学得了一丝一毫的好脾气，如果我学得了一点点待人接物的和气，如果我能宽恕人，体谅人——我都得感谢我的慈母。”</p>
<p>可见，自身所处的家庭氛围与父母的品行和行为举止，都会在生活中慢慢渗透于孩子的品行和教养中。</p>
<p>英国切斯特菲尔德说：</p>
<p>“所谓良好教养，它们在几乎所有国家中乃至于一个地区里，都不尽相同；每一个明辨事理的人都会模仿他所在之地的良好教养，并与之看齐。”</p>
<p>正所谓：“玉不琢，不成器；人不学，不知义。”</p>
<p>人要明辨是非就得学习，做一个品德高尚的人也要学习，而做一个有教养的人更要学习，学习端正己身，立身处世，待人接物。</p>
<p>【02】教养，是由内散发的文化修养。</p>
<p>德米特里．利哈乔夫在《论教养》中说：“良好的教养不仅来自家庭和学校，而且可以得之于自身。”</p>
<p>但是前提是必须了解，什么是真正的教养。</p>
<p>教养，是发自于内心，是以成长环境，教育基础，自身经历等所综合成一种内在素质。</p>
<p>一个人是否有教养，不止是行为上彬彬有礼，更注重于其文化内涵和道德修养。</p>
<p>其中，文化，不单单指文化学识，更是一种以行为习惯和精神价值结合成的意识。</p>
<p>作家梁晓声说：“文化是根植于内心的修养，无需自觉提醒的自觉；以约束为前提的自由；为别人着想的善良。”</p>
<p>文化修养是一种由内散发的一种气质，是从自我认知，自我教育，自我学习，且沉淀到一定程度所散发出的一股无形力量。</p>
<p>一个人有没有文化，不在于其学历高低，而是是否具有这种无形中所沉淀下来的气质修养。</p>
<p>有文化修养的人，总能发现事物中的美好和希望，更是对光明的未来充满着极大的向往。</p>
<p>【03】教养，是有别于礼貌却依托于礼貌。</p>
<p>教养，是发自于内心，是一种经过时间的磨练和规范后综合的内在品质素养，是待人处事上的行为习惯。</p>
<p>礼貌，是外在的行为，是在模仿和刻意下也能假装出来的一种谦恭有礼的行为表现，它不一定发自于内心。</p>
<p>有教养的人，总表现的很有礼貌。</p>
<p>有礼貌的的人却未必是有教养的人。</p>
<p>一个人若是金玉其外败絮其中，不能内外兼修，这样的人不是有教养，只能称其“伪君子”。</p>
<p>一个人牙尖嘴利，却背地里又做好事，我们不能说这样的人有教养，只能说其有一副好心肠，刀子嘴豆腐心。<br>
日常生活中，吵架后，我们总能听到劝架的人说：“你别跟他一般见识，他人就那样，嘴巴坏但心地善良，你也别太介意。”等等之类的。</p>
<p>但他忘了，说者无心，听者有意，伤人往往也就在那一两句话中，伤过之后便是千疮百孔。</p>
<p>“良言一句三冬暖，恶语伤人六月寒”，有教养的人不会口无遮拦，也不会以嘴毒心肠好为借口的；反之，有教养的人相处起来是舒服的。</p>
<p>歌德说：“没有一种礼貌会在外表上叫人一眼就看出教养的不足，正确的教养在于使外表上的彬彬有礼和人的高尚的教养同时表现出来。”</p>
<p>【04】教养，是自我的约束和将心比心。</p>
<p>《菜根谭》：“有教养的人，不责人小过，不发人阴私，不念人旧恶。”</p>
<p>有教养的人不责难别人的小过错，不随便揭露别人的隐私，不念叨别人过去的坏处。</p>
<p>教养，体现于细节。</p>
<p>它不是看笑话，更不是让别人感到难堪或轻视。</p>
<p>洛克说：“教养的本质是在交往中对于任何人不表示任何轻视或侮蔑。”</p>
<p>有教养的人，不会让别人觉着尴尬困窘，在冒犯了他人后，懂得及时反省自身以及调整自己的行为。</p>
<p>当你在图书馆看书时，你可以选择自己喜欢的去看，但不能大声喧哗，这是你的个人教养。</p>
<p>当公共区域有人休息时，你不能总弄出动静，影响他人。不然这就是你素质低，没教养了。</p>
<p>一个人是否拥有最高级的教养，就看他懂不懂顾忌别人的感受，懂不懂将心比心，会不会让与之交往的人感到亲切舒适和满足。</p>
<p>格里美尔斯豪森言道：“没有教养、没有学识、没有实践的人的心灵好比一块田地，这块田地即使天生肥沃，但倘若不经耕耘和播种，也是结不出果实来的”</p>
<p>一个人的教养，是他立足社会的根基。</p>
<p>内在的修养让人吸引着志同道合的人，外在的行为礼仪拉近彼此距离，而内外兼修的教养，是稳固所有关系的壁垒。</p>
<p>教养是人生的一大课题，需要我们用一生的时间都去研修。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务拆分]]></title>
        <id>https://kangjn.github.io/post/wei-fu-wu-chai-fen/</id>
        <link href="https://kangjn.github.io/post/wei-fu-wu-chai-fen/">
        </link>
        <updated>2021-04-22T09:04:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-拆分"><strong>一、拆分</strong></h3>
<p>**1、新浪微博微服务从纵横两个维度来划分，简单粗暴：</p>
<p><strong>1.1 纵向拆分</strong></p>
<p>从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p><strong>1.2 横向拆分</strong></p>
<p>从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<p>纵向以业务为基准，关系铁的在一起；横向功能独立的在一起。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/115502.png" alt="img" loading="lazy"></figure>
<p><strong>2.1 服务拆分要迎合业务的需要</strong></p>
<p>充分考虑业务独立性和专业性，避免以团队来定义服务边界，从而出现“土匪”抢地盘，影响团队信任。</p>
<p>这个维度和上面的类似，但是强调的是业务和团队成员的各自独立性，对上面是一种很好的补充。</p>
<p><strong>2.2 拆分后的维护成本要低于拆分前</strong></p>
<p>这里的维护成本包括：人力、物力、时间。</p>
<p>这里的成本对大部分中小团队来说都是必须要考虑的重要环节，如果投入和收益不能成正比，或者超出领导的预算或者市场窗口，那么先进的技术就是绊脚石，千万不要迷恋技术，所谓工程师思维千万要不得。</p>
<p><strong>2.3 拆分不仅仅是架构的调整，组织结构上也要做响应的适应性优化</strong></p>
<p>确保拆分后的服务由相对独立的团队负责维护。</p>
<p>这句话怎么理解呢？传统的团队划分是按照产品部、前端、后端横向划分，微服务化以后的团队可能就会是吃一张披萨饼的人数，产品、前端、后端被归类到服务里面，以服务为中心来分配人数。</p>
<p>把具有不同扩展性要求的服务拆分出来，分别进行部署，降低成本，提高效率。比如全文搜索服务。</p>
<p>这点和上面的按功能独立性来拆分有点类似，功能独立其实就是面向可扩展性。</p>
<p><strong>2.5 考虑软件发布频率</strong></p>
<p>比如把20%经常变动的部分进行抽离，80%不经常变动的单独部署和管理。说白了就是按照8/2原则进行拆分。这个拆分的好处很明显，可以尽可能的减少发布产生的后遗症，比如用户体验、服务相互干扰等。</p>
<p>但是这里有一个问题，假如20%的服务分属于不同的业务层面，那该怎么办？所以这里的拆分应该有个优先级，在拆分相互冲突的时候应该要优先考虑权重比较高的那个。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/303502.png" alt="img" loading="lazy"></figure>
<p>**3、另一种拆分：</p>
<p><strong>3.1 基于业务逻辑</strong></p>
<p>将系统中的业务按照职责范围进行识别，职责相同的划分为一个单独的服务。这种业务优先的方式在前面两种姿势当中都出现过，可见是最基本，最重要的划分方式（没有之一）。</p>
<p><strong>3.2 基于稳定性</strong></p>
<p>将系统中的业务模块按照稳定性进行排序。稳定的、不经常修改的划分一块；将不稳定的，经常修改的划分为一个独立服务。比如日志服务、监控服务都是相对稳定的服务，可以归到一起。这个很类似上面提到的2/8原则，80%的业务是稳定的。</p>
<p>至此你会发现服务的拆分真的没有绝对的标准，只有合理才是标准。</p>
<p><strong>3.3 基于可靠性</strong></p>
<p>同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求比较高的核心模块归在一起，对可靠性要求不高的非核心模块归在一块。</p>
<p>这种拆分的高明可以很好的规避因为一颗老鼠屎坏了一锅粥的单体弊端，同时将来要做高可用方案也能很好的节省机器或带宽的成本。</p>
<p><strong>3.4 基于高性能</strong></p>
<p>同上，将系统中的业务模块按照对性能的要求进行优先级排序。把对性能要求较高的模块独立成一个服务，对性能要求不高的放在一起。比如全文搜索，商品查询和分类，秒杀就属于高性能的核心模块。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/457502.png" alt="img" loading="lazy"></figure>
<p><strong>4、盘点</strong></p>
<p>以上不同拆分各有千秋，异曲同工！</p>
<ul>
<li>对业务逻辑均不约而同的放在第一位。</li>
<li>对业务模块的稳定性和可靠性，对功能的独立性、可扩展性都有相似的看法</li>
<li>强调拆分应该是多选，而不是单选。具体情况具体分析，可以自由灵活排列组合。</li>
</ul>
<h3 id="二-题外话">**二、题外话</h3>
<p>如果你把上面的划分角度背下来了拿去现场套，可能还会遇到矛盾或争议。</p>
<p><strong>1、业务矛盾</strong></p>
<p>假如我们按照业务来划分，根据粒度大小，可能存在以下两种：</p>
<ul>
<li>第一种分为商品、交易、用户3个服务；</li>
<li>第二种分为商品、订单、支付、物流、买家、卖家6个服务。</li>
</ul>
<p>3 VS 6，这该怎么办？</p>
<p>如果你的团队只有9个人，那么分成3个是合理的，如果有18个人，那么6个服务是合理的。这里引入团队成员进行协助拆分。</p>
<p>可见拆分的姿势不是单选，而是多选的。这个时候必须要考虑团队成员数量。</p>
<p>在拆分遇到争议的时候，一般情况下我们增加一项拆分条件，虽然不是充要条件，但至少我们的答案会更加接近真理。</p>
<p>除了业务可能存在争议，其他的划分也会有争议，比如一个独立的服务到底需要多少人员的配置？</p>
<p><strong>2、三个火枪手(人员配置)</strong></p>
<p>上面提到的人员数量配置，这里为什么是9和18呢？(这里的团队配置参考李云华前辈提到的三个火枪手的观点)</p>
<p>换一种问法，为什么说是三个人分配一个服务（当然，成员主要是后端人员）？</p>
<ul>
<li>假设是1个人，请个假、生个病都不行。一个人会遇到单点的问题，所以不合理。</li>
<li>假设是2个人，终于有备份了，但是抽离一个后，剩下1个压力还是很大，不合理。</li>
<li>假设是3个人，抽离一个还有2个在。而且数字3是个稳定而神奇数字，用得好事半功倍。特别是遇到技术讨论，3个人相对周全，如果是2个可能会各持己见，带有自我的偏见和盲区。</li>
</ul>
<p>那么这个3是不是就是稳定的数量呢？</p>
<p>假设你做的是边开飞机边换引擎的重写工作，那么前期3个人都可能捉襟见肘。但是到了服务后期，你可能1个就够了。</p>
<p>所以3在我的理解应该是一个基准线，不同的时间段会有上下波动，但是相对稳定。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一份微服务架构手稿图]]></title>
        <id>https://kangjn.github.io/post/yi-fen-wei-fu-wu-jia-gou-shou-gao-tu/</id>
        <link href="https://kangjn.github.io/post/yi-fen-wei-fu-wu-jia-gou-shou-gao-tu/">
        </link>
        <updated>2021-04-22T08:26:56.000Z</updated>
        <content type="html"><![CDATA[<p>什么是微服务？</p>
<p>微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下：</p>
<p>就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。</p>
<p>但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。</p>
<p>服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。</p>
<p>另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>
<p>根据马丁.福勒的描述，我总结了以下几点：</p>
<figure data-type="image" tabindex="1"><a href="http://img.javastack.cn/1590629991746502.png"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/746502.png" alt="img" loading="lazy"></a></figure>
<p><strong>①小服务</strong></p>
<p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p>
<p><strong>②进程独立</strong></p>
<p>每一组服务都是独立运行的，可能我这个服务运行在 Tomcat 容器，而另一个服务运行在 Jetty 上。可以通过进程方式，不断的横向扩展整个服务。</p>
<p><strong>③通信</strong></p>
<p>过去的协议都是很重的，就像 ESB，就像 SOAP，轻通信，这意味着相比过去更智能更轻量的服务相互调用，就所谓 smart endpoints and dumb pipes。</p>
<p>这些 Endpoint 都是解耦的，完成一个业务通信调用串起这些 Micro Service 就像是 Linux 系统中通过管道串起一系列命令业务。</p>
<p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p>
<p><strong>④部署</strong></p>
<p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维职责。</p>
<p><strong>⑤管理</strong></p>
<p>传统的企业级 SOA 服务往往很大，不易于管理，耦合性高，团队开发成本比较大。</p>
<p>微服务，可以让团队各思其政的选择技术实现，不同的 Service 可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p>
<h2 id="微服务的利与弊">微服务的利与弊</h2>
<p>为什么用微服务呢？因为好玩？不是的。下面是我从网络上找到说的比较全的优点：</p>
<ul>
<li>优点是每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。</li>
<li>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。</li>
<li>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins，Hudson，bamboo。</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。</li>
<li>微服务只是业务逻辑的代码，不会和 HTML，CSS 或其他界面组件混合。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库。</li>
</ul>
<p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p>
<p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p>
<h2 id="什么组织适合使用微服务">什么组织适合使用微服务？</h2>
<p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务？</p>
<p>①墨菲定律（设计系统）和康威定律（系统划分）<br>
康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p>
<blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these  organizations.</p>
<p>-Melvin Conway(1967)</p>
</blockquote>
<p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</p>
<figure data-type="image" tabindex="2"><a href="http://img.javastack.cn/1590629991985502.png"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/985502.png" alt="img" loading="lazy"></a></figure>
<p>②架构演化</p>
<p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。[淘宝千万并发，14 次架构演进]，推荐大家看下。</p>
<p>[<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/233502.png" alt="img" loading="lazy">]</p>
<p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。</p>
<p>我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/387502.png" alt="img" loading="lazy"></figure>
<p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用 API 方式发布他们的功能，而平台使用他们的功能发布产品。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/717502.png" alt="img" loading="lazy"></figure>
<h2 id="微服务技术架构体系">微服务技术架构体系</h2>
<p>下面我分享一下大部分公司都使用的微服务技术架构体系：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/956502.png" alt="img" loading="lazy"></figure>
<h3 id="服务发现">服务发现</h3>
<p>主流的服务发现，分为三种：</p>
<p><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/87502.jpg" alt="1590629993087502" loading="lazy">第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过 DNS 就能找到我们对应的服务。</p>
<p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/191502.jpg" alt="191502" loading="lazy"></figure>
<p>第二种，是目前普遍的做法。可以参考 Zuul 网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p>
<p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在 Spring Cloud 上的。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/640383.jpg" alt="img" loading="lazy"></figure>
<p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p>
<ul>
<li>[这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。]</li>
</ul>
<h3 id="网关">[网关]</h3>
<p>微服务的网关是什么？我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p>
<p>将生活实际联系到微服务上，就不难理解网关的意思了：</p>
<figure data-type="image" tabindex="8"><a href="http://img.javastack.cn/1590629993612502.png"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/640324.jpg" alt="img" loading="lazy"></a></figure>
<p>网关的作用如下：</p>
<ul>
<li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务调用。</li>
<li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li>
<li>限流熔断：当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题。</li>
<li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息。</li>
<li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行 A/B testing。即让一部分用户继续用产品特性 A，一部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。</li>
</ul>
<p>[开源网关 Zuul 架构：]</p>
<figure data-type="image" tabindex="9"><a href="http://img.javastack.cn/1590629993902502.png"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/640321.jpg" alt="img" loading="lazy"></a></figure>
<p>Zuul 网关核心其实是一个 Servlet，所有请求都会经过 Zuul Servlet 传到 ZuulFilter Runner，然后分发到三种过滤器。</p>
<p>先说说架构图左半部分，分别是使用 Groovy 实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p>
<p>一般请求都会先经过前置路由过滤器处理，一般的自定义 Java 封装逻辑也会在这里实现。</p>
<p>路由过滤器，实现的是找到对应的微服务进行调用。调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p>
<p>可以说 Zuul 网关最大的特色就是它的三层过滤器。是 Zuul 网关设计的自定义过滤器加载机制。</p>
<p>网关内部会有生产者消费者模型，自动的将过滤器脚本发布到 Zuul 网关读取加载运行。</p>
<h3 id="配置中心">配置中心</h3>
<p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。</p>
<p>一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p>
<p>因此就有配置中心这个喽！现在的开源中心有百度配置中心 Disconf，Spring Cloud Config，Apollo。</p>
<p>今天重点说说现在应用质量不错的配置中心，携程开源的阿波罗（Apollo）：</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/781502.png" alt="img" loading="lazy"></figure>
<p>Apollo 的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。关注微信公众号：Java技术栈，在后台回复：架构，可以获取我整理的 N 篇最新架构干货。</p>
<h3 id="通讯方式">通讯方式</h3>
<p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/516502.png" alt="img" loading="lazy"></figure>
<h3 id="监控预警">监控预警</h3>
<p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。</p>
<p>一般监控分为如下层次：</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/744502.png" alt="img" loading="lazy"></figure>
<p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。</p>
<p>总体来说，微服务可分为 5 个监控点：</p>
<ul>
<li>日志监控</li>
<li>Metrics 监控</li>
<li>健康检查</li>
<li>调用链检查</li>
<li>告警系统</li>
</ul>
<p><strong>①监控架构</strong></p>
<p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。</p>
<p>同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。关注微信公众号：Java技术栈，在后台回复：架构，可以获取我整理的 N 篇最新架构干货。</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/874502.png" alt="img" loading="lazy"></figure>
<p><strong>②调用链监控 APM</strong></p>
<p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的 Cat，大部分调用链监控（没错，我指的 Zipkin）架构是这样的：</p>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/055502.jpg" alt="055502" loading="lazy"></figure>
<p>当请求进入 Web 容器的时候，会经过创建 Tracer，连接 Spans（模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过 HTTP Headers）。</p>
<p>Spans 有一个上下文，其中包含 Tracer 标识符，将其放在表示分布式操作的树的正确位置。</p>
<p>当我们把图中的各种 Span 放到后端的时候，我们的服务调用链会动态的生成调用链。</p>
<p>下面是一些市场上用的比较多的调用链监控对比：</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/193502.jpg" alt="193502" loading="lazy"></figure>
<h3 id="熔断-隔离-限流-降级">熔断、隔离、限流、降级</h3>
<p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务或任务进行服务的延迟使用或暂停使用）措施。</p>
<p>下面介绍一下 Hystrix 的运行流程：</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/492502.png" alt="img" loading="lazy"></figure>
<p>Hystrix 停止开发，Spring Cloud 何去何从？</p>
<p>每一个微服务调用时，都会使用 Hystrix 的 Command 方式（上图的左上角那个），然后使用 Command 同步的，或者是响应式的，或者是异步的，判断电路是否熔断（顺着图从左往右看），如果断路则走降级 Fallback。</p>
<p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施（看图的第 5 步）。</p>
<p>如果走完了，执行成功了，则走 run() 方法，获取 Response，但是这个过程如果出错了，则继续走降级 Fallback。</p>
<p>同时，看图最上面有一个后缀是 Health 的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p>
<h3 id="容器与服务编排引擎">容器与服务编排引擎</h3>
<p>从物理机到虚拟机，从虚拟机到容器；从物理集群到 OpenStack，OpenStack 到 Kubernetes；科技不断的变化，我们的认知也没刷新。</p>
<p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。</p>
<p>虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。</p>
<p>虚拟机依赖于 Hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致 Hypervisor 在某些方面被认为是一种操作系统。</p>
<p>一旦 Hypervisor 安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载（应用程序）。</p>
<p>简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层 Runtime，然后供应用程序运行。</p>
<p>对于容器环境来说，不需要安装主机操作系统，直接将容器层（比如 LXC 或 Libcontainer）安装在主机操作系统（通常是 Linux 变种）之上。</p>
<p>在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。</p>
<p>但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p>
<p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味着相比于虚拟机，单个操作系统能够承载更多的容器。</p>
<p>云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p>
<p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。</p>
<p>因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p>
<p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。</p>
<p>正因为如此，容器才拥有极为出色的轻量化特性。我们最常用的容器是 Docker。</p>
<p><strong>①容器编排</strong></p>
<p>过去虚拟机可以通过云平台 OpenStack 管理虚拟化，容器时代如何管理容器呢？这就要看看容器编排引擎了。</p>
<p>Apache Mesos：Mesos 是基于 Master，Slave 架构，框架决定如何利用资源，Master 负责管理机器，Slave 会定期的将机器情况报告给 Master，Master 再将信息给框架。Master 是高可用的，因为 ZK，也有 Leader 的存在。</p>
<p>下面是架构图：</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/731502.jpg" alt="731502" loading="lazy"></figure>
<p>Kubernetes：Kubernetes 是最近十分火热的开源容器编排引擎</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/981502.jpg" alt="981502" loading="lazy"></figure>
<p>Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，先说说每一个 Kubernetes 节点内部，kubelet 管理全局全局 pod，而每一个 pod 承载着一个或多个容器，kube-proxy 负责网络代理和负载均衡。</p>
<p>Kubernetes 节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p>
<p><strong>②服务网格化</strong></p>
<p>关于服务网络化，后面会更加深入的为大家进行讲解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务介绍]]></title>
        <id>https://kangjn.github.io/post/wei-fu-wu-jie-shao/</id>
        <link href="https://kangjn.github.io/post/wei-fu-wu-jie-shao/">
        </link>
        <updated>2021-04-22T08:05:18.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>微服务是什么</strong></p>
</li>
<li>
<p><strong>为什么要采用微服务</strong></p>
</li>
<li>
<p><strong>微服务架构</strong></p>
</li>
<li>
<p><strong>架构设计模式</strong></p>
</li>
<li>
<p><strong>服务拆分</strong></p>
</li>
<li>
<p><strong>微服务框架</strong></p>
</li>
<li>
<p>架构模式有很多，微服务不是唯一的选择也不是什么银弹。</p>
</li>
<li>
<p>“你必须长的足够高才能使用微服务”。微服务基础设施，尤其是容器技术、自动化部署、自动化测试这些不完备，微服务形同虚设，不会带来什么质的提升。</p>
</li>
<li>
<p>微服务架构的关键不在于具体的实现，而在于如何合理地划分服务边界以及组织架构是否相匹配。不考虑研发团队的规模和组成就盲目上微服务是不良的技术选型。</p>
</li>
<li>
<p>Spring Boot 是 Spring 全家桶的上层封装，并不是什么崭新的技术，也不是什么值得成为自己杀手锏的技术。</p>
</li>
<li>
<p>Spring Cloud 中 Spring Cloud Netflix 的组件是经过生产环境验证的，其他的则建议慎重选择。</p>
</li>
</ul>
<p><strong>微服务是什么</strong></p>
<p>微服务起源于 2005 年 Peter Rodgers 博士在云端运算博览会提出的微 Web 服务(Micro-Web-Service)，根本思想类似于 Unix 的管道设计理念。</p>
<p>2014 年，由 Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯（HTTP API）。</p>
<p><strong>关键的三点是：</strong></p>
<ul>
<li><strong>small</strong></li>
<li><strong>automated</strong></li>
<li><strong>lightweight</strong></li>
</ul>
<p>对比 SOA，微服务可以看做是 SOA 的子集，是轻量级的 SOA，粒度更细的服务，独立进程、数据分离，更注重敏捷、持续交付、DevOps 以及去中心化实践。</p>
<p><strong>其共同的架构原理：</strong></p>
<ul>
<li><strong>单一职责</strong></li>
<li><strong>关注分离：控制与逻辑相分离</strong></li>
<li><strong>模块化和分而治之</strong></li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>用服务进行组件化</strong></li>
<li><strong>围绕业务能力进行组织</strong></li>
<li><strong>是产品而非项目</strong></li>
<li><strong>端点智能化和哑管道: 控制逻辑都在端点，管道仅仅是传输</strong></li>
<li><strong>全自动化部署</strong></li>
<li><strong>语言和数据的去中心化控制</strong></li>
<li><strong>面向失败设计</strong></li>
<li><strong>渐进式设计</strong></li>
</ul>
<p><strong>综合来看，其优缺点如下：</strong></p>
<ul>
<li><strong>优点：</strong> 模块的强边界；独立部署；技术选型的多样性。</li>
<li><strong>缺点：</strong> 分布式带来编程复杂度，远程调用的消耗；舍弃强一致性，实现最终一致性；操作复杂性要求有一个成熟的运维团队或者运维基础设施。</li>
</ul>
<p><strong>为什么要采用微服务</strong></p>
<p>是否选择微服务取决于你要设计的系统的复杂度。微服务是用来把控复杂系统的，但是随之而来的就是引入了微服务本身的复杂度。</p>
<p>需要解决包括自动化部署、监控、容错处理、最终一致性等其他分布式系统面临的问题。即使已经有一些普遍使用的解决方案，但是仍然是有不小的成本的。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/bZVnx0" alt="img" loading="lazy"></figure>
<p>生产力和复杂度的关系如图所示，可见系统越复杂，微服务带来的收益越大。此外，无论是单体应用还是微服务，团队的技能都需要能够把控住。</p>
<p><strong>马丁·福勒的一个观点是：</strong> 除非管理单体应用的成本已经太复杂了（太大导致很难修改和部署），否则都不要考虑微服务。</p>
<p>大部分应用都应该选择单体架构，做好单体应用的模块化而不是拆分成服务。</p>
<p>因此，系统一开始采用单体架构，做好模块化，之后随着系统变得越来越复杂、模块/服务间的边界越来越清晰，再重构为微服务架构是一个合理的架构演化路径。</p>
<p><strong>四个可以考虑上微服务的情况：</strong></p>
<ul>
<li>多人开发一个模块/项目，提交代码频繁出现大量冲突。</li>
<li>模块间严重耦合，互相依赖，每次变动需要牵扯多个团队，单次上线需求太多，风险大。</li>
<li>主要业务和次要业务耦合，横向扩展流程复杂。</li>
<li>熔断降级全靠 if-else。</li>
</ul>
<p><strong>微服务的三个阶段：</strong></p>
<ul>
<li><strong>微服务 1.0：</strong> 仅使用注册发现，基于 Spring Cloud 或者 Dubbo 进行开发。</li>
<li><strong>微服务 2.0：</strong> 使用了熔断、限流、降级等服务治理策略，并配备完整服务工具和平台。</li>
<li><strong>微服务 3.0：</strong> Service Mesh 将服务治理作为通用组件，下沉到平台层实现，应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现 AIOps 和智能调度。</li>
</ul>
<p><strong>微服务架构</strong></p>
<p><strong>先决条件</strong></p>
<p><strong>微服务的先决条件如下：</strong></p>
<ul>
<li><strong>快速的环境提供能力：</strong> 依赖于云计算、容器技术，快速交付环境。</li>
<li><strong>基本的监控能力：</strong> 包括基础的技术监控和业务监控。</li>
<li><strong>快速的应用部署能力：</strong> 需要部署管道提供快速的部署能力。</li>
<li><strong>Devops 文化：</strong> 需要具有良好的持续交付能力，包括全链路追踪、快速环境提供和部署等，还需要快速的反应能力（对问题、故障的快速响应），开发和运维的协同工作。</li>
</ul>
<p>此外，根据康威定律和逆康威定律（技术架构倒逼组织架构改进），组织架构也是一个很关键的因素。</p>
<p><strong>对应于微服务架构，组织架构需要遵循以下原则：</strong></p>
<ul>
<li>一个微服务由一个团队维护，团队成员以三人为宜。</li>
<li>单个团队的任务和发展是独立的，不受其他因素影响。</li>
<li>团队是功能齐全、全栈、自治的，扁平、自我管理。</li>
</ul>
<p><strong>基础设施</strong></p>
<p>微服务的推行需要依赖于很多底层基础设施，包括提供微服务的编译、集成、打包、部署、配置等工作，采用 PaaS 平台解决微服务从开发到运行的全生命周期管理，同时提供异构环境管理、容器资源隔离与互通、服务伸缩漂移、服务升级与回退、服务熔断与降级、服务注册与发现。</p>
<p><strong>①最基本的基础设施</strong></p>
<p><strong>进程间通讯机制：</strong> 微服务是独立进程的，需要确定之间的通讯方式。</p>
<p><strong>服务发现+服务路由：</strong> 提供服务注册中心，服务提供者和消费者通过服务发现获取服务的信息从而调用服务，实现服务的负载均衡等。</p>
<p><strong>服务容错：</strong> 微服务架构中，由于服务非常多，往往是一个服务挂了，整个请求链路的服务都受到影响。</p>
<p>因此需要服务容错，在服务调用失败的时候能够处理错误或者快速失败，包括熔断、Fallback、重试、流控和服务隔离等。</p>
<p><strong>分布式事务支持：</strong> 随着业务拆分为服务，那么有时候不开避免的就是跨服务的事务，即分布式事务的问题。</p>
<p>原则是尽量避免分布式事务，如果无法避免那么可以使用消息系统或者 CQRS 和 Event Sourcing 方案来实现最终一致性。</p>
<p>如果需要强一致性，则有两阶段提交、三阶段提交、TCC 等分布式事务解决方案。</p>
<p><strong>②提升外部服务对接效率和内部开发效率</strong></p>
<p><strong>API 网关：</strong> 负责外部系统的访问，跨横切面的公共层面的工作，包括安全、日志、权限控制、传输加密、请求转发、流量控制等。</p>
<p>典型的网关功能即对外暴露一个域名 xx.com，根据第一级目录做反向路由 xx.com/user，xx.com/trade。</p>
<p>每一级目录，如 user、trade 对应一个服务的域名。此外，API 网关也可以有服务编排的功能（不推荐）。</p>
<p><strong>接口框架：</strong> 规范服务之间通讯使用的数据格式、解析包、自解释文档，便于服务使用方快速上手等。</p>
<p><strong>③提升测试和运维效率</strong></p>
<p><strong>配置中心:</strong>  运行时配置管理能够解决动态修改配置并批量生效的问题。包括配置版本管理、配置项管理、节点管理、配置同步等。</p>
<p><strong>持续交付：</strong> 包括持续集成、自动化部署等流程。目的就是小步迭代，快速交付。</p>
<p><strong>持续集成：</strong> 这一部分并非是微服务特定的，对于之前的单体应用，此部分一般来说也是必要的。</p>
<p>主要是指通过自动化手段，持续地对代码进程编译构建、自动化测试，以得到快速有效的质量反馈，从而保证代码的顺利交付。</p>
<p>自动化测试包括代码级别的单元测试、单个系统的集成测试、系统间的接口测试。</p>
<p><strong>自动化部署：</strong> 微服务架构，节点数动辄上百上千，自动化部署能够提高部署速度和部署频率，从而保证持续交付。</p>
<p>包括版本管理、资源管理、部署操作、回滚操作等功能。而对于微服务的部署方式，包括蓝绿部署、滚动部署以及金丝雀部署。</p>
<p><strong>④进一步提升运维效率</strong></p>
<p><strong>服务监控：</strong> 微服务架构下节点数目众多，需要监控的机器、网络、进程、接口等的数量大大增加，需要一个强大的监控系统，能够提供实时搜集信息进行分析以及实时分析之上的预警。</p>
<p>包括监控服务的请求次数、响应时间分布、最大/最小响应值、错误码分布等。</p>
<p><strong>服务跟踪：</strong> 跟踪一个请求的完整路径，包括请求发起时间、响应时间、响应码、请求参数、返回结果等信息，也叫做全链路跟踪。</p>
<p>通常的服务可以和服务监控做在一起，宏观信息由服务跟踪呈现，微观单个服务/节点的信息由服务监控呈现。服务跟踪目前的实现理论基本都是 Google 的 Dapper 论文。</p>
<p><strong>服务安全：</strong> 内网之间的微服务调用原则上讲应该是都可以互相访问写，一般并不需要权限控制，但有时候限于业务要求，会对接口、数据等方面有安全控制的要求。</p>
<p>此部分可以以配置的方式存在于服务注册中心中，和服务绑定，在请求时由做为服务提供者的服务节点进行安全策略控制。配置则可以存储在配置中心以方便动态修改。</p>
<p>在微服务数量很少的情况下，以上基础设施的优先级自上而下降低。否则，仅仅依赖人工操作，则投入产出比会很低。</p>
<p>还需要提到的是 Docker 容器技术。虽然这个对于微服务并不是必须的，但是容器技术轻量级、灵活、与应用依存、屏蔽环境差异的特性对于持续交付的实现是至关重要的，即使对于传统的单体应用也能够给其带来交付效率的大幅提升。</p>
<p><strong>架构设计模式</strong></p>
<p>在引入微服务之后，传统的单体应用变为了一个一个服务，之前一个应用直接提供接口给客户端访问的架构不再适用。</p>
<p>微服务架构下，针对不同设备的接口做为 BFF 层（Backend For Frontend），也叫做用户体验适配层，负责聚合、编排微服务的数据转换成前端需要的数据。</p>
<p>服务之间的调用则在允许的情况下（允许延迟）尽可能使用异步消息传递方式，如此形成面向用户体验的微服务架构设计模式。</p>
<p><strong>如下图所示：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/crkgUc" alt="img" loading="lazy"></figure>
<p>Client→API Gateway→BFF（Backend For Frontend）→Downstream Microservices：</p>
<ul>
<li>后台采用微服务架构，微服务可以采用不同的编程语言和不同的存储机制。</li>
<li>前台采用 BFF 模式对不同的用户体验（如桌面浏览器，Native App，平板响应式 Web）进行适配。</li>
<li>BFF、API Orchestration Layer，Edge Service Layer，Device Wrapper Layer 是相同的概念。</li>
<li>BFF 不能过多，过多会造成代码逻辑重复冗余。</li>
<li>可以将网关承担的功能，如 Geoip、限流、安全认证等跨横切面功能和 BFF 做在同一层，虽然增加了 BFF 层的复杂性，但能够得到性能优势。</li>
</ul>
<p><strong>服务拆分</strong></p>
<p>微服务架构最核心的环节，主要是对服务的横向拆分。服务拆分就是将一个完整的业务系统解耦为服务，服务需要职责单一，之间没有耦合关系，能够独立开发和维护。</p>
<p>服务拆分不是一蹴而就的，需要在开发过程中不断地理清边界。在完全理清服务之前，尽量推迟对服务的拆分，尤其是对数据库的拆分。</p>
<p><strong>拆分方法如下：</strong></p>
<ul>
<li><strong>基于业务逻辑拆分</strong></li>
<li><strong>基于可扩展拆分</strong></li>
<li><strong>基于可靠性拆分</strong></li>
<li><strong>基于性能拆分</strong></li>
</ul>
<p>其中，对于无法修改的遗留系统，采用绞杀者模式：在遗留系统外面增加新的功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。</p>
<p><strong>拆分过程需要遵守的规范如下：</strong></p>
<ul>
<li>先少后多、先粗后细（粒度）</li>
<li>服务纵向拆分最多三层，两次调用：Controller、组合服务、基础服务</li>
<li>仅仅单向调用，禁止循环调用</li>
<li>串行调用改为并行调用或者异步化</li>
<li>接口应该幂等</li>
<li>接口数据定义严禁内嵌，透传</li>
<li>规范化工程名</li>
<li>先拆分服务，等服务粒度确定后再拆分数据库。</li>
</ul>
<p><strong>微服务框架</strong></p>
<p>上面讲述了微服务架构的众多基础设施，如果每一个基础设施都需要自己开发的话是非常巨大的开发工作。目前市面上已经有不少开源的微服务框架可以选择。</p>
<p><strong>Spring Boot</strong></p>
<p>Spring Boot 是用来简化新 Spring 应用的初始搭建以及开发过程的。其虽然不是微服务框架，但其设计的初衷本质就是微应用的底层框架，因此非常适合用于微服务基础设施的开发以及微服务的应用开发。</p>
<p>尤其对于 Spring 技术栈的团队来说，基于 Spring Boot 开发微服务框架和应用是自然而然的一个选择。关注微信公众号：Java技术栈，在后台回复：boot，可以获取我整理的 N 篇最新 Spring Boot 教程，都是干货。</p>
<p><strong>Dubbo&amp;Motan</strong></p>
<p>Dubbo 是阿里开源的服务治理框架。其出现在微服务理念兴起之前，可以看做是 SOA 框架的集大成之作。</p>
<p><strong>但其仅仅包含了微服务基础设施的部分功能，诸如熔断、服务跟踪、网关等都没有实现：</strong></p>
<ul>
<li><strong>服务发现：</strong> 服务发布、订阅、通知。</li>
<li><strong>高可用策略：</strong> 失败重试（Failover）、快速失败（Failfast）、资源隔离 - 负载均衡 ：最少活跃连接、一致性 Hash、随机请求、轮询等。</li>
<li><strong>扩展性 ：</strong> 支持 SPI 扩展（service provider interface）。</li>
<li><strong>其他 ：</strong> 调用统计、访问日志等。</li>
</ul>
<p>Motan 则是微博开源的类似 Dubbo 的 RPC 框架，与 Dubbo 相比更轻量级。</p>
<p><strong>Spring Cloud</strong></p>
<p>Spring Cloud 是基于 Spring Boot 实现的微服务框架，也可以看做一套微服务实现规范。关注微信公众号：Java技术栈，在后台回复：cloud，可以获取我整理的 N 篇最新 Spring Cloud 教程，都是干货。</p>
<p>基本涵盖了微服务基础设施的方方面面，包括配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等。</p>
<p>其基于 Spring 生态，社区支持非常好。但其很多组件都没有经过生产环境验证，需要慎重选择。</p>
<p>Spring Cloud Netflix 是 Spring Cloud 的一个子项目，是 Spring 对 Netflix OSS 的集成实现。</p>
<p><strong>基于 Netflix 的大规模使用，其中的已经被广泛使用的组件包括：</strong></p>
<ul>
<li><strong>Eureka：</strong> 服务注册和服务发现</li>
<li><strong>Ribbon：</strong> 弹性而智能的进程间和服务通讯机制，客户端负载均衡</li>
<li><strong>Hystrix：</strong> 熔断器，在运行时提供延迟和容错的隔离</li>
<li><strong>Zuul：</strong> 服务网关</li>
</ul>
<p>此外，另一个子项目 Spring Cloud Alibaba 则是 Alibaba 开源的基于 Spring Boot 的微服务框架，主要是对阿里云服务的支持。</p>
<p><strong>Service Mesh</strong></p>
<p>上述的微服务框架都是侵入式的，服务化的过程都需要进行代码改造。Service Mesh 则是下一代微服务架构，最明显的特征就是无入侵。采用 Sidecar 模式来解决系统架构微服务化后的服务间通信和治理问题。</p>
<p><strong>如下图所示：</strong></p>
<p><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/1hjB5S" alt="img" loading="lazy"><br>
<strong>目前主流的开源实现包括：</strong></p>
<ul>
<li>
<p><strong>Linkerd 和 Envoy：</strong> 以 Sidecar 为核心，关注如何做好 Proxy，并完成一些通用控制平面的功能。缺乏对这些 Sidecar 的管理和控制。</p>
</li>
<li>
<p><strong>Istio 和 Conduit：</strong> 目前最为流行的 Service Mesh 实现方案，集中在更加强大的控制平面(Sidecar 被称为数据平面)功能。</p>
<p>前者由 Google 和 IBM 合作，并使用了 Envoy 作为 Sidecar 部分的实现；后者则是 Linkerd 作者的作品。</p>
<p>相比起来，Istio 有巨头背景，功能强大，但可用性和易用性一直不高，Conduit 则相对简单、功能聚焦。</p>
</li>
</ul>
<p>限于 Service Mesh 带来的性能延迟的开销以及 Sidecar 对分布复杂性的增加，其对大规模部署(微服务数目多)、异构复杂(交互协议/开发语言类型多)的微服务架构带来的收益会更大。</p>
<p><strong>Sofastack</strong></p>
<p>蚂蚁金服开源的构建金融级分布式架构的一套中间件。包括微服务开发框架、RPC 框架、服务注册中心、全链路追踪、服务监控、Service Mesh 等一整套分布式应用开发工具。</p>
<p>特别值得一提的是 SOFAMesh。其实对下一代微服务架构 Service Mesh 的大规模落地方案实践，基于 Istio 改进和扩展而来，应该是国内最为成熟的开源 Service Mesh 方案。</p>
<p>此外，需要提到 Kubernetes（K8s），其本身提供了部分的微服务特性支持（通过域名做服务发现），对代码无侵入。但服务调用、熔断这些都需要自己实现。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/le2NKP" alt="img" loading="lazy"></figure>
<p>综上，目前公司技术团队技术栈是 Spring，并且已有服务的实现都是基于 Dubbo。</p>
<p>因此选择 Spring Cloud Netflix 做为基础的微服务框架，对其中不成熟或者缺乏的组件，选择业界更为成熟的组件替代即可：</p>
<ul>
<li><strong>API 网关：</strong> Zuul。</li>
<li><strong>服务注册中心：</strong> Dubbo。</li>
<li><strong>配置中心：</strong> Disconf。</li>
<li><strong>服务监控&amp;全链路追踪：</strong> CAT。</li>
<li><strong>服务开发框架：</strong> Spring Boot。</li>
<li><strong>日志监控、告警：</strong> ELK+Elasalert。</li>
<li><strong>流量控制：</strong> Sentinel。</li>
<li><strong>消息队列：</strong> Kafka。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务设计 10 大反模式和陷阱]]></title>
        <id>https://kangjn.github.io/post/wei-fu-wu-she-ji-10-da-fan-mo-shi-he-xian-jing/</id>
        <link href="https://kangjn.github.io/post/wei-fu-wu-she-ji-10-da-fan-mo-shi-he-xian-jing/">
        </link>
        <updated>2021-04-22T07:49:39.000Z</updated>
        <content type="html"><![CDATA[<p>O’Reilly的电子书《Microservices AntiPatterns and Pitfalls》讲述了在微服务设计实现时十种最常见的反模式和陷阱。本文基于此书，将这十个点列出。</p>
<p>数据驱动迁移反模式（Data-Driven Migration）</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/678393.png" alt="img" loading="lazy"></figure>
<p>如上图所示，此种反模式的问题在于微服务的粒度没有最终确定之前就做了数据迁移，如此当不断的调整服务粒度时，那么数据库就免不了频繁迁移，带来极大的成本。更好的方式如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/758392.png" alt="img" loading="lazy"></figure>
<p>即先分离功能，数据库先保持之前的单体，等到服务粒度最终确定之后，再分离数据库。</p>
<p>超时反模式（The Timeout）</p>
<p>微服务架构是由一系列分离的服务组成的，这些服务之间通过一些远程协议进行互相之间的通信。其中牵扯到了服务的可用性和响应性问题。如下图所示：</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/921392.png" alt="img" loading="lazy"></figure>
<ul>
<li>可用性：服务消费方能够连接服务方，并可以向其发送请求。</li>
<li>响应性：服务方能够在消费方期望时间内给予请求响应。</li>
</ul>
<p>为了防止服务的不可用和无法响应，通常的做法就是设置一个调用超时。此种做法表面上看是没问题的，但是试想一下如下情景：发起一个购买100个商品的请求，请求成功返回一个确认号。如果当请求超时但是请求在服务端已经成功执行了，此时这个交易实际是完成的，但是消费方没有拿到确认号，如果重试请求，那么服务方需要一个复杂的机制判断这是否一次重复提交。</p>
<p>一种解决此问题的方案是设置一个较长的超时时间，如一个服务的通常响应耗时需要2s，最大耗时需要5s，那么超时时间可以设置为10s。但这样的问题就是如果服务不可用，所有消费方都得等待10s，这个是非常损耗性能的。</p>
<p>解决超时反模式的方案就是使用“断路器模式”。就类似于房屋中的电源断路器，当断路器关闭，电流可以通过，当断路器打开，那么电流中断一直到断路器关闭。断路器模式就是说当检测到服务方无法响应时就打开，后续的请求都会被拒绝掉。一旦服务方可响应了，那么断路器关闭，恢复请求。其工作模式如下图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/020392.png" alt="img" loading="lazy"></figure>
<p>断路器会持续地监测远程服务，确保其是可响应的。只要服务可响应，那么断路器会一直关闭，允许请求通过。如果服务突然不可响应，那么断路器打开，拒绝后续的请求。而后续如果断路器又检测到服务恢复了，那么断路器会自动关闭，请求也就恢复了。此种方案与超时时间相比，最大的优势就是一旦服务不可响应，那么断路器模式可以让请求立刻返回而不是需要等待一定的时间。</p>
<p>[Hystrix]的Netflix是此种断路器模式的一种开源实现。此外，Akka中也包含了一个断路器实现：Akka CircuitBreaker类。</p>
<p>共享反模式（“I Was Taught to Share”）</p>
<p>微服务被普遍认为是一种不共享任何东西的架构。但实际上只能是尽可能地少共享，毕竟在某些层面代码被多个服务共享也能带来一定好处。</p>
<p>例如，与单独部署一套安全服务（认证和授权）其他所有服务都通过远程访问此服务相比，把安全相关的功能封装成jar包（security.jar），然后其他服务都集成此jar包，就能够避免每次都要发起对安全服务的访问，从而提高性能和可靠性。但后面的方案带来的问题就是依赖噩梦：每一个服务都依赖多个自定义的jar包。如此不仅打破了服务之间的边界上下文，同时也引入了诸如总体可靠性、变更控制、易测试性、部署等问题。</p>
<p>在一个使用面向对象编程语言的单体应用中，使用abstract类和接口实现代码复用和共享是一个良好的实践。但当从单体切换到微服务架构时，对于很多自定义的共享类和工具类（日期、字符串、计算）的处理要考虑到微服务间共享的东西越少越有利于保持服务间的边界上下文，从而更利于快速测试和部署。以下是几种推荐的方式，也是解决“共享反模式”的方案：</p>
<p><strong>共享项目</strong></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/257392.jpg" alt="257392" loading="lazy"></figure>
<p>将共享的代码作为一个项目在编译期与各个服务集成。此种方式便于变更和开发软件，但是最大的问题在于很难发觉哪一个共享模块被修改以及修改的原因，也无法确定自己的服务是否需要这些变更。尤其是在服务发布前期发现某一个共享模块发生了变动的话需要再一次的测试才能走后续流程。</p>
<p><strong>共享库</strong></p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/358392.jpg" alt="358392" loading="lazy"></figure>
<p>此种方式即将共享的代码作为类库集成到服务中。如此每次共享的库有改动，服务都需要重新打包、测试、重启。但相比起第一种，其有版本标记，能够更好地控制服务的部署和开发，服务开发者可以自己控制何时将共享库的改动集成进来。</p>
<p>更进一步的，如果采用此种方案，一定要避免把所有共享的代码都打包进一个jar包中如common.jar。否则会很难确定何时要把库的变动集成到服务中。更好的做法是将共享代码分成几个单独上下文的库，如：security.jar、dateutils.jar、persistence.jar等，如此会比较容易的确定何时去集成共享库的变动。</p>
<p><strong>冗余</strong></p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/454393.png" alt="img" loading="lazy"></figure>
<p>此种方案违反DRY原则，在每一服务中都冗余一份共享代码，能够避免依赖共享也能够保持边界上下文。但是一旦共享的代码有变动，那么所有服务都需要改动。因此，此种方案适用于共享模块非常稳定，极小可能变动的情况。</p>
<p><strong>服务合并</strong></p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/563392.png" alt="img" loading="lazy"></figure>
<p>当多个服务共享的代码变动比较频繁时可以采用此种方案合并成一个服务，如此就避免了多了服务频繁的测试和部署，也避免了依赖共享库。</p>
<p>可达性报告反模式（Reach-in Reporting）</p>
<p>微服务中各个服务以及其相应的数据都是包含在一个单独的边界上下文中的，也就是说数据是隔离到多个数据库中的。因此，这也会使得收集微服务的各种数据生成报告变得相对困难。一般来说有四种方案解决这个问题。其中，前三种都是从各个微服务中拉取数据，是这里所说的反模式，被称作“Reach-in Reporting”。</p>
<p><strong>数据库拉取模式</strong></p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/732392.png" alt="img" loading="lazy"></figure>
<p>报告服务直接从各个服务的数据库中拉取数据从而生成各种报告。此种方式简单迅速，但是会让报告服务和业务服务相互依赖，是一种数据库共享集成风格（通过共享的数据库将多个应用耦合在一起）。如此一旦数据库有改动，所有相关服务都要改动，也就打破了微服务中极为重要的边界上下文。</p>
<p><strong>HTTP拉取模式</strong></p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/820392.png" alt="img" loading="lazy"></figure>
<p>与数据库拉取模式相比，此种方式不再是直接去访问服务的数据库，而是通过HTTP接口去请求服务的数据。此种方式能够保持服务的边界上下文，但是性能比较慢，而且HTTP请求无法很好的承载大数据。</p>
<p><strong>批量拉取模式</strong></p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/931392.png" alt="img" loading="lazy"></figure>
<p>此种方式会有一个单独的报告数据库/数据仓库来存储各个服务的聚合数据。会通过一个批量任务（离线或者基于增量实时）将服务更新的数据导入到报告数据库/数据仓库中。与数据库拉取模式一样，此种方式这也是一种数据库共享集成风格，会打破服务的边界上下文。</p>
<p><strong>异步事件推送模式</strong></p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/068392.png" alt="img" loading="lazy"></figure>
<p>此种方式即解决“Reach-in  Reporting”反模式的方案。每个服务都把自己的发生的事件异步推送到一个数据捕获服务，后续数据捕获服务会将数据解析存储到报告数据库中。此种方式实现起来较复杂，需要在服务和数据捕获服务之间制定一种协议用于异步传输事件数据。但其能够保持服务的边界上下文，同时也能保证数据的时效性。</p>
<p>沙粒陷阱（Grains of Sand）</p>
<p>微服务实现中最有挑战的问题在于如何拆分service，如何控制服务的粒度，而正确的服务粒度则决定了微服务是否能够成功实现。服务粒度也能够影响到性能、健壮性、可靠性、易测试性、部署等。</p>
<p>“沙粒陷阱”即把服务拆分的太细。其中的一个原因就是很多时候开发者会把一个class与一个服务等同。合理的，应该是一个服务组件（Service component）对应一个服务。一个服务组件具有清晰、简洁的角色、职责，具有一组定义好的操作。其一般通过多个模块（Java  Class）实现。如果组件和模块是一对一的关系，那么不仅仅会造成服务粒度过细同时也是一种不好的编程实践：服务的实现都是通过一个Class，那么此Class会非常大并且承担太多的责任，不利于测试和维护。</p>
<p>更进一步的，服务的粒度并不应该受其中实现类的数目影响：有些服务可能只需要一个类就可以实现，而有些服务会需要多个类来实现。</p>
<p>为了避免“沙粒陷阱”，可以通过以下三种测试来判断服务粒度是否合理：</p>
<p><strong>分析服务范围和功能</strong></p>
<p>要明确服务用来干什么？有哪些操作？一般通过使用文档或者语言来描述服务的范围和功能就能够看出来服务是否做的工作太多。如果在描述中使用了“和”（“and”）或者“此外”（“in addition”）之类的词，很有可能就是此服务职责太多。</p>
<p>服务的高内聚是一种良好的实践，其明确一个服务提供的操作之间必须要是有关联的。如对于一个顾客服务，有以下操作：</p>
<ul>
<li>添加顾客</li>
<li>更新顾客信息</li>
<li>获取顾客信息</li>
<li>通知顾客</li>
<li>记录顾客评论</li>
<li>获取顾客评论</li>
</ul>
<p>其中的前三个操作都是对顾客的CRUD操作，是相关联的。而后三者则无关。为了实现服务的高内聚，合理的应该是把此服务拆分成三个服务：顾客维护、顾客通知、顾客评论。</p>
<p>如此，以粗粒度的服务开始，然后逐渐拆分成细粒度的服务有利于对微服务的拆分。</p>
<p><strong>分析数据库事务</strong></p>
<p>传统的关系型数据库都提供了ACID事务特性用于把多个更新操作打包成一个整体提交，要么都成功，要么都失败。而在微服务中，由于服务都是一个个分离的应用，很难实现ACID，一般实现BASE事务（basic availability、soft state、eventual  consistence）即可。但是无法避免的，仍然会有一些场景是需要ACID的。因此，当你不断的需要在BASE和ACID事务做判断和取舍的时候，很有可能就是服务粒度过细。</p>
<p>如果业务场景无法接受最终一致性，那么最好就是将服务粒度粗化一些，把多个更新操作放到一个服务中。</p>
<p><strong>分析服务编排</strong></p>
<p>这里主要说的是服务之间的互相通信。由于对服务的调用都是一次远程调用，因此服务编排会非常大的影响微应用总体的性能。此外，它也会影响系统整体的健壮性和可靠性，越多的远程调用，那么越高的几率会有失败或者超时的请求出现。</p>
<p>如果发现完成一次业务逻辑需要调用太多的远程服务，就说明服务的粒度可能太细了。这时候就需要将服务粗化。而合并细粒度服务还能够提高性能，提升总体的健壮性和可靠性。同时也减少了多个服务间的依赖，更利于测试和部署。</p>
<p>此外，使用响应式编程技术异步并行调用远程服务也是一种提升性能和可靠性的方案。</p>
<p>无因的开发者陷阱（Developer Without a Cause）</p>
<p>此陷阱主要讲的是开发者或者架构师在做设计时很多时候是拍脑袋在做，没有任何合理的原因或者原因是错误的，也不会做取舍。而想要解决此问题，不仅仅是架构师，开发者也需要同时了解技术带来的好处以及缺陷，从中做权衡。</p>
<p>了解业务驱动是避免此陷阱的关键一步。每一个开发者和架构师都应该清楚的了解下面这些问题的答案：</p>
<ul>
<li>为什么要使用微服务？</li>
<li>最重要的业务驱动是什么？</li>
<li>架构中的哪一点是最为重要的？</li>
</ul>
<p>假如易部署性、性能、健壮性、可扩展性是系统最看重的特性，那么对于不同的业务侧重点，微服务的粒度需求也是不同的。细粒度的服务能够达到更好的易测试性和易部署性，而粗粒度的服务则有更好的性能、健壮性以及可靠性。</p>
<p>追随流行陷阱（Jump on the Bandwagon）</p>
<p>微服务是目前非常流行的架构理念，越来越多的公司也都在紧跟这个潮流纷纷转型微服务架构，而不管到底自己是否真的需要。为了避免此陷阱，需要首先了解微服务的优点和缺点。</p>
<p>优点：</p>
<ul>
<li>易部署：容易部署是微服务的一个很大的优点。毕竟相比起一个庞大的单体应用，一个小并且职责单一的微服务的部署非常简单并且带来的风险也会小很多。而持续部署技术则进一步放大了这个优点。</li>
<li>易测试：职责单一、共享依赖少使得测试一个微服务是很容易的。而基于微服务做回归测试与单体大应用相比也是很容易的。 控制变更：每个服务的范围和边界上下文使得很容易控制服务的功能变动。</li>
<li>模块化：微服务就是一个高度模块化的架构风格。这种风格也是一种敏捷方式的表达，能够很快的响应变化。一个系统模块化程度越高，就越容易测试、部署和发布变更。一个服务粒度划分合理的微服务系统是所有架构中模块化程度最高的架构形式。</li>
<li>可扩展性：由于每一个服务都是一个职责单一的细粒度服务，因此此种架构风格是所有架构分隔中可扩展性最高的。其非常容易扩展某一个或者某几个功能从而满足整体系统的需求。而得益于服务的容器化特性以及各种运维监控工具，服务也能够自动化进行启动和关闭。</li>
</ul>
<p>缺点：</p>
<ul>
<li>组织变动：微服务需要组织在很多层面进行变动。研发团队需要包含UI、后端开发、规则处理、数据库处理建模等多种职位，从而使得一个小的团队能够具有实现微服务的所有技术栈。同时，传统的单体、分层应用架构的软件发布流程也需要更新为自动化、高效的部署流水线。</li>
<li>性能：由于服务都是隔离的，因此发起对服务的远程调用肯定是会影响性能的。服务编排、运行环境都是影响性能的很大因素。了解远程调用的延迟、需要与多少服务通信都是与性能相关的需要掌握的信息。</li>
<li>可靠性：和性能一样。服务的远程调用越多，那么失败的几率就越高，总体的可靠性就会越低。</li>
<li>DevOps：随着微服务架构而来的是成千上百的服务。手动管理这么多的服务是很不现实的。这就对于自动化运维部署、协作提出了很高的挑战。需要依赖非常多的操作工具和实践，是一个非常复杂的工作。目前差不多有12种类型的操作工具（监控工具、服务注册、发现工具、部署工具等）和框架在微服务架构中被使用，其中每一种又包含了很多具体的工具和产品供选择。对于这些工具和框架的选择一般都会需要将近数月的研究、测试、权衡分析才能做出最适合的技术选型。</li>
</ul>
<p>了解了微服务的优缺点后，下一步则需要根据实际的业务来分析微服务是不是解决这些问题的最佳方案。可以采取以下问题：</p>
<ul>
<li>业务和技术的目标是什么？</li>
<li>使用微服务是为了完成什么？</li>
<li>目前和可预知的痛点是什么？</li>
<li>应用的最关键的技术特性是什么？（性能、易部署性、易测试性、可扩展性）</li>
</ul>
<p>回答这些问题再结合微服务的优缺点能够让你明确现在是否是使用微服务的适当时机。</p>
<p>除了微服务以外，还有其他7种比较普遍使用的架构供选择：</p>
<ul>
<li>基于服务的架构（Service-Based）</li>
<li>面向服务的架构（Service-Oriented）</li>
<li>分层架构（Layered）</li>
<li>微内核架构（Microkernel）</li>
<li>基于空间的架构（Space-Based）</li>
<li>事件驱动架构（Event-Driven）</li>
<li>流水线架构（Pipeline）</li>
</ul>
<p>静态合约陷阱（The Static Contract）</p>
<p>微服务的消费方和服务提供方之间会有一个合约/协议用来规定输入输出数据的格式、操作名称等等。一般情况下这个合约是不变的。但是如果没有使用版本号来管理服务接口，那么就会进入“静态合约”陷阱。</p>
<p>给合约打上版本标记不仅仅能够避免巨大的变动（服务提供方修改合约使得所有消费方也都得修改），还能够提供向后兼容性。这里有两种技术可以实现合约的版本号：</p>
<p><strong>在头部信息附加版本号</strong></p>
<figure data-type="image" tabindex="13"><img src="http://img.javastack.cn/1588152255455392.png" alt="img" loading="lazy"></figure>
<p>此种方式即在远程访问协议的头部添加版本信息。而如果远程协议使用的是REST，那么还可以使用vendor mime type（vnd）来指定合约的版本号。如下：</p>
<pre><code>POST /trade/buy
Accept: application/vnd.svc.trade.v2+json
</code></pre>
<p>服务接受到请求，能够通过正则等手段简单解析出其中的合约版本号再根据版本号做相应的处理。</p>
<p>如果使用消息队列，那么可以将版本号放置在属性部分(Property section)。JMS的一个例子如下：</p>
<pre><code>String msg = createJSON(&quot;acct&quot;,&quot;12345&quot;,&quot;sedol&quot;,&quot;2046251&quot;,&quot;shares&quot;,&quot;1000&quot;);
jsmContext.createProducer()
  .setProperty(&quot;version&quot;,2)
  .send(queue,msg);
</code></pre>
<p><strong>在合约本身中附加版本号</strong></p>
<p>此种方式版本号独立于远程访问协议，与头部信息版本号相比，这也是其最大的优点。但与此同时，其缺点比较多。首先要从请求信息主体中解析版本号，会出现很多解析的问题。其次，合约的模式可能会非常复杂，使得很难做数据转换。最后，服务还要引入对模式的验证逻辑。</p>
<p>我们到了吗陷阱（Are We There Yet）</p>
<p>微服务架构中，各个服务都是独立的个体，也就意味着所有客户端或者API层和服务之间的通信都是一次远程调用。如果对这些远程调用的耗时没有什么概念，那么就陷入了“Are We There  Yet”陷阱。合理的做法需要去测试远程访问的平均延迟、长尾延迟（95%、99%、99.%之外的请求延迟）等指标。而很多时候即使有很好的平均延迟，但是较差的长尾延迟会造成非常大的破坏。</p>
<p>在生产环境或者准生产环境测试有助于去了解应用的真实性能。例如，一个业务请求需要调用四个服务，假设一个服务调用的延迟是100毫秒，那么加上业务请求本身的延迟，完成此次业务请求共需要500毫秒的延迟。这和单单从代码上去看得出的结论是不一样的。</p>
<p>了解目前所用协议的平均延迟是一方面，另一方面则需要对比其他远程协议的延迟，从而在合适的地方使用合适的协议。如：JMS、AMQP、MSMQ。</p>
<p>AMQP协议的性能是最好的。那么结合业务场景，就可以选择REST作为客户端与服务间的通信协议，AMQP做为服务之间的通信协议以提高应用的性能。</p>
<p>当然，性能并非在选择远程协议时唯一考虑的因素。下一节中就会考虑利用消息队列的一些额外功能。</p>
<p>REST使用陷阱（Give It a Rest）</p>
<p>REST现在是微服务中用的最多的通信协议。流行的开发框架如DropWizard、Spring  Boot都提供了REST支持。但是如果只选择REST这一种协议，不去考虑其他诸如消息队列的优势，那么就陷入了“REST使用”陷阱。毕竟异步通信、广播、合并请求事务这些需求，REST是很难实现的。</p>
<p>消息队列标准目前包括平台特定和平台无关两种。前者包括Java平台中的JMS和C#平台的MSMQ，后者则是AMQP。对于平台特定的消息标准JMS，其规范了API，因此切换broker实现（ActiveMQ、HornetQ）时无需修改API，但由于底层通信协议是不同的，集成的客户端或者服务端jar包需要随着修改。</p>
<p>对于平台无关的消息标准，其规范了协议实现标准，并没有规范API。使得不同平台之间都可以互相通信，而不管实际产品是什么。如一个使用了RabbitMQ的客户端可以很容易地与一个StormMQ通信（假设使用的协议相同）。也就是其独立于平台的特性使得RabbitMQ成为微服务架构中最流行的消息队列。</p>
<p><strong>异步请求</strong></p>
<p>异步通信是消息队列适用的场景之一。服务消费者发起请求后无需等待服务方响应能够提高总体的性能，同时调用方无需担心调用超时，也就无需使用断路器，从而提高了系统的可靠性。</p>
<p><strong>广播</strong></p>
<p>将消息广播给多个service是消息队列的又一个适用场景。一个消息生产者向多个消息接受者发送消息，无需知道谁在接受消息以及如何处理它。</p>
<p><strong>事务请求</strong></p>
<p>消息系统提供了对事务消息的支持：如果多个消息被发送到了在一个交易上下文的多个队列或者主题中时，那么直到消息发送者commit，服务才会真正的接受到相应的所有消息（在commit之前会一直保存在队列中）。</p>
<p>因此对于服务消费者需要合并多个远程请求到一个事务中的场景可以选择事务消息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 多线程]]></title>
        <id>https://kangjn.github.io/post/java-duo-xian-cheng/</id>
        <link href="https://kangjn.github.io/post/java-duo-xian-cheng/">
        </link>
        <updated>2021-04-22T06:17:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>线程</strong></p>
<p>线程的概念，百度是这样解释的：</p>
<p>线程（英语：Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>在Unix System V及SunOS中也被称为轻量进程（Lightweight Processes），但轻量进程更多指内核线程（Kernel Thread），而把用户线程（User Thread）称为线程。</p>
<p><strong>1.1 线程与进程的区别</strong></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/778301.png" alt="" loading="lazy"></figure>
<p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<p>也就是，进程可以包含多个线程，而线程是程序执行的最小单位。</p>
<p><strong>1.2 线程的状态</strong></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/129301.png" alt="" loading="lazy"></figure>
<ul>
<li>NEW：线程刚创建</li>
<li>RUNNABLE: 在JVM中正在运行的线程，其中运行状态可以有运行中RUNNING和READY两种状态，由系统调度进行状态改变。</li>
<li>BLOCKED：线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</li>
<li>WAITING : 等待状态</li>
<li>TIMED_WAITING: 调用sleep() join() wait()方法可能导致线程处于等待状态</li>
<li>TERMINATED: 线程执行完毕，已经退出</li>
</ul>
<p><strong>1.3 Notify和Wait ：</strong></p>
<p>Notify和Wait 的作用</p>
<p>首先看源码给出的解释，这里翻译了一下：</p>
<p>Notify：唤醒一个正在等待这个对象的线程监控。如果有任何线程正在等待这个对象，那么它们中的一个被选择被唤醒。选择是任意的，发生在执行的酌情权。一个线程等待一个对象通过调用一个{@code wait}方法进行监视。</p>
<p>Notify()需要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁</p>
<p>Wait：导致当前线程等待，直到另一个线程调用{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法。</p>
<p>换句话说，这个方法的行为就像它简单一样执行调用{@code wait(0)}。当前线程必须拥有该对象的监视器。</p>
<p>线程释放此监视器的所有权，并等待另一个线程通知等待该对象的监视器的线程，唤醒通过调用{@code notify}方法或{@code notifyAll}方法。然后线程等待，直到它可以重新取得监视器的所有权，然后继续执行。</p>
<p>Wait()的作用是使当前执行代码的线程进行等待，它是Object类的方法，该方法用来将当前线程置入预执行队列中，并且在Wait所在的代码行处停止执行，直到接到通知或被中断为止。</p>
<p>在调用Wait方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用Wait方法。</p>
<p>Wait和Sleep的区别：</p>
<ul>
<li>它们最大本质的区别是，Sleep()不释放同步锁，Wait()释放同步锁。</li>
<li>还有用法的上的不同是：Sleep(milliseconds)可以用时间指定来使他自动醒过来，如果时间不到你只能调用Interreput()来强行打断；Wait()可以用Notify()直接唤起。</li>
<li>这两个方法来自不同的类分别是Thread和Object</li>
<li>最主要是Sleep方法没有释放锁，而Wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li>
</ul>
<p><strong>1.4 Thread.sleep() 和Thread.yield()的异同</strong></p>
<ul>
<li>相同 ：Sleep()和yield()都会释放CPU。</li>
<li>不同：Sleep()使当前线程进入停滞状态，所以执行Sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。Sleep()可使优先级低的线程得到执行的机会，当然也可以让同优先级和高优先级的线程有执行的机会；yield()只能使同优先级的线程有执行的机会。</li>
</ul>
<p><strong>1.5 补充：死锁的概念</strong></p>
<p>死锁：指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>死锁产生的四个必要条件（缺一不可）：</p>
<ul>
<li>互斥条件：顾名思义，线程对资源的访问是排他性，当该线程释放资源后下一线程才可进行占用。</li>
<li>请求和保持：简单来说就是自己拿的不放手又等待新的资源到手。线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li>
<li>不可剥夺：在没有使用完资源时，其他线性不能进行剥夺。</li>
<li>循环等待：一直等待对方线程释放资源。</li>
</ul>
<p>我们可以根据死锁的四个必要条件破坏死锁的形成。</p>
<p><strong>1.6 补充：并发和并行的区别</strong></p>
<p>并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。在一个时间段的线程代码运行时，其它线程处于挂起状。</p>
<p>并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，CPU同时处理这些线程请求的能力。</p>
<p>区别就在于CPU是否能同时处理所有任务，并发不能，并行能。</p>
<p><strong>1.7 补充：线程安全三要素</strong></p>
<ul>
<li>原子性：Atomic包、CAS算法、Synchronized、Lock。</li>
<li>可见性：Synchronized、Volatile（不能保证原子性）。</li>
<li>有序性：Happens-before规则。</li>
</ul>
<p><strong>1.8 补充：如何实现线程安全</strong></p>
<ul>
<li>互斥同步：Synchronized、Lock。</li>
<li>非阻塞同步：CAS。</li>
<li>无需同步的方案：如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性。</li>
</ul>
<p><strong>1.9 补充：保证线程安全的机制：</strong></p>
<ul>
<li>[Synchronized]关键字</li>
<li>[Lock]</li>
<li>[CAS]、原子变量</li>
<li>[ThreadLocal]：简单来说就是让每个线程，对同一个变量，都有自己的独有副本，每个线程实际访问的对象都是自己的，自然也就不存在线程安全问题了。</li>
<li>[Volatile]</li>
<li>[CopyOnWrite]写时复制</li>
</ul>
<p>随着CPU核心的增多以及互联网迅速发展，单线程的程序处理速度越来越跟不上发展速度和大数据量的增长速度，多线程应运而生，充分利用CPU资源的同时，极大提高了程序处理速度。</p>
<p><strong>创建线程的方法</strong></p>
<p>继承Thread类：</p>
<pre><code>public class ThreadCreateTest {
    public static void main(String\[\] args) {
        new MyThread().start();
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + Thread.currentThread().getId());
    }
}
</code></pre>
<p>实现Runable接口：</p>
<pre><code>public class RunableCreateTest {
    public static void main(String\[\] args) {
        MyRunnable runnable = new MyRunnable();
        new Thread(runnable).start();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + Thread.currentThread().getId());
    }
}
</code></pre>
<p>通过Callable和Future创建线程：</p>
<pre><code>public class CallableCreateTest {
    public static void main(String [] args) throws Exception {
         // 将Callable包装成FutureTask，FutureTask也是一种Runnable
        MyCallable callable = new MyCallable();
        FutureTask futureTask = new FutureTask&lt;&gt;(callable);
        new Thread(futureTask).start();

        // get方法会阻塞调用的线程
        Integer sum = futureTask.get();
        System.out.println(Thread.currentThread().getName() + Thread.currentThread().getId() + &quot;=&quot; + sum);
    }
}

class MyCallable implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + Thread.currentThread().getId() + &quot;\\t&quot; + new Date() + &quot; \\tstarting...&quot;);

        int sum = 0;
        for (int i = 0; i &lt;= 100000; i++) {
            sum += i;
        }
        Thread.sleep(5000);

        System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + Thread.currentThread().getId() + &quot;\\t&quot; + new Date() + &quot; \\tover...&quot;);
        return sum;
    }
}
</code></pre>
<p>线程池方式创建：</p>
<p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承，但可以多实现啊），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<p><strong>2.1 线程池创建线程</strong></p>
<p>线程池，顾名思义，线程存放的地方。和数据库连接池一样，存在的目的就是为了较少系统开销，主要由以下几个特点：</p>
<p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗（主要）。</p>
<p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。</p>
<p>Java提供四种线程池创建方式：</p>
<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。</li>
</ul>
<p>通过源码我们得知ThreadPoolExecutor继承自AbstractExecutorService，而AbstractExecutorService实现了ExecutorService。</p>
<pre><code>public class ThreadPoolExecutor extends AbstractExecutorService

public abstract class AbstractExecutorService implements ExecutorService
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/473301.png" alt="" loading="lazy"></figure>
<p><strong>2.2 ThreadPoolExecutor介绍</strong></p>
<p>实际项目中，用的最多的就是ThreadPoolExecutor这个类，而《阿里巴巴Java开发手册》中强制线程池不允许使用Executors去创建，而是通过New ThreadPoolExecutor实例的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/789301.png" alt="img" loading="lazy"></figure>
<p>我们从ThreadPoolExecutor入手多线程创建方式，先看一下线程池创建的最全参数。</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<p>参数说明如下：</p>
<ul>
<li>corePoolSize：线程池的核心线程数，即便线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</li>
<li>maximumPoolSize：最大线程数，不管提交多少任务，线程池里最多工作线程数就是maximumPoolSize。</li>
<li>keepAliveTime：线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。</li>
<li>Unit：这个用来指定keepAliveTime的单位，比如秒：TimeUnit.SECONDS。</li>
<li>BlockingQueue：一个阻塞队列，提交的任务将会被放到这个队列里。</li>
<li>threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。</li>
<li>handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。</li>
</ul>
<p><strong>2.2.1BlockingQueue</strong></p>
<p>对于BlockingQueue个人感觉还需要单独拿出来说一下。</p>
<p>BlockingQueue：阻塞队列，有先进先出（注重公平性）和先进后出（注重时效性）两种，常见的有两种阻塞队列：ArrayBlockingQueue和LinkedBlockingQueue</p>
<p>队列的数据结构大致如图：</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/137301.png" alt="img" loading="lazy"></figure>
<p>队列一端进入，一端输出。而当队列满时，阻塞。BlockingQueue核心方法：1. 放入数据put2. 获取数据take。常见的两种Queue：</p>
<p><strong>2.2.2 ArrayBlockingQueue</strong></p>
<p>基于数组实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>一段代码来验证一下：</p>
<pre><code>package map;

import java.util.concurrent.*;

public class MyTestMap {
    // 定义阻塞队列大小
    private static final int maxSize = 5;
    public static void main(String\[\] args){
        ArrayBlockingQueue queue = new ArrayBlockingQueue(maxSize);
        new Thread(new Productor(queue)).start();
        new Thread(new Customer(queue)).start();
    }
}

class Customer implements Runnable {
    private BlockingQueue queue;
    Customer(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        this.cusume();
    }

    private void cusume() {
        while (true) {
            try {
                int count = (int) queue.take();
                System.out.println(&quot;customer正在消费第&quot; + count + &quot;个商品===&quot;);
                // 只是为了方便观察输出结果
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Productor implements Runnable {
    private BlockingQueue queue;
    private int count = 1;
    Productor(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        this.product();
    }
    private void product() {
        while (true) {
            try {
                queue.put(count);
                System.out.println(&quot;生产者正在生产第&quot; + count + &quot;个商品&quot;);
                count++;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code>生产者正在生产第1个商品
生产者正在生产第2个商品
生产者正在生产第3个商品
生产者正在生产第4个商品
生产者正在生产第5个商品
customer正在消费第1个商品===
</code></pre>
<p><strong>2.2.3 LinkedBlockingQueue</strong></p>
<p>基于链表的阻塞队列，内部也维护了一个数据缓冲队列。需要我们注意的是如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小。</p>
<p>LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p>
<p><strong>2.2.4 LinkedBlockingQueue和ArrayBlockingQueue的主要区别</strong></p>
<ul>
<li>ArrayBlockingQueue的初始化必须传入队列大小，LinkedBlockingQueue则可以不传入。</li>
<li>ArrayBlockingQueue用一把锁控制并发，LinkedBlockingQueue俩把锁控制并发，锁的细粒度更细。即前者生产者消费者进出都是一把锁，后者生产者生产进入是一把锁，消费者消费是另一把锁。</li>
<li>ArrayBlockingQueue采用数组的方式存取，LinkedBlockingQueue用Node链表方式存取。</li>
</ul>
<p><strong>2.2.5handler拒绝策略</strong></p>
<p>Java提供了4种丢弃处理的方法，当然你也可以自己实现，主要是要实现接口：RejectedExecutionHandler中的方法。</p>
<ul>
<li>AbortPolicy：不处理，直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务，即提交任务的线程。</li>
<li>DiscardOldestPolicy：LRU策略，丢弃队列里最近最久不使用的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉，不抛出异常。</li>
</ul>
<p><strong>2.2.6线程池五种状态</strong></p>
<pre><code>private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
</code></pre>
<p>RUNNING：在这个状态的线程池能判断接受新提交的任务，并且也能处理阻塞队列中的任务。</p>
<p>SHUTDOWN：处于关闭的状态，该线程池不能接受新提交的任务，但是可以处理阻塞队列中已经保存的任务，在线程处于RUNNING状态，调用shutdown()方法能切换为该状态。</p>
<p>STOP：线程池处于该状态时既不能接受新的任务也不能处理阻塞队列中的任务，并且能中断现在线程中的任务。当线程处于RUNNING和SHUTDOWN状态，调用shutdownNow()方法就可以使线程变为该状态。</p>
<p>TIDYING：在SHUTDOWN状态下阻塞队列为空，且线程中的工作线程数量为0就会进入该状态，当在STOP状态下时，只要线程中的工作线程数量为0就会进入该状态。</p>
<p>TERMINATED：在TIDYING状态下调用terminated()方法就会进入该状态。可以认为该状态是最终的终止状态。</p>
<p>回到线程池创建ThreadPoolExecutor，我们了解了这些参数，再来看看ThreadPoolExecutor的内部工作原理：</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/378301.png" alt="" loading="lazy"></figure>
<ul>
<li>判断核心线程是否已满，是进入队列，否：创建线程</li>
<li>判断等待队列是否已满，是：查看线程池是否已满，否：进入等待队列</li>
<li>查看线程池是否已满，是：拒绝，否创建线程</li>
</ul>
<p><strong>2.3深入理解ThreadPoolExecutor</strong></p>
<p>进入Execute方法可以看到：</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
  //判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
  //如果不小于corePoolSize，则将任务添加到workQueue队列。
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
  //如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<p>AddWorker方法：</p>
<ul>
<li>创建Worker对象，同时也会实例化一个Thread对象。在创建Worker时会调用threadFactory来创建一个线程。</li>
<li>然后启动这个线程。</li>
</ul>
<p><strong>2.3.1线程池中CTL属性的作用是什么？</strong></p>
<p>CTL属性包含两个概念：</p>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<ul>
<li>runState：即rs 表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying。</li>
<li>workerCount：即wc表明当前有效的线程数。</li>
</ul>
<p>我们点击workerCount即工作状态记录值，以RUNNING为例，RUNNING = -1 &lt;&lt;  COUNT_BITS;，即-1无符号左移COUNT_BITS位，进一步我们得知COUNT_BITS位29，因为Integer位数为31位（2的五次方减一）</p>
<pre><code>private static final int COUNT_BITS = Integer.SIZE - 3;
</code></pre>
<p>既然是29位那么就是Running的值为：</p>
<pre><code>1110 0000 0000 0000 0000 0000 0000 0000
|||
31~29位
</code></pre>
<p>那低28位呢，就是记录当前线程的总线数啦：</p>
<pre><code>// Packing and unpacking ctl
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>从上述代码可以看到workerCountOf这个函数传入ctl之后，是通过CTL&amp;CAPACITY操作来获取当前运行线程总数的。</p>
<p>也就是RunningState|WorkCount&amp;CAPACITY，算出来的就是低28位的值。因为CAPACITY得到的就是高3位（29-31位）位0，低28位（0-28位）都是1，所以得到的就是ctl中低28位的值。</p>
<p>而runStateOf这个方法的话，算的就是RunningState|WorkCount&amp;CAPACITY，高3位的值，因为CAPACITY是CAPACITY的取反，所以得到的就是高3位（29-31位）为1，低28位（0-28位）为0，所以通过&amp;运算后，所得到的值就是高3为的值。</p>
<p>简单来说就是ctl中是高3位作为状态值，低28位作为线程总数值来进行存储。</p>
<p><strong>2.3.2 shutdownNow和shutdown的区别</strong></p>
<p>看源码发现有两种近乎一样的方法，shutdownNow和shutdown，设计者这么设计自然是有它的道理，那么这两个方法的区别在哪呢？</p>
<ul>
<li>shutdown会把线程池的状态改为SHUTDOWN，而shutdownNow把当前线程池状态改为STOP。</li>
<li>shutdown只会中断所有空闲的线程，而shutdownNow会中断所有的线程。</li>
<li>shutdown返回方法为空，会将当前任务队列中的所有任务执行完毕；而shutdownNow把任务队列中的所有任务都取出来返回。</li>
</ul>
<p><strong>2.3.3 线程复用原理</strong></p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre>
<p>就是任务在并不只执行创建时指定的firstTask第一任务，还会从任务队列的中自己主动取任务执行，而且是有或者无时间限定的阻塞等待，以保证线程的存活。</p>
<p>默认的是不允许。</p>
<p><strong>2.4 CountDownLatch和CyclicBarrier区别</strong></p>
<p>countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次。</p>
<p>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供Reset功能，可以多次使用。</p>
<p><strong>3. 多线程间通信的几种方式</strong></p>
<p>提及多线程又不得不提及多线程通信的机制。首先，要短信线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析：</p>
<p>题目：有两个线程A、B，A线程向一个集合里面依次添加元素”abc”字符串，一共添加十次，当添加到第五次的时候，希望B线程能够收到A线程的通知，然后B线程执行相关的业务操作。</p>
<p><strong>3.1使用volatile关键字</strong></p>
<pre><code>package thread;

/**
 *
 * @author hxz
 * @description 多线程测试类
 * @version 1.0
 * @data 2020年2月15日 上午9:10:09
 */
public class MyThreadTest {

    public static void main(String\[\] args) throws Exception {

        notifyThreadWithVolatile();

    }

    /**
     * 定义一个测试
     */
    private static volatile boolean flag = false;
    /**
     * 计算I++，当I==5时，通知线程B
     * @throws Exception
     */
    private static void notifyThreadWithVolatile() throws Exception {
        Thread thc = new Thread(&quot;线程A&quot;){
            @Override
            public void run() {
                for (int i = 0; i &lt; 10; i++) {
                    if (i == 5) {
                        flag = true;
                        try {
                            Thread.sleep(500L);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        break;
                    }
                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + i);
                }
            }
        };

        Thread thd = new Thread(&quot;线程B&quot;) {
            @Override
            public void run() {
                while (true) {
                    // 防止伪唤醒 所以使用了while
                    while (flag) {
                        System.out.println(Thread.currentThread().getName() + &quot;收到通知&quot;);
                        System.out.println(&quot;do something&quot;);
                        try {
                            Thread.sleep(500L);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        return ;
                    }

                }
            }
        };

        thd.start();
        Thread.sleep(1000L);
        thc.start();

    }
}
</code></pre>
<p>个人认为这是基本上最好的通信方式，因为A发出通知B能够立马接受并Do Something。</p>
]]></content>
    </entry>
</feed>