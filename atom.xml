<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-15T09:19:33.843Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[RabbitMQ使用教程(五)]]></title>
        <id>https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/</id>
        <link href="https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/">
        </link>
        <updated>2021-04-15T08:55:57.000Z</updated>
        <content type="html"><![CDATA[<p>4.7.主题模式（通配符模式）<br>
<img src="https://kangjn.github.io//post-images/1618477080812.png" alt="" loading="lazy"><br>
<img src="https://kangjn.github.io//post-images/1618477088471.png" alt="" loading="lazy"><br>
4.7.1.图示<br>
<img src="https://kangjn.github.io//post-images/1618477096171.png" alt="" loading="lazy"><br>
同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p>
<p>4.7.2.生产者</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Send {</p>
<pre><code>private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

public static void main(String[] argv) throws Exception {
    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明exchange
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);

    // 消息内容
    String message = &quot;Hello World!!&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes());
    System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);

    channel.close();
    connection.close();
}
</code></pre>
<p>}<br>
4.7.3.消费者1（前台系统）</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Recv {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;;

private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;);

    // 同一时刻服务器只会发一条消息给消费者
    channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，手动返回完成
    channel.basicConsume(QUEUE_NAME, false, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;);
        Thread.sleep(10);

        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}
</code></pre>
<p>}<br>
4.7.4.消费者2（搜索系统）</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;</p>
<p>public class Recv2 {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;;

private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;);

    // 同一时刻服务器只会发一条消息给消费者
    channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，手动返回完成
    channel.basicConsume(QUEUE_NAME, false, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;);
        Thread.sleep(10);

        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}
</code></pre>
<p>}<br>
5.Springboot集成RabbitMQ</p>
<pre><code>springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。
</code></pre>
<p>5.1.简单队列</p>
<p>1、配置pom文件，主要是添加spring-boot-starter-amqp的支持</p>
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
2、配置application.properties文件
配置rabbitmq的安装地址、端口以及账户信息
<p>spring.application.name=spirng-boot-rabbitmq<br>
spring.rabbitmq.host=127.0.0.1<br>
spring.rabbitmq.port=5672<br>
spring.rabbitmq.username=admin<br>
spring.rabbitmq.password=admin<br>
3、配置队列</p>
<p>package com.zpc.rabbitmq;</p>
<p>import org.springframework.amqp.core.Queue;<br>
import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>@Configuration<br>
public class RabbitConfig {<br>
@Bean<br>
public Queue queue() {<br>
return new Queue(&quot;q_hello&quot;);<br>
}<br>
}<br>
4、发送者</p>
<p>package com.zpc.rabbitmq;</p>
<p>import org.springframework.amqp.core.AmqpTemplate;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.stereotype.Component;</p>
<p>import java.text.SimpleDateFormat;<br>
import java.util.Date;</p>
<p>@Component<br>
public class HelloSender {<br>
@Autowired<br>
private AmqpTemplate rabbitTemplate;</p>
<pre><code>public void send() {
    String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制
    String context = &quot;hello &quot; + date;
    System.out.println(&quot;Sender : &quot; + context);
    //简单对列的情况下routingKey即为Q名
    this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context);
}
</code></pre>
<p>}<br>
5、接收者</p>
<p>package com.zpc.rabbitmq;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_hello&quot;)<br>
public class HelloReceiver {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;Receiver  : &quot; + hello);
}
</code></pre>
<p>}<br>
6、测试</p>
<p>package com.zpc.rabbitmq;</p>
<p>import org.junit.Test;<br>
import org.junit.runner.RunWith;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.boot.test.context.SpringBootTest;<br>
import org.springframework.test.context.junit4.SpringRunner;</p>
<p>@RunWith(SpringRunner.class)<br>
@SpringBootTest<br>
public class RabbitMqHelloTest {</p>
<pre><code>@Autowired
private HelloSender helloSender;

@Test
public void hello() throws Exception {
    helloSender.send();
}
</code></pre>
<p>}<br>
5.2.多对多使用（Work模式）</p>
<p>注册两个Receiver:</p>
<p>package com.zpc.rabbitmq;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_hello&quot;)<br>
public class HelloReceiver2 {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;Receiver2  : &quot; + hello);
}
</code></pre>
<p>}<br>
@Test<br>
public void oneToMany() throws Exception {<br>
for (int i=0;i&lt;100;i++){<br>
helloSender.send(i);<br>
Thread.sleep(300);<br>
}<br>
}<br>
public void send(int i) {<br>
String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制<br>
String context = &quot;hello &quot; + i + &quot; &quot; + date;<br>
System.out.println(&quot;Sender : &quot; + context);<br>
//简单对列的情况下routingKey即为Q名<br>
this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context);<br>
}<br>
5.3.Topic Exchange（主题模式）</p>
<pre><code>topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列
</code></pre>
<p>首先对topic规则配置，这里使用两个队列(消费者)来演示。<br>
1)配置队列，绑定交换机</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import org.springframework.amqp.core.Binding;<br>
import org.springframework.amqp.core.BindingBuilder;<br>
import org.springframework.amqp.core.Queue;<br>
import org.springframework.amqp.core.TopicExchange;<br>
import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>@Configuration<br>
public class TopicRabbitConfig {</p>
<pre><code>final static String message = &quot;q_topic_message&quot;;
final static String messages = &quot;q_topic_messages&quot;;

@Bean
public Queue queueMessage() {
    return new Queue(TopicRabbitConfig.message);
}

@Bean
public Queue queueMessages() {
    return new Queue(TopicRabbitConfig.messages);
}

/**
 * 声明一个Topic类型的交换机
 * @return
 */
@Bean
TopicExchange exchange() {
    return new TopicExchange(&quot;mybootexchange&quot;);
}

/**
 * 绑定Q到交换机,并且指定routingKey
 * @param queueMessage
 * @param exchange
 * @return
 */
@Bean
Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) {
    return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);
}

@Bean
Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) {
    return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);
}
</code></pre>
<p>}<br>
2)创建2个消费者<br>
q_topic_message 和q_topic_messages</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_topic_message&quot;)<br>
public class Receiver1 {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;Receiver1  : &quot; + hello);
}
</code></pre>
<p>}<br>
package com.zpc.rabbitmq.topic;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_topic_messages&quot;)<br>
public class Receiver2 {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;Receiver2 : &quot; + hello);
}
</code></pre>
<p>}<br>
3)消息发送者（生产者）</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import org.springframework.amqp.core.AmqpTemplate;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
public class MsgSender {</p>
<pre><code>@Autowired
private AmqpTemplate rabbitTemplate;

public void send1() {
    String context = &quot;hi, i am message 1&quot;;
    System.out.println(&quot;Sender : &quot; + context);
    this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context);
}


public void send2() {
    String context = &quot;hi, i am messages 2&quot;;
    System.out.println(&quot;Sender : &quot; + context);
    this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context);
}
</code></pre>
<p>}<br>
send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。<br>
4)测试</p>
<p>package com.zpc.rabbitmq.topic;</p>
<p>import org.junit.Test;<br>
import org.junit.runner.RunWith;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.boot.test.context.SpringBootTest;<br>
import org.springframework.test.context.junit4.SpringRunner;</p>
<p>@RunWith(SpringRunner.class)<br>
@SpringBootTest<br>
public class RabbitTopicTest {</p>
<pre><code>@Autowired
private MsgSender msgSender;

@Test
public void send1() throws Exception {
    msgSender.send1();
}

@Test
public void send2() throws Exception {
    msgSender.send2();
}
</code></pre>
<p>}<br>
5.4.Fanout Exchange（订阅模式）</p>
<pre><code>Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。
1)配置队列，绑定交换机
</code></pre>
<p>package com.zpc.rabbitmq.fanout;</p>
<p>import org.springframework.amqp.core.Binding;<br>
import org.springframework.amqp.core.BindingBuilder;<br>
import org.springframework.amqp.core.FanoutExchange;<br>
import org.springframework.amqp.core.Queue;<br>
import org.springframework.context.annotation.Bean;<br>
import org.springframework.context.annotation.Configuration;</p>
<p>@Configuration<br>
public class FanoutRabbitConfig {</p>
<pre><code>@Bean
public Queue aMessage() {
    return new Queue(&quot;q_fanout_A&quot;);
}

@Bean
public Queue bMessage() {
    return new Queue(&quot;q_fanout_B&quot;);
}

@Bean
public Queue cMessage() {
    return new Queue(&quot;q_fanout_C&quot;);
}

@Bean
FanoutExchange fanoutExchange() {
    return new FanoutExchange(&quot;mybootfanoutExchange&quot;);
}

@Bean
Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) {
    return BindingBuilder.bind(aMessage).to(fanoutExchange);
}

@Bean
Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) {
    return BindingBuilder.bind(bMessage).to(fanoutExchange);
}

@Bean
Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) {
    return BindingBuilder.bind(cMessage).to(fanoutExchange);
}
</code></pre>
<p>}<br>
2）创建3个消费者</p>
<p>package com.zpc.rabbitmq.fanout;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_fanout_A&quot;)<br>
public class ReceiverA {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;AReceiver  : &quot; + hello + &quot;/n&quot;);
}
</code></pre>
<p>}<br>
package com.zpc.rabbitmq.fanout;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_fanout_B&quot;)<br>
public class ReceiverB {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;BReceiver  : &quot; + hello + &quot;/n&quot;);
}
</code></pre>
<p>}<br>
package com.zpc.rabbitmq.fanout;</p>
<p>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>
import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
@RabbitListener(queues = &quot;q_fanout_C&quot;)<br>
public class ReceiverC {</p>
<pre><code>@RabbitHandler
public void process(String hello) {
    System.out.println(&quot;CReceiver  : &quot; + hello + &quot;/n&quot;);
}
</code></pre>
<p>}</p>
<p>3）生产者</p>
<p>package com.zpc.rabbitmq.fanout;</p>
<p>import org.springframework.amqp.core.AmqpTemplate;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.stereotype.Component;</p>
<p>@Component<br>
public class MsgSenderFanout {</p>
<pre><code>@Autowired
private AmqpTemplate rabbitTemplate;

public void send() {
    String context = &quot;hi, fanout msg &quot;;
    System.out.println(&quot;Sender : &quot; + context);
    this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context);
}
</code></pre>
<p>}<br>
4）测试</p>
<p>package com.zpc.rabbitmq.fanout;</p>
<p>import org.junit.Test;<br>
import org.junit.runner.RunWith;<br>
import org.springframework.beans.factory.annotation.Autowired;<br>
import org.springframework.boot.test.context.SpringBootTest;<br>
import org.springframework.test.context.junit4.SpringRunner;</p>
<p>@RunWith(SpringRunner.class)<br>
@SpringBootTest<br>
public class RabbitFanoutTest {</p>
<pre><code>@Autowired
private MsgSenderFanout msgSender;

@Test
public void send1() throws Exception {
    msgSender.send();
}
</code></pre>
<p>}<br>
结果如下，三个消费者都收到消息：<br>
AReceiver : hi, fanout msg<br>
CReceiver : hi, fanout msg<br>
BReceiver : hi, fanout msg<br>
6.总结</p>
<pre><code>使用MQ实现商品数据的同步优势：
1、降低系统间耦合度
2、便于管理数据的同步（数据一致性）
</code></pre>
<p>推荐阅读<br>
《RabbitMQ详解》</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ使用教程(四)]]></title>
        <id>https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/</id>
        <link href="https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/">
        </link>
        <updated>2021-04-15T08:40:40.000Z</updated>
        <content type="html"><![CDATA[<p>4.4.消息的确认模式</p>
<p>消费者从队列中获取消息，服务端如何知道消息已经被消费呢？</p>
<p>模式1：自动确认<br>
只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。<br>
模式2：手动确认<br>
消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。</p>
<p>手动模式：<br>
<img src="https://kangjn.github.io//post-images/1618476346645.png" alt="" loading="lazy"></p>
<p>自动模式：<br>
<img src="https://kangjn.github.io//post-images/1618476205553.png" alt="" loading="lazy"><br>
4.5.订阅模式<br>
<img src="https://kangjn.github.io//post-images/1618476386137.png" alt="" loading="lazy"><br>
4.5.1.图示<br>
<img src="https://kangjn.github.io//post-images/1618476431946.png" alt="" loading="lazy"></p>
<p>解读：<br>
1、1个生产者，多个消费者<br>
2、每一个消费者都有自己的一个队列<br>
3、生产者没有将消息直接发送到队列，而是发送到了交换机<br>
4、每个队列都要绑定到交换机<br>
5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的<br>
注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费<br>
<img src="https://kangjn.github.io//post-images/1618476439883.png" alt="" loading="lazy"></p>
<p>4.5.2.消息的生产者（看作是后台系统）<br>
向交换机中发送消息。</p>
<p>package com.zpc.rabbitmq.subscribe;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;</p>
<p>public class Send {</p>
<pre><code>private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

public static void main(String[] argv) throws Exception {
    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明exchange
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);

    // 消息内容
    String message = &quot;Hello World!&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
    System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);

    channel.close();
    connection.close();
}
</code></pre>
<p>}<br>
注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。<br>
4.5.3.消费者1（看作是前台系统）</p>
<p>package com.zpc.rabbitmq.subscribe;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Recv {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_work1&quot;;

private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);

    // 同一时刻服务器只会发一条消息给消费者
    channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，手动返回完成
    channel.basicConsume(QUEUE_NAME, false, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;);
        Thread.sleep(10);

        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}
</code></pre>
<p>}<br>
4.5.4.消费者2（看作是搜索系统）</p>
<p>package com.zpc.rabbitmq.subscribe;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Recv2 {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_work2&quot;;

private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);

    // 同一时刻服务器只会发一条消息给消费者
    channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，手动返回完成
    channel.basicConsume(QUEUE_NAME, false, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;);
        Thread.sleep(10);

        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}
</code></pre>
<p>}<br>
4.5.5.测试<br>
测试结果：<br>
同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p>
<p>在管理工具中查看队列和交换机的绑定关系：<br>
<img src="https://kangjn.github.io//post-images/1618476617492.png" alt="" loading="lazy"><br>
4.6.路由模式<br>
<img src="https://kangjn.github.io//post-images/1618476772382.png" alt="" loading="lazy"></p>
<p>4.6.1.图示<br>
<img src="https://kangjn.github.io//post-images/1618476797031.png" alt="" loading="lazy"></p>
<p>4.6.2.生产者<br>
<img src="https://kangjn.github.io//post-images/1618476806674.png" alt="" loading="lazy"><br>
4.6.3.消费者1(假设是前台系统)<br>
<img src="https://kangjn.github.io//post-images/1618476905097.png" alt="" loading="lazy"><br>
4.6.4.消费2（假设是搜索系统）<br>
<img src="https://kangjn.github.io//post-images/1618476911474.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ使用教程(三)]]></title>
        <id>https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/</id>
        <link href="https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/">
        </link>
        <updated>2021-04-15T08:23:31.000Z</updated>
        <content type="html"><![CDATA[<p>4、学习五种队列<br>
4.1 简单队列<br>
4.1.1.图示<br>
<img src="https://kangjn.github.io//post-images/1618475273831.png" alt="" loading="lazy"><br>
P：消息的生产者<br>
C：消息的消费者<br>
红色：队列</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息。<br>
4.1.2.导入RabbitMQ的客户端依赖</p>
<dependency>
   <groupId>com.rabbitmq</groupId>
   <artifactId>amqp-client</artifactId>
   <version>3.4.1</version>
</dependency>
<p>4.1.3.获取MQ的连接</p>
<p>package com.zpc.rabbitmq.util;<br>
import com.rabbitmq.client.ConnectionFactory;<br>
import com.rabbitmq.client.Connection;</p>
<p>public class ConnectionUtil {</p>
<pre><code>public static Connection getConnection() throws Exception {
    //定义连接工厂
    ConnectionFactory factory = new ConnectionFactory();
    //设置服务地址
    factory.setHost(&quot;localhost&quot;);
    //端口
    factory.setPort(5672);
    //设置账号信息，用户名、密码、vhost
    factory.setVirtualHost(&quot;testhost&quot;);
    factory.setUsername(&quot;admin&quot;);
    factory.setPassword(&quot;admin&quot;);
    // 通过工程获取连接
    Connection connection = factory.newConnection();
    return connection;
}
</code></pre>
<p>}</p>
<p>4.1.4.生产者发送消息到队列</p>
<p>package com.zpc.rabbitmq.simple;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;</p>
<p>public class Send {</p>
<pre><code>private final static String QUEUE_NAME = &quot;q_test_01&quot;;

public static void main(String[] argv) throws Exception {
    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    // 从连接中创建通道
    Channel channel = connection.createChannel();

    // 声明（创建）队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 消息内容
    String message = &quot;Hello World!&quot;;
    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
    System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);
    //关闭通道和连接
    channel.close();
    connection.close();
}
</code></pre>
<p>}<br>
4.1.5.管理工具中查看消息<br>
<img src="https://kangjn.github.io//post-images/1618475362118.png" alt="" loading="lazy"></p>
<p>点击上面的队列名称，查询具体的队列中的信息：<br>
<img src="https://kangjn.github.io//post-images/1618475394411.png" alt="" loading="lazy"><br>
4.1.6.消费者从队列中获取消息</p>
<p>package com.zpc.rabbitmq.simple;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;</p>
<p>public class Recv {</p>
<pre><code>private final static String QUEUE_NAME = &quot;q_test_01&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    // 从连接中创建通道
    Channel channel = connection.createChannel();
    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);

    // 监听队列
    channel.basicConsume(QUEUE_NAME, true, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;);
    }
}
</code></pre>
<p>}<br>
4.2.Work模式<br>
<img src="https://kangjn.github.io//post-images/1618475631375.png" alt="" loading="lazy"><br>
4.2.1.图示<br>
<img src="https://kangjn.github.io//post-images/1618475639907.png" alt="" loading="lazy"><br>
一个生产者、2个消费者。</p>
<p>一个消息只能被一个消费者获取。<br>
4.2.2.消费者1</p>
<p>package com.zpc.rabbitmq.work;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;<br>
import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Recv {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 同一时刻服务器只会发一条消息给消费者
    //channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，false表示手动返回完成状态，true表示自动
    channel.basicConsume(QUEUE_NAME, true, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;);
        //休眠
        Thread.sleep(10);
        // 返回确认状态，注释掉表示使用自动确认模式
        //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)；
      }
}
</code></pre>
<p>}<br>
4.2.3.消费者2</p>
<p>package com.zpc.rabbitmq.work;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;<br>
import com.rabbitmq.client.QueueingConsumer;<br>
import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>public class Recv2 {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

public static void main(String[] argv) throws Exception {

    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 同一时刻服务器只会发一条消息给消费者
    //channel.basicQos(1);

    // 定义队列的消费者
    QueueingConsumer consumer = new QueueingConsumer(channel);
    // 监听队列，false表示手动返回完成状态，true表示自动
    channel.basicConsume(QUEUE_NAME, true, consumer);

    // 获取消息
    while (true) {
        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
        String message = new String(delivery.getBody());
        System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;);
        // 休眠1秒
        Thread.sleep(1000);
        //下面这行注释掉表示使用自动确认模式
        //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
}
</code></pre>
<p>}<br>
4.2.4.生产者<br>
向队列中发送100条消息。</p>
<p>package com.zpc.rabbitmq.work;</p>
<p>import com.zpc.rabbitmq.util.ConnectionUtil;</p>
<p>import com.rabbitmq.client.Channel;<br>
import com.rabbitmq.client.Connection;</p>
<p>public class Send {</p>
<pre><code>private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

public static void main(String[] argv) throws Exception {
    // 获取到连接以及mq通道
    Connection connection = ConnectionUtil.getConnection();
    Channel channel = connection.createChannel();

    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    for (int i = 0; i &lt; 100; i++) {
        // 消息内容
        String message = &quot;&quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);

        Thread.sleep(i * 10);
    }

    channel.close();
    connection.close();
}
</code></pre>
<p>}<br>
4.2.5.测试<br>
测试结果：<br>
1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。<br>
2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。</p>
<pre><code>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。
RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。

怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。
basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。

2个概念

轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。

公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。
</code></pre>
<p>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br>
还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。<br>
4.3.Work模式的“能者多劳”</p>
<p>打开上述代码的注释：</p>
<p>// 同一时刻服务器只会发一条消息给消费者<br>
channel.basicQos(1);<br>
//开启这行 表示使用手动确认模式<br>
channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>
同时改为手动确认：</p>
<p>// 监听队列，false表示手动返回完成状态，true表示自动<br>
channel.basicConsume(QUEUE_NAME, false, consumer);</p>
<p>测试：<br>
消费者1比消费者2获取的消息更多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ使用教程(二)]]></title>
        <id>https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/</id>
        <link href="https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/">
        </link>
        <updated>2021-04-15T08:03:23.000Z</updated>
        <content type="html"><![CDATA[<p>2.4.学习5种队列<br>
<img src="https://kangjn.github.io//post-images/1618473879189.png" alt="" loading="lazy"></p>
<p>2.5.安装文档<br>
<img src="https://kangjn.github.io//post-images/1618473885597.png" alt="" loading="lazy"></p>
<p>3.搭建RabbitMQ环境<br>
3.1.下载</p>
<p>下载地址：http://www.rabbitmq.com/download.html<br>
3.2.windows下安装</p>
<p>3.2.1.安装Erlang<br>
下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装</p>
<p>3.2.2.安装RabbitMQ<br>
3.2.3.启用管理工具<br>
<img src="https://kangjn.github.io//post-images/1618474136752.png" alt="" loading="lazy"><br>
1、双击<br>
2、进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin输入命令：<br>
rabbitmq-plugins enable rabbitmq_management<br>
<img src="https://kangjn.github.io//post-images/1618474162617.png" alt="" loading="lazy"><br>
这样就启动了管理工具，可以试一下命令：<br>
停止：net stop RabbitMQ<br>
启动：net start RabbitMQ</p>
<p>3、在浏览器中输入地址查看：http://127.0.0.1:15672/<br>
<img src="https://kangjn.github.io//post-images/1618474216700.png" alt="" loading="lazy"><br>
4、使用默认账号登录：guest/ guest<br>
3.3.Linux下安装</p>
<p>3.3.1.安装Erlang<br>
3.3.2.添加yum支持<br>
cd /usr/local/src/<br>
mkdir rabbitmq<br>
cd rabbitmq</p>
<p>wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm<br>
rpm -Uvh erlang-solutions-1.0-1.noarch.rpm</p>
<p>rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc</p>
<p>使用yum安装：<br>
sudo yum install erlang</p>
<p><img src="https://kangjn.github.io//post-images/1618474485653.png" alt="" loading="lazy"><br>
3.3.3.安装RabbitMQ<br>
上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/<br>
安装：<br>
rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm</p>
<p>3.3.4.启动、停止<br>
service rabbitmq-server start<br>
service rabbitmq-server stop<br>
service rabbitmq-server restart<br>
3.3.5.设置开机启动<br>
chkconfig rabbitmq-server on<br>
3.3.6.设置配置文件<br>
cd /etc/rabbitmq<br>
cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/</p>
<p>mv rabbitmq.config.example rabbitmq.config<br>
3.3.7.开启用户远程访问<br>
vi /etc/rabbitmq/rabbitmq.config<br>
<img src="https://kangjn.github.io//post-images/1618474539694.png" alt="" loading="lazy"><br>
注意要去掉后面的逗号。<br>
3.3.8.开启web界面管理工具<br>
rabbitmq-plugins enable rabbitmq_management<br>
service rabbitmq-server restart<br>
3.3.9.防火墙开放15672端口<br>
/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT<br>
/etc/rc.d/init.d/iptables save<br>
3.4.安装的注意事项</p>
<p>1、推荐使用默认的安装路径<br>
2、系统用户名必须是英文</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ使用教程(一)]]></title>
        <id>https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/</id>
        <link href="https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/">
        </link>
        <updated>2021-04-15T07:53:27.000Z</updated>
        <content type="html"><![CDATA[<p>1.什么是MQ</p>
<pre><code>消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
其主要用途：不同进程Process/线程Thread之间通信。
</code></pre>
<p>为什么会产生消息队列？有几个原因：</p>
<pre><code>不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；

不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；

关于消息队列的详细介绍请参阅：
《Java帝国之消息队列》
《一个故事告诉你什么是消息队列》
《到底什么时候该使用MQ》

MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。
2.RabbitMQ
</code></pre>
<p>2.1.RabbitMQ的简介<br>
<img src="https://kangjn.github.io//post-images/1618473530111.png" alt="" loading="lazy"></p>
<p>开发语言：Erlang – 面向并发的编程语言。<br>
<img src="https://kangjn.github.io//post-images/1618473637764.png" alt="" loading="lazy"></p>
<p>2.1.1.AMQP<br>
AMQP是消息队列的一个协议。<br>
<img src="https://kangjn.github.io//post-images/1618473691679.png" alt="" loading="lazy"></p>
<p>2.2.官网<br>
<img src="https://kangjn.github.io//post-images/1618473710782.png" alt="" loading="lazy"><br>
2.3.MQ的其他产品<br>
<img src="https://kangjn.github.io//post-images/1618473783159.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试题目（二）]]></title>
        <id>https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/</id>
        <link href="https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/">
        </link>
        <updated>2021-04-15T07:20:09.000Z</updated>
        <content type="html"><![CDATA[<p><strong>解决HTML5新标签的兼容性：</strong></p>
<p>&lt;![if lt IE 9]&gt;</p>
<script src="html5shiv.js"></script>//解决IE6-8支持HTML5新元素
<script src="respond.js"></script>//解决IE6-8对css Media Query//媒体查询
<p>&lt;![endif]&gt;</p>
<p><strong>a:hover，a:active失效的问题？(lvha)</strong></p>
<p>现象：</p>
<p>a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。</p>
<p>解决方式：</p>
<p>a:link {color:black}</p>
<p>a:visited{color:pink}</p>
<p>a:hover {color: blue}</p>
<p>a:active {color: green}</p>
<p>将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。</p>
<p>如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。</p>
<p>为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。</p>
<p><strong>选择器优先级？</strong></p>
<p>内联样式&gt;内部样式&gt;外部样式</p>
<p>！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式</p>
<p>注意：</p>
<p>1、!important声明的样式优先级最高，如果冲突再进行计算。</p>
<p>2、如果优先级相同，则选择最后出现的样式。</p>
<p>3、继承得到的样式的优先级最低。</p>
<p><strong>文本怎么自动换行？</strong></p>
<p>word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。</p>
<p>word-wrap:normal</p>
<p>word-wrap:break-word</p>
<p>box-sizing模型？</p>
<p>content-box:默认</p>
<p>padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding</p>
<p>border-box:</p>
<p>padding和border包含在元素的宽度内，元素的实际宽度为：width</p>
<p>js中创建自定义对象 ?</p>
<p>var f=function(){}</p>
<p>new Object()</p>
<p>function f()</p>
<p><strong>this?</strong></p>
<p>指向调用它的对象，如果没有，就指window</p>
<p><strong>HTML5表单新元素？</strong></p>
<p>date time color number range email url search</p>
<p><strong>5种常见的HTTP状态码及意义？</strong></p>
<p>200:请求成功</p>
<p>301、302：永久重定向/暂时重定向</p>
<p>400：请求格式错误</p>
<p>404：找不到资源</p>
<p>500：服务器内部错误</p>
<p><strong>怎么让一个图片在一个DIV中垂直居中对齐？</strong></p>
<p>父元素使用相对定位</p>
<p>子元素使用绝对定位</p>
<p><strong>怎么让文字垂直居中对齐？</strong></p>
<p>一行文字父元素不固定：padding:20px</p>
<p>父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell</p>
<p><strong>如何让图片跟文字在居中显示：</strong></p>
<p>父元素设置为vertical-align:middle</p>
<p><strong>浏览器兼容？</strong></p>
<p>1、不同的浏览器默认样式不一样：padding margin</p>
<p>2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden</p>
<p>3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距</p>
<p><strong>页面优化/站点优化？</strong></p>
<p>1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度</p>
<p>2、代码压缩/css/js  yui compressor</p>
<p>数组的方法：</p>
<p>join concat</p>
<p>push pop</p>
<p>unshift shift</p>
<p>slice</p>
<p>splice</p>
<p>正则表达式：</p>
<p>\d数字</p>
<p>\s空白字符</p>
<p>\w数字、字母、下划线</p>
<p>？ 0-1  或 改为懒惰模式</p>
<ul>
<li>0-n</li>
</ul>
<ul>
<li>1-n</li>
</ul>
<p>^  开关</p>
<p>$  结尾</p>
<p>\b 边界</p>
<p><strong>new 一个对象具体干了什么？</strong></p>
<p>第一步是建立一个新对象；</p>
<p>第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象；</p>
<p>第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。</p>
<p><strong>如何判断一个对象是否为数组？</strong></p>
<p>typeof &quot;sflkj&quot;</p>
<p>typeof无法判断数组跟对象</p>
<p>[] instanceof Array</p>
<p>Array.prototype.isPrototypeOf([])</p>
<p>Array.isArray([])</p>
<p><strong>获取一个选项卡的值？</strong></p>
<select name="sl" id="s1" onchange="showinfo()">
<option value="1">aa</option>
<option value="2">bb</option>
  </select>
<script>

function showinfo(){

var sel=document.getElementById("s1");

var i=sel.selectedIndex;

var result=sel.options[i].value;

}

</script>
<p><strong>浏览器对象有哪些？</strong></p>
<p>navigator</p>
<p>history</p>
<p>window</p>
<p>location</p>
<p>screen</p>
<p>event</p>
<p>document</p>
<p><strong>window对象的常用方法？</strong></p>
<p>alert</p>
<p>confirm</p>
<p>prompt</p>
<p>close</p>
<p><strong>js绑定事件：</strong></p>
<p>btnObj.addEventListener(&quot;click&quot;,function(){})</p>
<p>jquery 把变量$的控制权交给其他JS库</p>
<p>jQuery.noConflict();</p>
<p>jQuery(function($){})</p>
<p>jQuery 遍历？（$.each()方法）</p>
<ul>
  <li>asdf</li>
  <li>luili</li>
  <li>234</li>
  </ul>
<script>

var m=$("ul li");

m.each(function(i){

if(i==0){

$(this).css("font-size","18px")

}

})

</script>
<p><strong>怎么把一个JSON字符串转换成一个js对象？</strong></p>
<p>var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}'</p>
<p>var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}</p>
<p>把一个js对象转换成一个josn字符吕？</p>
<p>var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}</p>
<p>var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}'</p>
<p>表单序列化成字符串：serialize（）</p>
<p>序列化成json对象：serializeArray()</p>
<p><strong>手机端头部怎么写？</strong></p>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<p><strong>不通过插件实现自响应布局？</strong></p>
<p>CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局</p>
<p>CSS的媒体查询？</p>
<p>@media screen and(min-width:990px){//(一个css文件内)</p>
<p>#id{</p>
<p>float:left</p>
<p>}</p>
<p>}</p>
<p>@media screen and(min-width:700px) and (max-width:989px){</p>
<p>#id{</p>
<p>float:left</p>
<p>}</p>
<p>@media screen and(max-width:699px){</p>
<p>}</p>
<p><strong>angularjs？</strong></p>
<p>采用MVC模式</p>
<p>数据绑定</p>
<p>依赖注入</p>
<p>模块化设计</p>
<p>初始化一个模型数据</p>
<p>ng-bind=&quot;name&quot;</p>
<p>ng-repeat=&quot;data in array&quot;</p>
<html ng-app="myApp">
<div ng-controller="myCtrl">
</div>
<p>angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){</p>
<p>.controller(&quot;myCtrl&quot;,function($scope){</p>
<p>$scope.newsTitle=&quot;hello&quot;</p>
<p>})</p>
<p>}</p>
<p><strong>什么是高内聚，低耦合？</strong></p>
<p>高内聚：一个模块内的元素的关系赵紧密越好</p>
<p>低耦合：不同模块间的关系尽量不要有关联</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试题目（一）]]></title>
        <id>https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/</id>
        <link href="https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/">
        </link>
        <updated>2021-04-14T06:47:35.000Z</updated>
        <content type="html"><![CDATA[<p><strong>什么是闭包？</strong><br>
指有权访问另一个函数作用域中变量的函数</p>
<p><strong>null 和undefined的区别？</strong></p>
<p>共同点：都是原始类型，保存在栈中变量本地<br>
不同点：<br>
undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用<br>
null:表示一个变量不再指向任何对象地址<br>
表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用</p>
<p><strong>常见行内元素和块级元素有哪些，他们有什么区别？</strong><br>
行内元素：span img a u s i input select<br>
块级元素：div ul ol li dt dd h1-h6<br>
块级元素会单独占一行，行内元素会在一行显示。</p>
<p><strong>什么是ajax？</strong><br>
ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。<br>
实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新：<br>
如何创建XMLHttpRequest请求步骤：<br>
1、获取ajax对象<br>
var xhr=new XMLHttpRequest();<br>
2、创建请求:调用XMLHttpRequest对象的open方法<br>
xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步])<br>
3、回调函数的处理<br>
xhr.onreadystatechange=function(){<br>
if(xhr.readyState<mark>4){<br>
if(xhr.status</mark>200){<br>
var txt=xhr.responseText/responseXML<br>
}<br>
}<br>
}<br>
4、发送请求<br>
xhr.send(&quot;name=value$pwd=value&quot;);<br>
readyState属性：<br>
0=未初始化<br>
1=正在加载<br>
2=以加载<br>
3=交互中<br>
4=加载完成</p>
<p>Ajax异步请求？<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …e:&quot;post&quot;,
data:'>.ajax(
{
url:&quot;destination.php&quot;,
type:&quot;post&quot;,
data:</span>(&quot;#id&quot;).val(),<br>
dataType:&quot;json&quot;,<br>
success:function(data){<br>
console.log(data)<br>
}<br>
error:function(){<br>
window.alert(&quot;error&quot;)<br>
}<br>
}<br>
)</p>
<p><strong>AJAX的优缺点？</strong><br>
优点：<br>
页面局部刷新，提高用户体验<br>
减轻服务器负担<br>
具有更迅速的响应能力<br>
能被广泛支持</p>
<p>缺点：<br>
不支持浏览器后退按钮<br>
安全问题<br>
对搜索引擎支持比较弱</p>
<p>html中有哪些定位？<br>
static:默认规则定位。<br>
absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间<br>
relative:相对定位，相对于初始位置定位/占页面空间<br>
fixed:固定定位，相对于浏览器窗口</p>
<p><strong>http</strong><br>
建立TCP连接<br>
发送请求命令<br>
发送请求头部<br>
服务器应答<br>
服务器发送应答头部<br>
服务器发送应答具体信息<br>
关闭连接</p>
<p><strong>如何居中DIV？</strong><br>
给DIV设置一个宽度，再设置margin为:0 auto;</p>
<p><strong>如何居中一个浮动元素？</strong><br>
使用一个居中显示的DIV包含些浮动元素。</p>
<pre><code>position:fixed;//固定定位
    width: 200px;
    height: 200px;
    background: red;
    margin-left:-100px;
    margin-top: -100px;
    left: 50%;
    top: 50%;
</code></pre>
<p><strong>纯CSS实现一个三角形？</strong><br>
width: 0;<br>
height: 0;<br>
border:25px solid transparent;<br>
border-top-color: red;</p>
<p><strong>重写trim()方法</strong><br>
if(String.prototype.trim===undefined){<br>
String.prototype.trim=function () {<br>
return this.replace(/^\s+|\s+$/g)<br>
}<br>
}<br>
var str=&quot; helloworld &quot;;<br>
document.write(&quot;|&quot;+str+&quot;|<br>
&quot;);<br>
str=str.trim();<br>
document.write(&quot;|&quot;+str+&quot;|&quot;);</p>
<p>function trim(str){//同时去掉开头和结尾的空字符<br>
var reg=/^\s+|\s+$/g;<br>
return str.replace(reg,&quot;&quot;);<br>
}<br>
var str=&quot; zhang dong &quot;;<br>
console.log(ltrim(str));//&quot;zhang dong &quot;<br>
console.log(rtrim(str));//&quot; zhang dong&quot;<br>
console.log(trim(str));//&quot;zhang dong&quot;</p>
<p><strong>水仙花数</strong><br>
var a,b,c<br>
for(var i=100;i&lt;1000;i++){<br>
a=parseInt(i%10);<br>
b=parseInt((i/10)%10);<br>
c=parseInt(i/100);<br>
if(i<mark>aaa+bbb+ccc){<br>
console.log(i);<br>
}<br>
}<br>
<strong>判断某一年是不是闰年</strong><br>
function isLeap(year){<br>
console.log(year%4</mark>0&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;);<br>
}<br>
isLeap(prompt(&quot;主输入年份&quot;));</p>
<p><strong>在单词后面加上数字</strong><br>
var str=&quot;one two three four&quot;;<br>
var i=4;<br>
var reg=/\b[a-z]+\b/g;<br>
str=str.replace(reg,function(kw){<br>
return kw+i++;<br>
})<br>
console.log(str);</p>
<p><strong>判断是不是数组</strong><br>
var str=[]<br>
Array.prototype.isPrototypeOf(str);//true<br>
Object.prototype.toString.call(str);//[Object Array];<br>
str instanceof Array;<br>
Array.isArray([])</p>
<p><strong>什么是继承？</strong><br>
父对象已有的成员，子对象不用重复定义，就可以直接使用</p>
<p><strong>什么是原型？</strong><br>
每个函数都有一个prototype属性，该属性引用的就是原型对象，<br>
原型对象就是保存共有属性和方法的对象</p>
<p><strong>window窗口的全局对象？</strong><br>
history<br>
navigator<br>
screen<br>
location<br>
event</p>
<p><strong>动态加载Dom?</strong><br>
var frg=document.createDocumentFragment();<br>
var m=document.createElement(&quot;div&quot;);<br>
m.innerHTML=&quot;this is first page&quot;;<br>
frg.appendChild(m);<br>
document.body.appendChild(frg);<br>
<strong>数组去重？</strong><br>
var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]<br>
function unique(arr){<br>
for(var i=0,arr2={};i&lt;arr.length;i++){<br>
arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1);</p>
<p>}</p>
<p>var arr=[];<br>
for(var key in arr2){<br>
arr.push(key)<br>
}<br>
return arr;<br>
}<br>
console.log(unique(arr));</p>
<p>var arr1=[2,5,9,1,7]<br>
function sort(arr){<br>
for(var i=0;iarr[j+1]]){<br>
var temp=arr[j];<br>
arr[j]=arr[j+1];<br>
arr[j+1]=temp;<br>
}<br>
}<br>
}<br>
}<br>
sort(arr1);<br>
console.log(arr1)</p>
<p><strong>数组降维</strong><br>
var arr=[[1,2,3],[1,3,2]];<br>
var res=Array.prototype.concat.apply([],arr)<br>
console.log(res);</p>
<p><strong>如何理解HTML语义化？</strong><br>
可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性<br>
常用的语义化标签：</p>
<p><strong>哪些属性可以继承？</strong><br>
font-size<br>
font-family<br>
color</p>
<p>display:none和visibility:hidden的区别？<br>
display不占据页面空间<br>
visibility仍然占据空间</p>
<p><strong>css3伪类选择器</strong><br>
:enabled<br>
:disabled<br>
:checked<br>
:firtt-child :last-child</p>
<p><strong>为什么建议在设置背景图像的同时还设置背景颜色？</strong><br>
如果因为各种原因图片无法加载的时候，页面会显示背景颜色。</p>
<p><strong>CSS sprite的优缺点？</strong><br>
把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位<br>
优点：<br>
减少网页的http请求，提高性能<br>
减少图片的大小<br>
维护更方便，只需要在一张图片上修改就可以。</p>
<p>缺点：<br>
图片合成比较麻烦<br>
背景设置时需要得到每一个图片的精确位置</p>
<p>CSS3新特性<br>
box-shadow<br>
border-radius<br>
text-shadow</p>
]]></content>
    </entry>
</feed>