<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-12-10T01:02:16.055Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[与神对话摘抄（二）]]></title>
        <id>https://kangjn.github.io/post/yu-shen-dui-hua-zhai-chao-er/</id>
        <link href="https://kangjn.github.io/post/yu-shen-dui-hua-zhai-chao-er/">
        </link>
        <updated>2021-11-03T06:07:32.000Z</updated>
        <content type="html"><![CDATA[<p>21、生活的过程是完美的，而且所有 的生活都源自于选择。干预选择是不合理的，质疑它也是。而谴责它尤 其不合理。 合理的做法是观察它，然后尽量帮助灵魂寻求和做出更高的选择 。 因此，请关注他者的选择，但别对其指手画脚。请认识到他们的选择对 于此刻的他们来说是完美的——然而，若是某个时刻来临，他们要寻找 新的选择，不同的选择，更高的选择，请随时准备协助他们。<br>
神圣的宇宙法则： 让每个灵魂去走它的路。</p>
<p>22、如果某件事明显是对的，那 么你就去做。但请记住，别向你所谓的“对”与“错”下终极判断。 事物是对或错，只是因为你说它是而已。事物本质上没有对或者 错。</p>
<p>23、对”与“错”并非本质的条件，而是个人价值系统中的主观判断。你 的自我是通过你的主观判断而被创造出来的——你的真正身份是通过你 的个人价值观而被确定和展示的。</p>
<p>24、世人基本上可以分为两类：把你想要的东西给你的人，修东西的 人。从某种意义上来讲，即使那些只是把你想要的东西给你的人——肉 贩、面包师傅、制蜡工人——也是修理者。因为你对事物有欲望，通常 意味着你对它有需要。所以人们说瘾君子需要修理 。因此，当心点， 别让欲望变成瘾 。</p>
<p>25、我说的是，如同雪花以它的形状存在那样，世界以它的现状存在， 原因在于它的现状是被设计好的。它的现状，正如你们的生活的现状， 是你们创造出来的。</p>
<p>26、只有在不斗争中过程才会继续。只有在让步中才能获得胜利。</p>
<p>27、意外事故发生，是因为它们发生了。在生活的过程里，某些特定的 因素会在特定的时刻以特定的方式聚集，产生特定的后果；出于你自己 某些特定的原因，你选择称这些后果为不幸。然而如果结合你的灵魂的 任务安排来看，或许它们根本并非不幸。我告诉你：世上没有 巧合，没有 “偶然”发生的事情。每件事、每次 遇险都是你的自我召唤给你的自我的，目的是让你能够创造和经验到你 的真实身份。所有真正的大师都明白这道理。所以这些神秘的大师在面 临你们所谓的 最糟糕的生活经验时，依旧能够处之泰然。</p>
<p>28、因为你们是你们的实 在的创造者，你们想要 生活展现什么样的面貌，生活就将会展现什么 样的面貌。 事物最初只能在你的思维 中存在。这是创造的第一步。圣父就是思 维。你的思维是万物的起源。</p>
<p>29、第一定律是，你能够成为任何你想成为的人，你能够做任何你想做 的事，你能够拥有任何你想拥有的东西。第二定律是，你会吸引你怕的 东西。</p>
<p>30、情绪 是吸引力。如果你非常怕某样东西，那你将会经验到它。动物 ——你们认为这是较为低级的生命形式（尽管动物的行动比人类更加率真和更加坚毅）——能够马上认识到你是否怕它。植物——你们认为这是更为低级的生命形式——对那些爱它们的人远比对那些不在乎它们的人亲近。</p>
<p>31、情绪是移动的能量。移动能量的时候，你便创造出效应。如果移动 足够多的能量，你便能创造出物质。物质是聚合的能量。是四处移动的 能量。是相互碰撞的能量。如果你以特定的方式操控能量，而且操控的 时间足够长久，你就能得到物质。每个大师都明白这条定律。这是宇宙 的炼丹术。这是所有生命的秘密。</p>
<p>32、思维是纯粹的能量。你现在所有、曾经有过、将来会有的每个思维 都是创造性的。你的思维的能量永远不会消灭。永远不会。离开你的存 在之后，它便进入宇宙，永远地前进。思维是永恒的。 所有的思维都会凝固；所有的思维都会彼此相遇，交织出不可思议 的能量之网，形成美丽得难以言喻的、复杂得难以置信的、永远变幻不 定的形态。</p>
<p>33、相似的能量吸引相似的能量——形成相似的能 量“块”。当足够多的同类“块”彼此相遇，相互冲撞，它们就会相互“黏合” 。因而，需要多得超乎想象的同样能量“黏合 起来”才能形成物质。但物质是由纯粹的能量形成的。实际上，这也是 物质唯一能够形成的方式。能量一旦变成物质，就长久地保持物质的状 态——除非其结构被相反的或者相异的能量形式打破 。这种作用于物 质的相异能量确实能够分解物质，释放出构成物质的原始能量。</p>
<p>34、你最怕的东西将会折磨你最多。怕将会像磁铁般把它吸到你身上。<br>
这些定律十分简单： 1. 思维是创造性的。 2. 怕吸引相似的能量。 3. 爱无所不在。</p>
<p>35、是的，坚持你的价值观——只要你经验到它们对你有用。然而要 仔细看清楚，这些你用思维、话语和行动保卫的价值观是否将你心目中最美好的自己带入你的经验空间。<br>
逐一检查你的价值观。让它们接受公众的审视。假如你能够泰然 自若、毫不犹豫地告诉世界你是谁，你的信念是什么，你对自己便是 满意的。那你就再也没有理由继续与我对话了，因为你已经创造出不 需要提高改进的自我，以及适合 这个自我的生活。那你就到达完美<br>
的境界，可以放下这本书了。</p>
<p>36、你的存在可以分为三层。你由身体、精神 和灵魂 组成。你也将这些称为物质、非物质和超物质。这就是三位一体，它也有其他许 多种名称。 你的本质和我的本质是相同的。<br>
我也表现为三位一体。有些神学家称之为圣父、圣子和圣灵。<br>
精神学家认识到这种三合一的关系，将其称为意识、潜意识、超意识。<br>
哲学家称它为本我、自我和超我。<br>
科学将其定义为能量、物质和反物质。<br>
诗人的说法是脑、心和魂。新时代运动的思想家称之为精、气和神。<br>
你的时间分为过去、现在和未来。难道这不等于潜意识、意识和超意识吗？<br>
空间同样分为三种：此，彼，彼此之间。<br>
定义和描绘“彼此之间”才是困难的、深奥的。在开始定义或描 绘的那一刻，你描绘的空间就会变成“此”或“彼”。然而我们知道这种“彼此之间”是存在的。正是它隔开了“此”和“彼”——正如<br>
永恒的如今隔开了“从前”和“以后”。<br>
你的这三种属性实际上是三种能量。你可以称它们为思维、话语 和行动。三者加起来便能产生结果——在你们的语言和理解当中，这被称为感受或者经验。<br>
你的灵魂 （潜意识、本我、灵魂、过去等等）是你曾经拥有 （创造）的每个感受的总和 。关于其中某些感受的意识被称为记 忆。如果你拥有记忆，你就忆起了那些感受。也就是说，把那些感受<br>
拼起来。组装各个部分。<br>
当你把你的所有部分组装完毕，你将会忆起你的真实身份。<br>
创造的过程始于思维——观念、概念或者形象。你目睹的一切都 曾是某个人的观念。人世间没有什么最初不曾以纯粹的思维存在过的东西。<br>
整个宇宙中的情形亦是如此</p>
<p>37、行动是移动的话语。话语是被表达的思维。思维是已形成的观 念。观念是相聚的能量。能量是被释放的力量。力量是存在的元 素。元素是神的粒子，是整体的部分，是一切的本质。<br>
始于神，终于行动。行动是创造中的神——或者被经验到的神。</p>
<p>38、你在世上看到的一切，皆是你关于世界的观念的后果。你不是希望你的生活“平步青云”吗？那么请改变你关于生活的 观念。改变你关于你自己的观念。以神的身份 去思考、言说和行动。要明白所有的状况都是暂时的。没有不变的东西，没有 静止的状态。事物以何种方式改变取决于你</p>
<p>39、</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[与神对话摘抄（一）]]></title>
        <id>https://kangjn.github.io/post/yu-shen-dui-hua-zhai-chao-yi/</id>
        <link href="https://kangjn.github.io/post/yu-shen-dui-hua-zhai-chao-yi/">
        </link>
        <updated>2021-11-03T05:33:46.000Z</updated>
        <content type="html"><![CDATA[<p>**1、最高级的思维永远是包含了欢乐的思维。最清晰的话语永远是包含 了真相的话语。最美好的感受是你称之为爱的感受。 欢乐、真相、爱。 这三者是可以相互替换的，它们之间永远是互通的。无论它们的次 序如何</p>
<p>2、看看如今的世界是什么样子吧。你们显然 错过了某些事物。有些事物分明是你们所无法理解的。而你们所理解 的，在你们看来必定是对的，因为“对”是一个你们用来形容某些你们同 意的事物的字眼。因此，你们所错过的，起初必定显得有“错”。 摆脱这种思维定势的唯一方法是扪心自问：“假如所有我认为‘错’的 事情其实是‘对’的，那么会出现什么样的情况呢？”每个伟大的科学家都 懂得这么自问。当所做的并没有取得成功时，科学家便抛开全部假设， 从头再来。一切 伟大的发现都是由不自认为 对的意志和能力创造出来 的。那样的意志和能力正是这里所需要的。 你无法认识神，除非你不再告诉自己你已经认识了神。你无法听见 神，除非你不再认为你已经听到神。 我无法把我的真相告诉你，除非你不再把你的真相告诉我。</p>
<p>3、聆听你的感受 。聆听你最高级的思维。聆听你的经验。假如它们有 别于你的老师教给你的，或者你从书上看到的，就忘掉那些话语吧。话 语是最不可靠的真相供给源。</p>
<p>4、正确的祈祷从来不是恳求的祈祷，而是感恩的祈祷。 当你为了自己希望在现实生活中拥有的经验而预先感谢神时，从效 果上来讲，你已经承认它存在于你的现实生活中……从效果上来讲 是 这样的。所以感恩是向神所说的最有力的宣言；这种肯定的宣言甚至在 你说出口之前，我便已经做出了回答。 因此不要哀求。要感恩</p>
<p>5、没有祈祷——祈祷无非就是表明事物如此这般 的强烈宣言而已—— 得不到回应。所有的祈祷——所有的想法、所有的宣言、所有的感受 ——都是创造性的。你在多大程度上认为它是真实的，它就会在多大程 度上出现于你的经验。</p>
<p>6、只有一种诱发思维能够压制这样的思维，那就是信仰的思维，坚定 地认为无论你想要什么，神都会毫不例外地 满足你的要求。有些人拥 有这样的信仰，但这样的人很少。</p>
<p>7、神是观察者 ，而非创造者。神随时准备帮助你过好你的生活，但用 的可能不是你期待的方式。 神的功能并非创造或毁灭你的生活境况或条件。 神创造了你，依照 神的形象与模样。其余都是你创造的，利用神给予你的力量。神创造了 生命的历程以及你所了解的生活。然而神给你自由的选择，让你能够依 照自己的意愿去生活</p>
<p>8、人类行为在最深层次上无不受到两种情感（怕或爱）之一的驱使。 情感实际上只有两种，灵魂的语言仅有两个词汇。我在创造宇宙和你今 天所认识的世界时，也为其创造了两极，而它们分别是这两极的末端。 它们是起点和终点，有了它们，被人类称为“相对性”的那个系统才 能存在。倘若缺乏这两个点，缺乏这两种关于事物的观念，别的观念便 都不能存在。 人类所有的想法和人类所有的行为，不是出于爱，便是由于怕。人 类的动机只有这两种，一切其他观念无非是这两者的派生物。只是形式 有所区别而已——它们是对同个主题的不同反映。</p>
<p>9、人类采取的每项行动都基于爱或怕，而且不仅仅是那些和人际关系 有关的行动。所有影响商业、工业、政治、宗教、教育、社会事务、经 济目标的决议，所有涉及战争、和平、攻击、防守、侵略、投降的选 择，所有攫取或施舍、独吞或分享、统一或分裂的主张——所有人类曾 经做出的自由选择，都必定出自于这两种思维中的一种：要么是爱的思 维，要么是怕的思维。 怕是收缩、封闭、攫取、跑开、隐藏、独吞、伤害的能量。 爱是扩张、开放、赠送、停留、敞开、分享、治疗的能量。 怕用服饰裹起我们的身体，爱让我们赤裸地站出来。怕粘住和抓紧 我们拥有的一切，爱送走我们拥有的一切。怕纠缠，爱松手。怕激怒， 爱抚慰。怕攻击，爱改变。 所有人类的思维、话语或举动要么基于怕，要么基于爱。这一点你 们别无选择，因为除此以外没有什么好选的了。但至于选怕还是爱， 你们可以自由决定</p>
<p>10、最伟大的提醒者并非他人，而是你内心的声音。这是我使用的 第一种工具，因为它是最方便使用的。 内心的声音是我说出的声音中最响的，因为它离你最近。只要你能 听清楚，这个声音将会告诉你别的一切 是真还是假，是对还是错，是 善还是恶。它便是雷达，能够设定航行的路线，掌控船舶的方向，指引 整个旅程，只要你听从它。 也正是这个声音，告诉你此刻你正在阅读的这些话语是爱的话语或 怕的话语。利用这把尺子，你可以衡量它们是应该牢记的话语或应该忽 略的话语。</p>
<p>11、最深层的秘密是，生活不是发现的过程，而是创造的过程。 你并不是在发现自我，而是在创造新的自我。因此，别试图解答你 是什么人，要试图确定你想成为什么人</p>
<p>12、你所谓的生活是个机会，让你能够通过经验 认识你已经通过概念 认 识到的东西。你无需学习任何东西 便能做到这一点。你只需要记住你 已有的知识，并将其付诸实践就够了。</p>
<p>13、太极自我分裂——在那辉煌的时刻，变成了阴和阳 （亦即此和 彼 ）。阴和阳 第一次出现了，彼此分离。然而它们又同时存在。并存 的还有非阴非阳 。 三种要素 因而突然出现：第一种是阴 。第二种是阳 。第三种是非阴非阳 ——但它是阴和阳存在的必要条件 。 太极便是生有之无，生实之虚，生小之大。</p>
<p>14、绝对的领域里没有经验，只有认识。认识是神圣的状态，然而最大 的欢乐却是存在。存在唯有于经验之后才能实现。其先后关系是这样 的：认识，经验，存在。 这就是三位一体——这三位一体就是神。 圣父是认识 ——亦即所有的理解之父，所有的经验之源，因为你无 法经验你从不认识的东西。<br>
圣子是经验 ——亦即所有圣父对自身的认识的落实与执行，因为你 无法成为你不曾经验的东西。 圣灵是存在 ——亦即所有圣子对自身的经验的抽象；唯有通过对认 识与经验的记忆，才能获得这种简单而美妙的存在感。 简单的存在即是极乐。它是神在认识和经验自身之后达到的境界。 它是神从开始便渴望得到的。<br>
三位一体的实在是神的标志。它是神圣的模式。神圣的领域里到处 是这种三合一的关系。当你应对有关时间和空间、神和意识或者任何神 圣关系的事务，你必定会遇到它。换个角度来说，在所有生活的世俗关 系中，你无法 找到这种三合一真相。</p>
<p>15、而在世俗的关系中，你辨认不出“之间”。那是因为世俗关系永远是<br>
二价的，而神圣领域中的关系则毫无例外是三价的。所以呢，世俗关系 里有左－右、上－下、大－小、快－慢、热－冷，以及神创造过的最了 不起的二价关系：雄－雌。这些二价关系没有“之间”。在这些关系里， 事物非此即彼，或者是这两极中某一极较大或者较小的变体。 在世俗关系的领域里，任何被概念化的事物都不可能存在，除非其 对立物 也已经被概念化。你的日常经验绝大部分扎根于这种实在。 在神圣关系的领域里，存在的事物全都没有 对立物。万物归一，一 切在无尽的循环中彼此相通。</p>
<p>16、每个灵魂都是大师，虽然有些并不记得它们的起源或者它们的天 赋。然而，每个灵魂依据其本身最远大的目标和最鲜活的记忆，创造出 各自的条件与境遇——在每个被称为现在的时刻。 所以呢，别去评判其他人走过的业力之路。别妒忌成功，别怜悯失 败，因为你不知道在灵魂的权衡中，什么算成功，什么算失败。 遇事 别称其为灾难或欢乐，除非你已确定或见证它的用途 。因为，如果死 拯救了数以千计的生命，它还能被称为灾难吗？如果生只带来悲哀，它 还能被称为欢乐吗？然而就算连这个你也别去判断，你永远走你的路， 同时允许别人走他们的路就可以了。 这并不意味着你应该忽略别人求助的呼声，或者你自己的灵魂想改 变某些境况或条件的冲动。而是意味着无论在做任何事情的时候，你都要避免先入之见和自以为是。因为每种境况都是礼物，每种经验中都隐 藏着财宝。</p>
<p>17、请你记住：你责怪的，将会责怪你；你批判的，将会变成你自己。<br>
较好的做法是，设法去改变这些不再反映最真实的你的事情，或者 帮助别人去改变这些事情。 更好的做法是，去祝福所有人——因为一切都是神借由活着的生命 所创造的，而活着的生命便是最高贵的造物。</p>
<p>18、由静修开始。摒绝外界的杂音，以让内在世界能够带给你观察力。 这种内观是你要追求的，然而当你深深地关注外在的世界时，你便不能 拥有它。因此，想办法尽可能地深入内在世界吧。如果你没有走进内在 世界，那么与外在世界打交道时，要由内在世界出发。记住这个道理： 如果你没有走进内在世界，你就会一事无成。 复述的时候用上第一人称，这样会更加亲切： 如果我 没有走进内在世界 我就会 一事无成。 你这辈子什么也没做成。然而你不必如此，本来不必如此。<br>
没有你达不到的成就。没有你做不到的事情。没有你得不到的东 西。</p>
<p>19、几千年来，人类不相信神的承诺，原因无它：那些承诺太美好了， 以至于你们认为是虚假的。于是你们宁可选择较差的承诺，选择较差的 爱。因为神最高的承诺来自最高的爱。然而你们无法想象出完美的爱， 所以想象不到完美的承诺。也想象不出完美的人。因此你们甚至连你们 的自我也不敢相信。 无法相信这些意味着无法信仰神。因为对神的信仰来自对神最大的 礼物（无条件之爱）和神最大的承诺（无限制之潜能）的信任。</p>
<p>20、假如再也没有什么可创造的，我们全体 的创造过程将会完结。让这个游戏继续下去 与我们全体有密切的利益 关系。我们常说要解决所有的问题，却不敢解决所有 的问题，否则我 们就没别的事可做了。 你们的军事工业复合体非常明白这个道理。所以，一切成立反战政 府的尝试都会遭到它的极力反对。 你们的医疗机构也明白这个道理。所以，一切神奇的新药或者新疗 法都会遭到它的顽固排斥，不药而愈的奇迹就更别提了——它为了自身 的生存不得不这么做。 你们的宗教团体也心知肚明。所以，一切不包含怕、审判和报应的 神的定义，一切认为其教义并非通往神的唯一道路 的自我的定义，都 会遭到它的驳斥。 如果我告诉你，你就是 神——宗教还有什么意义呢？如果我告诉 你，你已痊愈，科学和医学还有什么意义呢？如果我告诉你，你将会平 静地生活，那些致力于和平的人还有什么意义呢？如果我告诉你，世界 已被修好——世界还有什么意义呢？**</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[灵性成长（三）]]></title>
        <id>https://kangjn.github.io/post/ling-xing-cheng-chang-san/</id>
        <link href="https://kangjn.github.io/post/ling-xing-cheng-chang-san/">
        </link>
        <updated>2021-10-20T09:29:41.000Z</updated>
        <content type="html"><![CDATA[<p>灵性道路的唯一目的就是释放小我。剩下的就是你的真我。</p>
<p>只有一种成长，那就是消除小我。</p>
<p>小我就是这样一种感觉：我是与一切万有相分离的个体。到了极致就是自我中心。</p>
<p>成长就是超越你自己-----习惯性的自己，那正是小我。</p>
<p>成长就是小我从它的痛苦中解脱出来。</p>
<p>认出所有的喜悦都只不过是你的真我</p>
<p>每一个行动都会产生一个相等但相反的反应。这就是回偿法则，也称业力。</p>
<p>你所做的任何事，只要不跟成长有直接关系，就是在浪费时间。</p>
<p>匆匆忙忙的人都是忧心忡忡的，忧心忡忡的人都是匆匆忙忙的。</p>
<p>你相信什么或不相信什么并不重要，重要的是你做什么。</p>
<p>每个行动和念头若非从他人的利益出发，就是在创造束缚和限制，因为它必会显化。</p>
<p>将时间用在对喜悦或极乐的寻求上。剩下的则是待在永恒的宁静中，不分昼夜。</p>
<p>生活应该只由两种事构成，一种是能帮助我们成长的，另一种是能帮助他人成长的。</p>
<p>能帮到你的人只有你自己，明白这一点会让你的成长加速。</p>
<p>最大的慈悲是知道没有什么慈悲是必需的。</p>
<p>一个感到满足的人不需要行动，不满足的人才会行动。</p>
<p>所有行为都应该反映无我或真我的特性：恒定的，视一切为平等，只看到真我，只看到完美，对好运坏运无分别心，认同一切，对褒贬漠不关心，只在真我中幸福，完全被动，不再作为，彻底臣服，无欲无求，冷静，不执著，包容一切。</p>
<p>物理世界的一切都是围绕着原因和结果，行动和反应，这被称为业力。当我们知道业力时，生活会变得容易，因为我们不再与之对抗。清楚这一点，能够对你们的医生职业有所帮助。一切都按照我们预先设定的在运转，无法改变。我们能改变的只有态度。</p>
<p>这个世界有着一种奴隶意识。人类相信为了生存必须奋斗，因此也只能奋斗。如果不再奋斗，那么自然会提供一切所需。</p>
<p>我们所谓的知识其实是无知。人类所学的一切都在不断变化，因此，没有一样是正确的。而真实的却从不改变。有关真我的知识要求放弃有关这世界的一切知识。</p>
<p>我们总是在这世界中苦苦寻觅着世界的真相。这就等同于想要看到谎言的真实。这世界只有无常，没有真实。只有在真我中，我们才能找到世界的真相。</p>
<p>我和世界，观者和被观者，造物主和造物，同时出现，相互依存。看清这一点。没有看的人，便不会有被看到的世界。意识到你的观者身份，世界只是表象，来自你的想象。那么真相就只会是观者。</p>
<p>所以，并不存在世界与灵性之分，它们完全是一回事。问题只在于我们的角度。我们应该努力到达不被任何人或事所搅扰的境界。当你到达那个境界时，你就处在最顶端。你虽依然身处于世，但没有什么能够激起你内在的涟漪。发展这个能力，把它作为一项练习，让它成为你的生活方式。不要对人起反应，不要愤怒、嫉妒、怨恨等等。不管发生什么，都临危不乱，始终平静。</p>
<p>“爱是耐心的，是仁慈的。爱不会忌妒，不会自吹自擂。爱不会傲慢无礼，不会坚持己见，不会心怀恨意。爱不会因错误而欢喜，只会以正确而快乐。爱承载一切，信任一切，祝福一切，包容一切。”</p>
<p>因为业力是不可能消除的。一些玄学流派教导你要消除业力。你在消除业力的过程中，实际上是在造新业。所以，业力不可能消除。</p>
<p>业力和转世都是幻象的一部分，在实相中并不存在。不要沉迷于过去世中，因为那是在虚幻中游戏，使虚幻的看起来更真实了。</p>
<p>如果付诸行动时没有执着或憎恶，便无法创造业力。</p>
<p>身体所会付诸的一切行动早在成为现实前就已经被你终止了。你唯一拥有的自由就是是否要将你自己视为这具身体和它所能做的行动。</p>
<p>如果一个演员扮演国王或乞丐，他不会受其影响，因为他知道他不是那个角色。这与我们身处这世界的情况类似，不管我们是国王还是乞丐，我们都不应该受其影响，相反地，我们应该知道我们不是那个角色，而是恢弘而闪耀的存在，是我们自己无限的真我。</p>
<p>让头脑安静的冥想很好。释放小我欲望的冥想更好。有关“我是什么“的冥想最好。</p>
<p>冥想时应该问自己：我是什么？上帝是什么？这个世界是什么？我与这世界有何关系？这世界的本质是什么？无限是什么？智力是什么？世界在哪里？或者对你听到过的一些话提出质疑，比如“世界不在我的外面，而是在我的里面”。问自己为什么，试着去挖掘这些真理背后的意义。</p>
<p>去往无限，向内走；去往有限，向外走。 将你的注意力向内，因为一切向外的注意力都是浪费。</p>
<p>除了真我，其它一切都是想象。小我只是演员，表演你所编剧的幻想故事。此时此地你就是那。不要蛊惑你自己，放开你那幻想的限制。</p>
<p>真我是完全的静止，完全的觉知。</p>
<p>无限的感觉是怎样的？无论在哪一方面都完全自由、不受限——不需要食物，不需要氧气，不需要工作。想要什么就能在瞬间显化。宇宙中的任何一个地方都能到达。想要变得多大就多大，多小就多小，哪怕小到一粒原子那么大。全然的宁静、满足和喜悦。</p>
<p>没有人能通过别人的传授得到真相，他们必须自己去认识。一位教师能够给出的是方向，只有小学生才会全盘接受。所有的真相都是可以证实的。不要接受任何口耳相传的消息。人必须要为自己证实一切。</p>
<p>我想让你做的第一件事是花几分钟想想你真的很想达成的几个目标。我们在书里也举了几个例子，你可以看一下，这样你会更清楚地知道自己要选哪几个目标。例如，可能有一个目标是“我让自己释放的时候自然而轻松”，这是一个关于释放法的目标；可能还有一个目标是“我让自己自己每天都经历丰盛与财富”；可能还有一个目标是“我让自己轻松地拥有丰盛的现金流动”或“我让自己的身材体重变得完美”。你可以挑选你想要集中精力解决的任何一个目标，而且可以对它重复做这练习。所以花几分钟想出一个特别想解决的目标吧。</p>
<p>我对真实(real)的定义是：那个永远不会改变的就是真实。实相(The reality) 是永不改变的，这是永远不变的绝对真理；这永远是真理。</p>
<p>每一种本质(nature)的人都会有一种自然的途径来达成觉醒，对你而言最自然的方式，就是对你最好的途径。这就是为什么会有四种涵盖所有人本质(nature)的主要途径的原因。</p>
<p>这四种途径是：理性的，就是心智途径；科学的，就是特定方法学(methodological)的途径；感性的，就是爱和奉献的途径；以及行动性的，就是实践对人类无私服务的途径。</p>
<p>当你的心智安静到足够让你望穿心智的噪音时，你就会看到你就是的真「我」。</p>
<p>那又是什么在决定思想力量的差别呢？就是你加在思想背后的定意、决心、或意志力的总量。</p>
<p>如果你无法做到这些的话，那么下一个大方法就是卸下你的自我感(ego sense)，当自我消失时，剩下的就是那个无限的你。</p>
<p>爱是耐心和亲切仁慈，爱没有妒忌或者自夸，没有骄傲和无礼，爱不会坚持己见，爱不会急躁和忿怒，爱不会因不道德的事情而高兴，但对正确的事情会感到喜悦：爱是承担一切，爱是相信一切，爱对一切都有信心，爱是宽容一切。　　平和是宁静、安详，是回归真我。</p>
<p>小我由肉体（生理）、灵魂（心理、精神）、因果关系构成。每天，人分别经历着肉体、灵魂及因果关系，在醒着时，有梦和无梦的睡眠中。消除小我，这三个状态也被消除。</p>
<p>恢复到思想初始状态，也是最正确的就是“没有想法”。真理在知觉领域。当所有的思想停止了，全知外面的遮盖物被移除了，我们立刻拥有了一切。</p>
<p>物质、能量、空间、时间都在心智里，当人了解这些时，他们用精神、意图控制它们。</p>
<p>如果一个人谈论他人坏话，他不会伤害他人，按照回馈法则，他只会伤害自己。因为他在诋毁他人的言语构成了憎恨。</p>
<p>对于相关事物作无害化处理就是不作评判。</p>
<p>无害化的相互关系一直指引人采用正确的行为。</p>
<p>没有对错、好坏。只有为了学习真相的体验。</p>
<p>带有附着情绪的喜欢，是带有痛苦和欲望的喜欢，一种饥饿。没有附着情绪的喜欢，是自由、没有束缚的喜欢。</p>
<p>获得无限喜悦的途径是去除欲望，没有喜欢，没有厌恶。</p>
<p>研究人的情绪，你总是会发现阻扰（挫败感）或者欲望的成分。人类的爱是占有他人的爱。无论人想要占有什么，他一定是感到缺乏。这是人类爱无法带来持续快乐的原因。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[灵性成长（二）]]></title>
        <id>https://kangjn.github.io/post/ling-xing-cheng-chang-er/</id>
        <link href="https://kangjn.github.io/post/ling-xing-cheng-chang-er/">
        </link>
        <updated>2021-09-23T00:50:08.000Z</updated>
        <content type="html"><![CDATA[<p><strong>-<br>
- 这门功课修得如何取决于你所获得的结果。<br>
- 你越成长，就感觉越不需要成长。<br>
- 你越精进，就越不想更精进。<br>
- 不去亲证就无法学会任何事，想要获得智慧就只能去亲证。<br>
- 研究幻象会让你误以为真实。如果你想知道真相，就不要研究假象。<br>
- 成长的整个过程就是释放念头。当念头被完全清除，就只剩下真我。<br>
- 它太简单，所以不要把它搞复杂了。<br>
- 我们只能超越小我。真我就是超越了小我。<br>
- 成长是释放你所不是的样子。<br>
- 随着你成长，整个世界都会向你开放，你将经验更多。但是，即使你拥有全世界，你也只是拥有一个小点。拿下整个宇宙吧！<br>
- 对自由的渴望是关键。一旦你得到自由，你就会被它永远带走。<br>
- 在达到自由或开悟的过程中，我们获得多少帮助取决于我们帮助别人多少。<br>
- 成长吧，把你的注意力从自己身上移开，转到其他人身上。<br>
- 为什么不应该是此时此地所有人都成大师，我们所有人？<br>
- 当我们下定决心成为真我的那一刻，我们就是真我！<br>
- 你的境界越高，就越无分别心。你接纳所有宗教。<br>
- 在顺境中感到平静，并不表明你的境界有多高，这只是逃避。<br>
- 如果不成长，就只会退转。<br>
- 你应该感谢那些反对你的人，因为他们给了你不寻常的成长机会。<br>
- 当我们关注其他人在做什么时，我们就得以把注意力从自己身上移开。<br>
- 你需要不断确认，直到你不再需要确认为止。<br>
- 坚持不懈是必需的。<br>
- 逆境促使成长。<br>
- 这个世界越陷入危机，我们就越有机会成长。<br>
- 如果人们不断强烈地质问“我是什么”，成长就会非常迅速。<br>
- 当你找到“我是什么”的答案时，你就能控制自己的身体和心智。<br>
- 如果你不喜欢什么，那就改变你自己。<br>
- 你可能已经看到你是谁，但却无法持住。我们可以瞥见无限的真我，在那待一会儿，但突然间感觉我们已经失去了它。因为头脑还未被清除。全然地进入真我时，头脑在那一刻退居幕后，但是潜意识里的那些限制性念头依然还在。你尚未清除头脑，只是暂时释放了它。它会再次出现，小我再次接管，你都不明白刚刚（进入真我）发生了什么，然后再次被带回沉重的现实。我们要做的就是重新进入真我，一次又一次地，直到能永久地待在那里。每次我们这么做时，都能烧掉更多的头脑，直到头脑彻底灰飞烟灭。此时我们便能永久地待在真我中。你只是旁观着，头脑依然还在，但你已不是那头脑；身体依然还在，你也不再是那身体。只要你知道你既非那头脑，亦非那身体，它们便无法再触碰你。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[灵性成长（一）]]></title>
        <id>https://kangjn.github.io/post/ling-xing-cheng-chang-yi/</id>
        <link href="https://kangjn.github.io/post/ling-xing-cheng-chang-yi/">
        </link>
        <updated>2021-09-23T00:46:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="-灵性道路的唯一目的就是释放小我-剩下的就是你的真我-只有一种成长那就是消除小我-小我就是这样一种感觉我是与一切万有相分离的个体-到了极致就是自我中心-成长就是超越你自己-习惯性的自己那正是小我-成长就是小我从它的痛苦中解脱出来-认出所有的喜悦都只不过是你的真我-如果你不经验你的真我就不会有真正的幸福可言-当你明白这一点道路是非常直接的-你不再追寻海市蜃楼而是奔幸福而去-你知道了幸福在哪里它就在你内-你所追寻的一切其实你本自具足却非常愚蠢地说我不是-这是个迷-每个人所苦苦求索的其实本自具足甚至更多-这就是你当你说我这就是指那无限的本质-有趣的是作为无限的你却在寻找你所是的真我-谁若说他自己不是个大师他就是在撒谎-你的努力应该用在合适的身份认同上认同你真我的身份-灵性成长的衡量标准是你有多认同你真我的身份-小我非常狡猾它经常把我们从灵性道路上拉出去一段时间有时甚至很久-一旦我们陷入小我的陷阱我们通常很难逃脱-所以你必须提防小我它是我们的一部分-不管我们在灵性道路上有多精进小我总是像个变节的同伴把我们带离觉醒之路有时甚至是终生-以下是我们要提防的小我始终抓着我们对我们不离不弃它会说我就是上帝-以此来阻碍我们进一步的成长-当你发现小我在抗拒时你可以释放抗拒的感觉-经过不断的练习这会变得容易-当你释放掉了足够的小我就能自然地感觉到真我的平静和喜悦-这真的是一条能够逐渐呈现你那无限本质的道路-你放下限制-放下痛苦但你永远不会失去任何有价值的-美好的东西-在这条路上你会不断地脱离麻烦-痛苦是我们的第一位老师-它第一个推动我们去寻找出路-我们走上道途一开始源于躲避痛苦-接着我们尝到了真我的滋味并且想要继续体味因为它实在太美妙-在这条路上你永远不会失去任何东西你只会拥有越来越多你真正想要的直到你拥有全部-去品尝你内的甜蜜而不是逃离你外的痛苦-我们发现在灵性道路上永远不会失去什么除了我们给自己强加的伤痛和绷带-若你对灵性道路没兴趣那么只会执着于感官世界物质世界-为什么你不能因为你认为你不能-你之所以认为你做不了仅仅是因为你认为你做不了-那些认为自己做不了的人实际上是不想做-你是否能够成长只取决于你自己-只要你能做它就会发生-唯一想要改变你的人是你自己-愿望和企图都没用你必须行动-美好的意图抵不上正确的行动-想要改变更快发生那就想象它发生-若你想改变意愿必须非常强烈因为你长期受到习气的控制以致于就像一个溺水者渴望空气一样-想要摆脱习气的控制那你必须对体悟真我的渴望就同溺水者渴望空气一样-你的成功取决于你对成功的渴望程度-如果你失去勇气那意味着你对成功没有了兴趣-你唯一的朋友是你自己-你唯一的敌人也是你自己-你越限制你自己你就越是自己的敌人-相反地你越放开你自己你就越是自己的朋友-你要做的工作是回归无限的真我-只有你自己才能完成-你限制了自己你必须亲自解除这个限制-灵性道路就是自助的道路-做能做到的事并尽力去做-每个经历都是为了祝福你而非伤害你-若能一直遵循灵性法则你将去往更高的境界-生命中的每个地方每种状况都是成长的契机-成长的最佳地点就是此地最佳时间就是此时-对成长的各种机会心怀感恩-测试的最佳地点是待在家里和你的原生家庭一起-因此家是绝佳的成长地点-通过练习对伴侣和家人无私的爱可以获得很大的灵性成长-人们说你坏话这给了你成长的机会让你练习如何才能真爱如何才能真平静-因为他们只是用他们的嘴巴发出声音你没有任何理由对此感觉不好-被反对是件好事它激发并巩固成长-有必要记住每个人都是我们的老师-如果我们对赞美起反应那是在助长小我同样地若对批评感到沮丧那也是小我-当我们成为真我就不再起反应-没有什么事是毫无用处的-每个意外都可以被视为老师-每一天的每一分钟都可以用来成长-如果我们想象我们在那里但我们是在这里-命运很快会把我们拉回此时此地-如果你告诉其他人有关你的高峰体验有关你的成长收获人们会因为嫉妒而说你以为你是谁-这往往很容易把你拖回来-每当你吹牛时你都是在邀请考验-所以我警告你除非你确定你自己是知道借由吹牛的体验你不会失去什么否则就不要吹牛-为你的灵性成果感到骄傲欢喜-当你对自己的灵性成长不诚实时你就是在邀请挑战-有必要消除疑虑-灵性成长不仅需要信仰还需要了解-从信仰开始但必须转到了解-因为你必须通过检验才能明了-为了真正了悟就必须去了解-当你去经历时就不再停留在头脑层面-开悟无需阐释的能力-灵性开悟是唯一的成熟-要站出来变得与众不同不要再让他人将你拉回原地-这不容易需要刚毅-我们应该努力走完全程因为我们被赋予这种能力-我们有可能走完全程直达源头-期待无限-也只能期待无限-沿着道途走到终点-你越沿着道途走就能越快到达终点-每个收获都是永恒的-每一个向前的步伐也是永恒的-我们爬梯子时每当上了一个阶梯就会忘了下面的-当我们到达顶端时干脆踢了梯子-灵性道路的唯一目的就是释放小我-剩下的就是你的真我-有必要记住每个人都是我们的老师-如果我们对赞美起反应那是在助长小我同样地若对批评感到沮丧那也是小我-当我们成为真我就不再起反应-没有什么事是毫无用处的-每个意外都可以被视为老师-为你的灵性成果感到骄傲欢喜">**-<br>
- 灵性道路的唯一目的就是释放小我。剩下的就是你的真我。<br>
- 只有一种成长，那就是消除小我。<br>
- 小我就是这样一种感觉：我是与一切万有相分离的个体。到了极致就是自我中心。<br>
- 成长就是超越你自己-----习惯性的自己，那正是小我。<br>
- 成长就是小我从它的痛苦中解脱出来。<br>
- 认出所有的喜悦都只不过是你的真我<br>
- 如果你不经验你的真我，就不会有真正的幸福可言。当你明白这一点，道路是非常直接的。你不再追寻海市蜃楼，而是奔幸福而去。你知道了幸福在哪里，它就在你内。<br>
- 你所追寻的一切，其实你本自具足，却非常愚蠢地说“我不是”。这是个迷。每个人所苦苦求索的，其实本自具足，甚至更多。<br>
- 这就是你，当你说：“我”，这就是指那无限的本质。有趣的是，作为无限的你，却在寻找你所是的真我。<br>
- 谁若说他自己不是个大师，他就是在撒谎。<br>
- 你的努力应该用在合适的身份认同上，认同你真我的身份。<br>
- 灵性成长的衡量标准是你有多认同你真我的身份。<br>
- 小我非常狡猾，它经常把我们从灵性道路上拉出去一段时间，有时甚至很久。一旦我们陷入小我的陷阱，我们通常很难逃脱。所以你必须提防小我，它是我们的一部分。不管我们在灵性道路上有多精进，小我总是像个变节的同伴，把我们带离觉醒之路，有时甚至是终生。<br>
- 以下是我们要提防的：小我始终抓着我们，对我们不离不弃，它会说：我就是上帝。以此来阻碍我们进一步的成长。<br>
- 当你发现小我在抗拒时，你可以释放抗拒的感觉。经过不断的练习，这会变得容易。当你释放掉了足够的小我，就能自然地感觉到真我的平静和喜悦。<br>
- 这真的是一条能够逐渐呈现你那无限本质的道路。你放下限制、放下痛苦，但你永远不会失去任何有价值的、美好的东西。<br>
- 在这条路上，你会不断地脱离麻烦。<br>
- 痛苦是我们的第一位老师。它第一个推动我们去寻找出路。<br>
- 我们走上道途一开始源于躲避痛苦。接着我们尝到了真我的滋味并且想要继续体味，因为它实在太美妙。<br>
- 在这条路上你永远不会失去任何东西，你只会拥有越来越多你真正想要的，直到你拥有全部。<br>
- 去品尝你内的甜蜜，而不是逃离你外的痛苦。<br>
- 我们发现在灵性道路上永远不会失去什么，除了我们给自己强加的伤痛和绷带。<br>
- 若你对灵性道路没兴趣，那么只会执着于感官世界（物质世界）。<br>
- 为什么你不能？因为你认为你不能。<br>
- 你之所以认为你做不了，仅仅是因为你认为你做不了。<br>
- 那些认为自己做不了的人，实际上是不想做。<br>
- 你是否能够成长只取决于你自己。<br>
- 只要你能做，它就会发生。<br>
- 唯一想要改变你的人，是你自己。<br>
- 愿望和企图都没用，你必须行动！<br>
- 美好的意图抵不上正确的行动。<br>
- 想要改变更快发生，那就想象它发生！<br>
- 若你想改变，意愿必须非常强烈，因为你长期受到习气的控制，以致于就像一个溺水者渴望空气一样。想要摆脱习气的控制，那你必须对体悟真我的渴望就同溺水者渴望空气一样<br>
- 你的成功取决于你对成功的渴望程度。如果你失去勇气，那意味着你对成功没有了兴趣。<br>
- 你唯一的朋友是你自己。你唯一的敌人也是你自己。你越限制你自己，你就越是自己的敌人。相反地，你越放开你自己，你就越是自己的朋友。<br>
- 你要做的工作是回归无限的真我。只有你自己才能完成。你限制了自己，你必须亲自解除这个限制。<br>
- 灵性道路就是自助的道路。<br>
- 做能做到的事，并尽力去做。<br>
- 每个经历都是为了祝福你，而非伤害你。若能一直遵循（灵性）法则，你将去往更高的境界。<br>
- 生命中的每个地方，每种状况，都是成长的契机。<br>
- 成长的最佳地点就是此地，最佳时间就是此时。<br>
- 对成长的各种机会心怀感恩。<br>
- 测试的最佳地点是待在家里，和你的原生家庭一起。因此，家是绝佳的成长地点。<br>
- 通过练习对伴侣和家人无私的爱，可以获得很大的灵性成长。<br>
- 人们说你坏话，这给了你成长的机会，让你练习如何才能真爱，如何才能真平静。因为他们只是用他们的嘴巴发出声音，你没有任何理由对此感觉不好。被反对是件好事，它激发并巩固成长。<br>
- 有必要记住每个人都是我们的老师。如果我们对赞美起反应，那是在助长小我；同样地，若对批评感到沮丧，那也是小我。当我们成为真我，就不再起反应。<br>
- 没有什么事是毫无用处的。每个意外都可以被视为老师。<br>
- 每一天的每一分钟都可以用来成长。<br>
- 如果我们想象我们在那里，但我们是在这里。命运很快会把我们拉回此时此地。<br>
- 如果你告诉其他人有关你的高峰体验，有关你的成长收获，人们会因为嫉妒而说“你以为你是谁”。这往往很容易把你拖回来。<br>
- 每当你吹牛时，你都是在邀请考验。所以，我警告你，除非你确定你自己是知道借由吹牛的体验你不会失去什么，否则就不要吹牛。<br>
- 为你的灵性成果感到骄傲，欢喜。<br>
- 当你对自己的灵性成长不诚实时，你就是在邀请挑战<br>
- 有必要消除疑虑。<br>
- 灵性成长不仅需要信仰，还需要了解。从信仰开始，但必须转到了解。因为你必须通过检验才能明了。<br>
- 为了真正了悟，就必须去了解。<br>
- 当你去经历时，就不再停留在头脑层面。<br>
- 开悟无需阐释的能力。<br>
- 灵性开悟是唯一的成熟。<br>
- 要站出来，变得与众不同，不要再让他人将你拉回原地。这不容易，需要刚毅。<br>
- 我们应该努力走完全程，因为我们被赋予这种能力。我们有可能走完全程，直达源头。<br>
- 期待无限。也只能期待无限。<br>
- 沿着道途走到终点。你越沿着道途走，就能越快到达终点。<br>
- 每个收获都是永恒的。每一个向前的步伐也是永恒的。<br>
- 我们爬梯子时，每当上了一个阶梯就会忘了下面的。当我们到达顶端时，干脆踢了梯子。<br>
- 灵性道路的唯一目的就是释放小我。剩下的就是你的真我。<br>
- 有必要记住每个人都是我们的老师。如果我们对赞美起反应，那是在助长小我；同样地，若对批评感到沮丧，那也是小我。当我们成为真我，就不再起反应。<br>
- 没有什么事是毫无用处的。每个意外都可以被视为老师。<br>
- 为你的灵性成果感到骄傲，欢喜。</h2>
<ul>
<li>**</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker命令大全]]></title>
        <id>https://kangjn.github.io/post/docker-ming-ling-da-quan/</id>
        <link href="https://kangjn.github.io/post/docker-ming-ling-da-quan/">
        </link>
        <updated>2021-07-01T02:49:33.000Z</updated>
        <content type="html"><![CDATA[<p>*一、基本命令：</p>
<p>查看镜像：docker images</p>
<p>搜索镜像：docker search mysql:5.7.0 (5.7.0：搜索指定的版本)</p>
<p>列出当前运行的容器：docker ps</p>
<p>列出所有的容器（包括已停止的）：docker ps -a</p>
<p>停止容器 ：docker stop 5d034c6ea010 （5d034c6ea010 : 容器id）</p>
<p>进入容器： docker exec -it 容器id /bin/bash</p>
<p>下载镜像：docker pull ubuntu（默认latest,最新版）</p>
<p>下载带版本的镜像：docker pull ubuntu:13.10</p>
<p>创建容器时，设置自动启动容器：docker run --restart=always 容器id（或者容器名称）如果创建时未指定 --restart=always ,</p>
<p>​	可通过update 命令设置：docker update --restart=always 容器id（或者容器名称）</p>
<p>查看docker信息：docker info</p>
<p>查看容器的日志：docker logs -f 容器ID（-f：可以滚动查看日志的最后几行）</p>
<p>查看我们的容器与基础镜像有什么不同：docker container diff sample</p>
<p>A代表新增文件</p>
<p>C代表修改过的文件</p>
<p>D代表被删除的文件</p>
<p>将修改过的容器导出为自己的镜像：docker container commit sample my-alpine</p>
<p>看本地镜像runoob/ubuntu:v3的创建历史：docker history runoob/ubuntu:v3</p>
<p>将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档：</p>
<p>docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3（-o :输出到的文件）</p>
<p>导入使用 docker save 命令导出的镜像：</p>
<p>docker load &lt; busybox.tar.gz</p>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4：</p>
<p>docker import my_ubuntu_v3.tar runoob/ubuntu:v4</p>
<p>创建容器：docker run -i -t -v /root/software/:/mnt/software/ 9f38484d220f /bin/bash （-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;）</p>
<p>运行容器：docker run --rm -t -i ubuntu:15.10 /bin/bash （/bin/bash：交互式 Shell，-t: 表示容器启动后会进入其命令行，-i: 表示以“交互模式”运行容器，</p>
<p>--rm:停止容器后直接删除容器）</p>
<p>数据拷贝： docker cp，此命令用于容器与宿主机之间进行数据拷贝,如 docker cp 5d034c6ea010: /etc/nginx/nginx.conf /dockerData/nginx/conf/nginx.conf 将容器的目录文件拷贝到宿主机指定位置,容器ID可以替换成容器名</p>
<p>删除镜像：docker rmi 镜像名/镜像id</p>
<p>删除容器： docker rm 容器id (必须是未启动的容器 )</p>
<p>强制删除容器 db01、db02：docker rm -f db01 db02</p>
<p>删除容器 nginx01, 并删除容器挂载的数据卷：docker rm -v nginx01</p>
<p>移除所有的容器：docker rm -f (docker container ls -aq)</p>
<p>杀掉一个运行中的容器:docker kill -s KILL mynginx（-s :向容器发送一个信号）</p>
<p>更新镜像:</p>
<p>1.从已经创建的容器中更新镜像，并且提交这个镜像，使用 yum update 更新镜像,在完成操作之后，输入 exit 命令来退出这个容器。</p>
<p>提交镜像： docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2，其中： -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名</p>
<p>2、使用 Dockerfile 指令来创建一个新的镜像</p>
<p>设置镜像标签： docker tag 860c279d2fec ubuntu:dev</p>
<p>查询最后一次创建的容器： docker ps -l</p>
<p>容器命名： docker run -d -P --name runoob training/webapp python app.py(--name命令:定义容器别名，其中runoob ：容器名，training/webapp：容器所属的镜像名，python：为启动的容器创建的别名)</p>
<p>新建网络：docker network create -d bridge test-net，参数说明：-d：参数指定 Docker 网络类型，有 bridge、overlay，其中 overlay 网络类型用于 Swarm mode</p>
<p>登录docker远程镜像仓库： sudo docker login --username=qweads registry.cn-hangzhou.aliyuncs.com</p>
<p>退出docker远程镜像仓库：docker logout</p>
<p>推送镜像到远程仓库：docker push 镜像名/镜像id</p>
<p>导出容器：docker export 容器id&gt; /地址/容器别名.tar，</p>
<p>导入容器：cat docker/ubuntu.tar | docker import - test/ubuntu:v1 (将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1)</p>
<p>查看镜像或容器的详细信息：docker inspect 容器id (可以加-f参数只查看某一项信息)</p>
<p>查看容器IP： docker inspect --format='{{.NetworkSettings.IPAddress}}'CONTAINER_ID/NAME</p>
<p>查看容器数据卷挂载目录：docker inspect container_id | grep Mounts -A 20</p>
<p>手动创建数据卷： docker volume create shared-data</p>
<p>删除数据卷： docker volume rm my-data</p>
<p>列出目前已有的volume：docker volume ls</p>
<p>与磁盘空间使用情况相关的命令：docker system df</p>
<p>移除所有不在运行状态的容器：docker container prune</p>
<p>清除未被使用到的镜像：docker image prune --force --all</p>
<p>清除未被使用到的数据卷：docker volume prune</p>
<p>创建一个自定的网络：docker network create --driver bridge sample-net</p>
<p>查看所有网络 ：docker network ls</p>
<p>删除所有未被任何容器或者服务连接的网络：docker network prune</p>
<p>查看该网络的详细情况：docker network inspect test-network</p>
<p>将一个容器连接到多个网络：</p>
<p>第一步：docker run -itd --name test --network test-net mysql /bin/bash ping</p>
<p>127.0.0.1</p>
<p>第二步：docker network connect test-net mysql</p>
<p>从网络中移除容器：docker network disconnect 网络名/id mysql</p>
<p>删除网络：docker network rm my-network1（删除前,必须确认没有容器在使用该网络）</p>
<p>修改已启动容器的端口号：</p>
<p>​    docker ps 查看 Container 的 id</p>
<p>​    docker stop {container_id}</p>
<p>​    3.找到 /var/lib/docker/containers/{container_id}/hostconfig.json 修改</p>
<p>​    sudo service docker restart 重启docker</p>
<p>​    docker start {container_id} 重新启动 container</p>
<p>二、dockerfile:</p>
<p>1、创建Dockerfile文件：mkdir Dockerfile</p>
<p>2、编辑文件 ：vi Dockerfile</p>
<p>3、添加脚本如：</p>
<p>FROM nginx</p>
<p>RUN echo '这是一个本地构建的nginx镜像' &gt; /usr/share/nginx/html/index.html</p>
<p>介绍：</p>
<p>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<p>shell 格式：RUN &lt;命令行命令&gt;，&lt;命令行命令&gt; 等同于，在终端操作的 shell命令。</p>
<p>exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</p>
<p>例如：#RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于RUN ./test.php dev offline</p>
<p>​        指令详解</p>
<p>​        1》COPY</p>
<p>​        复制指令，从上下文目录中复制文件或者目录到容器里指定路径：</p>
<p>​        COPY . /app #将上下文目录中所有文件或目录递归拷贝到容器的/app目录下</p>
<p>​        COPY ./web /app/web #将上下文目录中的web目录下的内容拷贝到容器的/app/web目录下</p>
<p>​        COPY sample.txt /data/my-sample.txt #拷贝单个文件并重命名</p>
<p>​        ADD sample.tar /app/bin/ #解压tar包内的文件到指定目录</p>
<p>​        ADD http://example.com/sample.txt /data/ #拷贝远程文件到指定目录</p>
<p>​        COPY ./sample* /mydir/ #支持源路径中使用通配符</p>
<p>​        2》WORKDIR</p>
<p>​        WORKDIR用来定义工作目录或者上下文目录。常见的问题：</p>
<p>​        （WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p>​        由于每执行一次RUN，都是在原有镜像上添加一个新层，因此上面的命令只是在root目录下新建了sample.txt文件。</p>
<p>​        正确的切换至一个目录下，并新建文件，命令如下：</p>
<p>​        WORKDIR /app/bin</p>
<p>​        RUN touch sample.txt</p>
<p>​        3》CMD</p>
<p>​        类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<p>​        CMD 在docker run 时运行。</p>
<p>​        RUN 是在 docker build。</p>
<p>​        作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p>​        如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
<p>​        CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;<param1>&quot;,&quot;<param2>&quot;,...]</p>
<p>​        CMD [&quot;<param1>&quot;,&quot;<param2>&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</p>
<p>​        4》ENTRYPOINT</p>
<p>​        类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>​        但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p>​        假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<p>​        FROM nginx</p>
<p>​        ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</p>
<p>​        CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参</p>
<p>​        1、不传参运行</p>
<p>​        docker run nginx:test</p>
<p>​        容器内会默认运行以下命令，启动主进程。</p>
<p>​        nginx -c /etc/nginx/nginx.conf</p>
<p>​        2、传参运行</p>
<p>​        docker run nginx:test -c /etc/nginx/new.conf</p>
<p>​        容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<p>​        nginx -c /etc/nginx/new.conf</p>
<p>​        Dockerfile构建镜像命令：docker build -t nginx:test . （. 代表Dockerfile文件的路径）</p>
<p>​        当你的配置文件不是默认的名字时，可以使用-f参数指定：</p>
<p>docker build -t nginx:test -f my-Dockerfile .</p>
<p>三、docker-compose:</p>
<p>docker-compose.yml 配置文件：</p>
<p># <strong>yaml 配置</strong></p>
<p>version: '3'</p>
<p>services:</p>
<p>webapp:</p>
<p>build: ./dir</p>
<p>ports:</p>
<p>- &quot;5000:5000&quot;</p>
<p>redis:</p>
<p>image: &quot;redis:alpine&quot;</p>
<p>介绍：</p>
<p>docker-compose命令需在docker-compose.yml 所在目录下才能运行</p>
<p>启动应用程序：docker-compose up -d (-d:在后台启动)</p>
<p>指定使用的 Compose 模板文件，默认为 docker-compose.yml：</p>
<p>docker-compose -f docker-compose.yml up -d</p>
<p>停用移除所有容器以及网络相关：docker-compose down</p>
<p>docker-compose logs：docker-compose logs</p>
<p>列出所有容器：docker-compose ps</p>
<p>构建（重新构建）项目中的服务容器：docker-compose build</p>
<p>拉取服务依赖的镜像：docker-compose pull</p>
<p>列出指定服务的容器：docker-compose ps eureka</p>
<p>删除指定服务的容器：docker-compose rm eureka</p>
<p>启动指定服务已存在的容器：docker-compose start eureka</p>
<p>在一个服务上执行一个命令：docker-compose run web bash（这样即可启动一个web服务，同时执行bash命令）</p>
<p>停止已运行的容器：docker-compose stop eureka</p>
<p>通过发送SIGKILL 信号停止指定服务的容器：docker-compose kill eureka</p>
<p>一个web服务形成瓶颈的时候，我们可以快速地的扩充几个web服务出来 ：</p>
<p>docker-compose up --scale web=3（ports:需要修改为随即映射端口，如 -5000）</p>
<p>version：指定本 yml 依从的 compose 哪个版本制定的。</p>
<p>build：指定为从上下文路径 ./dir/Dockerfile 所构建的镜像,</p>
<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<p>version: &quot;3.7&quot;</p>
<p>services:</p>
<p>webapp:</p>
<p>build:</p>
<p>context: ./dir</p>
<p>dockerfile: Dockerfile-alternate</p>
<p>args:</p>
<p>buildno: 1</p>
<p>labels:</p>
<p>- &quot;com.example.description=Accounting webapp&quot;</p>
<p>- &quot;com.example.department=Finance&quot;</p>
<p>- &quot;com.example.label-with-empty-value&quot;</p>
<p>target: prod</p>
<p>context：上下文路径。</p>
<p>dockerfile：指定构建镜像的 Dockerfile 文件名。</p>
<p>args：添加构建参数，这是只能在构建过程中访问的环境变量。</p>
<p>labels：设置构建镜像的标签。</p>
<p>target：多层构建，可以指定构建哪一层。</p>
<p>​        depends_on 设置依赖关系:</p>
<p>​        docker-compose up ：以依赖性顺序启动服务</p>
<p>​        docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</p>
<p>​        docker-compose stop ：按依赖关系顺序停止服务。</p>
<p>​        docker-compose.yml：</p>
<p>​        version: &quot;3.7&quot;</p>
<p>​        services:</p>
<p>​        web:</p>
<p>​        build: .</p>
<p>​        depends_on:</p>
<p>​        - db</p>
<p>​        - redis</p>
<p>​        redis:</p>
<p>​        image: redis</p>
<p>​        db:</p>
<p>​        image: postgres</p>
<p>​        注意：web 服务不会等待 redis db 完全启动 之后才启动。</p>
<p>deploy：指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p>
<p>docker-compose.yml：</p>
<p>version: &quot;3.7&quot;</p>
<p>services:</p>
<p>redis:</p>
<p>image: redis:alpine</p>
<p>deploy:</p>
<p>mode：replicated</p>
<p>replicas: 6</p>
<p>endpoint_mode: dnsrr</p>
<p>labels:</p>
<p>description: &quot;This redis service label&quot;</p>
<p>resources:</p>
<p>limits:</p>
<p>cpus: '0.50'</p>
<p>memory: 50M</p>
<p>reservations:</p>
<p>cpus: '0.25'</p>
<p>memory: 20M</p>
<p>restart_policy:</p>
<p>condition: on-failure</p>
<p>delay: 5s</p>
<p>max_attempts: 3</p>
<p>window: 120s</p>
<p>endpoint_mode：访问集群服务的方式：</p>
<p>vip：集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</p>
<p>dnsrr：DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</p>
<p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
<p>mode：指定服务提供的模式：</p>
<p>replicated：复制服务，复制指定服务到集群的机器上</p>
<p>global：全局服务，服务将部署至集群的每个节点。</p>
<p>replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p>
<p>resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p>
<p>restart_policy：配置如何在退出容器时重新启动容器。</p>
<p>condition：可选 none，on-failure 或者 any（默认值：any）。</p>
<p>delay：设置多久之后重启（默认值：0）。</p>
<p>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默 认值：一直重试）。</p>
<p>window：设置容器重启超时时间（默认值：0）。</p>
<p>四、docker-machine：</p>
<p>列出可用的机器：docker-machine ls</p>
<p>创建一台名为 test 的机器：docker-machine create --driver virtualbox test（--driver：指定用来创建机器的驱动类型。）</p>
<p>查看机器的 ip：docker-machine ip test</p>
<p>停止机器： docker-machine stop test</p>
<p>启动机器：docker-machine start test</p>
<p>进入机器：docker-machine ssh test</p>
<p>查看当前激活状态的 Docker 主机：docker-machine active</p>
<p>查看某一个docker vm主机的信息：docker-machine env test</p>
<p>删除某台 Docker 主机，对应的虚拟机也会被删除:：docker-machine rm test</p>
<p>以 json 格式输出指定Docker的详细信息：docker-machine inspect test</p>
<p>设置当前的环境变量为某一个主机的信息：eval (docker-machine env test) 取消当前环境变量：eval(docker-machine env -u)</p>
<p>通过 SSH 连接到主机上，执行命令：docker-machine ssh swarm-manager</p>
<p>五、docker swarm：</p>
<p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p>
<p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<p>swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</p>
<p>work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/0c6eae.png" alt="img" loading="lazy"></figure>
<p>1、创建 swarm 集群管理节点（manager）</p>
<p>创建 docker 机器： docker-machine create -d virtualbox swarm-manager</p>
<p>连接到主机上：docker-machine ssh swarm-manager</p>
<p>初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点:</p>
<p>docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。</p>
<p>会输出：</p>
<p>docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377</p>
<p>查看集群节点信息: docker node ls</p>
<p>2、创建 swarm 集群工作节点（worker）</p>
<p>使用docker-machine 创建swarm-worker1 和 swarm-worker2 两台机器。</p>
<p>docker-machine create -d virtualbox worker1</p>
<p>docker-machine create -d virtualbox worker2</p>
<p>docker-machine ssh swarm-worker1进入机器里</p>
<p>添加上一步输出的内容。</p>
<p>3、查看集群信息</p>
<p>docker-machine ssh swarm-manager进入集群管理节点,执行docker info 可以查看当前集群的信息（Swarm:active,Managers:1,Nodes:3,有三个节点,其中有一个是管理节点）</p>
<p>4、部署服务到集群中</p>
<p>注意：跟集群管理有关的任何操作，都是在管理节点上操作的。</p>
<p>在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：docker service create --replicas 1 --name helloworld alpine ping docker.com</p>
<p>命令解释：</p>
<p>docker service create 命令创建一个服务</p>
<p>--name 服务名称命名为 helloworld</p>
<p>--replicas 设置启动的示例数</p>
<p>alpine指的是使用的镜像名称，ping docker.com指的是容器运行的bash</p>
<p>5、查看服务部署情况</p>
<p>查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点： docker service ps helloworld</p>
<p>查看 helloworld 部署的具体信息：docker service inspect --pretty helloworld</p>
<p>6、扩展集群服务</p>
<p>将上述的 helloworld 服务扩展到俩个节点：docker service scale helloworld=2</p>
<p>可以看到已经从一个节点，扩展到两个节点：docker service ps helloworld</p>
<p>7、删除服务：docker service rm helloworld</p>
<p>查看是否已删除：docker service ps helloworld</p>
<p>8、滚动升级服务</p>
<p>介绍 redis 版本如何滚动升级至更高版本</p>
<p>创建一个 3.0.6 版本的 redis。</p>
<p>docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</p>
<p>滚动升级 redis</p>
<p>docker service update --image redis:3.0.7 redis</p>
<p>9、停止某个节点接收新的任务</p>
<p>查看所有的节点：docker node ls</p>
<p>可以看到目前所有的节点都是 Active, 可以接收新的任务分配。</p>
<p>停止节点 swarm-worker1：</p>
<p>docker node update --availability drain swarm-worker1 （Drain：节点状态）</p>
<p>重新激活swarm-worker1：</p>
<p>docker node update --availability active swarm-worker1（active ：活跃状态）</p>
<p>10.退出 Swarm 集群</p>
<p>如果 Manager 想要退出 Swarm 集群， 在 Manager Node 上执行如下命令：</p>
<p>docker swarm leave</p>
<p>就可以退出集群，如果集群中还存在其它的 Worker Node，还希望 Manager 退出集群，则加上一个强制选项，命令行如下所示：docker swarm leave --force</p>
<p>在 Worker2 上进行退出测试，登录 worker2 节点：</p>
<p>docker-machine ssh worker2</p>
<p>执行退出命令：docker swarm leave</p>
<p>11.重新搭建命令</p>
<p>使用 VirtualBox 做测试的时候，如果想重复实验可以将实验节点删掉再重来。</p>
<p>停止虚拟机：docker-machine stop manager1 worker1 worker2</p>
<p>移除虚拟机：docker-machine rm manager1 worker1 worker2</p>
<p>停止、删除虚拟主机后，再重新创建即可。</p>
<ul>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个WEB程序员发展历程]]></title>
        <id>https://kangjn.github.io/post/yi-ge-web-cheng-xu-yuan-fa-zhan-li-cheng/</id>
        <link href="https://kangjn.github.io/post/yi-ge-web-cheng-xu-yuan-fa-zhan-li-cheng/">
        </link>
        <updated>2021-06-17T06:36:44.000Z</updated>
        <content type="html"><![CDATA[<p>做一个静态网页：</p>
<ul>
<li>
<p>HTML：用来布局网页</p>
</li>
<li>
<p>CSS：用来美化网页</p>
</li>
<li>
<p>JavaScript：用来做点击跳转，窗口弹出</p>
</li>
</ul>
<p>真正开发时需要用一些开发框架和组件来快速开发：</p>
<ul>
<li>JQUERY：极大简化了JavaScript的编程方式</li>
<li>BootStrap.js：可直接套用其好看的样式进行快速开发</li>
</ul>
<p>浏览器兼容</p>
<ul>
<li>
<p>谷歌浏览器</p>
</li>
<li>
<p>火狐浏览器</p>
</li>
<li>
<p>IE6,7,8,9浏览器</p>
</li>
<li>
<p>360安全浏览器</p>
</li>
<li>
<p>360极速浏览器</p>
</li>
</ul>
<p>网页是静态，需要改成动态的...</p>
<ul>
<li>
<p>Ajax，用来进行前端调后端接口</p>
</li>
<li>
<p>Json，后端接口返回的数据的一种格式</p>
</li>
<li>
<p>Spring：轻量级的快速开发框架</p>
</li>
<li>
<p>Spring MVC：一个快速开发Web应用框架</p>
</li>
<li>
<p>FreeMarker：一种服务端模板引擎</p>
</li>
<li>
<p>HttpClient：一个Java实现的Http请求客户端</p>
</li>
<li>
<p>Mybatis：一款优秀的持久层框架</p>
</li>
<li>
<p>Mysql：一个国内最流行的数据库软件</p>
</li>
<li>
<p>Maven：一个项目管理工具，可以对 Java 项目进行构建、依赖管理</p>
</li>
<li>
<p>Tomcat：使用得最多的Servlet容器，可以用来接收浏览器请求</p>
<p>管理工具</p>
</li>
<li>
<p>Git：一个代码版本管理工具</p>
</li>
<li>
<p>GitLab：一个项目管理和代码托管平台</p>
</li>
<li>
<p>Nexus：一个强大的Maven仓库管理器，它极大地简化了自己内部仓库的维护和外部仓库的访问</p>
</li>
<li>
<p>禅道：第一款国产的开源项目管理软件，完整地覆盖了项目管理的核心流程</p>
</li>
<li>
<p>jira：Jira融合了项目管理、任务管理和缺陷管理，许多著名的开源项目都采用了JIRA</p>
</li>
</ul>
<p>有了这些管理工具，还需要一些自动化构建工具，这样能使得开发测试上线更加顺利：</p>
<ul>
<li>Docker：一个开源的应用容器引擎</li>
<li>Jenkins：一个开源的、提供友好操作界面的持续集成(CI)工具</li>
</ul>
<p>一套自动化开发测试搭建起来了，有了这一整套项目开发管理工具，可以进行小团队合作</p>
<p>为了上线之后能够有保障的运行，我们需要给我们的网站配套一套监控和日志系统：</p>
<ul>
<li>
<p>Prometheus：一个开源的服务监控系统和时间序列数据库</p>
</li>
<li>
<p>Grafana：一个开源的、功能齐全的度量仪表盘和图形编辑器</p>
</li>
<li>
<p>Zabbix：一个企业级分布式开源监控解决方案</p>
</li>
<li>
<p>ElasticSearch：一个实时的分布式搜索分析引擎</p>
</li>
<li>
<p>Kibana：一个能对日志进行高效的搜索、可视化、分析等各种操作的平台</p>
</li>
<li>
<p>LogStash：一个应用程序日志、事件的传输、处理、管理和搜索的平台</p>
</li>
<li>
<p>Log4j：一个可以控制日志信息输送的目的地的开源组件</p>
</li>
<li>
<p>Logback：og4j创始人设计的另外一个开源日志组件</p>
</li>
</ul>
<p>搭完这一套，网站上线了，一段时间后，网站的用户慢慢在增多，我们通过我们的监控系统，发现有几个核心应用压力在不停地增加，要做负载均衡了：</p>
<ul>
<li>
<p>nginx：一个高性能的HTTP和反向代理web服务器</p>
</li>
<li>
<p>lvs：一个虚拟的服务器集群系统</p>
</li>
<li>
<p>keepalive：一个可以检测web服务器的状态的服务</p>
</li>
</ul>
<p>最后通过使用nginx并增加几台服务器来做了负载均衡，仅仅做负载均衡还不够，可以把热门商品给提前缓存起来：</p>
<ul>
<li>
<p>Redis：一个高性能的key-value数据库，对关系数据库起到很好的补充作用</p>
</li>
<li>
<p>Jedis：一个Redis 官方首选的 Java 客户端开发包</p>
</li>
<li>
<p>Redisson：一个在NIO的基础上，为使用者提供了一系列具有分布式特性的常用工具类</p>
</li>
</ul>
<p>这样，我们的网站访问速度提升了，要做一个订单状态变更短信通知的功能，用消息队列来做，：</p>
<ul>
<li>
<p>RabbitMQ：是一款高性能、搞健壮性以及高伸缩性的消息队列中间件</p>
</li>
<li>
<p>Kafka：是一种高吞吐量的分布式发布订阅消息系统</p>
</li>
<li>
<p>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务</p>
</li>
</ul>
<p>最后，选了阿里的RocketMQ</p>
<p>随着业务的发展，要对我们的项目做一次重构，改成分布式微服务架构：</p>
<ul>
<li>
<p>Dubbo：阿里开源的高性能RPC调用框架</p>
</li>
<li>
<p>Spring Cloud：一个为开发人员快速构建微服务架构的开发框架</p>
</li>
<li>
<p>Zookeeper：一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供组服务</p>
</li>
<li>
<p>Netty：一个高性能网络应用框架</p>
</li>
<li>
<p>Xxl-Job：一个轻量级分布式任务调度平台</p>
</li>
<li>
<p>Elastic-Job：一个分布式调度解决方案</p>
</li>
</ul>
<p>选用Spring Cloud，他所提供的几个组件太强大了，比如：</p>
<ul>
<li>
<p>Nacos：一个动态服务发现、配置和服务管理平台</p>
</li>
<li>
<p>Ribbon：一个在客户侧提供软件负载均衡算法的组件</p>
</li>
<li>
<p>Feign：一个更强大好用的Java HTTP 客户端库</p>
</li>
<li>
<p>Sentinel：一个面向分布式服务架构的高可用流量防护组件</p>
</li>
</ul>
<p>进入了高速发展期：</p>
<ul>
<li>
<p>敏捷开发：一种新型的互联网开发模式</p>
</li>
<li>
<p>迭代：敏捷开发过程中的周期概念</p>
</li>
<li>
<p>看板：敏捷开发过程中最重要的效能工具</p>
</li>
<li>
<p>DDD：一种微服务拆分设计思想</p>
</li>
</ul>
<p>等等开发设计理念...</p>
<p>直到有一天，出事了...，我们网站瘫痪了，一看监控，数据库压力爆了，通过调整限流等措施，暂时得到了缓解，需要分库分表了：</p>
<ul>
<li>Mycat：一个彻底开源的，面向企业应用开发的数据库中间件产品</li>
<li>ShardingSphere：一套开源的分布式数据库中间件解决方案组成的生态圈</li>
</ul>
<p>还要做到自动扩缩容：</p>
<ul>
<li>kubernetes：一个来自 Google 云平台的开源容器集群管理系统</li>
<li>openshift：一个由红帽推出的面向开发人员的Paas</li>
</ul>
<p>一些概念：</p>
<ul>
<li>
<p>ServiceMesh架构：下一代微服务架构</p>
</li>
<li>
<p>Serverless架构：用来构建和运行不需要服务器管理的应用程序</p>
</li>
<li>
<p>云原生架构：一种结合云环境，充分利用云资源的架构</p>
</li>
</ul>
<p>进入了平稳期</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式锁 三种实现方式]]></title>
        <id>https://kangjn.github.io/post/fen-bu-shi-suo-san-chong-shi-xian-fang-shi/</id>
        <link href="https://kangjn.github.io/post/fen-bu-shi-suo-san-chong-shi-xian-fang-shi/">
        </link>
        <updated>2021-05-26T01:51:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>一、为什么要使用分布式锁</strong></p>
<p>我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的Java多线程的18般武艺进行处理，并且可以完美的运行，毫无Bug！</p>
<p>注意这是单机应用，也就是所有的请求都会分配到当前服务器的JVM内部，然后映射为操作系统的线程进行处理！而这个共享变量只是在这个JVM内部的一块内存空间！</p>
<p>后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做[负载均衡]，大致如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/b2ngry.png" alt="" loading="lazy"></figure>
<p>上图可以看到，变量A存在JVM1、JVM2、JVM3三个JVM内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象，例如：UserController控制器中的一个整形类型的成员变量)，如果不加任何控制的话，变量A同时都会在JVM分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同JVM内存区域的数据，变量A之间不存在共享，也不具有可见性，处理的结果也是不对的！</p>
<p>如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！</p>
<p>为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<h3 id="二-分布式锁应该具备哪些条件"><strong>二、分布式锁应该具备哪些条件</strong></h3>
<p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p>
<ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li>
<li>高可用的获取锁与释放锁；</li>
<li>高性能的获取锁与释放锁；</li>
<li>具备可重入特性；</li>
<li>具备锁失效机制，防止死锁；</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>
</ol>
<h3 id="三-分布式锁的三种实现方式"><strong>三、分布式锁的三种实现方式</strong></h3>
<p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p>
<ul>
<li>基于缓存（Redis等）实现分布式锁；</li>
<li>基于数据库实现分布式锁；</li>
<li>基于Zookeeper实现分布式锁；</li>
</ul>
<h4 id="基于-redis-的分布式锁"><strong>基于 Redis 的分布式锁</strong></h4>
<h5 id="利用-setnx-和-setex"><strong>利用 SETNX 和 SETEX</strong></h5>
<p>基本命令主要有：</p>
<ul>
<li>SETNX(SET If Not Exists)：当且仅当 Key 不存在时，则可以设置，否则不做任何动作。</li>
<li>SETEX：可以设置超时时间</li>
</ul>
<p>其原理为：通过 SETNX 设置 Key-Value 来获得锁，随即进入死循环，每次循环判断，如果存在 Key 则继续循环，如果不存在 Key，则跳出循环，当前任务执行完成后，删除 Key 以释放锁。</p>
<p>这种方式可能会导致死锁，为了避免这种情况，需要设置超时时间。</p>
<p>下面，请看具体的实现步骤。</p>
<p>1.创建一个 Maven 工程并在 pom.xml 加入以下依赖：</p>
<pre><code class="language-javascript">&lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- 开启web--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- redis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>2.创建启动类 Application.java：</p>
<pre><code class="language-javascript">@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class,args);
    }

}
</code></pre>
<p>3.添加配置文件 application.yml：</p>
<pre><code class="language-javascript">server:
  port: 8080
spring:
  redis:
    host: localhost
    port: 6379
</code></pre>
<p>4.创建全局锁类 Lock.java：</p>
<pre><code class="language-javascript">/**
 * 全局锁，包括锁的名称
 */
public class Lock {
    private String name;
    private String value;

    public Lock(String name, String value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public String getValue() {
        return value;
    }

}
</code></pre>
<p>5.创建分布式锁类 DistributedLockHandler.java：</p>
<pre><code class="language-javascript">@Component
public class DistributedLockHandler {

    private static final Logger logger = LoggerFactory.getLogger(DistributedLockHandler.class);
    private final static long LOCK_EXPIRE = 30 * 1000L;//单个业务持有锁的时间30s，防止死锁
    private final static long LOCK_TRY_INTERVAL = 30L;//默认30ms尝试一次
    private final static long LOCK_TRY_TIMEOUT = 20 * 1000L;//默认尝试20s

    @Autowired
    private StringRedisTemplate template;

    /**
     * 尝试获取全局锁
     *
     * @param lock 锁的名称
     * @return true 获取成功，false获取失败
     */
    public boolean tryLock(Lock lock) {
        return getLock(lock, LOCK_TRY_TIMEOUT, LOCK_TRY_INTERVAL, LOCK_EXPIRE);
    }

    /**
     * 尝试获取全局锁
     *
     * @param lock    锁的名称
     * @param timeout 获取超时时间 单位ms
     * @return true 获取成功，false获取失败
     */
    public boolean tryLock(Lock lock, long timeout) {
        return getLock(lock, timeout, LOCK_TRY_INTERVAL, LOCK_EXPIRE);
    }

    /**
     * 尝试获取全局锁
     *
     * @param lock        锁的名称
     * @param timeout     获取锁的超时时间
     * @param tryInterval 多少毫秒尝试获取一次
     * @return true 获取成功，false获取失败
     */
    public boolean tryLock(Lock lock, long timeout, long tryInterval) {
        return getLock(lock, timeout, tryInterval, LOCK_EXPIRE);
    }

    /**
     * 尝试获取全局锁
     *
     * @param lock           锁的名称
     * @param timeout        获取锁的超时时间
     * @param tryInterval    多少毫秒尝试获取一次
     * @param lockExpireTime 锁的过期
     * @return true 获取成功，false获取失败
     */
    public boolean tryLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) {
        return getLock(lock, timeout, tryInterval, lockExpireTime);
    }


    /**
     * 操作redis获取全局锁
     *
     * @param lock           锁的名称
     * @param timeout        获取的超时时间
     * @param tryInterval    多少ms尝试一次
     * @param lockExpireTime 获取成功后锁的过期时间
     * @return true 获取成功，false获取失败
     */
    public boolean getLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) {
        try {
            if (StringUtils.isEmpty(lock.getName()) || StringUtils.isEmpty(lock.getValue())) {
                return false;
            }
            long startTime = System.currentTimeMillis();
            do{
                if (!template.hasKey(lock.getName())) {
                    ValueOperations&lt;String, String&gt; ops = template.opsForValue();
                    ops.set(lock.getName(), lock.getValue(), lockExpireTime, TimeUnit.MILLISECONDS);
                    return true;
                } else {//存在锁
                    logger.debug(&quot;lock is exist!！！&quot;);
                }
                if (System.currentTimeMillis() - startTime &gt; timeout) {//尝试超过了设定值之后直接跳出循环
                    return false;
                }
                Thread.sleep(tryInterval);
            }
            while (template.hasKey(lock.getName())) ;
        } catch (InterruptedException e) {
            logger.error(e.getMessage());
            return false;
        }
        return false;
    }

    /**
     * 释放锁
     */
    public void releaseLock(Lock lock) {
        if (!StringUtils.isEmpty(lock.getName())) {
            template.delete(lock.getName());
        }
    }

}
</code></pre>
<p>6.最后创建 HelloController 来测试分布式锁。</p>
<pre><code class="language-javascript">@RestController
public class HelloController {

    @Autowired
    private DistributedLockHandler distributedLockHandler;

    @RequestMapping(&quot;index&quot;)
    public String index(){
        Lock lock=new Lock(&quot;lynn&quot;,&quot;min&quot;);
        if(distributedLockHandler.tryLock(lock)){
            try {
                //为了演示锁的效果，这里睡眠5000毫秒
                System.out.println(&quot;执行方法&quot;);
                Thread.sleep(5000);
            }catch (Exception e){
                e.printStackTrace();
            }
            distributedLockHandler.releaseLock(lock);
        }
        return &quot;hello world!&quot;;
    }
}
</code></pre>
<p>7.测试。</p>
<p>启动 Application.java，连续访问两次浏览器：http://localhost:8080/index，控制台可以发现先打印了一次“执行方法”，说明后面一个线程被锁住了，5秒后又再次打印了“执行方法”，说明锁被成功释放。</p>
<blockquote>
<p>通过这种方式创建的分布式锁存在以下问题：</p>
</blockquote>
<ol>
<li>高并发的情况下，如果两个线程同时进入循环，可能导致加锁失败。</li>
<li>SETNX 是一个耗时操作，因为它需要判断 Key 是否存在，因为会存在性能问题。</li>
</ol>
<p>因此，Redis 官方推荐 Redlock 来实现分布式锁。</p>
<h5 id="利用-redlock"><strong>利用 Redlock</strong></h5>
<p>通过 Redlock 实现分布式锁比其他算法更加可靠，继续改造上一例的代码。</p>
<p>1.pom.xml 增加以下依赖：</p>
<pre><code class="language-javascript">&lt;dependency&gt;
            &lt;groupId&gt;org.redisson&lt;/groupId&gt;
            &lt;artifactId&gt;redisson&lt;/artifactId&gt;
            &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>2.增加以下几个类：</p>
<pre><code class="language-javascript">/**
 * 获取锁后需要处理的逻辑
 */
public interface AquiredLockWorker&lt;T&gt; {
    T invokeAfterLockAquire() throws Exception;
}
/**
 * 获取锁管理类
 */
public interface DistributedLocker {

    /**
     * 获取锁
     * @param resourceName  锁的名称
     * @param worker 获取锁后的处理类
     * @param &lt;T&gt;
     * @return 处理完具体的业务逻辑要返回的数据
     * @throws UnableToAquireLockException
     * @throws Exception
     */
    &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws UnableToAquireLockException, Exception;

    &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception;

}
/**
 * 异常类
 */
public class UnableToAquireLockException extends RuntimeException {

    public UnableToAquireLockException() {
    }

    public UnableToAquireLockException(String message) {
        super(message);
    }

    public UnableToAquireLockException(String message, Throwable cause) {
        super(message, cause);
    }
}
/**
 * 获取RedissonClient连接类
 */
@Component
public class RedissonConnector {
    RedissonClient redisson;
    @PostConstruct
    public void init(){
        redisson = Redisson.create();
    }

    public RedissonClient getClient(){
        return redisson;
    }

}
@Component
public class RedisLocker  implements DistributedLocker{

    private final static String LOCKER_PREFIX = &quot;lock:&quot;;

    @Autowired
    RedissonConnector redissonConnector;
    @Override
    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws InterruptedException, UnableToAquireLockException, Exception {

        return lock(resourceName, worker, 100);
    }

    @Override
    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception {
        RedissonClient redisson= redissonConnector.getClient();
        RLock lock = redisson.getLock(LOCKER_PREFIX + resourceName);
        // Wait for 100 seconds seconds and automatically unlock it after lockTime seconds
        boolean success = lock.tryLock(100, lockTime, TimeUnit.SECONDS);
        if (success) {
            try {
                return worker.invokeAfterLockAquire();
            } finally {
                lock.unlock();
            }
        }
        throw new UnableToAquireLockException();
    }
}
</code></pre>
<p>3.修改 HelloController：</p>
<pre><code class="language-javascript">@RestController
public class HelloController {

    @Autowired
    private DistributedLocker distributedLocker;

    @RequestMapping(&quot;index&quot;)
    public String index()throws Exception{
        distributedLocker.lock(&quot;test&quot;,new AquiredLockWorker&lt;Object&gt;() {

            @Override
            public Object invokeAfterLockAquire() {
                try {
                    System.out.println(&quot;执行方法！&quot;);
                    Thread.sleep(5000);
                }catch (Exception e){
                    e.printStackTrace();
                }
                return null;
            }

        });
        return &quot;hello world!&quot;;
    }
}
</code></pre>
<p>4.按照上节的测试方法进行测试，我们发现分布式锁也生效了。</p>
<p>Redlock 是 Redis 官方推荐的一种方案，因此可靠性比较高。</p>
<h4 id="基于数据库的分布式锁"><strong>基于数据库的分布式锁</strong></h4>
<h5 id="基于数据库表"><strong>基于数据库表</strong></h5>
<p>它的基本原理和 Redis 的 SETNX 类似，其实就是创建一个分布式锁表，加锁后，我们就在表增加一条记录，释放锁即把该数据删掉，具体实现，我这里就不再一一举出。</p>
<p>它同样存在一些问题：</p>
<ol>
<li>没有失效时间，容易导致死锁；</li>
<li>依赖数据库的可用性，一旦数据库挂掉，锁就马上不可用；</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作；</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库中数据已经存在了。</li>
</ol>
<h5 id="乐观锁"><strong>乐观锁</strong></h5>
<p>基本原理为：乐观锁一般通过 version 来实现，也就是在数据库表创建一个 version 字段，每次更新成功，则 version+1，读取数据时，我们将 version 字段一并读出，每次更新时将会对版本号进行比较，如果一致则执行此操作，否则更新失败！</p>
<h5 id="悲观锁排他锁"><strong>悲观锁（排他锁）</strong></h5>
<p>实现步骤见下面说明。</p>
<p>1.创建一张数据库表：</p>
<pre><code class="language-javascript">CREATE TABLE `methodLock` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',
  `desc` varchar(1024) NOT NULL DEFAULT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
</code></pre>
<p>2.通过数据库的排他锁来实现分布式锁。</p>
<p>基于MySQL 的 InnoDB 引擎，可以使用以下方法来实现加锁操作：</p>
<pre><code class="language-javascript">public boolean lock(){
    connection.setAutoCommit(false)
    while(true){
        try{
            result = select * from methodLock where method_name=xxx for update;
            if(result==null){
                return true;
            }
        }catch(Exception e){

        }
        sleep(1000);
    }
    return false;
}
</code></pre>
<p>3.我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<pre><code class="language-javascript">public void unlock(){
    connection.commit();
}
</code></pre>
<h4 id="基于-zookeeper-的分布式锁"><strong>基于 Zookeeper 的分布式锁</strong></h4>
<h5 id="zookeeper-简介"><strong>ZooKeeper 简介</strong></h5>
<p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google Chubby 的一个开源实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h5 id="分布式锁实现原理"><strong>分布式锁实现原理</strong></h5>
<p>实现原理为：</p>
<ol>
<li>建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent）</li>
<li>每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（<code>EPHEMERAL_SEQUENTIAL</code>），通过组成特定的名字 name+lock+顺序号。</li>
<li>在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。</li>
<li>假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件。同时在这里阻塞。等待监听事件的发生，获得锁控制权。</li>
<li>当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。</li>
</ol>
<p>实现的分布式锁是严格的按照顺序访问的并发锁。</p>
<h5 id="代码实现"><strong>代码实现</strong></h5>
<p>我们继续改造本文的工程。</p>
<p>1.创建 DistributedLock 类：</p>
<pre><code class="language-javascript">public class DistributedLock implements Lock, Watcher{
    private ZooKeeper zk;
    private String root = &quot;/locks&quot;;//根
    private String lockName;//竞争资源的标志
    private String waitNode;//等待前一个锁
    private String myZnode;//当前锁
    private CountDownLatch latch;//计数器
    private CountDownLatch connectedSignal=new CountDownLatch(1);
    private int sessionTimeout = 30000;
    /**
     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用
     * @param config localhost:2181
     * @param lockName 竞争资源标志,lockName中不能包含单词_lock_
     */
    public DistributedLock(String config, String lockName){
        this.lockName = lockName;
        // 创建一个与服务器的连接
        try {
            zk = new ZooKeeper(config, sessionTimeout, this);
            connectedSignal.await();
            Stat stat = zk.exists(root, false);//此去不执行 Watcher
            if(stat == null){
                // 创建根节点
                zk.create(root, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            }
        } catch (IOException e) {
            throw new LockException(e);
        } catch (KeeperException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        }
    }
    /**
     * zookeeper节点的监视器
     */
    public void process(WatchedEvent event) {
        //建立连接用
        if(event.getState()== Event.KeeperState.SyncConnected){
            connectedSignal.countDown();
            return;
        }
        //其他线程放弃锁的标志
        if(this.latch != null) {
            this.latch.countDown();
        }
    }

    public void lock() {
        try {
            if(this.tryLock()){
                System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; &quot; +myZnode + &quot; get lock true&quot;);
                return;
            }
            else{
                waitForLock(waitNode, sessionTimeout);//等待锁
            }
        } catch (KeeperException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        }
    }
    public boolean tryLock() {
        try {
            String splitStr = &quot;_lock_&quot;;
            if(lockName.contains(splitStr))
                throw new LockException(&quot;lockName can not contains \\u000B&quot;);
            //创建临时子节点
            myZnode = zk.create(root + &quot;/&quot; + lockName + splitStr, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);
            System.out.println(myZnode + &quot; is created &quot;);
            //取出所有子节点
            List&lt;String&gt; subNodes = zk.getChildren(root, false);
            //取出所有lockName的锁
            List&lt;String&gt; lockObjNodes = new ArrayList&lt;String&gt;();
            for (String node : subNodes) {
                String _node = node.split(splitStr)[0];
                if(_node.equals(lockName)){
                    lockObjNodes.add(node);
                }
            }
            Collections.sort(lockObjNodes);

            if(myZnode.equals(root+&quot;/&quot;+lockObjNodes.get(0))){
                //如果是最小的节点,则表示取得锁
                System.out.println(myZnode + &quot;==&quot; + lockObjNodes.get(0));
                return true;
            }
            //如果不是最小的节点，找到比自己小1的节点
            String subMyZnode = myZnode.substring(myZnode.lastIndexOf(&quot;/&quot;) + 1);
            waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - 1);//找到前一个子节点
        } catch (KeeperException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        }
        return false;
    }
    public boolean tryLock(long time, TimeUnit unit) {
        try {
            if(this.tryLock()){
                return true;
            }
            return waitForLock(waitNode,time);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
    private boolean waitForLock(String lower, long waitTime) throws InterruptedException, KeeperException {
        Stat stat = zk.exists(root + &quot;/&quot; + lower,true);//同时注册监听。
        //判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听
        if(stat != null){
            System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; waiting for &quot; + root + &quot;/&quot; + lower);
            this.latch = new CountDownLatch(1);
            this.latch.await(waitTime, TimeUnit.MILLISECONDS);//等待，这里应该一直等待其他线程释放锁
            this.latch = null;
        }
        return true;
    }
    public void unlock() {
        try {
            System.out.println(&quot;unlock &quot; + myZnode);
            zk.delete(myZnode,-1);
            myZnode = null;
            zk.close();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }
    public void lockInterruptibly() throws InterruptedException {
        this.lock();
    }
    public Condition newCondition() {
        return null;
    }

    public class LockException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        public LockException(String e){
            super(e);
        }
        public LockException(Exception e){
            super(e);
        }
    }
}
</code></pre>
<p>2.改造 HelloController.java：</p>
<pre><code class="language-javascript">@RestController
public class HelloController {

    @RequestMapping(&quot;index&quot;)
    public String index()throws Exception{
        DistributedLock lock   = new DistributedLock(&quot;localhost:2181&quot;,&quot;lock&quot;);
        lock.lock();
        //共享资源
        if(lock != null){
            System.out.println(&quot;执行方法&quot;);
            Thread.sleep(5000);
            lock.unlock();
        }
        return &quot;hello world!&quot;;
    }
}
</code></pre>
<p>3.按照本文 Redis 分布式锁的方法测试，我们发现同样成功加锁了。</p>
<h3 id="总结"><strong>总结</strong></h3>
<p>通过以上的实例可以得出以下结论：</p>
<ul>
<li>通过数据库实现分布式锁是最不可靠的一种方式，对数据库依赖较大，性能较低，不利于处理高并发的场景。</li>
<li>通过 Redis 的 Redlock 和 ZooKeeper 来加锁，性能有了比较大的提升。</li>
<li>针对 Redlock，曾经有位大神对其实现的分布式锁提出了质疑，但是 Redis 官方却不认可其说法，所谓公说公有理婆说婆有理，对于分布式锁的解决方案，没有最好，只有最适合的，根据不同的项目采取不同方案才是最合理的。</li>
</ul>
<p>最后的最后说明一下：</p>
<blockquote>
<p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>
</blockquote>
<h4 id="下面是从各个方面进行三种实现方式的对比"><strong>下面是从各个方面进行三种实现方式的对比</strong></h4>
<p>从理解的难易程度角度（从低到高）</p>
<blockquote>
<p>数据库 &gt; 缓存 &gt; Zookeeper</p>
</blockquote>
<p>从实现的复杂性角度（从低到高）</p>
<blockquote>
<p>Zookeeper &gt;= 缓存 &gt; 数据库</p>
</blockquote>
<p>从性能角度（从高到低）</p>
<blockquote>
<p>缓存 &gt; Zookeeper &gt;= 数据库</p>
</blockquote>
<p>从可靠性角度（从高到低）</p>
<blockquote>
<p>Zookeeper &gt; 缓存 &gt; 数据库</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[炼金术秘籍《翠玉录》]]></title>
        <id>https://kangjn.github.io/post/lian-jin-zhu-mi-ji-lesslesscui-yu-lu-greatergreater-niu-dun-fan-yi-ban-ben/</id>
        <link href="https://kangjn.github.io/post/lian-jin-zhu-mi-ji-lesslesscui-yu-lu-greatergreater-niu-dun-fan-yi-ban-ben/">
        </link>
        <updated>2021-04-30T04:03:10.000Z</updated>
        <content type="html"><![CDATA[<p>1. 当我走进洞穴，我看到了一块翠玉，上面写着字，那是从赫尔墨斯的双手间被书写出来。从那里我发现了以下这些文字：</p>
<p>When I entered into the cave,I received the tablet zaradi,which was inscribed,from between the hands of Hermes,in which I discovered these word:</p>
<p>2. 真实不虚，永不说谎，必然带来真实：</p>
<p>This true without lying, certain &amp; most true:</p>
<p>3. 下如同上，上如同下；依此成全太一的奇迹。</p>
<p>That which is below is like that which is above and that which is above is like that which is below to do ye miracles of one only thing.</p>
<p>4. 万物本是太一，藉由分化从太一创造出来。</p>
<p>And as all things have been and arose from one by ye mediation of one: so all things have their birth from this one thing by adaptation.</p>
<p>翠玉录开篇提出了大宇宙和小宇宙的呼应关系，这是炼金术宇宙观的核心。《墨子》提出一个类似的说法“上同下比”，但墨子的意思是人的思想行为要比照天、比照神明，顺应天道。赫耳墨斯的意思则是，理念、宇宙、自然这个大宇宙，跟个人、心灵、灵魂这个小宇宙是一种一体、和谐、映射的关系，利用炼金的转变过程将性灵从物质中解放出来，既重造物质、又重塑心灵，将可重现宇宙太一亦即道、“一切万有”创造的奇迹。太一创造的方式就是新柏拉图主义的“发散”说法，就是从一个一体而充盈的最高实在，象太阳放射光芒一样层层分化出了理性、灵魂和物质世界，而无损于太一的圆满。</p>
<p>5. 太阳为父，月亮为母，从风孕育，从地养护。</p>
<p>The Sun is its father, the moon its mother, the wind hath carried it in its belly, the earth its nourse.</p>
<p>6. 世间一切完美之源就在此处；其能力在地上最为完全。</p>
<p>The father of all perfection in ye whole world is here. Its force or power is entire if it be converted into earth.</p>
<p>这里的主语说的是完善的性灵，太阳指的是不朽的精神或高层次的自我——心性，太阴即月亮则是低层次的自我，是高我的投影。风是指灵性的生命力，地是指物质的躯体。神性与躯体的联合、精神和物质的统一，是创造奇迹的源泉，实际上也是神秘体验的普遍原则。《道德经》说，“道生之，德蓄之，物形之，势成之”，“之”指的也是生命、性灵，道与德就像太阳、月亮，而形、成大略也跟孕育和养护有一定的对应。</p>
<p>7. 分土于火，萃精于糙，谨慎行之。</p>
<p>Separate thou ye earth from ye fire, ye subtile from the gross sweetly wth great indoustry.</p>
<p>8. 从地升天，又从天而降，获得其上、其下之能力。</p>
<p>It ascends from ye earth to ye heaven &amp; again it desends to ye earth and receives ye force of things superior &amp; inferior.</p>
<p>9. 如此可得世界的荣耀、远离黑暗蒙昧。</p>
<p>By this means you shall have ye glory of ye whole world &amp; thereby all obscurity shall fly from you.</p>
<p>这里是说，在追求上述阴阳联合之前，必须分清属物和属灵的东西，分清灵性的呼唤和物质的欲望，才能体现真我的光辉。当一个人超越了阴与阳、自我与心性的对立，寻求到不朽的灵性，就从现实的存在中觉醒，获得通觉智慧、找到光明。再回到现实生活，一切都了然。</p>
<p>10. 此为万力之力，摧坚拔韧。</p>
<p>Its force is above all force, for it vanquishes every subtile thing &amp; penetrates every solid thing.</p>
<p>11.世界即如此创造，依此可达奇迹。</p>
<p>So was ye world created. From this are &amp; do come admirable adaptations whereof ye process is here in this.</p>
<p>12.我被称为三重伟大的赫尔墨斯，因我拥有世界三部分的智慧。</p>
<p>Hence I am called Hermes Trismegist, having the three parts of ye philosophy of ye whole world.</p>
<p>13.这就是我所说的伟大工作。</p>
<p>That which I have said of ye operation of ye Sun is accomplished &amp; ended.</p>
<p>这里所说的“力”，就是在炼金成功后所获得的贯通上下的能力，是最具有创造力的，因为他明了所经历的人生正像内在宇宙的外在投射。通过澈悟而达到的精神永恒，也将超越时间的局限，而时间是物质世界一切限制中最坚不可摧的。而赫耳墨斯号称拥有世界三部分的智慧，可能是因为他是埃及透特、希腊赫耳墨斯、罗马墨丘利三位同类神祗的融合，但更可能说是对理念、灵魂和物质这三个层面而言。翠玉录所谓伟大的工作，就是指从启蒙到开悟的漫长而宏伟的旅</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java后端学习路线]]></title>
        <id>https://kangjn.github.io/post/java-hou-duan-xue-xi-lu-xian/</id>
        <link href="https://kangjn.github.io/post/java-hou-duan-xue-xi-lu-xian/">
        </link>
        <updated>2021-04-27T05:57:47.000Z</updated>
        <content type="html"><![CDATA[<p><strong>后端技术学习路线</strong>思维导图框架：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/6961bc.png" alt="图片" loading="lazy"></figure>
<p>图中的每一个节点都可以点开，我都做了细分，在后面章节逐个展开介绍。</p>
<h2 id="计算机基础">计算机基础</h2>
<p>不管是后端开发还是前端开发，说到底我们所有的软件开发都是在计算上编写程序，虽然对于大部分人来说，真正开始写代码的时候很少会让你去解决计算机底层的问题，不接触不代表不重要，计算机基础是最重要的。</p>
<p>后端开发工作中经常用到 Java、C++、Python、Golang 这些语言称为高级编程语言，称为高级是它们接近我们日常交流的自然语言，离计算机底层远，<strong>但所有的高级语言最终都会转化成汇编-&gt;计算机指令-&gt;控制流操控计算机硬件</strong>，所以学习计算机构成和工作原理、操作系统这些基础知识，能够加深我们队高级语言的理解。</p>
<p><strong>中科大的计算机技术本科主要课程结构安排</strong>。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cc33dd.png" alt="图片" loading="lazy"></figure>
<p>一流大学的计算机专业要学什么可以对照着看下，从学科数学理论基础、计算机体系结构、软件工程方法等等维度展开。</p>
<p>那如果你不是计算机相关专业的想转行，也不要被吓到了，毕竟这是人家四年时间的学习内容，本科的培养目标不仅仅是培养出一个软件工程师，本科学习还是面向硕士博士的基础培养，注意是计算机科学专业，名字里有个词叫「科学」，我这篇文章要说的 BAT 公司后台软件开发，可以认为是「工学」方向，更多的是服务于工程开发。</p>
<p>如果只是面向后台开发和工作面试，或者你是非计算机专业想转行，社畜没有太多时间去学习大学那些理论课程，那帮我把计算机基础的范围缩小到下面这 4 门专业课：<strong>计算机组成原理、计算机网路、操作系统、数据结构</strong>。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/b91980.png" alt="图片" loading="lazy"></figure>
<h3 id="计算机组成原理">计算机组成原理</h3>
<p>这门课程让你了解计算机的组成和工作原理，要学习的内容包括：</p>
<ul>
<li>数据在计算机中的表示和运算（柠檬说：计算机不识数，只认得高低电平，所以数据在计算机内部都用二进制的0和1表示）</li>
<li>存储系统（柠檬说：数据和程序指令都要存储下来，学习计算机的存储层次，内存、外存、高速缓存、虚拟存储技术）</li>
<li>指令系统（柠檬说：写的代码最终都要被翻译成计算机指令，指令格式和寻址方式有多种，控制器来控制指令执行）</li>
<li>中央处理器（也就是 CPU 计算机的大脑，主要构成是运算器和控制器）</li>
<li>总线（柠檬说：计算机的血管动脉，连接计算机各功能组件，用来传输数据、地址信号、控制信号）</li>
<li>输入输出系统（柠檬说：Input/Output 也叫 IO 系统，连接和管理各种外部设备比如键盘、显示器等等）</li>
</ul>
<h3 id="计算机网络">计算机网络</h3>
<p>世界上第一台通用计算机「ENIAC」于 1946  被发明出来，如其名字一样仅仅是用于计算，在后来计算机越来越多，如果没有网络每台计算机都将成为一个孤岛，也不会有现在互联网的繁荣，「计算机网络」这门课程的学习路线非常清晰，就是围绕着如何让地理位置上不同的计算机连接起来，并高效可靠的交换数据信息，实现人在家中做，天下事尽知。</p>
<p>计算机网络有分层次，根据各层属性和特点，分为：</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
<p>这个层次划分从上到下就是一个网络数据包的接收路径，反之就是发送路径。既然要交换信息肯定得商量一套通用的协议，就像我们和老外交流，要么他们学中文要么我们学英文，反正得统一出一个标准语言出来，这在计算机网络中称之为「通信协议」。如上述的网络分层，每层都有各自适配的协议，所以计算机网络的学习基本就是围绕着分层协议的学习。</p>
<h3 id="操作系统">操作系统</h3>
<p>操作系统也是一种软件。你熟悉的微软Windos操作系统，后台开发熟悉的各种发行版的 Linux 系统，都是通过软件的形式安装在计算机上。</p>
<p>只不过这个软件和我们平常接触的应用程序软件不同，它比较特殊，因为它向下和计算机硬件（就是我们在计算机组成原理中学习的那些硬件）打交道，向上给其他应用程序和用户提供通用的交互的接口，说白了操作系统就是个中介和管家的角色。它帮我们做了下面这些事情：</p>
<ul>
<li>进程管理（柠檬说：你写的程序运行起来才能干活，运行起来的程序称为进程，进程是资源的最小单位）</li>
<li>内存管理（柠檬说：计算机内存又贵又少，动不动又要来个高并发，内存管理大有学问）</li>
<li>文件管理（柠檬说：计算机中的资料和信息需要通过文件系统来保存、管理）</li>
<li>输入输出管理（柠檬说：各种外部设备如何接入计算机和接入之后又如何管理）</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<p>数据结构大家最熟悉，即使毫无计算机基础或是想转行计算机，第一个遇到的就是数据结构，因为面试刷的算法题本质上就是对各种数据结构的运用。所以单纯对面试功利的角度来说，数据结构也是必须要掌握的计算机基础，数据结构要学到：</p>
<ul>
<li>线性表（链表、数组、循环链表）</li>
<li>栈和队列</li>
<li>树和各种二叉树（二叉排序树、平衡二叉树、哈夫曼树、B树、B+树、Trie树）</li>
<li>图（图的存储结构、BFS、DFS、最短路径、最小生成树、拓扑排序、关键路径）</li>
<li>查找算法（二分查找、B树查找、HASH表、KMP字符串模式匹配）</li>
<li>排序算法（插入排序、冒泡排序、归并排序、基数排序、堆排序）</li>
<li>贪心算法</li>
<li>位运算</li>
<li>分治算法</li>
<li>动态规划</li>
</ul>
<p>好了，计算机基础四大专业课已经大概过了一遍，当然这是我给没有计算机基础同学的实用主义建议，等你学完这四门课程也只能够说入门计算机了，不过这已经比很多人厉害了。如果想真正的了解计算机这门学科，可以等学完了这 4 门基础课程之后，再花写时间挑一些上面培养方案中的课程去学习，做一个知识体系完备的计算机软件后端开发工程师。</p>
<h2 id="linux">Linux</h2>
<p>在后台开发领域，你所能接触到的后端服务不敢说 100%，至少也有 90% 以上是运行在 Linux 系统之上，因为它开源、便利、功能强大，需要学习以下技术点：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/411ebf.png" alt="图片" loading="lazy"></figure>
<h3 id="linux系统使用">Linux系统使用</h3>
<p>所以如果你想走后端开发这条路线，我建议你趁早使用 Linux ，越早越好。可以是在个人 PC 上装 Linux  虚拟机，或者装个双系统贵。</p>
<h3 id="linux-高级编程">Linux 高级编程</h3>
<p>Linux「高级编程」的意思是比上面的 Linux 基础操作更深入一个层次。</p>
<p>学会了 Linux 的使用还不算是一个真正的开发人员，使用系统是成为开发者最基本要求，会操作Linux 就像使用 Windows 系统一样，只不过是学习成本的问题，如果这个世界没有 Window 系统，你女朋友花点时间也能掌握 Linux 系统基本操作。</p>
<p>要想进阶成为后端开发人员，就要懂得如何使用 Linux 系统提供的各种系统API（系统调用接口）进行编程开发，程序员用你写的代码来控制系统，普通用户只会用鼠标操纵。这个阶段需要学习：</p>
<ul>
<li>Unix 系统实现 Linux、基本系统数据类型</li>
<li>文件操作函数: <code>open</code> 、<code>read</code> <code>close</code> <code>write</code> <code>dup</code> <code>fcntl</code> <code>ioctl</code> <code>stat</code> <code>chmod``access</code> <code>chdir</code> ...</li>
<li>系统编程接口的基本特性和高级特性</li>
<li>Linux进程环境、如何创建进程、线程，程序的存储空间分配、环境变量</li>
<li>进程组、会话以及任务控制、进程优先级和调度</li>
<li>动态库和静态库</li>
<li>进程间通信：管道和FIFO、消息队列、信号量、共享内存、内存映射</li>
<li>套接字和网络编程</li>
</ul>
<p>总之，这一阶段需要学习的是在 Linux 环境下的高级编程技巧，通过对这些内容的学习也能让你更深入的理解 Linux 系统是如何工作和运行的，并且真正的踏入 Linux 系统编程大门。</p>
<h3 id="网络编程">网络编程</h3>
<p>网络编程是通过网络套接字 socket 方式实现的通信，所以也属于进程间通信 IPC（Inter-Process Communication）。</p>
<p>由于现在的后台服务基于服务端/客户端模型，两者之间基于网络通信，你在家用手机点个外卖的服务请求，也是通过网络通信发给某团的后台服务器，所以后台服务开发，说到底还是网络编程，以及建立在网络编程数据之上的应用层开发。</p>
<p>网络编程学什么：</p>
<ul>
<li>什么是socket套接字</li>
<li>套接字选项</li>
<li>TCP/UDP 套接字编程</li>
<li>Unix domain 协议和编程</li>
<li>原始套接字编程</li>
<li>IO多路复用：select 、poll、epoll、kqueue</li>
<li>序列化技术</li>
<li>零拷贝技术</li>
<li>开源网络库：muduo、libevent</li>
</ul>
<p>学完以上内容你大概可以写一个类似QQ一样的网络聊天小工具。</p>
<p>不在在工作中，都有成熟的网络框架或网络通信库，大公司比如鹅厂大部分是自研网络通信框架，小公司用开源项目，这让很多后台开发人员不必关心底层的网络通信细节，除了部分基础架构的开发同学，大部分后台开发同学工作都是在做业务系统的开发。</p>
<p>但了解底层网络编程原理，是后台开发人员的核心能力，这点对于 C/C++ 后台开发程序员尤为重要。它能拔高你看问题的高度，不了解底层原理，就像是在黑盒编程一样，出了问题无从下手排查。</p>
<p><strong>学完了以上内容，基本是具备了从事后台开发的基础能力，也能开发出一个简单的后台服务器了。</strong></p>
<h2 id="数据库">数据库</h2>
<p>除非是单纯的转发路由类后台服务，一般来说后台开发的web服务器后台程序，后台服务程序说白了就是个死循环：</p>
<blockquote>
<p>接收客户端数据包 -&gt; 处理数据包 -&gt; 业务逻辑处理 -&gt; 保存必要的数据 -&gt; 回复响应数据给客户端</p>
</blockquote>
<p>这其中会伴随对各种数据的处理，比如电商系统会处理订单数据、用户数据，游戏后台会处理角色数据和装备数据等等，有数据就会涉及到存储系统，数据一般都存储到数据库。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/751d77.png" alt="图片" loading="lazy"></figure>
<p>主要学习 2 大类数据库：</p>
<p><strong>关系型数据库</strong>是指采用了关系模型来组织数据的数据库，简单理解就是二维表格模型。</p>
<p><strong>非关系型数据库</strong>一般指的是 <code>key-value</code> 形式存储数据的 NoSQL 数据库，数据和键值是简单的映射关系。</p>
<h3 id="关系型数据库">关系型数据库</h3>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTE2OTY1Nw==&amp;mid=2247486864&amp;idx=1&amp;sn=d509ef3c3d06e9f1149fa136a44d777f&amp;chksm=c13f8b06f6480210fcbd2142e63ec1e8d15984f24a54b504f9c701a3c31bfc3be43fc86ae4ce&amp;token=2073211753&amp;lang=zh_CN&amp;scene=21#wechat_redirect">MySQL 数据库架构</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTE2OTY1Nw==&amp;mid=2247487268&amp;idx=1&amp;sn=6c97cbcd5ad12695ed2ffd64a16fb6fd&amp;chksm=c13f89b2f64800a48e7bbc39ee7f450a01ece6fc3d4aeaa27fad6ed8ce6a54381f44d1b83a77&amp;token=2073211753&amp;lang=zh_CN&amp;scene=21#wechat_redirect">MySQL索引使用和优化</a></li>
<li>innoDB存储引擎</li>
<li>查询性能优化</li>
<li>聚集索引、非聚集索引</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTE2OTY1Nw==&amp;mid=2247486900&amp;idx=1&amp;sn=ef7c98dc6c5ff787387410e0fc0eb3c4&amp;chksm=c13f8b22f6480234c1593c3d256758ab275c1864fc4c1c22fbe9970fb60814f41bf8046c016b&amp;token=2073211753&amp;lang=zh_CN&amp;scene=21#wechat_redirect">事务隔离，ACID，MVCC</a></li>
<li>锁机制，乐观锁、悲观锁、读锁、写锁、意向锁</li>
<li>日志</li>
<li>数据备份与恢复</li>
</ul>
<h3 id="非关系型数据库">非关系型数据库</h3>
<ul>
<li>redis 基本操作和使用</li>
<li>redis 设计与实现原理</li>
<li>MongoDB</li>
<li>levelDB</li>
<li>memcache</li>
<li>HBase</li>
<li>CKV+ 腾讯自研</li>
</ul>
<p>后台开发服务还需要学会解决<strong>三高问题</strong>：高并发、高可用、高性能。</p>
<h2 id="高并发">高并发</h2>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/105ea6.png" alt="图片" loading="lazy"></figure>
<p>利用到目前为止学习的内容，我们的开发的后台服务器应付一些小并发场景绰绰有余，但是随着互联网应用业务量的上涨，对后台服务端的请求数剧增，高并发需求随之而来，高并发指的就是高 TPS 和高 QPS</p>
<ul>
<li>TPS (Transactions Per Second)每秒事务数</li>
<li>QPS（Query Per Second）每秒查询数等。</li>
</ul>
<p>对于高并发服务必须改变传统的单进程模型，才能处理的过来如此海量的请求。</p>
<h3 id="多进程">多进程</h3>
<p>对于高并发的服务请求，由于后台服务一般都是 IO 密集型应用，IO 密集型应用就是大部分 CPU 时间用在网络 IO 上，相对的是 CPU 密集型应用大部分时间花在数据计算上。</p>
<p>大多数的后台服务程序都是 IO 密集型的应用，网络 IO 的时候 CPU 等待白白浪费时间， 这就告诉我们 CPU 的潜力还没有完全发挥，所以当一个进程的处理能力达到上限，我们可以多创建几个进程，这就是多进程模型。</p>
<h3 id="多线程">多线程</h3>
<p>多线程与多进程类似，实际在Linux系统中线程是由轻量级的进程 LWP（Light-weight process）实现，多线程方式实现的后台服务相对于多进程更加轻量，因为多线程是在同一个进程内部实现。</p>
<p>不过多线程也会带来新的问题，比如全局数据竞争和同步问题，引入线程锁还要防止死锁的发生。</p>
<h3 id="协程">协程</h3>
<p>那什么是协程呢？协程 <code>Coroutines</code> 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。</p>
<h3 id="异步回调">异步回调</h3>
<p>所谓异步回调就是，服务端发起 IO 请求的线程不等网络 IO  线程操作完成，就继续执行随后的代码，一般请求线程需要先注册一个回调函数，当IO 完成之后网络IO线程通过调用之前注册的回调函数来通知发起 IO  请求的线程，这样发起请求的线程就不会阻塞住等待结果，提高了服务处理性能。</p>
<h2 id="高性能">高性能</h2>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/4f1667.png" alt="图片" loading="lazy"></figure>
<p>按以上服务模型可以提高服务本身处理能力，高性能后台服务往往还会利用多种技术、从多个维度优化提高性能。比如采用CDN（Content  Delivery  Network）内容分发网络，存储和分发使用户就近获取内容，缩短响应时间；采用池化技术，避免频繁的资源分配与回收；采用服务集群，横向扩展服务能力；采用缓存技术，热点数据加入缓存，减少数据库访问。</p>
<ul>
<li>CND 内容分发技术</li>
<li>池化技术：数据库连接池，线程池</li>
<li>集群化</li>
<li>缓存技术</li>
</ul>
<h2 id="高可用">高可用</h2>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/781be6.png" alt="图片" loading="lazy"></figure>
<p>高可用即保证服务的稳定性，不出现重大问题或宕机，常见的解决高可用思路是冗余和负载均衡。冗余的意思就是多部署几台服务器，当其中一台挂掉另外一台能顶上。通过负载均衡技术实现对流量的动态调配，不至于出现大量流量冲击某台机器出现请求不均匀，软件负载均衡技术可以通过DNS、Nginx、LVS等技术实现。这里主要学习的技术有：</p>
<ul>
<li>负载均衡技术，软硬件负载均衡</li>
<li>限流隔离降级技术</li>
<li>应用层容灾，资源隔离熔断</li>
<li>异地多活</li>
</ul>
<h2 id="设计模式">设计模式</h2>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/2c32c5.png" alt="图片" loading="lazy"></figure>
<p>设计模式代表着软件开发的一种最佳实践。已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计，<strong>当设计大规模软件时遵循必要的设计模式能让写出的代码更加健壮和可扩展</strong>。</p>
<p>设计模式 6 大原则：</p>
<ul>
<li>开闭原则：对扩展开放，对修改关闭，多使用抽象类和接口。</li>
<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>
<li>依赖倒转原则：要依赖于抽象，不要依赖于具体，针对接口编程,不针对实现编程。</li>
<li>接口隔离原则：使用多个隔离的接口，比使用单个接口好，建立最小的接口。</li>
<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>
<li>合成复用原则：尽量使用合成/聚合，而不是使用继承。</li>
</ul>
<p>常见设计模式分类</p>
<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>适配器模式</li>
<li>桥接模式</li>
<li>过滤器模式</li>
<li>装饰器模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
<li>责任链模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>...</li>
</ul>
<h2 id="分布式">分布式</h2>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/a34448.png" alt="图片" loading="lazy"></figure>
<p>为什么会出现分布式？随着业务的体量不断增长，单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。</p>
<blockquote>
<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。</p>
</blockquote>
<p>分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议。这里需要学习的内容包括：</p>
<ul>
<li>分布式一致性算法：PAXOS、Raft、Zab</li>
<li>分布式事务：2PC、3PC、TCC</li>
<li>分布式唯一 ID 生成：雪花算法、UUID、淘宝 TDDL SEQUENCE方案、美团 Leaf</li>
<li>一致性HASH算法</li>
<li>扩展性设计，设计可扩展的软件架构</li>
<li>分布式文件系统：HDFS、FastDFS</li>
<li>微服务架构设计，服务注册、服务发现、服务路由</li>
</ul>
<h2 id="安全">安全</h2>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/ca3e59.png" alt="图片" loading="lazy"></figure>
<p>本质上后台服务在网络上运行，需要和各种网络环境交互，在正常情况下能够工作，但互联网中有很多针对后台服务的恶意攻击，因此网络安全也是后台开发工程师需要学习的内容。这里主要包括：</p>
<ul>
<li>web安全：CSRF、SQL注入、XSS</li>
<li>DDos防范</li>
<li>加解密算法：对称加密、哈希算法、非对称加密</li>
<li>网络隔离：内外网分离、跳板机</li>
<li>授权认证算法：OAuth2.0、OIDC、2FA、单点登录SSO</li>
</ul>
<h2 id="监控与统计">监控与统计</h2>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/618f3d.png" alt="图片" loading="lazy"></figure>
<p>后台服务运行我们如何了解其运行状态和健康度？如果只是开发小玩具监控和统计大可不必，只需记录本地日志即可，对于成熟的大型后台服务系统，监控、统计、追踪必不可少，<strong>无监控，不运营</strong>。</p>
<p>开源的监控软件有：Prometheus、Zabbix、Open-Falcon。</p>
<p>追踪系统也非常重要，特别是目前微服务化，一次服务请求需要经历多个不同的微服务处理，给分布式追踪带来新的挑战，主要包含以下三个方面：</p>
<ul>
<li>通过收集日志（Logging），记录程序的调试信息或错误信息，对系统和各个服务的运行状态进行监控</li>
<li>通过收集量度（Metrics），比如累加量，对系统和各个服务的性能进行监控</li>
<li>通过分布式追踪（Tracing ），追踪服务请求是如何在各个分布的组件中进行处理的细节</li>
</ul>
<p>业界也有一些成熟的开源软件用于监控与追踪：<strong>SkyWalking、Pinpoint、Zipkin、CAT大众点评开源</strong>。不过大公司一般都有自研的一套监控与追踪系统，比如腾讯内部就有多套自研监控与调用链追踪系统。</p>
<h2 id="搜索引擎">搜索引擎</h2>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/a7057f.png" alt="图片" loading="lazy"></figure>
<p>我们讨论的是全文搜索引擎，什么是全文搜索引擎？</p>
<blockquote>
<p>全文搜索引擎是目前广泛应用的主流搜索引擎。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p>
</blockquote>
<p><strong>数据分为结构化数据与非结构化数据</strong></p>
<p>像数据库表这种的数据是结构化数据；而对于像HTML、XML、文档这样不定长度且无固定格式的数据我们称之为非结构化数据。非结构化数据也称为全文数据，对非结构化数据的搜索可以用全文检索的方式，</p>
<p>目前两大主流的全文搜索引擎「Solr」和「Elasticsearch」都是基于 Lucene 建立。搜索引擎需要学习的内容：</p>
<ul>
<li>搜索引擎原理，搜索引擎利用<strong>倒排索引</strong>技术来实现对全文数据的高效检索。</li>
<li>Lucene，Apache Lucene 是一个开源的全文搜索引擎工具包。</li>
<li>Elasticsearch 原理与使用</li>
<li>Solr 原理与使用</li>
</ul>
<h2 id="大数据">大数据</h2>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/8ace66.png" alt="图片" loading="lazy"></figure>
<p>大数据，又称为巨量资料，指的是在传统数据处理应用软件不足以处理的大或复杂的数据集的术语。随着后台服务用户数增加和数据的积累，产生海量有待挖掘价值的数据，分析利用这些数据可以反馈线上决策，优化运营策略，产生数据价值。</p>
<p>海量数据也可以定义为来自各种来源的大量非结构化或结构化数据。</p>
<p>在软件开发领域的大数据概念自 20 世纪 90 年代的数据仓库开始，对于大数据的处理也导致各种海量数据的统计和处理技术发展。</p>
<p>主要包含以下的技术点需要学习：数据存储、离线分析、流式计算。</p>
<ul>
<li>大数据存储：Hadoop 框架，HDFS、HBase、YARN 架构、Apache Kudu</li>
<li>离线分析：Hive、MapReduce、Spark</li>
<li>流式计算：Flink、Storm、Kafka Stream、Spark Streaming</li>
</ul>
<h2 id="虚拟化">虚拟化</h2>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/41eedb.png" alt="图片" loading="lazy"></figure>
<p>虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。</p>
<h3 id="虚拟化的好处">虚拟化的好处</h3>
<ul>
<li>灵活性：在同一硬件上同时运行多个操作系统</li>
<li>敏捷性：移动操作系统的方式与将文件或图片从一台物理服务器移动到另一台物理服务器的方式相同。</li>
<li>容错：当物理服务器出现故障时，管理软件会自动将实例迁移到可用服务器，甚至无感知物理硬件故障。</li>
<li>降低成本：您不再需要过多的物理服务器，操作和维护所需的费用也随之减少。</li>
</ul>
<p>常见的虚拟化技术：KVM、Xen、OpenVZ、Docker</p>
<p>虽然对于大多数后台服务程序来说， 很多服务都是部署在 Docker 容器里，但 Docker 共用了底层系统的  kernel，所有容器共用一部分的运行库，因此隔离性相比 KVM 之类的虚拟化技术差一点，KVM 与 Docker  有各自的使用场景，未来很长一段时间是共存状态。</p>
<p>OpenStack 管理 VM（Virtual Machine）虚拟机的工具；Kubernetes 简称 K8s ，是管理 container 容器的工具。</p>
<h2 id="中间件">中间件</h2>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/a87304.png" alt="图片" loading="lazy"></figure>
<p>在后端开发中你可能经常听说到「中间件」这个词，那什么是中间件？看下Wiki上的定义：</p>
<blockquote>
<p>中间件技术创建在对应用软件部分常用功能的抽象上，<strong>将常用且重要的过程调用、分布式组件、消息队列、事务、安全、链接器、商业流程、网络并发、HTTP 服务器、Web Service</strong> 等功能集于一身或者分别在不同品牌的不同产品中分别完成。</p>
<p>中国科学院软件所研究员仲萃豪把中间件定义为「平台＋通信」。这个定义限定了只有用于分布式系统中的此类软件才能被称为中间件，同时此定义也把中间件与实际应用的应用软件区分开来。</p>
</blockquote>
<p>大白话来说，<strong>中间件就是把分布式系统中一些通用功能的抽象出来提供服务的一类软件统称</strong>。它屏蔽掉了底层操作系统的复杂性，向上提供一个统一的开发环境，降低了软件系统开发的复杂度，由于中间件是介于操作系统和应用软件之间，为应用软件提供服务功能的软件，<strong>由于介于两种软件之间，所以称为中间件</strong>。</p>
<p>常见的的开源中间件有下面几种，组合起来就能搭建一个完整的分布式后台服务系统：</p>
<ul>
<li>web server 中间件，Nginx、OpenResty、Tomcat...</li>
<li>缓存中间件，服务端缓存包括 Redis、Memcached...</li>
<li>消息队列中间件，Kafka、RabbitMQ、ActiveMQ...</li>
<li>RPC框架，Tars、Dubbo、gRPC、Thrift</li>
<li>数据库中间件，Sharding jdbc</li>
<li>日志系统中间件，ELK B指的是一套解决方案，是 Elasticsearch、Logstash 、 Kibana、Beats  是这 4 种软件产品的首字母缩写。</li>
<li>配置中心中间件，Apollo、zookeeper统一配置管理</li>
<li>API网关，开源项目有 Tyk、kong、zuul、orange...</li>
</ul>
<h2 id="版本控制">版本控制</h2>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/01b213.png" alt="图片" loading="lazy"></figure>
<p>大型软件项目的代码量巨大，如何有效组织和管理源码和版本，于是产生了版本控制系统。版本控制系统就是我们常说的SVN 或 Git，用来追踪、维护源码、文件以及配置文件等等的改动，并且提供控制这些改动控制权的程序。</p>
<p>常见的版本控制系统分为两大类：集中式版本控制和分布式版本控制。作为后端开发工程师，版本控制系统的使用也是必须掌握的基础技能，<strong>不过这些系统一般都是边使用边熟悉，刚开始熟悉一些常用操作就好</strong>。</p>
<ul>
<li>常见的有集中式版本控制系统，代表是SVN；</li>
<li>分布式版本控制系统，代表是Git</li>
</ul>
<h2 id="工具">工具</h2>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/104429.png" alt="图片" loading="lazy"></figure>
<p>一些和后端开发或者说软件开发相关的工具推荐，主要是编辑器和 IDE。</p>
<h3 id="编辑器">编辑器</h3>
<p>在 Linux 下开发肯定离不开 Vim 或者 Emacs，这两个都是常用的编辑器，已经形成了两大爱好者阵营。特别是 Vim  编辑器，学习成本有点高，配合上各种插件和配置，有些 Vim 爱好者已经把它当成 IDE 来用了，一旦掌握可以大幅提升工作效率，值得你去学习。</p>
<p>当然除了 Vim 如果是文字编辑工作，比如写 README 文档或者写技术博客，那么强烈推荐学习下 Markdown  语法，这是一种种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，注重内容本身不用过多的调整排版。Markdown 编辑器推荐  Typora 、有道云笔记 Markdown 编辑器、VSCode Markdown插件。</p>
<h3 id="ide">IDE</h3>
<p>编辑器作为小工程还可以胜任，不过后端开发工作中，一般都是大型的软件工程项目，所以不大可能用编辑器来管理，这时候就需要学习使用专业的集成开发工具。</p>
<p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</p>
<p>磨刀不误砍柴工，挑一把趁手的兵器再去编程世界遨游。各语言 IDE 五花八门，推荐 JetBrains 系列和 VS Code  ，JetBrains 产品包括各语言开发的一系列的 IDE，特别是Java 的Intellij IDEA 口碑非常不错，部分对应的产品系列如下。</p>
<ul>
<li>CLion - 跨平台的C/C++ IDE 开发工具，支持C++11 、C++14、libc++以及Boost。</li>
<li>GoLand - Go语言的集成开发环境。</li>
<li>IntelliJ IDEA - 2001年发布。一套智能的 Java 集成开发环境，特别专注与强调程序师的开发撰写效率提升。</li>
<li>PhpStorm - PHP IDE开发工具。</li>
<li>PyCharm - 一款结合了Django框架的Python IDE开发工具。</li>
<li>AppCode - Swift 和 Objective-C IDE开发工具。</li>
</ul>
<p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、  Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于  IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p>
<p>在2019年的 Stack Overflow 组织的开发者调研中，VS Code被认为是最受开发者欢迎的开发环境。</p>
<h2 id="测试">测试</h2>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/a101f4.png" alt="图片" loading="lazy"></figure>
<p>软件工程师不仅要写代码，还要做测试，软件测试和软件开发是相伴相生，测试能让保证我们写出代码更加健壮和可维护。</p>
<p><strong>TDD是测试驱动开发</strong>（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，根据测试代码确定需要编写什么产品代码。需要掌握和了解以下测试技术和方法。</p>
<ul>
<li>单元测试</li>
<li>压力测试</li>
<li>全链路测试</li>
<li>A/B 测试，灰度发布，蓝绿部署</li>
</ul>
<h2 id="学习顺序">学习顺序</h2>
<p>总结下，后端技术学习的内容还是很多的，不可能一蹴而就。</p>
<p><strong>把以上技术路线学习优先级做个排序，你照着学就行</strong>，<strong>排序规则</strong>：</p>
<blockquote>
<p>星级越高，排名越靠前，重要程度越高，优先安排时间学习。</p>
</blockquote>
<p>计算机基础  5星</p>
<p>Linux  5 星</p>
<p>数据库 5 星</p>
<p>设计模式 5 星</p>
<p>工具 5 星</p>
<p>中间件 4 星</p>
<p>分布式 4 星</p>
<p>高并发、高可用、高性能  4 星</p>
<p>搜索引擎 4 星</p>
<p>测试 3 星</p>
<p>监控与统计 3 星</p>
<p>虚拟化 3 星</p>
<p>安全 3 星</p>
<p>大数据 3 星</p>
]]></content>
    </entry>
</feed>