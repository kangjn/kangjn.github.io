<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-19T02:50:32.194Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络 — TCP的三次握手、四次挥手]]></title>
        <id>https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/</id>
        <link href="https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/">
        </link>
        <updated>2021-04-19T02:49:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="tcp-头部标识符意义解读">TCP 头部标识符意义解读</h2>
<ol>
<li>SYN：建立连接</li>
</ol>
<pre><code class="language-js">SYN=1，ACK=0  表示一个连接请求  
SYN=1，ACK=1  表示同意建立一个连接
 
</code></pre>
<ol>
<li>FIN：关闭连接</li>
</ol>
<pre><code class="language-js">FIN=1 表示发端完成发送任务
注意：表明发送方已经没有数据发送 但不代表之前的数据发送完毕
 
</code></pre>
<ol>
<li>ACK：置1时表示确认</li>
<li>seq：发送序列号</li>
<li>ack (number)：确认码</li>
</ol>
<p>更多关于TCP 和 UDP 的详细内容见 计算机网络系列 -- TCP和UDP</p>
<h2 id="tcp-三次握手">TCP 三次握手</h2>
<h4 id="过程通俗理解">过程通俗理解</h4>
<pre><code>A—&gt;B
B收到，B—&gt;A
A收到
 
</code></pre>
<p><a href="https://imgtu.com/i/coGDaT"><img src="https://z3.ax1x.com/2021/04/19/coGDaT.png" alt="coGDaT.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/92a3befa8a194e928795be19641d8e63~tplv-k3u1fbpfcp-watermark.png)</p>
<h4 id="过程的详细解读">过程的详细解读</h4>
<p>（1） 第一次握手：客户端发送【SYN = 1，随机序列号seq = x】的数据包到服务器,服务器由【SYN = 1】知道客户端要建立连接；<code>此时客户端进入已发送状态，等待服务器确认</code></p>
<p>（2） 第二次握手：服务器向客户端发送标【SYN = 1，ACK = 1】和【随机序列号seq = y, 确认码ack number = x+1】的数据包；<code>此时服务器进入已收到状态</code></p>
<p>（3） 第三次握手：客户端收到后判断【ACK=1】和【收的ack number =发的seq+1】；<br>
若正确，客户端发送标识位【ACK = 1、seq = x + 1】和【确认码ack number = y + 1】（服务器发送的seq+1）到服务器；</p>
<p>服务器收到后判断【ACK=1】和【收的ack number =发的seq+1】是否正确；<br>
若正确则完成建立连接，此包发送完毕。<code>此时客户端和服务器进入已连接状态，完成三次握手，客户端与服务器开始传送数据</code></p>
<h4 id="tcp-三次握手的目的">TCP 三次握手的目的</h4>
<ol>
<li>建立客户端和服务器之间的连接，确认各自的收发能力是否正常</li>
<li>对准好 TCP 包的序号问题，为保证可靠传送</li>
<li>如果是 https 协议，还会进行解密加密</li>
</ol>
<p>HTTPS解密解密过程见 计算机网络系列 -- HTTPS加密解密过程</p>
<h4 id="为什么要三次握手而不是两次">为什么要三次握手而不是两次？</h4>
<p>这句话可以转化为第三次握手的意义是什么？</p>
<pre><code class="language-js">第三次握手的意义在于：`让服务器知道客户端也收到了自己的同步信号`
 
</code></pre>
<p>通俗理解</p>
<pre><code class="language-js">两次握手只能保证`单向`：只知道A能向B发送数据
三次握手能保证`双向`：保证A也能收到B发送的数据
 
</code></pre>
<h4 id="第三次握手失败了怎么办">第三次握手失败了怎么办？</h4>
<p>server端发送了SYN+ACK报文后就会启动一个<strong>定时器</strong>，等待client返回的ACK报文。如果第三次握手失败的话client给server返回了ACK报文，<code>server并不能收到这个ACK报文</code>。那么server端就会启动超时重传机制，超过规定时间后<code>重新发送SYN+ACK</code>，重传次数默认是5次。如果重传指定次数到了后，仍然<code>未收到ACK应答</code>，那么一段时间后，<code>server自动关闭这个连接。但是client认为这个连接已经建立</code>，如果client端向server写数据，server端将<strong>发送RTS报文段</strong>，以防止syn洪泛攻击。</p>
<p>syn洪泛攻击</p>
<pre><code class="language-js">通俗的理解是：当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为dos（deny of service）攻击埋下隐患，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，server就会为这些syn包分配资源（但并未使用），就会使server占用大量内存，使server连接环境耗尽，这就是syn洪泛攻击
 
</code></pre>
<h4 id="为什么要三次握手而不是四次">为什么要三次握手而不是四次？</h4>
<p>四次握手的过程：</p>
<ol>
<li>第一次：客户端发送【SYN = 1，随机序列号seq = u】到服务器，用来请求开启客户A到服务器B的数据传送；</li>
<li>第二次：服务器B收到这个SYN，它发回【ACK = 1、确认序号ack=u+1】表示同意；</li>
<li>第三次：服务器开启与客户端的连接，发回标识位【SYN = 1，ACK = 1,，确认码ack =u+1】给客户端；</li>
<li>第四次：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。</li>
</ol>
<p>很明显，第二次和第三次没有分开的必要，可以合并，而且还能<code>提高建立连接时的效率</code></p>
<h2 id="tcp-四次挥手">TCP 四次挥手</h2>
<h4 id="过程通俗理解-2">过程通俗理解</h4>
<pre><code>A：B 啊，我不想玩了
B：好，知道了，等一下哈，我这边还没好
【注意】这时，只是A不想玩了，即不再发送数据。但是B可能还有未发送完的数据，所以需要等待B也主动关闭
B：好的，我弄完了，我也不玩了，拜拜
A：好的，拜拜
 
</code></pre>
<p>[<a href="https://imgtu.com/i/coGgz9"><img src="https://z3.ax1x.com/2021/04/19/coGgz9.png" alt="coGgz9.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/a3c8d5d638f54726b309ac405e646fd5~tplv-k3u1fbpfcp-watermark.png)</p>
<h4 id="过程的详细解读-2">过程的详细解读</h4>
<p>（1）第一次挥手：客户端发送【FIN = 1，随机序列号seq = u】到服务器，用来主动关闭客户A到服务器B的数据传送；<code>客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN</code></p>
<p>（2）第二次挥手：服务器B收到这个FIN，它发回【ACK = 1、确认序号ack number=u+1】表示同意；<code>客户端进入FIN-WAIT-2状态，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接;</code></p>
<p>（3）第三次挥手：服务器关闭与客户端的连接，发回标识位【FIN = 1，ACK = 1,，确认码ack number=u+1】给客户端；<code>服务器进入LAST_ACK，等待最后一次ACK确认</code></p>
<p>（4）第四次挥手：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。<code>客户端进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态</code></p>
<h4 id="tcp-四次挥手的目的">TCP 四次挥手的目的</h4>
<p>保证客户端、服务器真正断开连接</p>
<h4 id="为什么挥手要四次而握手只要三次">为什么挥手要四次？而握手只要三次？</h4>
<p>B表示收到A的报文之后，可能有未发送完的数据，所以需要把数据全部发送完毕后再来告诉A说可以断开了，所以多了一次</p>
<h4 id="2msl是什么目的是什么">2MSL是什么？目的是什么？</h4>
<p>MSL是时间单位 —— 任何报文在网络上存在的最长时间</p>
<p>2MSL目的：保证第四次挥手正常进行</p>
<ol>
<li>若第4次挥手的报文段丢失了</li>
<li>服务器就会超时重传第3次挥手的报文段</li>
<li>客户端就会重新给服务器发送第4次挥手的报文</li>
<li>最后，客户端、服务器才真正断开连接</li>
</ol>
<p>为什么客户端关闭后不能再发一下就行？</p>
<p>不能保证新、老连接端口号一致</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法小记]]></title>
        <id>https://kangjn.github.io/post/suan-fa-xiao-ji/</id>
        <link href="https://kangjn.github.io/post/suan-fa-xiao-ji/">
        </link>
        <updated>2021-04-19T02:37:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数组去重">数组去重</h1>
<h2 id="第一种-new-set">第一种 new Set</h2>
<pre><code class="language-js">let ary = [1,2,3,4,2,1,3,4,5,6,4,3,5,6,3]
let arr = Array.from(new Set(ary))

第二种

 

 
</code></pre>
<h2 id="第二种-拿出当前项和后面内容比较">第二种 拿出当前项和后面内容比较</h2>
<pre><code class="language-js">for(let i = 0;i &lt; ary.length - 1; i++){
    let item = ary[i]
    let arg = ary.slice(i + 1);
    if(arg.indexOf(item) &gt; -1){
        ary.splice(i,1); // 这个性能不如 新建一个数组好
        i--; // 会因为splice造成数组塌陷
    }
}
 
</code></pre>
<h2 id="第三种-判断是否包含包含的话-那最后一项把当前项覆盖">第三种 判断是否包含，包含的话 那最后一项把当前项覆盖</h2>
<pre><code class="language-js">for(let i = 0;i &lt; ary.length - 1; i++){
    let item = ary[i]
    let arg = ary.slice(i + 1);
    if(arg.indexOf(item) &gt; -1){
        ary[i] = ary[ary.length - 1];
        ary.length--;
        i--
    }
}

 
</code></pre>
<h2 id="第四种-循环遍历是否包含不包含push">第四种 循环遍历是否包含，不包含push</h2>
<pre><code class="language-js">let arr = []
for(let i = 0;i &lt; ary.length; i++){
    if(arr.indexOf(item) === -1){
      arr.push(ary[i])
    }
}
 
</code></pre>
<p>等等还有很多，比如对象键值对，比如包含置为null 在过滤</p>
<h1 id="数组扁平化">数组扁平化</h1>
<h2 id="第一种-flat">第一种 flat</h2>
<pre><code class="language-js">let arr = [
    [1,2,3],
    [3,4,5,6],
    [6,7,8,9,0,[1],[2,3]],10
]

flat()写  几  就扁平化 几级
Infinity 无限
arr.flat(Infinity)

 
</code></pre>
<h2 id="第二种-reduce">第二种 reduce</h2>
<pre><code class="language-js">function ab(arr){
   return arr.reduce((pre,cur) =&gt; {
       return pre.concat(Array.isArray(cur) ? ab(cur) : cur)
   },[])
}
 
</code></pre>
<h2 id="第三种-tostring">第三种 toString</h2>
<pre><code class="language-js">arr.toString().split(',').map(itm =&gt; parserFloat(itm))
 
</code></pre>
<h2 id="第四种-while-reduce-concat">第四种 while + reduce + concat</h2>
<pre><code class="language-js">while(arr.some(itm =&gt; Array.isArray(itm))){
  arr = [].concat(...arr)
}
 
</code></pre>
<h2 id="第五种-正则">第五种 正则</h2>
<pre><code class="language-js">JSON.stringify(arr).replace(/(\[|\])/g,'').split(',').map(itm =&gt;parseFloat(itm))
 
</code></pre>
<h1 id="斐波那契数列">斐波那契数列</h1>
<p>let arr = [1,1,2,3,5,8,13,21]</p>
<p><strong>当前项 = 当前项的 前面两位相加</strong></p>
<p>可以 <strong>实现</strong> 传入 <strong>number</strong> 就能计算出对应<strong>斐波那契下标</strong>的值</p>
<h2 id="第一种-while循环">第一种： while循环</h2>
<pre><code class="language-js">function fibonacci(n){
    if(n&lt;=1) return 1;
    let arr = [1,1];
    let i = n + 1 -2;
    // why?因为传入的n是数组下标，所以要+1 减2的话就是因为一开始就有两个所以只需要创建剩下的位数
    while(i &gt; 0){
        let a = arr[arr.length - 2];
        let b = arr[arr.length - 1];
        arr.push(a+b);
        i--
    }
    return arr[arr.length - 1];
}


 
</code></pre>
<h2 id="第二种-递归">第二种 递归</h2>
<p><strong>count</strong>：传进来的number<br>
<strong>cur</strong>：放的最终值<br>
<strong>next</strong>：每次递归的时候作为下一次 cur 的值，需要每次 cur + next</p>
<p><a href="https://imgtu.com/i/co8dAO"><img src="https://z3.ax1x.com/2021/04/19/co8dAO.png" alt="co8dAO.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/01fcb9a1a61742a29a3c276a25a83e5d~tplv-k3u1fbpfcp-watermark.png)<br>
||<br>
|| 搭配食用<br>
||</p>
<pre><code class="language-js">fibonacci(count){
    function fn(count,cur = 1,next = 1){
        if(count == 0){
            return cur
        }else {
            return fn(count - 1,next,cur+next)
        }
    }
    
    return fn(count)
}
 
</code></pre>
<h1 id="冒泡排序">冒泡排序</h1>
<p><strong>相邻两元素之间两两比较，比较出大值进行赋值互换，再依次与相邻的元素比较</strong></p>
<p>必须要明白总共比较几回，一回比较几次！！！</p>
<pre><code class="language-js">let arr = [1,2,3,5,8,0,10]

// 外层控制比较几回
for(let i = 0; i &lt; arr.length - 1; i++){
    // 内层控制一回比较几次，并且比较大小
    for(let j = 0; j &lt; arr.length -1 -i; j++){
        if(arr[j] &gt; arr[j + 1]){
            let temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
 
 
</code></pre>
<h1 id="快速排序">快速排序</h1>
<p>分三步</p>
<ul>
<li><strong>取出数组的中间值</strong></li>
<li><strong>遍历数组，大于的放在右数组，小于的放在左边数组</strong></li>
<li><strong>递归并且用 concat 连接</strong></li>
</ul>
<pre><code class="language-js">let arr = [1,5,2,7,9,10,90,29,25,11,45,34];

function fast(arr){
   if(arr.length &lt; 1) return arr;
   let num = Math.floor(arr.length / 2)
   let idx = arr.splice(num,1)[0];
   let left = [];
   let right = [];
   for(let i = 0; i &lt; arr.length; i++){
       if(arr[i] &lt; idx){
         left.push(arr[i])
       }else {
         right.push(arr[i])
       }
   }
   return fast(left).concat(idx,fast(right))
}
 
</code></pre>
<h1 id="插入排序">插入排序</h1>
<ul>
<li>拿出一个值，作为初始数组的值，</li>
<li>通过循环想要排序的数组</li>
<li>并和新数组的值从后向前比</li>
<li>大于就splice到该项后面</li>
</ul>
<pre><code class="language-js">function insert(arr){
    let handle = []; // 这是最终成型的数组
    handle.push(arr[0]); // 先拿一个值
    for(let i = 1; i&lt; arr.length; i++){
        let news = arr[i];
        for(let j = handle.length - 1; j &gt;= 0; j--){ //从后向前比较
            if(news &gt; handle[j]){
                handle.splice(j+1,0,news);
                break;
            }
            
            if(j === 0){ // 比到为0的话直接放到数组头部
               handle.unshift(news);
            }
        }
    }
   return handle
}

 
</code></pre>
<h1 id="单链表反转">单链表反转</h1>
<p>看到这的话，要明白它反转后是什么样<br>
{<br>
a:4,<br>
next:{<br>
a:3,<br>
next:{<br>
a:2,<br>
next:{<br>
a:1,<br>
next: null<br>
}<br>
}<br>
}<br>
}<br>
看到这，肯定是有个大概的思路，就是<strong>节点替换</strong></p>
<p><a href="https://imgtu.com/i/co8yjI"><img src="https://z3.ax1x.com/2021/04/19/co8yjI.png" alt="co8yjI.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/e9030c138fbf4e0e8ba87222f3b66dff~tplv-k3u1fbpfcp-watermark.png)</p>
<pre><code class="language-js">let obj = {
    a:1,
    next:{
        a:2,
        next: {
            a:3,
            next:{
                a:4,
                next:null
            }
        }
    }
}

function reverseObj(obj){
    let pre = null; // pre 最终的值(包含每一步)
    let cur = obj
    while(cur.next !== null){
        let context = cur.next; // 首先拿到下一个next的值保存
        cur.next = pre === null ? null : pre; // pre是上一项保存的值
        pre = cur; // 将 当前项的值赋值给最终的值
        cur = context // 拿到下一项next继续重复以商操作
    }
}

 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习笔记：promise]]></title>
        <id>https://kangjn.github.io/post/xue-xi-bi-ji-promise/</id>
        <link href="https://kangjn.github.io/post/xue-xi-bi-ji-promise/">
        </link>
        <updated>2021-04-19T02:28:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>then接收两个参数, onFulfilled 和 onRejected</li>
<li>检查并处理参数, 如果参数不是function就忽略(原样返回value或者reason)</li>
</ol>
<p>class MyPromise {<br>
constructor(fn) {<br>
// 初始状态为pending<br>
this.status = PENDING;//状态<br>
this.value = null;//成功的值<br>
this.reason = null;//失败的值<br>
try {<br>
fn(this.resolve.bind(this), this.reject.bind(this));<br>
} catch (e) {<br>
this.reject(e);<br>
}<br>
}<br>
resolve(value) {<br>
if (this.status === PENDING) {<br>
//这层判断是因为fulfilled状态只可以由pending状态改变而来<br>
this.status = FULFILLED;<br>
this.value = value;<br>
}<br>
}<br>
reject(reason) {<br>
if (this.status === PENDING) {<br>
//同理这层判断是因为rejected状态只可以由pending状态改变而来<br>
this.status = REJECTED;<br>
this.reason = reason;<br>
}<br>
}<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
3. 根据当前promise的状态, 调用不同的函数<br>
class MyPromise {<br>
.....<br>
//这时候then函数被调用会瞬间就会执行switch判断，那这时候如果status可能还没变成fulfilled或者rejected，很有可能还是pending<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
4、首先要拿到所有的回调, 然后在某个时机去执行他. 需要新建两个数组, 分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组.<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
case PENDING: {<br>
this.FULFILLED_CALLBACK_LIST.push(fulFilledFn);<br>
this.REJECTED_CALLBACK_LIST.push(rejectedFn);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
5、在status状态发生变化的时候调用数组里所有的函数<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
resolve(value) {<br>
if (this.status === PENDING) {<br>
//这层判断是因为fulfilled状态只可以由pending状态改变而来<br>
this.status = FULFILLED;<br>
this.value = value;<br>
//执行存储的函数<br>
this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; {<br>
callback(this.value);<br>
});<br>
}<br>
}<br>
reject(reason) {<br>
if (this.status === PENDING) {<br>
//同理这层判断是因为rejected状态只可以由pending状态改变而来<br>
this.status = REJECTED;<br>
this.reason = reason;<br>
//执行存储的函数<br>
this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; {<br>
callback(this.reason);<br>
});<br>
}<br>
}<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
case PENDING: {<br>
this.FULFILLED_CALLBACK_LIST.push(fulFilledFn);<br>
this.REJECTED_CALLBACK_LIST.push(rejectedFn);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
7、then的返回值<br>
情况1：如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则新promise必须reject e<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
const fulFilledFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
fulFilledFn(this.value);<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
rejectedFn(this.reason);<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
return new MyPromise(fulFilledFnWithCatch);<br>
}<br>
case REJECTED: {<br>
return new MyPromise(rejectedFnWithCatch);<br>
}<br>
case PENDING: {<br>
return new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject));<br>
});<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
情况2：如果onFulfilled不是函数且promise成功执行，那么新的promise必须返回同样的状态和val<br>
情况3：如果onRejected不是函数且promise拒绝执行，那么新的promise必须返回同样的状态和reason<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
const fulFilledFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
fulFilledFn(this.value);<br>
resolve(this.value);<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
rejectedFn(this.reason);<br>
if (this.isFunction(onRejected)) {<br>
resolve();<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
return new MyPromise(fulFilledFnWithCatch);<br>
}<br>
case REJECTED: {<br>
return new MyPromise(rejectedFnWithCatch);<br>
}<br>
case PENDING: {<br>
return new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject));<br>
});<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
情况4:如果onFulfilled或者onRejected 返回一个值 x ，则运行resolvePromise方法<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
try {<br>
if (!this.isFunction(onFulfilled)) {<br>
resolve(this.value);<br>
} else {<br>
const x = fulFilledFn(this.value);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
try {<br>
if (!this.isFunction(onRejected)) {<br>
reject(this.reason);<br>
} else {<br>
const x = rejectedFn(this.reason);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case REJECTED: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case PENDING: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
});<br>
return newPromise;<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
resolvePromise(newPromise, x, resolve, reject){}<br>
}<br>
8、resolvePromise<br>
resolvePromise(newPromise, x, resolve, reject) {<br>
// 防止死循环<br>
if (newPromise === x) {<br>
return reject(new TypeError('The promise and the return value are the same'));<br>
}<br>
if (x instanceof MPromise) {<br>
x.then((y) =&gt; {<br>
resolvePromise(newPromise, y, resolve, reject);<br>
}, reject);<br>
} else if (typeof x === 'object' || this.isFunction(x)) {<br>
if (x === null) {<br>
return resolve(x);<br>
}<br>
let then = null;<br>
try {<br>
then = x.then;<br>
} catch (error) {<br>
return reject(error);<br>
}<br>
// 如果 then 是函数<br>
if (this.isFunction(then)) {<br>
let called = false;<br>
try {<br>
then.call(<br>
x,<br>
(y) =&gt; {<br>
if (called) return;<br>
called = true;<br>
resolvePromise(promise, y, resolve, reject);<br>
},<br>
(r) =&gt; {<br>
if (called) return;<br>
called = true;<br>
reject(r);<br>
});<br>
} catch (error) {<br>
if (called) return;<br>
reject(error);<br>
}<br>
} else {<br>
resolve(x);<br>
}<br>
} else {<br>
resolve(x);<br>
}<br>
}<br>
9、onFulfilled 和 onRejected 是微任务<br>
then(onFulfilled, onRejected) {<br>
...<br>
const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
queueMicrotask(() =&gt; {<br>
try {<br>
if (!this.isFunction(onFulfilled)) {<br>
resolve(this.value);<br>
} else {<br>
const x = fulFilledFn(this.value);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e)<br>
}<br>
})<br>
};<br>
const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
queueMicrotask(() =&gt; {<br>
try {<br>
if (!this.isFunction(onRejected)) {<br>
reject(this.reason);<br>
} else {<br>
const x = rejectedFn(this.reason);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
})<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case REJECTED: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case PENDING: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
});<br>
return newPromise;<br>
}<br>
}<br>
}<br>
10. catch方法<br>
catch (onRejected) {<br>
return this.then(null, onRejected);<br>
}<br>
11. promise.resolve(静态方法)<br>
将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。<br>
static resolve(param) {<br>
if (param instanceof MyPromise) {<br>
return param;<br>
}<br>
return new MyPromise(function (resolve) {<br>
resolve(param);<br>
});<br>
}<br>
12. promise.reject(静态方法)<br>
返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。<br>
static reject(reason) {<br>
return new MPromise((resolve, reject) =&gt; {<br>
reject(reason);<br>
});<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端学习-Vue]]></title>
        <id>https://kangjn.github.io/post/qian-duan-xue-xi-vue/</id>
        <link href="https://kangjn.github.io/post/qian-duan-xue-xi-vue/">
        </link>
        <updated>2021-04-19T02:22:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心特性">核心特性</h2>
<h3 id="数据驱动视图">数据驱动视图</h3>
<ul>
<li>数据变化会自动更新到对应元素中，无需手动操作 DOM，这种行为称作单向数据绑定。</li>
<li>对于输入框等可输入元素，可设置双向数据绑定。<br>
双向数据绑定是在数据绑定基础上，可自动将元素输入内容更新给数据， 实现数据与元素内容的双向绑定。</li>
<li>Vue.js 的数据驱动视图是基于 MVVM 模型实现的。</li>
<li>MVVM (Model – View – ViewModel )是一种软件开发思想<br>
Model 层，代表数据<br>
View 层， 代表视图模板<br>
ViewModel 层，代表业务逻辑处理代码</li>
<li>基于MVVM 模型实现的数据驱动视图解放了DOM操作</li>
<li>View 与 Model 处理分离，降低代码耦合度</li>
<li>但双向绑定时的 Bug 调试难度增大</li>
<li>大型项目的 View 与 Model 过多，维护成本高</li>
</ul>
<h3 id="组件化开发">组件化开发</h3>
<ul>
<li>组件化开发，允许我们将网页功能封装为自定义 HTML 标签，复用时书写自定义标签名即可。</li>
<li>组件不仅可以封装结构，还可以封装样式与逻辑代码，大大提交 了开发效率与可维护性。</li>
</ul>
<h2 id="基础语法">基础语法</h2>
<h3 id="vue-实例">Vue 实例</h3>
<ul>
<li>通过 Vue 函数创建的对象，是使用 Vue 功能的基础。</li>
</ul>
<pre><code class="language-js">new Vue({
  //选项对象
});
 
</code></pre>
<h3 id="el-选项">el 选项</h3>
<ul>
<li>用于选取一个 DOM 元素作为 Vue 实例的挂载目标。</li>
<li>只有挂载元素内部才会被 Vue 进行处理，外部为普通 HTML 元素。</li>
<li>代表 MVVM 中的 View 层(视图)。</li>
<li>可以为 CSS 选择器格式的字符串 或 HTMLElement 实例，但不能为 html 或 body。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
   el: '#app'
});

var app = document.querySelector('#app');
var vm = new Vue({
    el: app
});
 
</code></pre>
<ul>
<li>挂载完毕后，可以通过 vm.$el 进行访问。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app'
});

console.log(vm.$el);
 
</code></pre>
<ul>
<li>未设置 el 的 vue 实例，也可以通过 vm.$mount() 进行挂载，参数形式与 el 规则相同。</li>
</ul>
<pre><code class="language-js">var app = document.getElementById('app');
var vm = new Vue({});
vm.$mount(app);
 
</code></pre>
<h3 id="插值表达式">插值表达式</h3>
<ul>
<li>挂载元素可以使用 Vue.js 的模板语法，模板中可以通过插值表达式为元素进行动态内容设置，写法为 {{ }}。</li>
</ul>
<pre><code class="language-html">&lt;li&gt;第一段示例内容：{{ 10 + 20 + 30 }}&lt;/li&gt;
&lt;li&gt;第二段示例内容：{{ 22 &gt; 3 ? '22比3大' : '3比22大' }}&lt;/li&gt;

&lt;!-- 错误写法 --&gt;
&lt;!-- &lt;li id=&quot;{{ 1 + 2 }}&quot;&gt;&lt;/li&gt; --&gt;
&lt;!-- &lt;li&gt;{{ var num = 100; }}&lt;/li&gt; --&gt;
 
</code></pre>
<p>注意点:</p>
<ul>
<li>插值表达式只能书写在标签内容区域，可以与其它内容混合。</li>
<li>内部只能书写 JavaScript 表达式，不能书写语句。</li>
</ul>
<h3 id="data-选项">data 选项</h3>
<ul>
<li>用于存储 Vue 实例需要使用的数据，值为对象类型。</li>
<li>data 中的数据可以通过 vm.$data.数据 或 vm.数据 访问。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
      title: '标题文本'
    }
});

console.log(vm.$data.title);
console.log(vm.title);
 
</code></pre>
<ul>
<li>data 中的数据可以直接在视图中通过插值表达式访问。</li>
<li>data 中的数据为响应式数据，在发生改变时，视图会自动更新。</li>
</ul>
<pre><code class="language-js">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ title }}&lt;/p&gt;    
&lt;/div&gt;

&lt;script&gt;
   var vm = new Vue({
    el: '#app',
    data: {
      title: '标题文本',
    }
});

vm.title = '新的标题内容';
&lt;/script&gt;
 
</code></pre>
<ul>
<li>data 中存在数组时，索引操作与 length 操作无法自动更新视图， 这时可以借助 Vue.set() 方法替代操作。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
      arr: ['内容1', '内容2', '内容3']
    }
});

Vue.set(vm.arr, 0, '新内容');
 
</code></pre>
<h3 id="methods-选项">methods 选项</h3>
<ul>
<li>用于存储需要在 Vue 实例中使用的函数。</li>
<li>methods 中的方法可以通过 vm.方法名 访问。</li>
<li>方法中的 this 为 vm 实例，可以便捷的访问 vm 数据等功能。</li>
</ul>
<pre><code class="language-js"> &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ fn(title1) }}&lt;/p&gt;
    &lt;p&gt;{{ fn(title2) }}&lt;/p&gt;
    
    &lt;p&gt;{{ title1.split('-').join('') }}&lt;/p&gt;
    &lt;p&gt;{{ title2.split('-').join('') }}&lt;/p&gt;
 &lt;/div&gt;
 
&lt;script&gt;
var vm = new Vue({
  el: '#app',
  data: {
    prefix: '处理的结果为：',
    title1: 'a-b-c-d-e',
    title2: 'x-y-z'
  },
  methods: {
    fn (value) {
      // console.log(this);
      this.fn1();
      this.fn2();
      return this.prefix + value.split('-').join('');
    },
    fn1 () {
      console.log('执行了 fn1 的代码');
    },
    fn2 () {
      console.log('执行了 fn2 的代码');
    }
  }
});

// console.log(vm)
&lt;/script&gt;
 
 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-文件上传/下载]]></title>
        <id>https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/</id>
        <link href="https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/">
        </link>
        <updated>2021-04-16T07:34:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-文件上传下载">springboot-文件上传/下载</h2>
<h2 id="代码">代码</h2>
<p>application.yml</p>
<pre><code>spring:
  servlet:
    multipart:
      max-file-size: 50MB  #上传文件最大大小
      max-request-size: 50MB  #单次请求最大大小

# 自定义文件上传路径
web:
  upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/
</code></pre>
<p><strong>ps : 路径中不能包含中文，不然无法读取</strong></p>
<p>FileUtils (文件上传工具类)</p>
<pre><code>package cn.justcoding.util;

import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

/**
 * 文件上传工具包
 */
public class FileUtils {

    /**
     *
     * @param file 文件
     * @param path 文件存放路径
     * @param fileName 源文件名
     * @return
     */
    public static boolean upload(MultipartFile file, String path, String fileName){

        //使用原文件名
        String realPath = path + &quot;/&quot; +fileName;

        File dest = new File(realPath);

        //判断文件父目录是否存在
        if(!dest.getParentFile().exists()){
            dest.getParentFile().mkdir();
        }

        try {
            //保存文件
            file.transferTo(dest);
            return true;
        } catch (IllegalStateException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>TestController(进行测试)</p>
<pre><code>@Controller
public class TestController {

    private final ResourceLoader resourceLoader;

    @Value(&quot;${web.upload-path}&quot;)
    private String path;

    @Autowired
    public TestController(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    /**
     * 跳转到文件上传页面
     * @return
     */
    @RequestMapping(&quot;test&quot;)
    public String toUpload(){
        return &quot;freemarker/test&quot;;
    }

    /**
     *
     * @param file 要上传的文件
     * @return
     */
    @RequestMapping(&quot;fileUpload&quot;)
    public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){

        // 要上传的目标文件存放路径
//        String localPath = &quot;/src/main/resources/static/photos&quot;;
        // 上传成功或者失败的提示
        String msg = &quot;&quot;;

        if (FileUtils.upload(file, path, file.getOriginalFilename())){
            // 上传成功，给出页面提示
            msg = &quot;上传成功！&quot;;
        }else {
            msg = &quot;上传失败！&quot;;

        }

        // 显示图片
        map.put(&quot;msg&quot;, msg);
        map.put(&quot;fileName&quot;, file.getOriginalFilename());
        return &quot;forward:/test&quot;;
    }

    /**
     * 显示单张图片
     * @return
     */
    @RequestMapping(&quot;show&quot;)
    public ResponseEntity showPhotos(String fileName){
        try {
            // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径
//            System.out.println(fileName);
            return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName));
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }

    @RequestMapping(&quot;batch&quot;)
    public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) {
        List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;);
        MultipartFile file = null;
        BufferedOutputStream stream = null;
        String msg = &quot;&quot;;
        for (int i = 0; i &lt; files.size(); ++i) {
            file = files.get(i);
            if (!file.isEmpty()) {
                try {
                    byte[] bytes = file.getBytes();
                    stream = new BufferedOutputStream(new FileOutputStream(
                            new File(path + file.getOriginalFilename())));//设置文件路径及名字
                    stream.write(bytes);// 写入
                    stream.close();
                } catch (Exception e) {
                    stream = null;
                    msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot;
                            + e.getMessage();
                }
            } else {
                msg= &quot;第 &quot; + i
                        + &quot; 个文件上传失败因为文件为空&quot;;
            }
        }
        msg= &quot;上传成功&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }

    @RequestMapping(&quot;/download&quot;)
    public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) {
        String msg = &quot;&quot;;
        if (fileName != null) {
            //设置文件路径
            File file = new File(path+fileName);
            //File file = new File(realPath , fileName);
            if (file.exists()) {
                response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开
                response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名
                byte[] buffer = new byte[1024];
                FileInputStream fis = null;
                BufferedInputStream bis = null;
                try {
                    fis = new FileInputStream(file);
                    bis = new BufferedInputStream(fis);
                    OutputStream os = response.getOutputStream();
                    int i = bis.read(buffer);
                    while (i != -1) {
                        os.write(buffer, 0, i);
                        i = bis.read(buffer);
                    }
                    msg = &quot;下载成功&quot;;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    if (bis != null) {
                        try {
                            bis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (fis != null) {
                        try {
                            fis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        msg =  &quot;下载失败&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }
}
</code></pre>
<p>test.ytl (简易freemarker测试模板)</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;图片上传Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 &gt;图片上传Demo&lt;/h1&gt;
&lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;#--判断是否上传文件--&gt;
&lt;#if msg??&gt;
    &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt;
&lt;#else &gt;
    &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt;
&lt;/#if&gt;
&lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt;
&lt;#if fileName??&gt;
    &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt;
&lt;#else&gt;
    &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt;
&lt;/#if&gt;

&lt;hr/&gt;
&lt;p&gt;多文件上传&lt;/p&gt;
&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt;
    &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;hr/&gt;
&lt;p&gt;文件下载&lt;/p&gt;
&lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-7.快速上手redis]]></title>
        <id>https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/</id>
        <link href="https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/">
        </link>
        <updated>2021-04-16T07:32:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-7快速上手redis">springboot-7.快速上手redis</h2>
<h2 id="前言">前言</h2>
<p>为什么需要Redis?<br>
在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。<br>
为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p>
<p><strong>Redis在java web中的应用场景</strong></p>
<ul>
<li>
<p>存储 缓存用的数据；</p>
</li>
<li>
<p>需要高速读/写的场合使用它快速读/写；</p>
<p>Redis作为缓存的读取逻辑<br>
<a href="https://imgtu.com/i/cWxz5t"><img src="https://z3.ax1x.com/2021/04/16/cWxz5t.jpg" alt="cWxz5t.jpg" loading="lazy"></a></p>
</li>
</ul>
<h2 id="下载安装redis">下载安装redis</h2>
<p>下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads<br>
选择最新版下载一个即可，下载完后解压便可使用。<br>
为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件：</p>
<pre><code>redis-server redis.windows.conf
</code></pre>
<p>这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动：</p>
<h2 id="下载安装redis可视化工具-redisdesktopmanager">下载安装redis可视化工具 RedisDesktopManager</h2>
<h2 id="springboot配置使用redis">springboot配置使用redis</h2>
<p>（1）在pom文件中添加依赖项</p>
<pre><code class="language-java">        &lt;!-- Redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2) 编写application.yml</p>
<pre><code class="language-yml">spring:
  # redis
  redis:
    host: 127.0.0.1
    port: 6379
    timeout: 3000 #连接超时
    password:
    minIdle: 1   #连接池中的最小空闲连接
    maxIdle: 10
    maxWait: 3  #连接池中的最大阻塞等待时间
    maxActive: 8   #连接池最大连接数
</code></pre>
<p>(3)新建文件夹和文件，如下所示：<br>
<a href="https://imgtu.com/i/cWzK2T"><img src="https://z3.ax1x.com/2021/04/16/cWzK2T.png" alt="cWzK2T.png" loading="lazy"></a></p>
<p>(4)Reidis配置文件-RedisConfig.java</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.*;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;


@Configuration
@EnableCaching //开启注解
public class RedisConfig extends CachingConfigurerSupport {

    /**
     * retemplate相关配置
     * @param factory
     * @return
     */
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {

        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        // 配置连接工厂
        template.setConnectionFactory(factory);

        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）
        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper om = new ObjectMapper();
        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jacksonSeial.setObjectMapper(om);

        // 值采用json序列化
        template.setValueSerializer(jacksonSeial);
        //使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());

        // 设置hash key 和value序列化模式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jacksonSeial);
        template.afterPropertiesSet();

        return template;
    }

    /**
     * 对hash类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForHash();
    }

    /**
     * 对redis字符串类型数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForValue();
    }

    /**
     * 对链表类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForList();
    }

    /**
     * 对无序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForSet();
    }

    /**
     * 对有序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForZSet();
    }
}
</code></pre>
<p><strong>(5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java）</strong></p>
<p>为了测试方便，只放入了get和set方法。</p>
<pre><code class="language-java">@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>(6)在controller文件中进行测试</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {
    @Resource
    private RedisUtil redisUtil;
    
    @RequestMapping(&quot;/setRedis&quot;)
    public boolean redisSet()
    {
        return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;);
    }
    @RequestMapping(&quot;/getRedis&quot;)
    public String redisGet()
    {
        return redisUtil.get(&quot;username&quot;).toString();
    }
}
</code></pre>
<p>(7)预览</p>
<p>ps:记得开启redis（通过startup.cmd）</p>
<p>访问 http://localhost:8080/user/setRedis<br>
<a href="https://imgtu.com/i/cWzsZd"><img src="https://z3.ax1x.com/2021/04/16/cWzsZd.png" alt="cWzsZd.png" loading="lazy"></a><br>
返回true说明缓存存储成功，使用工具查看<br>
<a href="https://imgtu.com/i/cWzWz8"><img src="https://z3.ax1x.com/2021/04/16/cWzWz8.png" alt="cWzWz8.png" loading="lazy"></a><br>
获取缓存存取的值<br>
访问 http://localhost:8080/user/getRedis<br>
<a href="https://imgtu.com/i/cWzqJ0"><img src="https://z3.ax1x.com/2021/04/16/cWzqJ0.png" alt="cWzqJ0.png" loading="lazy"></a><br>
以上便是redis的基本使用</p>
<h2 id="redisutiljava工具类">redisUtil.java工具类</h2>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * redisTemplate封装
 *
 *  @author yinxp@dist.com.cn
 */
@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 指定缓存失效时间
     * @param key 键
     * @param time 时间(秒)
     * @return
     */
    public boolean expire(String key,long time){
        try {
            if(time&gt;0){
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key){
        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key){
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void del(String ... key){
        if(key!=null&amp;&amp;key.length&gt;0){
            if(key.length==1){
                redisTemplate.delete(key[0]);
            }else{
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 普通缓存放入并设置时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key,Object value,long time){
        try {
            if(time&gt;0){
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            }else{
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     * @param key 键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     * @param key 键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    //================================Map=================================
    /**
     * HashGet
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return 值
     */
    public Object hget(String key,String item){
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object,Object&gt; hmget(String key){
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     * @param key 键
     * @param map 对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value,long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     * @param key 键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item){
        redisTemplate.opsForHash().delete(key,item);
    }

    /**
     * 判断hash表中是否有该项的值
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item){
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     * @param key 键
     * @param item 项
     * @param by 要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     * @param key 键
     * @param item 项
     * @param by 要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item,-by);
    }

    //============================set=============================
    /**
     * 根据key获取Set中的所有值
     * @param key 键
     * @return
     */
    public Set&lt;Object&gt; sGet(String key){
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     * @param key 键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key,Object value){
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     * @param key 键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object...values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     * @param key 键
     * @param time 时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key,long time,Object...values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if(time&gt;0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     * @param key 键
     * @return
     */
    public long sGetSetSize(String key){
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     * @param key 键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public long setRemove(String key, Object ...values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    //===============================list=================================

    /**
     * 获取list缓存的内容
     * @param key 键
     * @param start 开始
     * @param end 结束  0 到 -1代表所有值
     * @return
     */
    public List&lt;Object&gt; lGet(String key, long start, long end){
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     * @param key 键
     * @return
     */
    public long lGetListSize(String key){
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     * @param key 键
     * @param index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key,long index){
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     * @param key 键
     * @param index 索引
     * @param value 值
     * @return
     */
    public boolean lUpdateIndex(String key, long index,Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     * @param key 键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public long lRemove(String key,long count,Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 模糊查询获取key值
     * @param pattern
     * @return
     */
    public Set keys(String pattern){
        return redisTemplate.keys(pattern);
    }

    /**
     * 使用Redis的消息队列
     * @param channel
     * @param message 消息内容
     */
    public void convertAndSend(String channel, Object message){
        redisTemplate.convertAndSend(channel,message);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-6.整合Mybatis]]></title>
        <id>https://kangjn.github.io/post/springboot-6zheng-he-mybatis/</id>
        <link href="https://kangjn.github.io/post/springboot-6zheng-he-mybatis/">
        </link>
        <updated>2021-04-16T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-6整合mybatis">springboot-6.整合Mybatis</h2>
<h2 id="一-解析java框架中entity层mapper层service层各层作用">一 .解析Java框架中entity层，mapper层，service层各层作用</h2>
<p>（1）entity层<br>
别名： model层 ，domain层。<br>
用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应<br>
简单例子：user表的实体User</p>
<pre><code>public class User {
    private int id;//id
    private String username;//用户名
    //……省略set,get方法
}
</code></pre>
<p>（2）mapper层<br>
别名： dao层<br>
用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作<br>
简单例子：</p>
<pre><code>@Mapper
public interface UserMapper {
    public User selectUserById(int id);
}
</code></pre>
<p>(3) service层<br>
业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。<br>
封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。<br>
作用：为controller层的类提供接口进行调用。<br>
简单例子：</p>
<pre><code>public interface UserService extends Service&lt;User&gt; {

}
</code></pre>
<h2 id="二快速使用">二.快速使用</h2>
<p>（1）添加依赖项</p>
<pre><code> &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--通用mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.5&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--druid数据源--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.18&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>（2）配置application.yml</p>
<pre><code>spring:
  #数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
    username: root
    password: ******
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    connectionProperties: druid.stat.mergeSql=true

#为mybatis配置，生产环境可删除
restart:
  include:
    mapper: /mapper-[\\w-\\.]+jar
    pagehelper: /pagehelper-[\\w-\\.]+jar

pagehelper:
  auto-dialect: msyql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
</code></pre>
<p>(3)编写User.java【entity层】</p>
<pre><code>public class User {
    private String id;
    private String username;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}
</code></pre>
<p>(4)编写UserMapper.java(dao层)</p>
<pre><code>@Mapper
public interface UserMapper {
    @Select(&quot;select * from user where id = #{id}&quot;)
    public User selectUserById(int id);

    @Select(&quot;select * from user where username = #{username}&quot;)
    public List&lt;User&gt; selectUserByName(String userName);

    @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;)
    public void addUser(User user);

    @Update(&quot;update user set username=#{username} where id=#{id}&quot;)
    public void updateUser(User user);

    @Delete(&quot;delete from user where id=#{id}&quot;)
    public void deleteUser(int id);
}
</code></pre>
<p>(5)编写userController.java</p>
<pre><code>@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {

    @Autowired
    UserMapper userMapper;

    @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET)
    public User selectUserById(String id){
        User user = userMapper.selectUserById(Integer.parseInt(id));
        return user;
    }

    @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET)
    public List&lt;User&gt; selectUserByName(String userName){
        return userMapper.selectUserByName(userName);
    }

    @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST)
    public void addUser(User user){
        userMapper.addUser(user);
    }

    @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST)
    public void updateUser(User user){
        userMapper.updateUser(user);
    }

    @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST)
    public void deleteUser(String id){
        userMapper.deleteUser(Integer.parseInt(id));
    }
}
</code></pre>
<p>此时便已经全部配置结束<br>
为了方便测试，忽略了service层，直接调用了mapper层</p>
<p>（6）测试<br>
1.<br>
<a href="https://imgtu.com/i/cW7Rnx"><img src="https://z3.ax1x.com/2021/04/16/cW7Rnx.png" alt="cW7Rnx.png" loading="lazy"></a></p>
<ol start="2">
<li></li>
</ol>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cW74AO"><img src="https://z3.ax1x.com/2021/04/16/cW74AO.png" alt="cW74AO.png" loading="lazy"></a></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-5.全局异常捕获]]></title>
        <id>https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/</id>
        <link href="https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/">
        </link>
        <updated>2021-04-16T06:23:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-5全局异常捕获">springboot-5.全局异常捕获</h2>
<p>在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。</p>
<p>1 浏览器访问异常时：<br>
<a href="https://imgtu.com/i/cW5TOK"><img src="https://z3.ax1x.com/2021/04/16/cW5TOK.png" alt="cW5TOK.png" loading="lazy"></a></p>
<p>2.postman访问异常时：<br>
<a href="https://imgtu.com/i/cW5qTe"><img src="https://z3.ax1x.com/2021/04/16/cW5qTe.png" alt="cW5qTe.png" loading="lazy"></a></p>
<p>显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。</p>
<h2 id="正文">正文</h2>
<p><strong>1.自定义基础接口类+自定义枚举类</strong></p>
<pre><code>public interface BaseErrorInfoInterface {
    /** 错误码*/
    String getResultCode();

    /** 错误描述*/
    String getResultMsg();

    public enum CommonEnum implements BaseErrorInfoInterface {
        // 数据操作错误定义
        SUCCESS(&quot;200&quot;, &quot;成功!&quot;),
        BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;),
        SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;),
        NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;),
        INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;),
        SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;)
        ;

        /** 错误码 */
        private String resultCode;

        /** 错误描述 */
        private String resultMsg;

        CommonEnum(String resultCode, String resultMsg) {
            this.resultCode = resultCode;
            this.resultMsg = resultMsg;
        }

        @Override
        public String getResultCode() {
            return resultCode;
        }

        @Override
        public String getResultMsg() {
            return resultMsg;
        }
    }
}
</code></pre>
<p><strong>2.自定义异常类</strong></p>
<pre><code>public class BizException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * 错误码
     */
    protected String errorCode;
    /**
     * 错误信息
     */
    protected String errorMsg;

    public BizException() {
        super();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface) {
        super(errorInfoInterface.getResultCode());
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) {
        super(errorInfoInterface.getResultCode(), cause);
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(String errorMsg) {
        super(errorMsg);
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg) {
        super(errorCode);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg, Throwable cause) {
        super(errorCode, cause);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }


    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getMessage() {
        return errorMsg;
    }

    @Override
    public Throwable fillInStackTrace() {
        return this;
    }
}
</code></pre>
<p><strong>3.自定义数据格式</strong></p>
<pre><code>public class ResultBody {
    /**
     * 响应代码
     */
    private String code;

    /**
     * 响应消息
     */
    private String message;

    /**
     * 响应结果
     */
    private Object result;

    public ResultBody() {
    }

    public ResultBody(BaseErrorInfoInterface errorInfo) {
        this.code = errorInfo.getResultCode();
        this.message = errorInfo.getResultMsg();
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getResult() {
        return result;
    }

    public void setResult(Object result) {
        this.result = result;
    }

    /**
     * 成功
     * 
     * @return
     */
    public static ResultBody success() {
        return success(null);
    }

    /**
     * 成功
     * @param data
     * @return
     */
    public static ResultBody success(Object data) {
        ResultBody rb = new ResultBody();
        rb.setCode(CommonEnum.SUCCESS.getResultCode());
        rb.setMessage(CommonEnum.SUCCESS.getResultMsg());
        rb.setResult(data);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(BaseErrorInfoInterface errorInfo) {
        ResultBody rb = new ResultBody();
        rb.setCode(errorInfo.getResultCode());
        rb.setMessage(errorInfo.getResultMsg());
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(String code, String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(code);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error( String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(&quot;-1&quot;);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    @Override
    public String toString() {
        return JSONObject.toJSONString(this);
    }
}
</code></pre>
<p><strong>4.自定义全局异常处理类</strong></p>
<pre><code>@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    public static final String Demo_View =  &quot;error&quot;;
    /**
     * 处理自定义的业务异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value = BizException.class)
    public  Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,e.getErrorCode());
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    /**
     * 处理空指针的异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =NullPointerException.class)
    @ResponseBody
    public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){
        logger.error(&quot;发生空指针异常！原因是:&quot;,e);
        return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH);
    }


    /**
     * 处理其他异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =Exception.class)
    public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR);
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    //判断是否是ajax请求
    public static boolean isAjax(HttpServletRequest httpRequest)
    {
        return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null
                &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString()));
    }
}
</code></pre>
<p><strong>5.编写前端异常显示页面</strong><br>
ps:名称对应步骤4里的String Demo_View<br>
为了测试，快速建立一个html</p>
<pre><code>&lt;!doctype html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>此时全局异常捕获已经建立完毕，接下来进行测试</p>
<h2 id="测试">测试</h2>
<p>1.web页面跳转</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        int a = 1 / 0; //除以0，产生异常
        return &quot;error&quot;;
    }
}
</code></pre>
<p>此时访问web页面：<br>
<a href="https://imgtu.com/i/cWo0K0"><img src="https://z3.ax1x.com/2021/04/16/cWo0K0.png" alt="cWo0K0.png" loading="lazy"></a></p>
<p>2.ajax形式跳转<br>
更改controller文件</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;&quot;)
    public String err()
    {
        return &quot;thymeleaf/ajaxerror&quot;;
    }
    @RequestMapping(&quot;getAjaxError&quot;)
    public jsonResult ajaxError()
    {
        int a = 1/0;
        return jsonResult.ok(200);
    }
}
</code></pre>
<p>新建一个ajaxerror.html文件于thymeleaf文件夹下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax测试&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt;
&lt;/body&gt;
&lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个ajax.js文件编写ajax请求</p>
<pre><code>$(&quot;#test&quot;).click(function() {
    $.ajax({
        url: &quot;/err/getAjaxError&quot;,
        type: &quot;POST&quot;,
        async: false,
        success: function (data) {
            if (data.status == 200 &amp;&amp; data.msg == 'OK') {
                alert(&quot;success&quot;);
            } else {
                alert(&quot;发生异常&quot; + data.msg);
            }
        },
        error: function (response, ajaxOption, thrownError) {
            alert(&quot;error&quot;);
        }
    });
});
</code></pre>
<p>记得在application文件夹添加静态文件路径配置</p>
<pre><code>  mvc:
    static-path-pattern: /static/**
</code></pre>
<p>此时访问<br>
<a href="https://imgtu.com/i/cWoDbT"><img src="https://z3.ax1x.com/2021/04/16/cWoDbT.png" alt="cWoDbT.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/cWoR2R"><img src="https://z3.ax1x.com/2021/04/16/cWoR2R.png" alt="cWoR2R.png" loading="lazy"></a></p>
<p>3.测试自定义异常<br>
新建一个controller文件</p>
<pre><code>@Controller
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {
    @RequestMapping(&quot;&quot;)
    public String api(ModelMap map)
    {
        User u = new User();
        map.addAttribute(&quot;user&quot;,u);
        return &quot;thymeleaf/api&quot;;
    }

    @PostMapping(&quot;/user&quot;)
    public boolean insert(User user) {
        System.out.println(&quot;开始新增...&quot;);
        //如果姓名为空就手动抛出一个自定义的异常！
        if (user.getUsername() == null) {
            throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;);
        }
        return true;
    }
}
</code></pre>
<p>新建一个api.html文件</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>访问<br>
<a href="https://imgtu.com/i/cWoxqf"><img src="https://z3.ax1x.com/2021/04/16/cWoxqf.png" alt="cWoxqf.png" loading="lazy"></a></p>
<p>3.测试自定义异常</p>
<pre><code>    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;);
    }
</code></pre>
<h2 id="尾言">尾言</h2>
<p>按照步骤添加即可完成操作~<br>
User类自行添加或者浏览前文即可。</p>
<h2 id="其他">其他</h2>
<p>1.SpringBoot异常处理-自定义错误页面</p>
<p><strong>(1) 在Spring Boot中一共提供了几种处理异常的方式？</strong></p>
<p>SpringBoot 中对于异常处理提供了五种处理方式：</p>
<p>自定义错误页面；</p>
<p>@ExceptionHandle 注解处理异常；</p>
<p>@ControllerAdvice+@ExceptionHandler 注解处理异常；</p>
<p>配置 SimpleMappingExceptionResolver 处理异常；</p>
<p>自定义 HandlerExceptionResolver 类处理异常</p>
<p><strong>(2) 什么是自定义错误页面方式？</strong></p>
<p>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常  SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫  BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。</p>
<p><strong>(3) 自义定错误页面应该放到项目的什么位置？</strong></p>
<p>放在一般网页资源存放的位置 即src/main/resources/templates</p>
<p>2.SpringBoot异常处理-@ControlleAdvice</p>
<p><strong>(1) @ControllerAdvice注解的作用是什么？</strong></p>
<p>需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。</p>
<p><strong>(2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？</strong></p>
<p>是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-4.模板引擎]]></title>
        <id>https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/</id>
        <link href="https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/">
        </link>
        <updated>2021-04-16T06:15:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-4模板引擎">springboot-4.模板引擎</h2>
<h2 id="前言">前言</h2>
<p>关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。</p>
<h2 id="freemarker">freemarker</h2>
<p>(1)在pom文件中添加依赖项</p>
<pre><code>        &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加freemarker相关配置</p>
<pre><code>spring:
  http:
    encoding:
      force: true
      charset: UTF-8
  freemarker:
    allow-request-override: false
    cache: false
    check-template-location: true
    charset: UTF-8
    content-type: text/html; charset=utf-8
    expose-request-attributes: false
    expose-session-attributes: false
    expose-spring-macro-helpers: false
    suffix: .ftl
    template-loader-path: classpath:/templates
</code></pre>
<p>(3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl<br>
文件树结构：<br>
<a href="https://imgtu.com/i/cW4luT"><img src="https://z3.ax1x.com/2021/04/16/cW4luT.png" alt="cW4luT.png" loading="lazy"></a><br>
快速创建一个网页模板进行测试，内容如下：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;${host}&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ps：其中host的值通过后台读取。</p>
<p>（4）在controller文件夹下新建一个freemarkerController.java文件</p>
<pre><code>@Controller
   public class freemarkerController {
        @RequestMapping(&quot;/&quot;)
        public String index(ModelMap map) {
            map.addAttribute(&quot;host&quot;,&quot;ericam&quot;);
            return &quot;freemarker/center&quot;;
        }
   }
</code></pre>
<p>ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl）<br>
(5)预览<br>
此时打开浏览器可以看到如下内容：<br>
<a href="https://imgtu.com/i/cW4dv6"><img src="https://z3.ax1x.com/2021/04/16/cW4dv6.png" alt="cW4dv6.png" loading="lazy"></a></p>
<p>接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf）</p>
<h2 id="thymeleaf">Thymeleaf</h2>
<h3 id="一-快速入门使用">一. 快速入门使用</h3>
<p>（1）在pom文件夹添加项目依赖</p>
<pre><code>            &lt;!-- ThymeLeaf 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加themeleaf相关配置</p>
<pre><code>spring:
    thymeleaf:
        cache: false # 开发时关闭缓存,不然没法看到实时页面
        mode: HTML # 用非严格的 HTML
        encoding: UTF-8
        servlet:
        content-type: text/html
</code></pre>
<p>(3)<br>
在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html<br>
文件树：<br>
<a href="https://imgtu.com/i/cW428I"><img src="https://z3.ax1x.com/2021/04/16/cW428I.png" alt="cW428I.png" loading="lazy"></a><br>
新建一个User.java文件<br>
文件树：<br>
<a href="https://imgtu.com/i/cW4WxP"><img src="https://z3.ax1x.com/2021/04/16/cW4WxP.png" alt="cW4WxP.png" loading="lazy"></a><br>
(4)编写User.java文件<br>
为了方便测试，用户具备如下属性：</p>
<ul>
<li>id</li>
<li>用户名</li>
<li>年龄</li>
<li>创建时间</li>
<li>用户简介</li>
</ul>
<pre><code>public class User {
    private String id;
    private int age;
    private String username;
    private Date createTime;
    private String desc;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
//请读者自行补充 构造器和 get/set方法..

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }
}
</code></pre>
<p>(5)新建一个themeleafController.java进行测试</p>
<pre><code>@Controller
public class themeleafController {
    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);   //这里的user对应html里的user
        return &quot;thymeleaf/test&quot;;
    }
}
</code></pre>
<p>(6)最后我们进行编写test.html文件</p>
<pre><code>&lt;div&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt;
    &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。<br>
(7)预览<br>
<a href="https://imgtu.com/i/cW475j"><img src="https://z3.ax1x.com/2021/04/16/cW475j.png" alt="cW475j.png" loading="lazy"></a></p>
<h3 id="二thymeleaf常用标签-方法">二.Thymeleaf常用标签-方法</h3>
<p>（1）上述test.html的等同写法</p>
<pre><code>&lt;div th:object=&quot;${user}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>这样可以简化内容，使用更加广泛。</p>
<p>（2）表单的提交<br>
我们在test.html里添加如下内容</p>
<pre><code>&lt;div&gt;
    &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt;
        &lt;input type=&quot;submit&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username<br>
接着在themeleafController添加如下内容</p>
<pre><code>    @PostMapping(&quot;/postform&quot;)
    public String postform(User u)  //前端传入了一个User对象
    {
        System.out.println(u.getUsername());
        return &quot;redirect:/test&quot;;   //重定向（等于转向/test地址
    }
</code></pre>
<p>（3）th:if标签</p>
<pre><code>&lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt;
</code></pre>
<p>利用if判断变量是否为空，非空时显示</p>
<pre><code class="language-html">&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>if / else 的实现</p>
<pre><code>&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
&lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>(4)th:selected标签</p>
<pre><code>&lt;select&gt;
    &lt;option &gt;选择框&lt;/option&gt;
    &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>(5)table表单</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;年龄&lt;/th&gt;
        &lt;th&gt;创建时间&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;person:${userlist}&quot;&gt;
        &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>在这里我们需要修改下themeleafController文件，为其添加一个userlist。</p>
<pre><code>    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);
        List&lt;User&gt; userlist = new ArrayList&lt;&gt;();  //添加一个userlist
        userlist.add(u);
        u = new User();
        u.setId(&quot;234&quot;);
        u.setUsername(&quot;ericam&quot;);
        u.setCreateTime(new Date(2020-1900,5-1,12));
        u.setAge(3);
        userlist.add(u);
        map.addAttribute(&quot;userlist&quot;,userlist);
        return &quot;thymeleaf/test&quot;;
    }
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cW4jMV"><img src="https://z3.ax1x.com/2021/04/16/cW4jMV.png" alt="cW4jMV.png" loading="lazy"></a></figure>
<p>(6)th:switch</p>
<pre><code>&lt;div th:switch=&quot;${user.username}&quot;&gt;
    &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>备注：常用标签的效果可以自行去测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-3.资源文件属性配置]]></title>
        <id>https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/</id>
        <link href="https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/">
        </link>
        <updated>2021-04-16T06:15:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-3资源文件属性配置">springboot-3.资源文件属性配置</h2>
<h3 id="前言">前言</h3>
<p>为什么要进行资源文件属性配置呢？可以想象成就是一个设置文件。比如设置好数据库密码.port端口后，在其他地方只需要用名字引用即可。<br>
举个例子：<br>
我们设置以下项目的持有者名称为ericam</p>
<pre><code>demo:
    name: &quot;ericam&quot;
</code></pre>
<p>那么在其他地方只需要引用name名称即可，然后如果整个项目需要多次引用，后期我们只需要在一个配置文件里更改下名称即可，不必多次操作。</p>
<p>Spring Boot可使用注解的方式将自定义的properties文件映射到实体bean中，比如application.properties文件 或者application.yml</p>
<h3 id="正文">正文</h3>
<p>（1）首先，在pom文件中添加依赖项</p>
<pre><code>&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
</code></pre>
<p><img src="https://ericamblog.oss-cn-shanghai.aliyuncs.com/2020/springboot3/1.png" alt="img" loading="lazy"><br>
（2）修改application.yml文件，添加如下内容</p>
<pre><code>demo:
  name: &quot;ericam&quot;
</code></pre>
<p>（3）新建一个Resource.java文件<br>
<a href="https://imgtu.com/i/cWhDts"><img src="https://z3.ax1x.com/2021/04/16/cWhDts.png" alt="cWhDts.png" loading="lazy"></a></p>
<pre><code>package cn.ericam.nndemo;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
@Configuration  //使用配置注解 ，表示这个类是配置文件
@ConfigurationProperties(prefix = &quot;demo&quot;) //prefix 指定配置文件里的前缀
@PropertySource(value = &quot;classpath:application.yml&quot;)
public class Resource {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>ps：ConfigurationProperties是一个注解，可以标注在一个Class上，这样Spring Boot会从Environment中获取其属性对应的属性值给其进行注入。<br>
（4）接下来，我们开始引用一波尝试，打开helloController.java文件</p>
<pre><code>@RestController
public class helloController {
    @Autowired
    private Resource resource;    //构建一个Resource类对象，通过autowired自动赋值
    @RequestMapping(&quot;/getR&quot;)
    public jsonResult gr()
    {
        Resource b = new Resource();   
        BeanUtils.copyProperties(resource,b); //将resource的值拷贝复制给b
        return  jsonResult.ok(b);
    }
}
</code></pre>
<p>ps:@Autowired 注释可以对类成员变量、方法及构造函数进行标注，完成自动装配。<br>
通过 @Autowired的使用来消除 set、get方法。</p>
<p>打开浏览器<br>
<a href="https://imgtu.com/i/cWhccV"><img src="https://z3.ax1x.com/2021/04/16/cWhccV.png" alt="cWhccV.png" loading="lazy"></a></p>
<p>application.yml文件中重要属性</p>
<pre><code>server:
    port: 8080       #端口
    servlet:
        context-path: /demo   #配置路径，此后访问http://localhost:****/demo/****
</code></pre>
]]></content>
    </entry>
</feed>