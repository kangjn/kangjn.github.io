<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-19T06:48:06.827Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[Node–异步I/O解析]]></title>
        <id>https://kangjn.github.io/post/node-yi-bu-io-jie-xi/</id>
        <link href="https://kangjn.github.io/post/node-yi-bu-io-jie-xi/">
        </link>
        <updated>2021-04-19T02:58:55.000Z</updated>
        <content type="html"><![CDATA[<p>“异步”这个名词其实在Node之前就已经诞生了。但是在绝大多数高级编程语言中，异步并不多见。在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。</p>
<p>异步I/O、事件驱动和单线程构成了Node的基调，而Nginx与Node的事件驱动、异步I/O设计理念比较相近。Nginx采用纯C编写，性能表现非常优异，具备面向客户端管理连接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。</p>
<h2 id="为什么要异步io">为什么要异步I/O</h2>
<p>为什么异步I/O在Node中如此重要，这是因为Node面向网络设计，在跨网络的结构下，并发已经是现代编程中的标准配备了。</p>
<h3 id="用户体验">用户体验</h3>
<p>《高性能JavaScript》中提到过，如果脚本的执行时间超过100毫秒，用户就会感到页面卡顿，以为页面停止响应。而在B/S模型中，网络速度的限制给网页的实时体验造成很大的麻烦。</p>
<p>如果网页临时需要获取一个资源，通过同步的方式获取，那么JavaScript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI停顿，不响应用户的交互行为。这样用户体验将会极差。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>同理，前端通过异步可以消除掉UI阻塞现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源消耗M毫秒，第二个资源消耗N毫秒。如果采用同步的方式，获取两个资源消耗的的时间为M+N毫秒。而采用异步的方式，第一个资源的获取并不会阻塞第二个资源的获取，消耗的时间为max(M,N)。</p>
<p>随着网站或应用不断膨胀，M与N的值会线性增长，那么异步的性能将比同步更加优越。</p>
<h3 id="资源分配">资源分配</h3>
<p>假设业务场景中有一组互不相关的任务需要完成，有以下两种主流的方法：</p>
<ul>
<li>单线程串行一次执行</li>
<li>多线程并行完成</li>
</ul>
<p>如果创建多线程的开销小于并行执行，那么多线程是首选的，但是多线程在创建线程和执行期线程上下文切换的开销较大，而且多线程编程经常面临锁、状态同步等问题。</p>
<p>单线程顺序执行任务的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行执行的，但是同步的编程模型导致I/O的进行会让后续任务等待，造成资源不能被更好的利用。</p>
<p>Node利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，更好的利用CPU。</p>
<h2 id="异步io实现">异步I/O实现</h2>
<p>异步I/O在Node中应用最为广泛，但是它并不是Node的原创。</p>
<h3 id="异步io与非阻塞io">异步I/O与非阻塞I/O</h3>
<p>对于计算机内核I/O而言，异步/同步和阻塞/非阻塞是两码事。</p>
<p>操作系统对于I/O只有两种方式：阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。</p>
<p>阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。</p>
<p>为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回，非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时提升性能是明显的，但是由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前的调用状态。</p>
<p>为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做<strong>轮询</strong>。</p>
<p>现存的轮询技术主要有read、select、poll、epoll和kqueue。这里只讲一下epoll的轮询原理。</p>
<p>epoll是Linux下效率最高的I/O事件通知机制，在进入轮询的时候，如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件的通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/k3u1fbpfcp1.png" alt="image.png" loading="lazy"></figure>
<p>轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于程序而言，它仍然算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间等待。等待期间，CPU要么用于遍历文件描述符，要么用于休眠等待时间发生。</p>
<h3 id="现实的异步io">现实的异步I/O</h3>
<p>通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（虽然这是模拟的）</p>
<p>但是最初，Node在*nix 平台下采用了libeio配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O。</p>
<p>而Windows下的IOCP在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。但是它的内部其实依然是线程池原理，不同之处在于这些线程池有系统内核接手管理。</p>
<p>由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间个字独立。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/k3u1fbpfcp2.png" alt="image.png" loading="lazy"></figure>
<p>我们时常提到Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。</p>
<h2 id="node的异步io">Node的异步I/O</h2>
<p>完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>
<h3 id="事件循环">事件循环</h3>
<p>事件循环是Node自身的执行模型，正式它使得回调函数十分普遍。</p>
<p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下个循环，如果不再有事件处理，就退出进程。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJll9.png" alt="coJll9.png" loading="lazy"></figure>
<h3 id="观察者">观察者</h3>
<p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>在Node中，事件主要来源于网络请求、文件I/O等，这些时间对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。</p>
<p>事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<h3 id="请求对象">请求对象</h3>
<p>对于Node的异步I/O调用而言，回调函数不由开发者来调用。从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种产物，叫做<strong>请求对象</strong></p>
<p>下面用fs.open()方法作为一个小小的例子。</p>
<pre><code class="language-js">fs.open = function(path,flags,mode,callback){
    //...
    binding.open(pathModule._makeLong(path),
                    stringToFlags(flags),
                    mode,
                    callback);
}
 
</code></pre>
<p>fs.open()的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初试操作。JavaScript层面的代码通过调用C++核心模块进行下层的操作。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJ3O1.png" alt="coJ3O1.png" loading="lazy"></figure>
<p>从事JavaScript调用Node的核心模块，核心模块调用C++模块，内建模块通过libuv进行系统调用，这里是Node里经典的调用方式。这里libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uv_fs_open()的调用过程中，将从JavaScript层传入的参数和当前方法都封装在一个请求对象中，回调函数则被设置在这个对象的属性上。对象包装完毕后，将对象推入线程池等待执行。</p>
<p>至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。</p>
<p>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。</p>
<h3 id="执行回调">执行回调</h3>
<p>组装好请求对象、送入I/O线程池等待执行，只是完成一部I/O的第一部分，回调通知是第二部分。</p>
<p>线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueueCompletionStatus()通知IOCP，告知当前对象操作已经完成。</p>
<p>至此，整个异步I/O的流程完全结束。</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coJYTK.png" alt="coJYTK.png" loading="lazy"></figure>
<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
<h3 id="小结">小结</h3>
<p>整理下来，我们可以提取异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。单线程和线程池看起来有些悖论的样子。因为JavaScript是单线程的，所以很容易理解为它不能充分利用多核CPU。实际上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。还有就是除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）都是可以并行起来的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络 — TCP的三次握手、四次挥手]]></title>
        <id>https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/</id>
        <link href="https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/">
        </link>
        <updated>2021-04-19T02:49:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="tcp-头部标识符意义解读">TCP 头部标识符意义解读</h2>
<ol>
<li>SYN：建立连接</li>
</ol>
<pre><code class="language-js">SYN=1，ACK=0  表示一个连接请求  
SYN=1，ACK=1  表示同意建立一个连接
 
</code></pre>
<ol>
<li>FIN：关闭连接</li>
</ol>
<pre><code class="language-js">FIN=1 表示发端完成发送任务
注意：表明发送方已经没有数据发送 但不代表之前的数据发送完毕
 
</code></pre>
<ol>
<li>ACK：置1时表示确认</li>
<li>seq：发送序列号</li>
<li>ack (number)：确认码</li>
</ol>
<p>更多关于TCP 和 UDP 的详细内容见 计算机网络系列 -- TCP和UDP</p>
<h2 id="tcp-三次握手">TCP 三次握手</h2>
<h4 id="过程通俗理解">过程通俗理解</h4>
<pre><code>A—&gt;B
B收到，B—&gt;A
A收到
 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coGDaT.png" alt="coGDaT.png" loading="lazy"></figure>
<h4 id="过程的详细解读">过程的详细解读</h4>
<p>（1） 第一次握手：客户端发送【SYN = 1，随机序列号seq = x】的数据包到服务器,服务器由【SYN = 1】知道客户端要建立连接；<code>此时客户端进入已发送状态，等待服务器确认</code></p>
<p>（2） 第二次握手：服务器向客户端发送标【SYN = 1，ACK = 1】和【随机序列号seq = y, 确认码ack number = x+1】的数据包；<code>此时服务器进入已收到状态</code></p>
<p>（3） 第三次握手：客户端收到后判断【ACK=1】和【收的ack number =发的seq+1】；<br>
若正确，客户端发送标识位【ACK = 1、seq = x + 1】和【确认码ack number = y + 1】（服务器发送的seq+1）到服务器；</p>
<p>服务器收到后判断【ACK=1】和【收的ack number =发的seq+1】是否正确；<br>
若正确则完成建立连接，此包发送完毕。<code>此时客户端和服务器进入已连接状态，完成三次握手，客户端与服务器开始传送数据</code></p>
<h4 id="tcp-三次握手的目的">TCP 三次握手的目的</h4>
<ol>
<li>建立客户端和服务器之间的连接，确认各自的收发能力是否正常</li>
<li>对准好 TCP 包的序号问题，为保证可靠传送</li>
<li>如果是 https 协议，还会进行解密加密</li>
</ol>
<p>HTTPS解密解密过程见 计算机网络系列 -- HTTPS加密解密过程</p>
<h4 id="为什么要三次握手而不是两次">为什么要三次握手而不是两次？</h4>
<p>这句话可以转化为第三次握手的意义是什么？</p>
<pre><code class="language-js">第三次握手的意义在于：`让服务器知道客户端也收到了自己的同步信号`
 
</code></pre>
<p>通俗理解</p>
<pre><code class="language-js">两次握手只能保证`单向`：只知道A能向B发送数据
三次握手能保证`双向`：保证A也能收到B发送的数据
 
</code></pre>
<h4 id="第三次握手失败了怎么办">第三次握手失败了怎么办？</h4>
<p>server端发送了SYN+ACK报文后就会启动一个<strong>定时器</strong>，等待client返回的ACK报文。如果第三次握手失败的话client给server返回了ACK报文，<code>server并不能收到这个ACK报文</code>。那么server端就会启动超时重传机制，超过规定时间后<code>重新发送SYN+ACK</code>，重传次数默认是5次。如果重传指定次数到了后，仍然<code>未收到ACK应答</code>，那么一段时间后，<code>server自动关闭这个连接。但是client认为这个连接已经建立</code>，如果client端向server写数据，server端将<strong>发送RTS报文段</strong>，以防止syn洪泛攻击。</p>
<p>syn洪泛攻击</p>
<pre><code class="language-js">通俗的理解是：当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为dos（deny of service）攻击埋下隐患，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，server就会为这些syn包分配资源（但并未使用），就会使server占用大量内存，使server连接环境耗尽，这就是syn洪泛攻击
 
</code></pre>
<h4 id="为什么要三次握手而不是四次">为什么要三次握手而不是四次？</h4>
<p>四次握手的过程：</p>
<ol>
<li>第一次：客户端发送【SYN = 1，随机序列号seq = u】到服务器，用来请求开启客户A到服务器B的数据传送；</li>
<li>第二次：服务器B收到这个SYN，它发回【ACK = 1、确认序号ack=u+1】表示同意；</li>
<li>第三次：服务器开启与客户端的连接，发回标识位【SYN = 1，ACK = 1,，确认码ack =u+1】给客户端；</li>
<li>第四次：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。</li>
</ol>
<p>很明显，第二次和第三次没有分开的必要，可以合并，而且还能<code>提高建立连接时的效率</code></p>
<h2 id="tcp-四次挥手">TCP 四次挥手</h2>
<h4 id="过程通俗理解-2">过程通俗理解</h4>
<pre><code>A：B 啊，我不想玩了
B：好，知道了，等一下哈，我这边还没好
【注意】这时，只是A不想玩了，即不再发送数据。但是B可能还有未发送完的数据，所以需要等待B也主动关闭
B：好的，我弄完了，我也不玩了，拜拜
A：好的，拜拜
 
</code></pre>
<p>[<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/coGgz9.png" alt="coGgz9.png" loading="lazy"></p>
<h4 id="过程的详细解读-2">过程的详细解读</h4>
<p>（1）第一次挥手：客户端发送【FIN = 1，随机序列号seq = u】到服务器，用来主动关闭客户A到服务器B的数据传送；<code>客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN</code></p>
<p>（2）第二次挥手：服务器B收到这个FIN，它发回【ACK = 1、确认序号ack number=u+1】表示同意；<code>客户端进入FIN-WAIT-2状态，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接;</code></p>
<p>（3）第三次挥手：服务器关闭与客户端的连接，发回标识位【FIN = 1，ACK = 1,，确认码ack number=u+1】给客户端；<code>服务器进入LAST_ACK，等待最后一次ACK确认</code></p>
<p>（4）第四次挥手：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。<code>客户端进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态</code></p>
<h4 id="tcp-四次挥手的目的">TCP 四次挥手的目的</h4>
<p>保证客户端、服务器真正断开连接</p>
<h4 id="为什么挥手要四次而握手只要三次">为什么挥手要四次？而握手只要三次？</h4>
<p>B表示收到A的报文之后，可能有未发送完的数据，所以需要把数据全部发送完毕后再来告诉A说可以断开了，所以多了一次</p>
<h4 id="2msl是什么目的是什么">2MSL是什么？目的是什么？</h4>
<p>MSL是时间单位 —— 任何报文在网络上存在的最长时间</p>
<p>2MSL目的：保证第四次挥手正常进行</p>
<ol>
<li>若第4次挥手的报文段丢失了</li>
<li>服务器就会超时重传第3次挥手的报文段</li>
<li>客户端就会重新给服务器发送第4次挥手的报文</li>
<li>最后，客户端、服务器才真正断开连接</li>
</ol>
<p>为什么客户端关闭后不能再发一下就行？</p>
<p>不能保证新、老连接端口号一致</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法小记]]></title>
        <id>https://kangjn.github.io/post/suan-fa-xiao-ji/</id>
        <link href="https://kangjn.github.io/post/suan-fa-xiao-ji/">
        </link>
        <updated>2021-04-19T02:37:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数组去重">数组去重</h1>
<h2 id="第一种-new-set">第一种 new Set</h2>
<pre><code class="language-js">let ary = [1,2,3,4,2,1,3,4,5,6,4,3,5,6,3]
let arr = Array.from(new Set(ary))

第二种

 

 
</code></pre>
<h2 id="第二种-拿出当前项和后面内容比较">第二种 拿出当前项和后面内容比较</h2>
<pre><code class="language-js">for(let i = 0;i &lt; ary.length - 1; i++){
    let item = ary[i]
    let arg = ary.slice(i + 1);
    if(arg.indexOf(item) &gt; -1){
        ary.splice(i,1); // 这个性能不如 新建一个数组好
        i--; // 会因为splice造成数组塌陷
    }
}
 
</code></pre>
<h2 id="第三种-判断是否包含包含的话-那最后一项把当前项覆盖">第三种 判断是否包含，包含的话 那最后一项把当前项覆盖</h2>
<pre><code class="language-js">for(let i = 0;i &lt; ary.length - 1; i++){
    let item = ary[i]
    let arg = ary.slice(i + 1);
    if(arg.indexOf(item) &gt; -1){
        ary[i] = ary[ary.length - 1];
        ary.length--;
        i--
    }
}

 
</code></pre>
<h2 id="第四种-循环遍历是否包含不包含push">第四种 循环遍历是否包含，不包含push</h2>
<pre><code class="language-js">let arr = []
for(let i = 0;i &lt; ary.length; i++){
    if(arr.indexOf(item) === -1){
      arr.push(ary[i])
    }
}
 
</code></pre>
<p>等等还有很多，比如对象键值对，比如包含置为null 在过滤</p>
<h1 id="数组扁平化">数组扁平化</h1>
<h2 id="第一种-flat">第一种 flat</h2>
<pre><code class="language-js">let arr = [
    [1,2,3],
    [3,4,5,6],
    [6,7,8,9,0,[1],[2,3]],10
]

flat()写  几  就扁平化 几级
Infinity 无限
arr.flat(Infinity)

 
</code></pre>
<h2 id="第二种-reduce">第二种 reduce</h2>
<pre><code class="language-js">function ab(arr){
   return arr.reduce((pre,cur) =&gt; {
       return pre.concat(Array.isArray(cur) ? ab(cur) : cur)
   },[])
}
 
</code></pre>
<h2 id="第三种-tostring">第三种 toString</h2>
<pre><code class="language-js">arr.toString().split(',').map(itm =&gt; parserFloat(itm))
 
</code></pre>
<h2 id="第四种-while-reduce-concat">第四种 while + reduce + concat</h2>
<pre><code class="language-js">while(arr.some(itm =&gt; Array.isArray(itm))){
  arr = [].concat(...arr)
}
 
</code></pre>
<h2 id="第五种-正则">第五种 正则</h2>
<pre><code class="language-js">JSON.stringify(arr).replace(/(\[|\])/g,'').split(',').map(itm =&gt;parseFloat(itm))
 
</code></pre>
<h1 id="斐波那契数列">斐波那契数列</h1>
<p>let arr = [1,1,2,3,5,8,13,21]</p>
<p><strong>当前项 = 当前项的 前面两位相加</strong></p>
<p>可以 <strong>实现</strong> 传入 <strong>number</strong> 就能计算出对应<strong>斐波那契下标</strong>的值</p>
<h2 id="第一种-while循环">第一种： while循环</h2>
<pre><code class="language-js">function fibonacci(n){
    if(n&lt;=1) return 1;
    let arr = [1,1];
    let i = n + 1 -2;
    // why?因为传入的n是数组下标，所以要+1 减2的话就是因为一开始就有两个所以只需要创建剩下的位数
    while(i &gt; 0){
        let a = arr[arr.length - 2];
        let b = arr[arr.length - 1];
        arr.push(a+b);
        i--
    }
    return arr[arr.length - 1];
}


 
</code></pre>
<h2 id="第二种-递归">第二种 递归</h2>
<p><strong>count</strong>：传进来的number<br>
<strong>cur</strong>：放的最终值<br>
<strong>next</strong>：每次递归的时候作为下一次 cur 的值，需要每次 cur + next</p>
<p><a href="https://imgtu.com/i/co8dAO"><img src="https://z3.ax1x.com/2021/04/19/co8dAO.png" alt="co8dAO.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/01fcb9a1a61742a29a3c276a25a83e5d~tplv-k3u1fbpfcp-watermark.png)<br>
||<br>
|| 搭配食用<br>
||</p>
<pre><code class="language-js">fibonacci(count){
    function fn(count,cur = 1,next = 1){
        if(count == 0){
            return cur
        }else {
            return fn(count - 1,next,cur+next)
        }
    }
    
    return fn(count)
}
 
</code></pre>
<h1 id="冒泡排序">冒泡排序</h1>
<p><strong>相邻两元素之间两两比较，比较出大值进行赋值互换，再依次与相邻的元素比较</strong></p>
<p>必须要明白总共比较几回，一回比较几次！！！</p>
<pre><code class="language-js">let arr = [1,2,3,5,8,0,10]

// 外层控制比较几回
for(let i = 0; i &lt; arr.length - 1; i++){
    // 内层控制一回比较几次，并且比较大小
    for(let j = 0; j &lt; arr.length -1 -i; j++){
        if(arr[j] &gt; arr[j + 1]){
            let temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
 
 
</code></pre>
<h1 id="快速排序">快速排序</h1>
<p>分三步</p>
<ul>
<li><strong>取出数组的中间值</strong></li>
<li><strong>遍历数组，大于的放在右数组，小于的放在左边数组</strong></li>
<li><strong>递归并且用 concat 连接</strong></li>
</ul>
<pre><code class="language-js">let arr = [1,5,2,7,9,10,90,29,25,11,45,34];

function fast(arr){
   if(arr.length &lt; 1) return arr;
   let num = Math.floor(arr.length / 2)
   let idx = arr.splice(num,1)[0];
   let left = [];
   let right = [];
   for(let i = 0; i &lt; arr.length; i++){
       if(arr[i] &lt; idx){
         left.push(arr[i])
       }else {
         right.push(arr[i])
       }
   }
   return fast(left).concat(idx,fast(right))
}
 
</code></pre>
<h1 id="插入排序">插入排序</h1>
<ul>
<li>拿出一个值，作为初始数组的值，</li>
<li>通过循环想要排序的数组</li>
<li>并和新数组的值从后向前比</li>
<li>大于就splice到该项后面</li>
</ul>
<pre><code class="language-js">function insert(arr){
    let handle = []; // 这是最终成型的数组
    handle.push(arr[0]); // 先拿一个值
    for(let i = 1; i&lt; arr.length; i++){
        let news = arr[i];
        for(let j = handle.length - 1; j &gt;= 0; j--){ //从后向前比较
            if(news &gt; handle[j]){
                handle.splice(j+1,0,news);
                break;
            }
            
            if(j === 0){ // 比到为0的话直接放到数组头部
               handle.unshift(news);
            }
        }
    }
   return handle
}

 
</code></pre>
<h1 id="单链表反转">单链表反转</h1>
<p>看到这的话，要明白它反转后是什么样<br>
{<br>
a:4,<br>
next:{<br>
a:3,<br>
next:{<br>
a:2,<br>
next:{<br>
a:1,<br>
next: null<br>
}<br>
}<br>
}<br>
}<br>
看到这，肯定是有个大概的思路，就是<strong>节点替换</strong></p>
<p><a href="https://imgtu.com/i/co8yjI"><img src="https://z3.ax1x.com/2021/04/19/co8yjI.png" alt="co8yjI.png" loading="lazy"></a>](https://www.pipipi.net/wp-content/uploads/front-end-baike/e9030c138fbf4e0e8ba87222f3b66dff~tplv-k3u1fbpfcp-watermark.png)</p>
<pre><code class="language-js">let obj = {
    a:1,
    next:{
        a:2,
        next: {
            a:3,
            next:{
                a:4,
                next:null
            }
        }
    }
}

function reverseObj(obj){
    let pre = null; // pre 最终的值(包含每一步)
    let cur = obj
    while(cur.next !== null){
        let context = cur.next; // 首先拿到下一个next的值保存
        cur.next = pre === null ? null : pre; // pre是上一项保存的值
        pre = cur; // 将 当前项的值赋值给最终的值
        cur = context // 拿到下一项next继续重复以商操作
    }
}

 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习笔记：promise]]></title>
        <id>https://kangjn.github.io/post/xue-xi-bi-ji-promise/</id>
        <link href="https://kangjn.github.io/post/xue-xi-bi-ji-promise/">
        </link>
        <updated>2021-04-19T02:28:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>then接收两个参数, onFulfilled 和 onRejected</li>
<li>检查并处理参数, 如果参数不是function就忽略(原样返回value或者reason)</li>
</ol>
<p>class MyPromise {<br>
constructor(fn) {<br>
// 初始状态为pending<br>
this.status = PENDING;//状态<br>
this.value = null;//成功的值<br>
this.reason = null;//失败的值<br>
try {<br>
fn(this.resolve.bind(this), this.reject.bind(this));<br>
} catch (e) {<br>
this.reject(e);<br>
}<br>
}<br>
resolve(value) {<br>
if (this.status === PENDING) {<br>
//这层判断是因为fulfilled状态只可以由pending状态改变而来<br>
this.status = FULFILLED;<br>
this.value = value;<br>
}<br>
}<br>
reject(reason) {<br>
if (this.status === PENDING) {<br>
//同理这层判断是因为rejected状态只可以由pending状态改变而来<br>
this.status = REJECTED;<br>
this.reason = reason;<br>
}<br>
}<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
3. 根据当前promise的状态, 调用不同的函数<br>
class MyPromise {<br>
.....<br>
//这时候then函数被调用会瞬间就会执行switch判断，那这时候如果status可能还没变成fulfilled或者rejected，很有可能还是pending<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
4、首先要拿到所有的回调, 然后在某个时机去执行他. 需要新建两个数组, 分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组.<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
case PENDING: {<br>
this.FULFILLED_CALLBACK_LIST.push(fulFilledFn);<br>
this.REJECTED_CALLBACK_LIST.push(rejectedFn);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
5、在status状态发生变化的时候调用数组里所有的函数<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
resolve(value) {<br>
if (this.status === PENDING) {<br>
//这层判断是因为fulfilled状态只可以由pending状态改变而来<br>
this.status = FULFILLED;<br>
this.value = value;<br>
//执行存储的函数<br>
this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; {<br>
callback(this.value);<br>
});<br>
}<br>
}<br>
reject(reason) {<br>
if (this.status === PENDING) {<br>
//同理这层判断是因为rejected状态只可以由pending状态改变而来<br>
this.status = REJECTED;<br>
this.reason = reason;<br>
//执行存储的函数<br>
this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; {<br>
callback(this.reason);<br>
});<br>
}<br>
}<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
switch (this.status) {<br>
case FULFILLED: {<br>
fulFilledFn(this.value);<br>
break;<br>
}<br>
case REJECTED: {<br>
rejectedFn(this.reason);<br>
break;<br>
}<br>
case PENDING: {<br>
this.FULFILLED_CALLBACK_LIST.push(fulFilledFn);<br>
this.REJECTED_CALLBACK_LIST.push(rejectedFn);<br>
break;<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
7、then的返回值<br>
情况1：如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则新promise必须reject e<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
const fulFilledFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
fulFilledFn(this.value);<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
rejectedFn(this.reason);<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
return new MyPromise(fulFilledFnWithCatch);<br>
}<br>
case REJECTED: {<br>
return new MyPromise(rejectedFnWithCatch);<br>
}<br>
case PENDING: {<br>
return new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject));<br>
});<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
情况2：如果onFulfilled不是函数且promise成功执行，那么新的promise必须返回同样的状态和val<br>
情况3：如果onRejected不是函数且promise拒绝执行，那么新的promise必须返回同样的状态和reason<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
then(onFulfilled, onRejected) {<br>
const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value<br>
const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {<br>
throw reason<br>
};<br>
const fulFilledFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
fulFilledFn(this.value);<br>
resolve(this.value);<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject) =&gt; {<br>
try {<br>
rejectedFn(this.reason);<br>
if (this.isFunction(onRejected)) {<br>
resolve();<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
return new MyPromise(fulFilledFnWithCatch);<br>
}<br>
case REJECTED: {<br>
return new MyPromise(rejectedFnWithCatch);<br>
}<br>
case PENDING: {<br>
return new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject));<br>
});<br>
}<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
}<br>
情况4:如果onFulfilled或者onRejected 返回一个值 x ，则运行resolvePromise方法<br>
class MyPromise {<br>
FULFILLED_CALLBACK_LIST = [] //存储成功回调<br>
REJECTED_CALLBACK_LIST = [] //存储失败回调<br>
.....<br>
const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
try {<br>
if (!this.isFunction(onFulfilled)) {<br>
resolve(this.value);<br>
} else {<br>
const x = fulFilledFn(this.value);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e)<br>
}<br>
};<br>
const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
try {<br>
if (!this.isFunction(onRejected)) {<br>
reject(this.reason);<br>
} else {<br>
const x = rejectedFn(this.reason);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case REJECTED: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case PENDING: {<br>
const newPromise = new MyPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
});<br>
return newPromise;<br>
}<br>
}<br>
//检验是否为function<br>
isFunction(param) {<br>
return typeof param === 'function';<br>
}<br>
resolvePromise(newPromise, x, resolve, reject){}<br>
}<br>
8、resolvePromise<br>
resolvePromise(newPromise, x, resolve, reject) {<br>
// 防止死循环<br>
if (newPromise === x) {<br>
return reject(new TypeError('The promise and the return value are the same'));<br>
}<br>
if (x instanceof MPromise) {<br>
x.then((y) =&gt; {<br>
resolvePromise(newPromise, y, resolve, reject);<br>
}, reject);<br>
} else if (typeof x === 'object' || this.isFunction(x)) {<br>
if (x === null) {<br>
return resolve(x);<br>
}<br>
let then = null;<br>
try {<br>
then = x.then;<br>
} catch (error) {<br>
return reject(error);<br>
}<br>
// 如果 then 是函数<br>
if (this.isFunction(then)) {<br>
let called = false;<br>
try {<br>
then.call(<br>
x,<br>
(y) =&gt; {<br>
if (called) return;<br>
called = true;<br>
resolvePromise(promise, y, resolve, reject);<br>
},<br>
(r) =&gt; {<br>
if (called) return;<br>
called = true;<br>
reject(r);<br>
});<br>
} catch (error) {<br>
if (called) return;<br>
reject(error);<br>
}<br>
} else {<br>
resolve(x);<br>
}<br>
} else {<br>
resolve(x);<br>
}<br>
}<br>
9、onFulfilled 和 onRejected 是微任务<br>
then(onFulfilled, onRejected) {<br>
...<br>
const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
queueMicrotask(() =&gt; {<br>
try {<br>
if (!this.isFunction(onFulfilled)) {<br>
resolve(this.value);<br>
} else {<br>
const x = fulFilledFn(this.value);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e)<br>
}<br>
})<br>
};<br>
const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; {<br>
queueMicrotask(() =&gt; {<br>
try {<br>
if (!this.isFunction(onRejected)) {<br>
reject(this.reason);<br>
} else {<br>
const x = rejectedFn(this.reason);<br>
this.resolvePromise(newPromise, x, resolve, reject);<br>
}<br>
} catch (e) {<br>
reject(e);<br>
}<br>
})<br>
}<br>
switch (this.status) {<br>
case FULFILLED: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case REJECTED: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
return newPromise;<br>
}<br>
case PENDING: {<br>
const newPromise = new MPromise((resolve, reject) =&gt; {<br>
this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise));<br>
this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise));<br>
});<br>
return newPromise;<br>
}<br>
}<br>
}<br>
10. catch方法<br>
catch (onRejected) {<br>
return this.then(null, onRejected);<br>
}<br>
11. promise.resolve(静态方法)<br>
将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。<br>
static resolve(param) {<br>
if (param instanceof MyPromise) {<br>
return param;<br>
}<br>
return new MyPromise(function (resolve) {<br>
resolve(param);<br>
});<br>
}<br>
12. promise.reject(静态方法)<br>
返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。<br>
static reject(reason) {<br>
return new MPromise((resolve, reject) =&gt; {<br>
reject(reason);<br>
});<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端学习-Vue]]></title>
        <id>https://kangjn.github.io/post/qian-duan-xue-xi-vue/</id>
        <link href="https://kangjn.github.io/post/qian-duan-xue-xi-vue/">
        </link>
        <updated>2021-04-19T02:22:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="核心特性">核心特性</h2>
<h3 id="数据驱动视图">数据驱动视图</h3>
<ul>
<li>数据变化会自动更新到对应元素中，无需手动操作 DOM，这种行为称作单向数据绑定。</li>
<li>对于输入框等可输入元素，可设置双向数据绑定。<br>
双向数据绑定是在数据绑定基础上，可自动将元素输入内容更新给数据， 实现数据与元素内容的双向绑定。</li>
<li>Vue.js 的数据驱动视图是基于 MVVM 模型实现的。</li>
<li>MVVM (Model – View – ViewModel )是一种软件开发思想<br>
Model 层，代表数据<br>
View 层， 代表视图模板<br>
ViewModel 层，代表业务逻辑处理代码</li>
<li>基于MVVM 模型实现的数据驱动视图解放了DOM操作</li>
<li>View 与 Model 处理分离，降低代码耦合度</li>
<li>但双向绑定时的 Bug 调试难度增大</li>
<li>大型项目的 View 与 Model 过多，维护成本高</li>
</ul>
<h3 id="组件化开发">组件化开发</h3>
<ul>
<li>组件化开发，允许我们将网页功能封装为自定义 HTML 标签，复用时书写自定义标签名即可。</li>
<li>组件不仅可以封装结构，还可以封装样式与逻辑代码，大大提交 了开发效率与可维护性。</li>
</ul>
<h2 id="基础语法">基础语法</h2>
<h3 id="vue-实例">Vue 实例</h3>
<ul>
<li>通过 Vue 函数创建的对象，是使用 Vue 功能的基础。</li>
</ul>
<pre><code class="language-js">new Vue({
  //选项对象
});
 
</code></pre>
<h3 id="el-选项">el 选项</h3>
<ul>
<li>用于选取一个 DOM 元素作为 Vue 实例的挂载目标。</li>
<li>只有挂载元素内部才会被 Vue 进行处理，外部为普通 HTML 元素。</li>
<li>代表 MVVM 中的 View 层(视图)。</li>
<li>可以为 CSS 选择器格式的字符串 或 HTMLElement 实例，但不能为 html 或 body。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
   el: '#app'
});

var app = document.querySelector('#app');
var vm = new Vue({
    el: app
});
 
</code></pre>
<ul>
<li>挂载完毕后，可以通过 vm.$el 进行访问。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app'
});

console.log(vm.$el);
 
</code></pre>
<ul>
<li>未设置 el 的 vue 实例，也可以通过 vm.$mount() 进行挂载，参数形式与 el 规则相同。</li>
</ul>
<pre><code class="language-js">var app = document.getElementById('app');
var vm = new Vue({});
vm.$mount(app);
 
</code></pre>
<h3 id="插值表达式">插值表达式</h3>
<ul>
<li>挂载元素可以使用 Vue.js 的模板语法，模板中可以通过插值表达式为元素进行动态内容设置，写法为 {{ }}。</li>
</ul>
<pre><code class="language-html">&lt;li&gt;第一段示例内容：{{ 10 + 20 + 30 }}&lt;/li&gt;
&lt;li&gt;第二段示例内容：{{ 22 &gt; 3 ? '22比3大' : '3比22大' }}&lt;/li&gt;

&lt;!-- 错误写法 --&gt;
&lt;!-- &lt;li id=&quot;{{ 1 + 2 }}&quot;&gt;&lt;/li&gt; --&gt;
&lt;!-- &lt;li&gt;{{ var num = 100; }}&lt;/li&gt; --&gt;
 
</code></pre>
<p>注意点:</p>
<ul>
<li>插值表达式只能书写在标签内容区域，可以与其它内容混合。</li>
<li>内部只能书写 JavaScript 表达式，不能书写语句。</li>
</ul>
<h3 id="data-选项">data 选项</h3>
<ul>
<li>用于存储 Vue 实例需要使用的数据，值为对象类型。</li>
<li>data 中的数据可以通过 vm.$data.数据 或 vm.数据 访问。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
      title: '标题文本'
    }
});

console.log(vm.$data.title);
console.log(vm.title);
 
</code></pre>
<ul>
<li>data 中的数据可以直接在视图中通过插值表达式访问。</li>
<li>data 中的数据为响应式数据，在发生改变时，视图会自动更新。</li>
</ul>
<pre><code class="language-js">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ title }}&lt;/p&gt;    
&lt;/div&gt;

&lt;script&gt;
   var vm = new Vue({
    el: '#app',
    data: {
      title: '标题文本',
    }
});

vm.title = '新的标题内容';
&lt;/script&gt;
 
</code></pre>
<ul>
<li>data 中存在数组时，索引操作与 length 操作无法自动更新视图， 这时可以借助 Vue.set() 方法替代操作。</li>
</ul>
<pre><code class="language-js">var vm = new Vue({
    el: '#app',
    data: {
      arr: ['内容1', '内容2', '内容3']
    }
});

Vue.set(vm.arr, 0, '新内容');
 
</code></pre>
<h3 id="methods-选项">methods 选项</h3>
<ul>
<li>用于存储需要在 Vue 实例中使用的函数。</li>
<li>methods 中的方法可以通过 vm.方法名 访问。</li>
<li>方法中的 this 为 vm 实例，可以便捷的访问 vm 数据等功能。</li>
</ul>
<pre><code class="language-js"> &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ fn(title1) }}&lt;/p&gt;
    &lt;p&gt;{{ fn(title2) }}&lt;/p&gt;
    
    &lt;p&gt;{{ title1.split('-').join('') }}&lt;/p&gt;
    &lt;p&gt;{{ title2.split('-').join('') }}&lt;/p&gt;
 &lt;/div&gt;
 
&lt;script&gt;
var vm = new Vue({
  el: '#app',
  data: {
    prefix: '处理的结果为：',
    title1: 'a-b-c-d-e',
    title2: 'x-y-z'
  },
  methods: {
    fn (value) {
      // console.log(this);
      this.fn1();
      this.fn2();
      return this.prefix + value.split('-').join('');
    },
    fn1 () {
      console.log('执行了 fn1 的代码');
    },
    fn2 () {
      console.log('执行了 fn2 的代码');
    }
  }
});

// console.log(vm)
&lt;/script&gt;
 
 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-文件上传/下载]]></title>
        <id>https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/</id>
        <link href="https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/">
        </link>
        <updated>2021-04-16T07:34:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-文件上传下载">springboot-文件上传/下载</h2>
<h2 id="代码">代码</h2>
<p>application.yml</p>
<pre><code>spring:
  servlet:
    multipart:
      max-file-size: 50MB  #上传文件最大大小
      max-request-size: 50MB  #单次请求最大大小

# 自定义文件上传路径
web:
  upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/
</code></pre>
<p><strong>ps : 路径中不能包含中文，不然无法读取</strong></p>
<p>FileUtils (文件上传工具类)</p>
<pre><code>package cn.justcoding.util;

import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

/**
 * 文件上传工具包
 */
public class FileUtils {

    /**
     *
     * @param file 文件
     * @param path 文件存放路径
     * @param fileName 源文件名
     * @return
     */
    public static boolean upload(MultipartFile file, String path, String fileName){

        //使用原文件名
        String realPath = path + &quot;/&quot; +fileName;

        File dest = new File(realPath);

        //判断文件父目录是否存在
        if(!dest.getParentFile().exists()){
            dest.getParentFile().mkdir();
        }

        try {
            //保存文件
            file.transferTo(dest);
            return true;
        } catch (IllegalStateException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>TestController(进行测试)</p>
<pre><code>@Controller
public class TestController {

    private final ResourceLoader resourceLoader;

    @Value(&quot;${web.upload-path}&quot;)
    private String path;

    @Autowired
    public TestController(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    /**
     * 跳转到文件上传页面
     * @return
     */
    @RequestMapping(&quot;test&quot;)
    public String toUpload(){
        return &quot;freemarker/test&quot;;
    }

    /**
     *
     * @param file 要上传的文件
     * @return
     */
    @RequestMapping(&quot;fileUpload&quot;)
    public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){

        // 要上传的目标文件存放路径
//        String localPath = &quot;/src/main/resources/static/photos&quot;;
        // 上传成功或者失败的提示
        String msg = &quot;&quot;;

        if (FileUtils.upload(file, path, file.getOriginalFilename())){
            // 上传成功，给出页面提示
            msg = &quot;上传成功！&quot;;
        }else {
            msg = &quot;上传失败！&quot;;

        }

        // 显示图片
        map.put(&quot;msg&quot;, msg);
        map.put(&quot;fileName&quot;, file.getOriginalFilename());
        return &quot;forward:/test&quot;;
    }

    /**
     * 显示单张图片
     * @return
     */
    @RequestMapping(&quot;show&quot;)
    public ResponseEntity showPhotos(String fileName){
        try {
            // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径
//            System.out.println(fileName);
            return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName));
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }

    @RequestMapping(&quot;batch&quot;)
    public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) {
        List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;);
        MultipartFile file = null;
        BufferedOutputStream stream = null;
        String msg = &quot;&quot;;
        for (int i = 0; i &lt; files.size(); ++i) {
            file = files.get(i);
            if (!file.isEmpty()) {
                try {
                    byte[] bytes = file.getBytes();
                    stream = new BufferedOutputStream(new FileOutputStream(
                            new File(path + file.getOriginalFilename())));//设置文件路径及名字
                    stream.write(bytes);// 写入
                    stream.close();
                } catch (Exception e) {
                    stream = null;
                    msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot;
                            + e.getMessage();
                }
            } else {
                msg= &quot;第 &quot; + i
                        + &quot; 个文件上传失败因为文件为空&quot;;
            }
        }
        msg= &quot;上传成功&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }

    @RequestMapping(&quot;/download&quot;)
    public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) {
        String msg = &quot;&quot;;
        if (fileName != null) {
            //设置文件路径
            File file = new File(path+fileName);
            //File file = new File(realPath , fileName);
            if (file.exists()) {
                response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开
                response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名
                byte[] buffer = new byte[1024];
                FileInputStream fis = null;
                BufferedInputStream bis = null;
                try {
                    fis = new FileInputStream(file);
                    bis = new BufferedInputStream(fis);
                    OutputStream os = response.getOutputStream();
                    int i = bis.read(buffer);
                    while (i != -1) {
                        os.write(buffer, 0, i);
                        i = bis.read(buffer);
                    }
                    msg = &quot;下载成功&quot;;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    if (bis != null) {
                        try {
                            bis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (fis != null) {
                        try {
                            fis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        msg =  &quot;下载失败&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }
}
</code></pre>
<p>test.ytl (简易freemarker测试模板)</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;图片上传Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 &gt;图片上传Demo&lt;/h1&gt;
&lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;#--判断是否上传文件--&gt;
&lt;#if msg??&gt;
    &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt;
&lt;#else &gt;
    &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt;
&lt;/#if&gt;
&lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt;
&lt;#if fileName??&gt;
    &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt;
&lt;#else&gt;
    &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt;
&lt;/#if&gt;

&lt;hr/&gt;
&lt;p&gt;多文件上传&lt;/p&gt;
&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt;
    &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;hr/&gt;
&lt;p&gt;文件下载&lt;/p&gt;
&lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-7.快速上手redis]]></title>
        <id>https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/</id>
        <link href="https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/">
        </link>
        <updated>2021-04-16T07:32:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-7快速上手redis">springboot-7.快速上手redis</h2>
<h2 id="前言">前言</h2>
<p>为什么需要Redis?<br>
在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。<br>
为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p>
<p><strong>Redis在java web中的应用场景</strong></p>
<ul>
<li>
<p>存储 缓存用的数据；</p>
</li>
<li>
<p>需要高速读/写的场合使用它快速读/写；</p>
<p>Redis作为缓存的读取逻辑<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWxz5t.jpg" alt="cWxz5t.jpg" loading="lazy"></p>
</li>
</ul>
<h2 id="下载安装redis">下载安装redis</h2>
<p>下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads<br>
选择最新版下载一个即可，下载完后解压便可使用。<br>
为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件：</p>
<pre><code>redis-server redis.windows.conf
</code></pre>
<p>这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动：</p>
<h2 id="下载安装redis可视化工具-redisdesktopmanager">下载安装redis可视化工具 RedisDesktopManager</h2>
<h2 id="springboot配置使用redis">springboot配置使用redis</h2>
<p>（1）在pom文件中添加依赖项</p>
<pre><code class="language-java">        &lt;!-- Redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2) 编写application.yml</p>
<pre><code class="language-yml">spring:
  # redis
  redis:
    host: 127.0.0.1
    port: 6379
    timeout: 3000 #连接超时
    password:
    minIdle: 1   #连接池中的最小空闲连接
    maxIdle: 10
    maxWait: 3  #连接池中的最大阻塞等待时间
    maxActive: 8   #连接池最大连接数
</code></pre>
<p>(3)新建文件夹和文件，如下所示：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWzK2T.png" alt="cWzK2T.png" loading="lazy"></p>
<p>(4)Reidis配置文件-RedisConfig.java</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.*;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;


@Configuration
@EnableCaching //开启注解
public class RedisConfig extends CachingConfigurerSupport {

    /**
     * retemplate相关配置
     * @param factory
     * @return
     */
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {

        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        // 配置连接工厂
        template.setConnectionFactory(factory);

        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）
        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper om = new ObjectMapper();
        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jacksonSeial.setObjectMapper(om);

        // 值采用json序列化
        template.setValueSerializer(jacksonSeial);
        //使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());

        // 设置hash key 和value序列化模式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jacksonSeial);
        template.afterPropertiesSet();

        return template;
    }

    /**
     * 对hash类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForHash();
    }

    /**
     * 对redis字符串类型数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForValue();
    }

    /**
     * 对链表类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForList();
    }

    /**
     * 对无序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForSet();
    }

    /**
     * 对有序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForZSet();
    }
}
</code></pre>
<p><strong>(5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java）</strong></p>
<p>为了测试方便，只放入了get和set方法。</p>
<pre><code class="language-java">@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>(6)在controller文件中进行测试</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {
    @Resource
    private RedisUtil redisUtil;
    
    @RequestMapping(&quot;/setRedis&quot;)
    public boolean redisSet()
    {
        return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;);
    }
    @RequestMapping(&quot;/getRedis&quot;)
    public String redisGet()
    {
        return redisUtil.get(&quot;username&quot;).toString();
    }
}
</code></pre>
<p>(7)预览</p>
<p>ps:记得开启redis（通过startup.cmd）</p>
<p>访问 http://localhost:8080/user/setRedis<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWzsZd.png" alt="cWzsZd.png" loading="lazy"><br>
返回true说明缓存存储成功，使用工具查看<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWzWz8.png" alt="cWzWz8.png" loading="lazy"><br>
获取缓存存取的值<br>
访问 http://localhost:8080/user/getRedis<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWzqJ0.png" alt="cWzqJ0.png" loading="lazy"><br>
以上便是redis的基本使用</p>
<h2 id="redisutiljava工具类">redisUtil.java工具类</h2>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * redisTemplate封装
 *
 *  @author yinxp@dist.com.cn
 */
@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 指定缓存失效时间
     * @param key 键
     * @param time 时间(秒)
     * @return
     */
    public boolean expire(String key,long time){
        try {
            if(time&gt;0){
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key){
        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key){
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void del(String ... key){
        if(key!=null&amp;&amp;key.length&gt;0){
            if(key.length==1){
                redisTemplate.delete(key[0]);
            }else{
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 普通缓存放入并设置时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key,Object value,long time){
        try {
            if(time&gt;0){
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            }else{
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     * @param key 键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     * @param key 键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    //================================Map=================================
    /**
     * HashGet
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return 值
     */
    public Object hget(String key,String item){
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object,Object&gt; hmget(String key){
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     * @param key 键
     * @param map 对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value,long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     * @param key 键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item){
        redisTemplate.opsForHash().delete(key,item);
    }

    /**
     * 判断hash表中是否有该项的值
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item){
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     * @param key 键
     * @param item 项
     * @param by 要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     * @param key 键
     * @param item 项
     * @param by 要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item,-by);
    }

    //============================set=============================
    /**
     * 根据key获取Set中的所有值
     * @param key 键
     * @return
     */
    public Set&lt;Object&gt; sGet(String key){
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     * @param key 键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key,Object value){
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     * @param key 键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object...values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     * @param key 键
     * @param time 时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key,long time,Object...values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if(time&gt;0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     * @param key 键
     * @return
     */
    public long sGetSetSize(String key){
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     * @param key 键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public long setRemove(String key, Object ...values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    //===============================list=================================

    /**
     * 获取list缓存的内容
     * @param key 键
     * @param start 开始
     * @param end 结束  0 到 -1代表所有值
     * @return
     */
    public List&lt;Object&gt; lGet(String key, long start, long end){
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     * @param key 键
     * @return
     */
    public long lGetListSize(String key){
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     * @param key 键
     * @param index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key,long index){
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     * @param key 键
     * @param index 索引
     * @param value 值
     * @return
     */
    public boolean lUpdateIndex(String key, long index,Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     * @param key 键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public long lRemove(String key,long count,Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 模糊查询获取key值
     * @param pattern
     * @return
     */
    public Set keys(String pattern){
        return redisTemplate.keys(pattern);
    }

    /**
     * 使用Redis的消息队列
     * @param channel
     * @param message 消息内容
     */
    public void convertAndSend(String channel, Object message){
        redisTemplate.convertAndSend(channel,message);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-6.整合Mybatis]]></title>
        <id>https://kangjn.github.io/post/springboot-6zheng-he-mybatis/</id>
        <link href="https://kangjn.github.io/post/springboot-6zheng-he-mybatis/">
        </link>
        <updated>2021-04-16T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-6整合mybatis">springboot-6.整合Mybatis</h2>
<h2 id="一-解析java框架中entity层mapper层service层各层作用">一 .解析Java框架中entity层，mapper层，service层各层作用</h2>
<p>（1）entity层<br>
别名： model层 ，domain层。<br>
用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应<br>
简单例子：user表的实体User</p>
<pre><code>public class User {
    private int id;//id
    private String username;//用户名
    //……省略set,get方法
}
</code></pre>
<p>（2）mapper层<br>
别名： dao层<br>
用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作<br>
简单例子：</p>
<pre><code>@Mapper
public interface UserMapper {
    public User selectUserById(int id);
}
</code></pre>
<p>(3) service层<br>
业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。<br>
封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。<br>
作用：为controller层的类提供接口进行调用。<br>
简单例子：</p>
<pre><code>public interface UserService extends Service&lt;User&gt; {

}
</code></pre>
<h2 id="二快速使用">二.快速使用</h2>
<p>（1）添加依赖项</p>
<pre><code> &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--通用mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.5&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--druid数据源--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.18&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>（2）配置application.yml</p>
<pre><code>spring:
  #数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
    username: root
    password: ******
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    connectionProperties: druid.stat.mergeSql=true

#为mybatis配置，生产环境可删除
restart:
  include:
    mapper: /mapper-[\\w-\\.]+jar
    pagehelper: /pagehelper-[\\w-\\.]+jar

pagehelper:
  auto-dialect: msyql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
</code></pre>
<p>(3)编写User.java【entity层】</p>
<pre><code>public class User {
    private String id;
    private String username;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}
</code></pre>
<p>(4)编写UserMapper.java(dao层)</p>
<pre><code>@Mapper
public interface UserMapper {
    @Select(&quot;select * from user where id = #{id}&quot;)
    public User selectUserById(int id);

    @Select(&quot;select * from user where username = #{username}&quot;)
    public List&lt;User&gt; selectUserByName(String userName);

    @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;)
    public void addUser(User user);

    @Update(&quot;update user set username=#{username} where id=#{id}&quot;)
    public void updateUser(User user);

    @Delete(&quot;delete from user where id=#{id}&quot;)
    public void deleteUser(int id);
}
</code></pre>
<p>(5)编写userController.java</p>
<pre><code>@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {

    @Autowired
    UserMapper userMapper;

    @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET)
    public User selectUserById(String id){
        User user = userMapper.selectUserById(Integer.parseInt(id));
        return user;
    }

    @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET)
    public List&lt;User&gt; selectUserByName(String userName){
        return userMapper.selectUserByName(userName);
    }

    @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST)
    public void addUser(User user){
        userMapper.addUser(user);
    }

    @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST)
    public void updateUser(User user){
        userMapper.updateUser(user);
    }

    @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST)
    public void deleteUser(String id){
        userMapper.deleteUser(Integer.parseInt(id));
    }
}
</code></pre>
<p>此时便已经全部配置结束<br>
为了方便测试，忽略了service层，直接调用了mapper层</p>
<p>（6）测试<br>
1.<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW7Rnx.png" alt="cW7Rnx.png" loading="lazy"></p>
<ol start="2">
<li></li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW74AO.png" alt="cW74AO.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-5.全局异常捕获]]></title>
        <id>https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/</id>
        <link href="https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/">
        </link>
        <updated>2021-04-16T06:23:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-5全局异常捕获">springboot-5.全局异常捕获</h2>
<p>在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。</p>
<p>1 浏览器访问异常时：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW5TOK.png" alt="cW5TOK.png" loading="lazy"></p>
<p>2.postman访问异常时：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW5qTe.png" alt="cW5qTe.png" loading="lazy"></p>
<p>显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。</p>
<h2 id="正文">正文</h2>
<p><strong>1.自定义基础接口类+自定义枚举类</strong></p>
<pre><code>public interface BaseErrorInfoInterface {
    /** 错误码*/
    String getResultCode();

    /** 错误描述*/
    String getResultMsg();

    public enum CommonEnum implements BaseErrorInfoInterface {
        // 数据操作错误定义
        SUCCESS(&quot;200&quot;, &quot;成功!&quot;),
        BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;),
        SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;),
        NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;),
        INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;),
        SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;)
        ;

        /** 错误码 */
        private String resultCode;

        /** 错误描述 */
        private String resultMsg;

        CommonEnum(String resultCode, String resultMsg) {
            this.resultCode = resultCode;
            this.resultMsg = resultMsg;
        }

        @Override
        public String getResultCode() {
            return resultCode;
        }

        @Override
        public String getResultMsg() {
            return resultMsg;
        }
    }
}
</code></pre>
<p><strong>2.自定义异常类</strong></p>
<pre><code>public class BizException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * 错误码
     */
    protected String errorCode;
    /**
     * 错误信息
     */
    protected String errorMsg;

    public BizException() {
        super();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface) {
        super(errorInfoInterface.getResultCode());
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) {
        super(errorInfoInterface.getResultCode(), cause);
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(String errorMsg) {
        super(errorMsg);
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg) {
        super(errorCode);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg, Throwable cause) {
        super(errorCode, cause);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }


    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getMessage() {
        return errorMsg;
    }

    @Override
    public Throwable fillInStackTrace() {
        return this;
    }
}
</code></pre>
<p><strong>3.自定义数据格式</strong></p>
<pre><code>public class ResultBody {
    /**
     * 响应代码
     */
    private String code;

    /**
     * 响应消息
     */
    private String message;

    /**
     * 响应结果
     */
    private Object result;

    public ResultBody() {
    }

    public ResultBody(BaseErrorInfoInterface errorInfo) {
        this.code = errorInfo.getResultCode();
        this.message = errorInfo.getResultMsg();
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getResult() {
        return result;
    }

    public void setResult(Object result) {
        this.result = result;
    }

    /**
     * 成功
     * 
     * @return
     */
    public static ResultBody success() {
        return success(null);
    }

    /**
     * 成功
     * @param data
     * @return
     */
    public static ResultBody success(Object data) {
        ResultBody rb = new ResultBody();
        rb.setCode(CommonEnum.SUCCESS.getResultCode());
        rb.setMessage(CommonEnum.SUCCESS.getResultMsg());
        rb.setResult(data);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(BaseErrorInfoInterface errorInfo) {
        ResultBody rb = new ResultBody();
        rb.setCode(errorInfo.getResultCode());
        rb.setMessage(errorInfo.getResultMsg());
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(String code, String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(code);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error( String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(&quot;-1&quot;);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    @Override
    public String toString() {
        return JSONObject.toJSONString(this);
    }
}
</code></pre>
<p><strong>4.自定义全局异常处理类</strong></p>
<pre><code>@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    public static final String Demo_View =  &quot;error&quot;;
    /**
     * 处理自定义的业务异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value = BizException.class)
    public  Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,e.getErrorCode());
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    /**
     * 处理空指针的异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =NullPointerException.class)
    @ResponseBody
    public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){
        logger.error(&quot;发生空指针异常！原因是:&quot;,e);
        return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH);
    }


    /**
     * 处理其他异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =Exception.class)
    public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR);
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    //判断是否是ajax请求
    public static boolean isAjax(HttpServletRequest httpRequest)
    {
        return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null
                &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString()));
    }
}
</code></pre>
<p><strong>5.编写前端异常显示页面</strong><br>
ps:名称对应步骤4里的String Demo_View<br>
为了测试，快速建立一个html</p>
<pre><code>&lt;!doctype html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>此时全局异常捕获已经建立完毕，接下来进行测试</p>
<h2 id="测试">测试</h2>
<p>1.web页面跳转</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        int a = 1 / 0; //除以0，产生异常
        return &quot;error&quot;;
    }
}
</code></pre>
<p>此时访问web页面：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWo0K0.png" alt="cWo0K0.png" loading="lazy"></p>
<p>2.ajax形式跳转<br>
更改controller文件</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;&quot;)
    public String err()
    {
        return &quot;thymeleaf/ajaxerror&quot;;
    }
    @RequestMapping(&quot;getAjaxError&quot;)
    public jsonResult ajaxError()
    {
        int a = 1/0;
        return jsonResult.ok(200);
    }
}
</code></pre>
<p>新建一个ajaxerror.html文件于thymeleaf文件夹下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax测试&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt;
&lt;/body&gt;
&lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个ajax.js文件编写ajax请求</p>
<pre><code>$(&quot;#test&quot;).click(function() {
    $.ajax({
        url: &quot;/err/getAjaxError&quot;,
        type: &quot;POST&quot;,
        async: false,
        success: function (data) {
            if (data.status == 200 &amp;&amp; data.msg == 'OK') {
                alert(&quot;success&quot;);
            } else {
                alert(&quot;发生异常&quot; + data.msg);
            }
        },
        error: function (response, ajaxOption, thrownError) {
            alert(&quot;error&quot;);
        }
    });
});
</code></pre>
<p>记得在application文件夹添加静态文件路径配置</p>
<pre><code>  mvc:
    static-path-pattern: /static/**
</code></pre>
<p>此时访问<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWoDbT.png" alt="cWoDbT.png" loading="lazy"><br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWoR2R.png" alt="cWoR2R.png" loading="lazy"></p>
<p>3.测试自定义异常<br>
新建一个controller文件</p>
<pre><code>@Controller
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {
    @RequestMapping(&quot;&quot;)
    public String api(ModelMap map)
    {
        User u = new User();
        map.addAttribute(&quot;user&quot;,u);
        return &quot;thymeleaf/api&quot;;
    }

    @PostMapping(&quot;/user&quot;)
    public boolean insert(User user) {
        System.out.println(&quot;开始新增...&quot;);
        //如果姓名为空就手动抛出一个自定义的异常！
        if (user.getUsername() == null) {
            throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;);
        }
        return true;
    }
}
</code></pre>
<p>新建一个api.html文件</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>访问<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cWoxqf.png" alt="cWoxqf.png" loading="lazy"></p>
<p>3.测试自定义异常</p>
<pre><code>    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;);
    }
</code></pre>
<h2 id="尾言">尾言</h2>
<p>按照步骤添加即可完成操作~<br>
User类自行添加或者浏览前文即可。</p>
<h2 id="其他">其他</h2>
<p>1.SpringBoot异常处理-自定义错误页面</p>
<p><strong>(1) 在Spring Boot中一共提供了几种处理异常的方式？</strong></p>
<p>SpringBoot 中对于异常处理提供了五种处理方式：</p>
<p>自定义错误页面；</p>
<p>@ExceptionHandle 注解处理异常；</p>
<p>@ControllerAdvice+@ExceptionHandler 注解处理异常；</p>
<p>配置 SimpleMappingExceptionResolver 处理异常；</p>
<p>自定义 HandlerExceptionResolver 类处理异常</p>
<p><strong>(2) 什么是自定义错误页面方式？</strong></p>
<p>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常  SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫  BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。</p>
<p><strong>(3) 自义定错误页面应该放到项目的什么位置？</strong></p>
<p>放在一般网页资源存放的位置 即src/main/resources/templates</p>
<p>2.SpringBoot异常处理-@ControlleAdvice</p>
<p><strong>(1) @ControllerAdvice注解的作用是什么？</strong></p>
<p>需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。</p>
<p><strong>(2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？</strong></p>
<p>是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-4.模板引擎]]></title>
        <id>https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/</id>
        <link href="https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/">
        </link>
        <updated>2021-04-16T06:15:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-4模板引擎">springboot-4.模板引擎</h2>
<h2 id="前言">前言</h2>
<p>关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。</p>
<h2 id="freemarker">freemarker</h2>
<p>(1)在pom文件中添加依赖项</p>
<pre><code>        &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加freemarker相关配置</p>
<pre><code>spring:
  http:
    encoding:
      force: true
      charset: UTF-8
  freemarker:
    allow-request-override: false
    cache: false
    check-template-location: true
    charset: UTF-8
    content-type: text/html; charset=utf-8
    expose-request-attributes: false
    expose-session-attributes: false
    expose-spring-macro-helpers: false
    suffix: .ftl
    template-loader-path: classpath:/templates
</code></pre>
<p>(3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl<br>
文件树结构：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW4luT.png" alt="cW4luT.png" loading="lazy"><br>
快速创建一个网页模板进行测试，内容如下：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;${host}&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ps：其中host的值通过后台读取。</p>
<p>（4）在controller文件夹下新建一个freemarkerController.java文件</p>
<pre><code>@Controller
   public class freemarkerController {
        @RequestMapping(&quot;/&quot;)
        public String index(ModelMap map) {
            map.addAttribute(&quot;host&quot;,&quot;ericam&quot;);
            return &quot;freemarker/center&quot;;
        }
   }
</code></pre>
<p>ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl）<br>
(5)预览<br>
此时打开浏览器可以看到如下内容：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW4dv6.png" alt="cW4dv6.png" loading="lazy"></p>
<p>接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf）</p>
<h2 id="thymeleaf">Thymeleaf</h2>
<h3 id="一-快速入门使用">一. 快速入门使用</h3>
<p>（1）在pom文件夹添加项目依赖</p>
<pre><code>            &lt;!-- ThymeLeaf 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加themeleaf相关配置</p>
<pre><code>spring:
    thymeleaf:
        cache: false # 开发时关闭缓存,不然没法看到实时页面
        mode: HTML # 用非严格的 HTML
        encoding: UTF-8
        servlet:
        content-type: text/html
</code></pre>
<p>(3)<br>
在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html<br>
文件树：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master" alt="cW428I.png" loading="lazy"><br>
新建一个User.java文件<br>
文件树：<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW4WxP.png" alt="cW4WxP.png" loading="lazy"><br>
(4)编写User.java文件<br>
为了方便测试，用户具备如下属性：</p>
<ul>
<li>id</li>
<li>用户名</li>
<li>年龄</li>
<li>创建时间</li>
<li>用户简介</li>
</ul>
<pre><code>public class User {
    private String id;
    private int age;
    private String username;
    private Date createTime;
    private String desc;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
//请读者自行补充 构造器和 get/set方法..

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }
}
</code></pre>
<p>(5)新建一个themeleafController.java进行测试</p>
<pre><code>@Controller
public class themeleafController {
    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);   //这里的user对应html里的user
        return &quot;thymeleaf/test&quot;;
    }
}
</code></pre>
<p>(6)最后我们进行编写test.html文件</p>
<pre><code>&lt;div&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt;
    &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。<br>
(7)预览<br>
<img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW475j.png" alt="cW475j.png" loading="lazy"></p>
<h3 id="二thymeleaf常用标签-方法">二.Thymeleaf常用标签-方法</h3>
<p>（1）上述test.html的等同写法</p>
<pre><code>&lt;div th:object=&quot;${user}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>这样可以简化内容，使用更加广泛。</p>
<p>（2）表单的提交<br>
我们在test.html里添加如下内容</p>
<pre><code>&lt;div&gt;
    &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt;
        &lt;input type=&quot;submit&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username<br>
接着在themeleafController添加如下内容</p>
<pre><code>    @PostMapping(&quot;/postform&quot;)
    public String postform(User u)  //前端传入了一个User对象
    {
        System.out.println(u.getUsername());
        return &quot;redirect:/test&quot;;   //重定向（等于转向/test地址
    }
</code></pre>
<p>（3）th:if标签</p>
<pre><code>&lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt;
</code></pre>
<p>利用if判断变量是否为空，非空时显示</p>
<pre><code class="language-html">&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>if / else 的实现</p>
<pre><code>&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
&lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>(4)th:selected标签</p>
<pre><code>&lt;select&gt;
    &lt;option &gt;选择框&lt;/option&gt;
    &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>(5)table表单</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;年龄&lt;/th&gt;
        &lt;th&gt;创建时间&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;person:${userlist}&quot;&gt;
        &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>在这里我们需要修改下themeleafController文件，为其添加一个userlist。</p>
<pre><code>    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);
        List&lt;User&gt; userlist = new ArrayList&lt;&gt;();  //添加一个userlist
        userlist.add(u);
        u = new User();
        u.setId(&quot;234&quot;);
        u.setUsername(&quot;ericam&quot;);
        u.setCreateTime(new Date(2020-1900,5-1,12));
        u.setAge(3);
        userlist.add(u);
        map.addAttribute(&quot;userlist&quot;,userlist);
        return &quot;thymeleaf/test&quot;;
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/kangjun/MyBlogImage/raw/master/cW4jMV.png" alt="cW4jMV.png" loading="lazy"></figure>
<p>(6)th:switch</p>
<pre><code>&lt;div th:switch=&quot;${user.username}&quot;&gt;
    &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>备注：常用标签的效果可以自行去测试</p>
]]></content>
    </entry>
</feed>