<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kangjn.github.io/</id>
    <title>MyBlog</title>
    <updated>2021-04-16T07:35:39.115Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kangjn.github.io/"/>
    <link rel="self" href="https://kangjn.github.io/atom.xml"/>
    <subtitle>我的博客</subtitle>
    <logo>https://kangjn.github.io/images/avatar.png</logo>
    <icon>https://kangjn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, MyBlog</rights>
    <entry>
        <title type="html"><![CDATA[springboot-文件上传/下载]]></title>
        <id>https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/</id>
        <link href="https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/">
        </link>
        <updated>2021-04-16T07:34:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-文件上传下载">springboot-文件上传/下载</h2>
<h2 id="代码">代码</h2>
<p>application.yml</p>
<pre><code>spring:
  servlet:
    multipart:
      max-file-size: 50MB  #上传文件最大大小
      max-request-size: 50MB  #单次请求最大大小

# 自定义文件上传路径
web:
  upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/
</code></pre>
<p><strong>ps : 路径中不能包含中文，不然无法读取</strong></p>
<p>FileUtils (文件上传工具类)</p>
<pre><code>package cn.justcoding.util;

import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

/**
 * 文件上传工具包
 */
public class FileUtils {

    /**
     *
     * @param file 文件
     * @param path 文件存放路径
     * @param fileName 源文件名
     * @return
     */
    public static boolean upload(MultipartFile file, String path, String fileName){

        //使用原文件名
        String realPath = path + &quot;/&quot; +fileName;

        File dest = new File(realPath);

        //判断文件父目录是否存在
        if(!dest.getParentFile().exists()){
            dest.getParentFile().mkdir();
        }

        try {
            //保存文件
            file.transferTo(dest);
            return true;
        } catch (IllegalStateException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>TestController(进行测试)</p>
<pre><code>@Controller
public class TestController {

    private final ResourceLoader resourceLoader;

    @Value(&quot;${web.upload-path}&quot;)
    private String path;

    @Autowired
    public TestController(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    /**
     * 跳转到文件上传页面
     * @return
     */
    @RequestMapping(&quot;test&quot;)
    public String toUpload(){
        return &quot;freemarker/test&quot;;
    }

    /**
     *
     * @param file 要上传的文件
     * @return
     */
    @RequestMapping(&quot;fileUpload&quot;)
    public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){

        // 要上传的目标文件存放路径
//        String localPath = &quot;/src/main/resources/static/photos&quot;;
        // 上传成功或者失败的提示
        String msg = &quot;&quot;;

        if (FileUtils.upload(file, path, file.getOriginalFilename())){
            // 上传成功，给出页面提示
            msg = &quot;上传成功！&quot;;
        }else {
            msg = &quot;上传失败！&quot;;

        }

        // 显示图片
        map.put(&quot;msg&quot;, msg);
        map.put(&quot;fileName&quot;, file.getOriginalFilename());
        return &quot;forward:/test&quot;;
    }

    /**
     * 显示单张图片
     * @return
     */
    @RequestMapping(&quot;show&quot;)
    public ResponseEntity showPhotos(String fileName){
        try {
            // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径
//            System.out.println(fileName);
            return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName));
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }

    @RequestMapping(&quot;batch&quot;)
    public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) {
        List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;);
        MultipartFile file = null;
        BufferedOutputStream stream = null;
        String msg = &quot;&quot;;
        for (int i = 0; i &lt; files.size(); ++i) {
            file = files.get(i);
            if (!file.isEmpty()) {
                try {
                    byte[] bytes = file.getBytes();
                    stream = new BufferedOutputStream(new FileOutputStream(
                            new File(path + file.getOriginalFilename())));//设置文件路径及名字
                    stream.write(bytes);// 写入
                    stream.close();
                } catch (Exception e) {
                    stream = null;
                    msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot;
                            + e.getMessage();
                }
            } else {
                msg= &quot;第 &quot; + i
                        + &quot; 个文件上传失败因为文件为空&quot;;
            }
        }
        msg= &quot;上传成功&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }

    @RequestMapping(&quot;/download&quot;)
    public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) {
        String msg = &quot;&quot;;
        if (fileName != null) {
            //设置文件路径
            File file = new File(path+fileName);
            //File file = new File(realPath , fileName);
            if (file.exists()) {
                response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开
                response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名
                byte[] buffer = new byte[1024];
                FileInputStream fis = null;
                BufferedInputStream bis = null;
                try {
                    fis = new FileInputStream(file);
                    bis = new BufferedInputStream(fis);
                    OutputStream os = response.getOutputStream();
                    int i = bis.read(buffer);
                    while (i != -1) {
                        os.write(buffer, 0, i);
                        i = bis.read(buffer);
                    }
                    msg = &quot;下载成功&quot;;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    if (bis != null) {
                        try {
                            bis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (fis != null) {
                        try {
                            fis.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        msg =  &quot;下载失败&quot;;
        map.put(&quot;msg&quot;, msg);
        return &quot;forward:/test&quot;;
    }
}
</code></pre>
<p>test.ytl (简易freemarker测试模板)</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;图片上传Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 &gt;图片上传Demo&lt;/h1&gt;
&lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;#--判断是否上传文件--&gt;
&lt;#if msg??&gt;
    &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt;
&lt;#else &gt;
    &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt;
&lt;/#if&gt;
&lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt;
&lt;#if fileName??&gt;
    &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt;
&lt;#else&gt;
    &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt;
&lt;/#if&gt;

&lt;hr/&gt;
&lt;p&gt;多文件上传&lt;/p&gt;
&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt;
    &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;hr/&gt;
&lt;p&gt;文件下载&lt;/p&gt;
&lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-7.快速上手redis]]></title>
        <id>https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/</id>
        <link href="https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/">
        </link>
        <updated>2021-04-16T07:32:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-7快速上手redis">springboot-7.快速上手redis</h2>
<h2 id="前言">前言</h2>
<p>为什么需要Redis?<br>
在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。<br>
为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。</p>
<p><strong>Redis在java web中的应用场景</strong></p>
<ul>
<li>
<p>存储 缓存用的数据；</p>
</li>
<li>
<p>需要高速读/写的场合使用它快速读/写；</p>
<p>Redis作为缓存的读取逻辑<br>
<a href="https://imgtu.com/i/cWxz5t"><img src="https://z3.ax1x.com/2021/04/16/cWxz5t.jpg" alt="cWxz5t.jpg" loading="lazy"></a></p>
</li>
</ul>
<h2 id="下载安装redis">下载安装redis</h2>
<p>下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads<br>
选择最新版下载一个即可，下载完后解压便可使用。<br>
为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件：</p>
<pre><code>redis-server redis.windows.conf
</code></pre>
<p>这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动：</p>
<h2 id="下载安装redis可视化工具-redisdesktopmanager">下载安装redis可视化工具 RedisDesktopManager</h2>
<h2 id="springboot配置使用redis">springboot配置使用redis</h2>
<p>（1）在pom文件中添加依赖项</p>
<pre><code class="language-java">        &lt;!-- Redis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2) 编写application.yml</p>
<pre><code class="language-yml">spring:
  # redis
  redis:
    host: 127.0.0.1
    port: 6379
    timeout: 3000 #连接超时
    password:
    minIdle: 1   #连接池中的最小空闲连接
    maxIdle: 10
    maxWait: 3  #连接池中的最大阻塞等待时间
    maxActive: 8   #连接池最大连接数
</code></pre>
<p>(3)新建文件夹和文件，如下所示：<br>
<a href="https://imgtu.com/i/cWzK2T"><img src="https://z3.ax1x.com/2021/04/16/cWzK2T.png" alt="cWzK2T.png" loading="lazy"></a></p>
<p>(4)Reidis配置文件-RedisConfig.java</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.*;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;


@Configuration
@EnableCaching //开启注解
public class RedisConfig extends CachingConfigurerSupport {

    /**
     * retemplate相关配置
     * @param factory
     * @return
     */
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {

        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        // 配置连接工厂
        template.setConnectionFactory(factory);

        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）
        Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper om = new ObjectMapper();
        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jacksonSeial.setObjectMapper(om);

        // 值采用json序列化
        template.setValueSerializer(jacksonSeial);
        //使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());

        // 设置hash key 和value序列化模式
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jacksonSeial);
        template.afterPropertiesSet();

        return template;
    }

    /**
     * 对hash类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForHash();
    }

    /**
     * 对redis字符串类型数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForValue();
    }

    /**
     * 对链表类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForList();
    }

    /**
     * 对无序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForSet();
    }

    /**
     * 对有序集合类型的数据操作
     *
     * @param redisTemplate
     * @return
     */
    @Bean
    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        return redisTemplate.opsForZSet();
    }
}
</code></pre>
<p><strong>(5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java）</strong></p>
<p>为了测试方便，只放入了get和set方法。</p>
<pre><code class="language-java">@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
}
</code></pre>
<p>(6)在controller文件中进行测试</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {
    @Resource
    private RedisUtil redisUtil;
    
    @RequestMapping(&quot;/setRedis&quot;)
    public boolean redisSet()
    {
        return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;);
    }
    @RequestMapping(&quot;/getRedis&quot;)
    public String redisGet()
    {
        return redisUtil.get(&quot;username&quot;).toString();
    }
}
</code></pre>
<p>(7)预览</p>
<p>ps:记得开启redis（通过startup.cmd）</p>
<p>访问 http://localhost:8080/user/setRedis<br>
<a href="https://imgtu.com/i/cWzsZd"><img src="https://z3.ax1x.com/2021/04/16/cWzsZd.png" alt="cWzsZd.png" loading="lazy"></a><br>
返回true说明缓存存储成功，使用工具查看<br>
<a href="https://imgtu.com/i/cWzWz8"><img src="https://z3.ax1x.com/2021/04/16/cWzWz8.png" alt="cWzWz8.png" loading="lazy"></a><br>
获取缓存存取的值<br>
访问 http://localhost:8080/user/getRedis<br>
<a href="https://imgtu.com/i/cWzqJ0"><img src="https://z3.ax1x.com/2021/04/16/cWzqJ0.png" alt="cWzqJ0.png" loading="lazy"></a><br>
以上便是redis的基本使用</p>
<h2 id="redisutiljava工具类">redisUtil.java工具类</h2>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * redisTemplate封装
 *
 *  @author yinxp@dist.com.cn
 */
@Component
public class RedisUtil {

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    /**
     * 指定缓存失效时间
     * @param key 键
     * @param time 时间(秒)
     * @return
     */
    public boolean expire(String key,long time){
        try {
            if(time&gt;0){
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key){
        return redisTemplate.getExpire(key,TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key){
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void del(String ... key){
        if(key!=null&amp;&amp;key.length&gt;0){
            if(key.length==1){
                redisTemplate.delete(key[0]);
            }else{
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    //============================String=============================
    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key){
        return key==null?null:redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key 键
     * @param value 值
     * @return true成功 false失败
     */
    public boolean set(String key,Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 普通缓存放入并设置时间
     * @param key 键
     * @param value 值
     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key,Object value,long time){
        try {
            if(time&gt;0){
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            }else{
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     * @param key 键
     * @param delta 要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递增因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     * @param key 键
     * @param delta 要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta){
        if(delta&lt;0){
            throw new RuntimeException(&quot;递减因子必须大于0&quot;);
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    //================================Map=================================
    /**
     * HashGet
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return 值
     */
    public Object hget(String key,String item){
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object,Object&gt; hmget(String key){
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     * @param key 键
     * @param map 对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     * @param key 键
     * @param item 项
     * @param value 值
     * @param time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key,String item,Object value,long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if(time&gt;0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     * @param key 键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item){
        redisTemplate.opsForHash().delete(key,item);
    }

    /**
     * 判断hash表中是否有该项的值
     * @param key 键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item){
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     * @param key 键
     * @param item 项
     * @param by 要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     * @param key 键
     * @param item 项
     * @param by 要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item,double by){
        return redisTemplate.opsForHash().increment(key, item,-by);
    }

    //============================set=============================
    /**
     * 根据key获取Set中的所有值
     * @param key 键
     * @return
     */
    public Set&lt;Object&gt; sGet(String key){
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     * @param key 键
     * @param value 值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key,Object value){
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     * @param key 键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object...values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     * @param key 键
     * @param time 时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key,long time,Object...values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if(time&gt;0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     * @param key 键
     * @return
     */
    public long sGetSetSize(String key){
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     * @param key 键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public long setRemove(String key, Object ...values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    //===============================list=================================

    /**
     * 获取list缓存的内容
     * @param key 键
     * @param start 开始
     * @param end 结束  0 到 -1代表所有值
     * @return
     */
    public List&lt;Object&gt; lGet(String key, long start, long end){
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     * @param key 键
     * @return
     */
    public long lGetListSize(String key){
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     * @param key 键
     * @param index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key,long index){
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     * @param key 键
     * @param value 值
     * @param time 时间(秒)
     * @return
     */
    public boolean lSet(String key, List&lt;Object&gt; value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time &gt; 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     * @param key 键
     * @param index 索引
     * @param value 值
     * @return
     */
    public boolean lUpdateIndex(String key, long index,Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     * @param key 键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public long lRemove(String key,long count,Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 模糊查询获取key值
     * @param pattern
     * @return
     */
    public Set keys(String pattern){
        return redisTemplate.keys(pattern);
    }

    /**
     * 使用Redis的消息队列
     * @param channel
     * @param message 消息内容
     */
    public void convertAndSend(String channel, Object message){
        redisTemplate.convertAndSend(channel,message);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-6.整合Mybatis]]></title>
        <id>https://kangjn.github.io/post/springboot-6zheng-he-mybatis/</id>
        <link href="https://kangjn.github.io/post/springboot-6zheng-he-mybatis/">
        </link>
        <updated>2021-04-16T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-6整合mybatis">springboot-6.整合Mybatis</h2>
<h2 id="一-解析java框架中entity层mapper层service层各层作用">一 .解析Java框架中entity层，mapper层，service层各层作用</h2>
<p>（1）entity层<br>
别名： model层 ，domain层。<br>
用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应<br>
简单例子：user表的实体User</p>
<pre><code>public class User {
    private int id;//id
    private String username;//用户名
    //……省略set,get方法
}
</code></pre>
<p>（2）mapper层<br>
别名： dao层<br>
用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作<br>
简单例子：</p>
<pre><code>@Mapper
public interface UserMapper {
    public User selectUserById(int id);
}
</code></pre>
<p>(3) service层<br>
业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。<br>
封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。<br>
作用：为controller层的类提供接口进行调用。<br>
简单例子：</p>
<pre><code>public interface UserService extends Service&lt;User&gt; {

}
</code></pre>
<h2 id="二快速使用">二.快速使用</h2>
<p>（1）添加依赖项</p>
<pre><code> &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--通用mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.5&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--druid数据源--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.18&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10 &lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>（2）配置application.yml</p>
<pre><code>spring:
  #数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
    username: root
    password: ******
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    connectionProperties: druid.stat.mergeSql=true

#为mybatis配置，生产环境可删除
restart:
  include:
    mapper: /mapper-[\\w-\\.]+jar
    pagehelper: /pagehelper-[\\w-\\.]+jar

pagehelper:
  auto-dialect: msyql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
</code></pre>
<p>(3)编写User.java【entity层】</p>
<pre><code>public class User {
    private String id;
    private String username;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}
</code></pre>
<p>(4)编写UserMapper.java(dao层)</p>
<pre><code>@Mapper
public interface UserMapper {
    @Select(&quot;select * from user where id = #{id}&quot;)
    public User selectUserById(int id);

    @Select(&quot;select * from user where username = #{username}&quot;)
    public List&lt;User&gt; selectUserByName(String userName);

    @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;)
    public void addUser(User user);

    @Update(&quot;update user set username=#{username} where id=#{id}&quot;)
    public void updateUser(User user);

    @Delete(&quot;delete from user where id=#{id}&quot;)
    public void deleteUser(int id);
}
</code></pre>
<p>(5)编写userController.java</p>
<pre><code>@RestController
@RequestMapping(&quot;/user&quot;)
public class userController {

    @Autowired
    UserMapper userMapper;

    @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET)
    public User selectUserById(String id){
        User user = userMapper.selectUserById(Integer.parseInt(id));
        return user;
    }

    @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET)
    public List&lt;User&gt; selectUserByName(String userName){
        return userMapper.selectUserByName(userName);
    }

    @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST)
    public void addUser(User user){
        userMapper.addUser(user);
    }

    @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST)
    public void updateUser(User user){
        userMapper.updateUser(user);
    }

    @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST)
    public void deleteUser(String id){
        userMapper.deleteUser(Integer.parseInt(id));
    }
}
</code></pre>
<p>此时便已经全部配置结束<br>
为了方便测试，忽略了service层，直接调用了mapper层</p>
<p>（6）测试<br>
1.<br>
<a href="https://imgtu.com/i/cW7Rnx"><img src="https://z3.ax1x.com/2021/04/16/cW7Rnx.png" alt="cW7Rnx.png" loading="lazy"></a></p>
<ol start="2">
<li></li>
</ol>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cW74AO"><img src="https://z3.ax1x.com/2021/04/16/cW74AO.png" alt="cW74AO.png" loading="lazy"></a></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-5.全局异常捕获]]></title>
        <id>https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/</id>
        <link href="https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/">
        </link>
        <updated>2021-04-16T06:23:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-5全局异常捕获">springboot-5.全局异常捕获</h2>
<p>在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。</p>
<p>1 浏览器访问异常时：<br>
<a href="https://imgtu.com/i/cW5TOK"><img src="https://z3.ax1x.com/2021/04/16/cW5TOK.png" alt="cW5TOK.png" loading="lazy"></a></p>
<p>2.postman访问异常时：<br>
<a href="https://imgtu.com/i/cW5qTe"><img src="https://z3.ax1x.com/2021/04/16/cW5qTe.png" alt="cW5qTe.png" loading="lazy"></a></p>
<p>显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。</p>
<h2 id="正文">正文</h2>
<p><strong>1.自定义基础接口类+自定义枚举类</strong></p>
<pre><code>public interface BaseErrorInfoInterface {
    /** 错误码*/
    String getResultCode();

    /** 错误描述*/
    String getResultMsg();

    public enum CommonEnum implements BaseErrorInfoInterface {
        // 数据操作错误定义
        SUCCESS(&quot;200&quot;, &quot;成功!&quot;),
        BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;),
        SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;),
        NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;),
        INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;),
        SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;)
        ;

        /** 错误码 */
        private String resultCode;

        /** 错误描述 */
        private String resultMsg;

        CommonEnum(String resultCode, String resultMsg) {
            this.resultCode = resultCode;
            this.resultMsg = resultMsg;
        }

        @Override
        public String getResultCode() {
            return resultCode;
        }

        @Override
        public String getResultMsg() {
            return resultMsg;
        }
    }
}
</code></pre>
<p><strong>2.自定义异常类</strong></p>
<pre><code>public class BizException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * 错误码
     */
    protected String errorCode;
    /**
     * 错误信息
     */
    protected String errorMsg;

    public BizException() {
        super();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface) {
        super(errorInfoInterface.getResultCode());
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) {
        super(errorInfoInterface.getResultCode(), cause);
        this.errorCode = errorInfoInterface.getResultCode();
        this.errorMsg = errorInfoInterface.getResultMsg();
    }

    public BizException(String errorMsg) {
        super(errorMsg);
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg) {
        super(errorCode);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }

    public BizException(String errorCode, String errorMsg, Throwable cause) {
        super(errorCode, cause);
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
    }


    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public String getMessage() {
        return errorMsg;
    }

    @Override
    public Throwable fillInStackTrace() {
        return this;
    }
}
</code></pre>
<p><strong>3.自定义数据格式</strong></p>
<pre><code>public class ResultBody {
    /**
     * 响应代码
     */
    private String code;

    /**
     * 响应消息
     */
    private String message;

    /**
     * 响应结果
     */
    private Object result;

    public ResultBody() {
    }

    public ResultBody(BaseErrorInfoInterface errorInfo) {
        this.code = errorInfo.getResultCode();
        this.message = errorInfo.getResultMsg();
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getResult() {
        return result;
    }

    public void setResult(Object result) {
        this.result = result;
    }

    /**
     * 成功
     * 
     * @return
     */
    public static ResultBody success() {
        return success(null);
    }

    /**
     * 成功
     * @param data
     * @return
     */
    public static ResultBody success(Object data) {
        ResultBody rb = new ResultBody();
        rb.setCode(CommonEnum.SUCCESS.getResultCode());
        rb.setMessage(CommonEnum.SUCCESS.getResultMsg());
        rb.setResult(data);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(BaseErrorInfoInterface errorInfo) {
        ResultBody rb = new ResultBody();
        rb.setCode(errorInfo.getResultCode());
        rb.setMessage(errorInfo.getResultMsg());
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error(String code, String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(code);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    /**
     * 失败
     */
    public static ResultBody error( String message) {
        ResultBody rb = new ResultBody();
        rb.setCode(&quot;-1&quot;);
        rb.setMessage(message);
        rb.setResult(null);
        return rb;
    }

    @Override
    public String toString() {
        return JSONObject.toJSONString(this);
    }
}
</code></pre>
<p><strong>4.自定义全局异常处理类</strong></p>
<pre><code>@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    public static final String Demo_View =  &quot;error&quot;;
    /**
     * 处理自定义的业务异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value = BizException.class)
    public  Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,e.getErrorCode());
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    /**
     * 处理空指针的异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =NullPointerException.class)
    @ResponseBody
    public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){
        logger.error(&quot;发生空指针异常！原因是:&quot;,e);
        return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH);
    }


    /**
     * 处理其他异常
     * @param req
     * @param e
     * @return
     */
    @ExceptionHandler(value =Exception.class)
    public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){
        if(isAjax(request))
        {
            return ResultBody.error(e.getMessage());
        }
        else
        {
            ModelAndView mav = new ModelAndView();
            mav.addObject(&quot;exception&quot;,e);
            mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR);
            mav.setViewName(Demo_View);
            return mav;
        }
    }

    //判断是否是ajax请求
    public static boolean isAjax(HttpServletRequest httpRequest)
    {
        return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null
                &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString()));
    }
}
</code></pre>
<p><strong>5.编写前端异常显示页面</strong><br>
ps:名称对应步骤4里的String Demo_View<br>
为了测试，快速建立一个html</p>
<pre><code>&lt;!doctype html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt;
&lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>此时全局异常捕获已经建立完毕，接下来进行测试</p>
<h2 id="测试">测试</h2>
<p>1.web页面跳转</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        int a = 1 / 0; //除以0，产生异常
        return &quot;error&quot;;
    }
}
</code></pre>
<p>此时访问web页面：<br>
<a href="https://imgtu.com/i/cWo0K0"><img src="https://z3.ax1x.com/2021/04/16/cWo0K0.png" alt="cWo0K0.png" loading="lazy"></a></p>
<p>2.ajax形式跳转<br>
更改controller文件</p>
<pre><code>@Controller
@RequestMapping(&quot;/err&quot;)
public class errorController {
    @RequestMapping(&quot;&quot;)
    public String err()
    {
        return &quot;thymeleaf/ajaxerror&quot;;
    }
    @RequestMapping(&quot;getAjaxError&quot;)
    public jsonResult ajaxError()
    {
        int a = 1/0;
        return jsonResult.ok(200);
    }
}
</code></pre>
<p>新建一个ajaxerror.html文件于thymeleaf文件夹下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ajax测试&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt;
&lt;/body&gt;
&lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个ajax.js文件编写ajax请求</p>
<pre><code>$(&quot;#test&quot;).click(function() {
    $.ajax({
        url: &quot;/err/getAjaxError&quot;,
        type: &quot;POST&quot;,
        async: false,
        success: function (data) {
            if (data.status == 200 &amp;&amp; data.msg == 'OK') {
                alert(&quot;success&quot;);
            } else {
                alert(&quot;发生异常&quot; + data.msg);
            }
        },
        error: function (response, ajaxOption, thrownError) {
            alert(&quot;error&quot;);
        }
    });
});
</code></pre>
<p>记得在application文件夹添加静态文件路径配置</p>
<pre><code>  mvc:
    static-path-pattern: /static/**
</code></pre>
<p>此时访问<br>
<a href="https://imgtu.com/i/cWoDbT"><img src="https://z3.ax1x.com/2021/04/16/cWoDbT.png" alt="cWoDbT.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/cWoR2R"><img src="https://z3.ax1x.com/2021/04/16/cWoR2R.png" alt="cWoR2R.png" loading="lazy"></a></p>
<p>3.测试自定义异常<br>
新建一个controller文件</p>
<pre><code>@Controller
@RequestMapping(value = &quot;/api&quot;)
public class UserRestController {
    @RequestMapping(&quot;&quot;)
    public String api(ModelMap map)
    {
        User u = new User();
        map.addAttribute(&quot;user&quot;,u);
        return &quot;thymeleaf/api&quot;;
    }

    @PostMapping(&quot;/user&quot;)
    public boolean insert(User user) {
        System.out.println(&quot;开始新增...&quot;);
        //如果姓名为空就手动抛出一个自定义的异常！
        if (user.getUsername() == null) {
            throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;);
        }
        return true;
    }
}
</code></pre>
<p>新建一个api.html文件</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>访问<br>
<a href="https://imgtu.com/i/cWoxqf"><img src="https://z3.ax1x.com/2021/04/16/cWoxqf.png" alt="cWoxqf.png" loading="lazy"></a></p>
<p>3.测试自定义异常</p>
<pre><code>    @RequestMapping(&quot;/error&quot;)
    public String error()
    {
        throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;);
    }
</code></pre>
<h2 id="尾言">尾言</h2>
<p>按照步骤添加即可完成操作~<br>
User类自行添加或者浏览前文即可。</p>
<h2 id="其他">其他</h2>
<p>1.SpringBoot异常处理-自定义错误页面</p>
<p><strong>(1) 在Spring Boot中一共提供了几种处理异常的方式？</strong></p>
<p>SpringBoot 中对于异常处理提供了五种处理方式：</p>
<p>自定义错误页面；</p>
<p>@ExceptionHandle 注解处理异常；</p>
<p>@ControllerAdvice+@ExceptionHandler 注解处理异常；</p>
<p>配置 SimpleMappingExceptionResolver 处理异常；</p>
<p>自定义 HandlerExceptionResolver 类处理异常</p>
<p><strong>(2) 什么是自定义错误页面方式？</strong></p>
<p>SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常  SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫  BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。</p>
<p><strong>(3) 自义定错误页面应该放到项目的什么位置？</strong></p>
<p>放在一般网页资源存放的位置 即src/main/resources/templates</p>
<p>2.SpringBoot异常处理-@ControlleAdvice</p>
<p><strong>(1) @ControllerAdvice注解的作用是什么？</strong></p>
<p>需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。</p>
<p><strong>(2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？</strong></p>
<p>是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-4.模板引擎]]></title>
        <id>https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/</id>
        <link href="https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/">
        </link>
        <updated>2021-04-16T06:15:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-4模板引擎">springboot-4.模板引擎</h2>
<h2 id="前言">前言</h2>
<p>关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。</p>
<h2 id="freemarker">freemarker</h2>
<p>(1)在pom文件中添加依赖项</p>
<pre><code>        &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加freemarker相关配置</p>
<pre><code>spring:
  http:
    encoding:
      force: true
      charset: UTF-8
  freemarker:
    allow-request-override: false
    cache: false
    check-template-location: true
    charset: UTF-8
    content-type: text/html; charset=utf-8
    expose-request-attributes: false
    expose-session-attributes: false
    expose-spring-macro-helpers: false
    suffix: .ftl
    template-loader-path: classpath:/templates
</code></pre>
<p>(3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl<br>
文件树结构：<br>
<a href="https://imgtu.com/i/cW4luT"><img src="https://z3.ax1x.com/2021/04/16/cW4luT.png" alt="cW4luT.png" loading="lazy"></a><br>
快速创建一个网页模板进行测试，内容如下：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;${host}&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ps：其中host的值通过后台读取。</p>
<p>（4）在controller文件夹下新建一个freemarkerController.java文件</p>
<pre><code>@Controller
   public class freemarkerController {
        @RequestMapping(&quot;/&quot;)
        public String index(ModelMap map) {
            map.addAttribute(&quot;host&quot;,&quot;ericam&quot;);
            return &quot;freemarker/center&quot;;
        }
   }
</code></pre>
<p>ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl）<br>
(5)预览<br>
此时打开浏览器可以看到如下内容：<br>
<a href="https://imgtu.com/i/cW4dv6"><img src="https://z3.ax1x.com/2021/04/16/cW4dv6.png" alt="cW4dv6.png" loading="lazy"></a></p>
<p>接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf）</p>
<h2 id="thymeleaf">Thymeleaf</h2>
<h3 id="一-快速入门使用">一. 快速入门使用</h3>
<p>（1）在pom文件夹添加项目依赖</p>
<pre><code>            &lt;!-- ThymeLeaf 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>(2)在application.yml文件中添加themeleaf相关配置</p>
<pre><code>spring:
    thymeleaf:
        cache: false # 开发时关闭缓存,不然没法看到实时页面
        mode: HTML # 用非严格的 HTML
        encoding: UTF-8
        servlet:
        content-type: text/html
</code></pre>
<p>(3)<br>
在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html<br>
文件树：<br>
<a href="https://imgtu.com/i/cW428I"><img src="https://z3.ax1x.com/2021/04/16/cW428I.png" alt="cW428I.png" loading="lazy"></a><br>
新建一个User.java文件<br>
文件树：<br>
<a href="https://imgtu.com/i/cW4WxP"><img src="https://z3.ax1x.com/2021/04/16/cW4WxP.png" alt="cW4WxP.png" loading="lazy"></a><br>
(4)编写User.java文件<br>
为了方便测试，用户具备如下属性：</p>
<ul>
<li>id</li>
<li>用户名</li>
<li>年龄</li>
<li>创建时间</li>
<li>用户简介</li>
</ul>
<pre><code>public class User {
    private String id;
    private int age;
    private String username;
    private Date createTime;
    private String desc;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
//请读者自行补充 构造器和 get/set方法..

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }
}
</code></pre>
<p>(5)新建一个themeleafController.java进行测试</p>
<pre><code>@Controller
public class themeleafController {
    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);   //这里的user对应html里的user
        return &quot;thymeleaf/test&quot;;
    }
}
</code></pre>
<p>(6)最后我们进行编写test.html文件</p>
<pre><code>&lt;div&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt;
    &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。<br>
(7)预览<br>
<a href="https://imgtu.com/i/cW475j"><img src="https://z3.ax1x.com/2021/04/16/cW475j.png" alt="cW475j.png" loading="lazy"></a></p>
<h3 id="二thymeleaf常用标签-方法">二.Thymeleaf常用标签-方法</h3>
<p>（1）上述test.html的等同写法</p>
<pre><code>&lt;div th:object=&quot;${user}&quot;&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt;
    &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>这样可以简化内容，使用更加广泛。</p>
<p>（2）表单的提交<br>
我们在test.html里添加如下内容</p>
<pre><code>&lt;div&gt;
    &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt;
        &lt;input type=&quot;submit&quot;/&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username<br>
接着在themeleafController添加如下内容</p>
<pre><code>    @PostMapping(&quot;/postform&quot;)
    public String postform(User u)  //前端传入了一个User对象
    {
        System.out.println(u.getUsername());
        return &quot;redirect:/test&quot;;   //重定向（等于转向/test地址
    }
</code></pre>
<p>（3）th:if标签</p>
<pre><code>&lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt;
&lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt;
</code></pre>
<p>利用if判断变量是否为空，非空时显示</p>
<pre><code class="language-html">&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>if / else 的实现</p>
<pre><code>&lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt;
&lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;
</code></pre>
<p>(4)th:selected标签</p>
<pre><code>&lt;select&gt;
    &lt;option &gt;选择框&lt;/option&gt;
    &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>(5)table表单</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;id&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;年龄&lt;/th&gt;
        &lt;th&gt;创建时间&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr th:each=&quot;person:${userlist}&quot;&gt;
        &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt;
        &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>在这里我们需要修改下themeleafController文件，为其添加一个userlist。</p>
<pre><code>    @RequestMapping(&quot;/test&quot;)
    public String test(ModelMap map)
    {
        User u = new User();
        u.setId(&quot;123&quot;);
        u.setUsername(&quot;fwf&quot;);
        u.setCreateTime(new Date(2020-1900,6-1,12));
        u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;);
        u.setAge(18);
        map.addAttribute(&quot;user&quot;,u);
        List&lt;User&gt; userlist = new ArrayList&lt;&gt;();  //添加一个userlist
        userlist.add(u);
        u = new User();
        u.setId(&quot;234&quot;);
        u.setUsername(&quot;ericam&quot;);
        u.setCreateTime(new Date(2020-1900,5-1,12));
        u.setAge(3);
        userlist.add(u);
        map.addAttribute(&quot;userlist&quot;,userlist);
        return &quot;thymeleaf/test&quot;;
    }
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cW4jMV"><img src="https://z3.ax1x.com/2021/04/16/cW4jMV.png" alt="cW4jMV.png" loading="lazy"></a></figure>
<p>(6)th:switch</p>
<pre><code>&lt;div th:switch=&quot;${user.username}&quot;&gt;
    &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>备注：常用标签的效果可以自行去测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-3.资源文件属性配置]]></title>
        <id>https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/</id>
        <link href="https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/">
        </link>
        <updated>2021-04-16T06:15:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-3资源文件属性配置">springboot-3.资源文件属性配置</h2>
<h3 id="前言">前言</h3>
<p>为什么要进行资源文件属性配置呢？可以想象成就是一个设置文件。比如设置好数据库密码.port端口后，在其他地方只需要用名字引用即可。<br>
举个例子：<br>
我们设置以下项目的持有者名称为ericam</p>
<pre><code>demo:
    name: &quot;ericam&quot;
</code></pre>
<p>那么在其他地方只需要引用name名称即可，然后如果整个项目需要多次引用，后期我们只需要在一个配置文件里更改下名称即可，不必多次操作。</p>
<p>Spring Boot可使用注解的方式将自定义的properties文件映射到实体bean中，比如application.properties文件 或者application.yml</p>
<h3 id="正文">正文</h3>
<p>（1）首先，在pom文件中添加依赖项</p>
<pre><code>&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
</code></pre>
<p><img src="https://ericamblog.oss-cn-shanghai.aliyuncs.com/2020/springboot3/1.png" alt="img" loading="lazy"><br>
（2）修改application.yml文件，添加如下内容</p>
<pre><code>demo:
  name: &quot;ericam&quot;
</code></pre>
<p>（3）新建一个Resource.java文件<br>
<a href="https://imgtu.com/i/cWhDts"><img src="https://z3.ax1x.com/2021/04/16/cWhDts.png" alt="cWhDts.png" loading="lazy"></a></p>
<pre><code>package cn.ericam.nndemo;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
@Configuration  //使用配置注解 ，表示这个类是配置文件
@ConfigurationProperties(prefix = &quot;demo&quot;) //prefix 指定配置文件里的前缀
@PropertySource(value = &quot;classpath:application.yml&quot;)
public class Resource {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>ps：ConfigurationProperties是一个注解，可以标注在一个Class上，这样Spring Boot会从Environment中获取其属性对应的属性值给其进行注入。<br>
（4）接下来，我们开始引用一波尝试，打开helloController.java文件</p>
<pre><code>@RestController
public class helloController {
    @Autowired
    private Resource resource;    //构建一个Resource类对象，通过autowired自动赋值
    @RequestMapping(&quot;/getR&quot;)
    public jsonResult gr()
    {
        Resource b = new Resource();   
        BeanUtils.copyProperties(resource,b); //将resource的值拷贝复制给b
        return  jsonResult.ok(b);
    }
}
</code></pre>
<p>ps:@Autowired 注释可以对类成员变量、方法及构造函数进行标注，完成自动装配。<br>
通过 @Autowired的使用来消除 set、get方法。</p>
<p>打开浏览器<br>
<a href="https://imgtu.com/i/cWhccV"><img src="https://z3.ax1x.com/2021/04/16/cWhccV.png" alt="cWhccV.png" loading="lazy"></a></p>
<p>application.yml文件中重要属性</p>
<pre><code>server:
    port: 8080       #端口
    servlet:
        context-path: /demo   #配置路径，此后访问http://localhost:****/demo/****
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-2.利用接口返回数据（json）]]></title>
        <id>https://kangjn.github.io/post/springboot-2li-yong-jie-kou-fan-hui-shu-ju-json/</id>
        <link href="https://kangjn.github.io/post/springboot-2li-yong-jie-kou-fan-hui-shu-ju-json/">
        </link>
        <updated>2021-04-16T06:04:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-2利用接口返回数据json">springboot-2.利用接口返回数据（json）</h2>
<h2 id="前言">前言</h2>
<p>项目前后台交互存在两种方式<br>
一种普通整体页面提交，比如form提交；<br>
还有一种局部刷新，或者叫做异步刷新，ajax提交；<br>
@Controller就是整体页面刷新提交的处理注解</p>
<p>@RestController就是ajax提交，一般返回json格式，相当于我们经常使用的@ResponseBody+@Controller组合</p>
<h2 id="正文">正文</h2>
<p>新建文件夹controller<br>
然后在该文件夹下新建 控制类.java文件<br>
<a href="https://imgtu.com/i/cWWn9x"><img src="https://z3.ax1x.com/2021/04/16/cWWn9x.png" alt="cWWn9x.png" loading="lazy"></a></p>
<h3 id="1最简单的数据返回">1.最简单的数据返回</h3>
<pre><code>@RestController
public class helloController {
    @RequestMapping(&quot;/&quot;)
    public String hello()
    {
        return &quot;hello&quot;;
    }
}
</code></pre>
<p>【@RequestMapping作用】<br>
<strong>处理请求地址的映射<br>
用于类和方法上，类上的 “请求地址” 是方法上的 “请求地址” 的父地址</strong><br>
<a href="https://imgtu.com/i/cWWgCq"><img src="https://z3.ax1x.com/2021/04/16/cWWgCq.png" alt="cWWgCq.png" loading="lazy"></a></p>
<h3 id="2返回类对象信息">2.返回类对象信息</h3>
<p>为了演示，我们新建一个文件夹User，然后在该文件夹下新建一个文件User.java<br>
<a href="https://imgtu.com/i/cWWWvT"><img src="https://z3.ax1x.com/2021/04/16/cWWWvT.png" alt="cWWWvT.png" loading="lazy"></a><br>
内容如下：</p>
<pre><code>public class User {
    private String name;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
</code></pre>
<p><strong>然后在controller文件夹下新建一个userController.java文件</strong><br>
(记得自行import需要的文件)<br>
<a href="https://imgtu.com/i/cWfMin"><img src="https://z3.ax1x.com/2021/04/16/cWfMin.png" alt="cWfMin.png" loading="lazy"></a></p>
<pre><code>@RestController
public class userController {
    @RequestMapping(&quot;/getUser&quot;)
    public User getUser() {
        User u = new User();
        u.setName(&quot;x&quot;);
        u.setSex(&quot;nan&quot;);
        return u;

    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://z3.ax1x.com/2021/04/16/cWWgCq.png" alt="cWWgCq.png" loading="lazy"></figure>
<h3 id="3返回封装的类对象信息">3.返回封装的类对象信息</h3>
<p>解释一下该处和2处的区别：<br>
@Description: 自定义响应数据结构这个类是提供给门户，ios，安卓，微信商城用的门户接受此类数据后需要使用本类的方法转换成对于的数据类型格式（类，或者list）其他自行处理</p>
<ul>
<li>
<p>200：表示成功</p>
</li>
<li>
<p>500：表示错误，错误信息在msg字段中</p>
</li>
<li>
<p>501：bean验证错误，不管多少个错误都以map形式返回</p>
</li>
<li>
<p>502：拦截器拦截到用户token出错</p>
</li>
<li>
<p>555：异常抛出信息<br>
简单来说，就是当前台提交用户信息给后台时，后台会返回一个json数据，其中包含状态码（200等），message（“ok”或者“failure”），然后再包含一个用户信息列表。</p>
<p><strong>首先，在pom文件中添加依赖项</strong></p>
</li>
<li>
<p>jackson-databind</p>
</li>
<li>
<p>jackson-core<br>
新建一个jsonResult.java文件</p>
</li>
</ul>
<pre><code>package cn.ericam.nndemo.Json;
public class jsonResult {
    // 响应业务状态
    private Integer status;
    // 响应消息
    private String msg;
    // 响应中的数据
    private Object data;
    public static jsonResult ok(Object data) {
        return new jsonResult(data);
    }
    //类含参初始化1
    public jsonResult(Integer status, String msg, Object data) {
        this.status = status;
        this.msg = msg;
        this.data = data;
    }

    //类含参初始化2
    public jsonResult(Object data) {
        this.status = 200;
        this.msg = &quot;OK&quot;;
        this.data = data;
    }

    //get和set方法
    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }
}
</code></pre>
<p>然后在userController.java下修改为如下代码：</p>
<pre><code>@RestController
public class userController {
    @RequestMapping(&quot;/getUser&quot;)
    
    public jsonResult getUser()
    {
        User u = new User();
        u.setName(&quot;x&quot;);
        u.setSex(&quot;nan&quot;);
        return  jsonResult.ok(u);
    }
}
</code></pre>
<p><a href="https://imgtu.com/i/cWfyLD"><img src="https://z3.ax1x.com/2021/04/16/cWfyLD.png" alt="cWfyLD.png" loading="lazy"></a><br>
<strong>【ps：IDEA利用ctrl+insert可以快速生成get和set方法】</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot-1.简约版创建第一个应用]]></title>
        <id>https://kangjn.github.io/post/springboot-1jian-yue-ban-chuang-jian-di-yi-ge-ying-yong/</id>
        <link href="https://kangjn.github.io/post/springboot-1jian-yue-ban-chuang-jian-di-yi-ge-ying-yong/">
        </link>
        <updated>2021-04-16T06:01:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot-1简约版创建第一个应用">springboot-1.简约版创建第一个应用</h2>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/cWgyU1"><img src="https://z3.ax1x.com/2021/04/16/cWgyU1.md.png" alt="cWgyU1.md.png" loading="lazy"></a></figure>
<p><strong>勾选依赖项</strong></p>
<p>由于只是体验搭建一个springboot项目，因此依赖项只需要勾选一个spring web</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/cW2ZqJ"><img src="https://z3.ax1x.com/2021/04/16/cW2ZqJ.md.png" alt="cW2ZqJ.md.png" loading="lazy"></a></figure>
<p><strong>创建成功后项目列表如下图所示</strong></p>
<p><a href="https://imgtu.com/i/cW21xO"><img src="https://z3.ax1x.com/2021/04/16/cW21xO.png" alt="cW21xO.png" loading="lazy"></a><br>
其中</p>
<ul>
<li><strong>DemoApplication.java:关键的启动类（程序的入口）</strong></li>
<li><strong>pom.xml:Maven构建说明文件</strong></li>
<li><strong>DemoApplicationTests.java:一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文</strong></li>
<li><strong>application.properties:一个空的properties文件，根据需要添加配置属性</strong></li>
</ul>
<p>为了演示简单，不再新建控制类，而是直接在这个入口类(DemoApplication.java)中编写，添加@RestController以及index方法，如下：<br>
<strong>红色框内 内容需要添加</strong><br>
<a href="https://imgtu.com/i/cW2NdA"><img src="https://z3.ax1x.com/2021/04/16/cW2NdA.png" alt="cW2NdA.png" loading="lazy"></a><br>
ps:@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。</p>
<h3 id="运行项目">运行项目</h3>
<p>浏览器访问http://localhost:8080/<br>
<a href="https://imgtu.com/i/cW2oyF"><img src="https://z3.ax1x.com/2021/04/16/cW2oyF.png" alt="cW2oyF.png" loading="lazy"></a><br>
<strong>至此第一个springboot项目已经创建完毕</strong></p>
<h3 id="端口被占用">端口被占用</h3>
<p>由于项目需要运行在端口8080，当端口被占用时，需要杀死该端口上运行的进程<br>
进入命令行</p>
<pre><code class="language-c">netstat -o -n -a | findstr :8080
# TCP    0.0.0.0:3000      0.0.0.0:0              LISTENING       3116
taskkill /F /PID 3116
</code></pre>
<h3 id="实现热启动">实现热启动</h3>
<p>热启动：修改代码保存时会自动重新启动项目</p>
<p><strong>1.修改pom.xml文件(添加spring-boot-devtools包)</strong></p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;scope&gt;true&lt;/scope&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>修改spring-boot-maven-plugin插件</p>
<pre><code class="language-java">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;!--fork:设置True，否则可能devtools不会起作用--&gt;
                &lt;fork&gt;true&lt;/fork&gt;
            &lt;/configuration&gt;
 &lt;/plugin&gt;
</code></pre>
<p><strong>2.修改IDEA配置</strong></p>
<pre><code>打开 File -&gt; Settings -&gt;Build,Executions,Deployment -&gt; Compiler ，勾选
</code></pre>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/cWREfP"><img src="https://z3.ax1x.com/2021/04/16/cWREfP.png" alt="cWREfP.png" loading="lazy"></a></figure>
<pre><code>然后，Ctrl + Shift + Alt + / 打开
</code></pre>
<p><a href="https://imgtu.com/i/cWR3Yq"><img src="https://z3.ax1x.com/2021/04/16/cWR3Yq.png" alt="cWR3Yq.png" loading="lazy"></a><br>
<strong>勾选该选项</strong><br>
<a href="https://imgtu.com/i/cWRam4"><img src="https://z3.ax1x.com/2021/04/16/cWRam4.png" alt="cWRam4.png" loading="lazy"></a><br>
热更新完成！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git命令行常用指令]]></title>
        <id>https://kangjn.github.io/post/git-ming-ling-xing-chang-yong-zhi-ling/</id>
        <link href="https://kangjn.github.io/post/git-ming-ling-xing-chang-yong-zhi-ling/">
        </link>
        <updated>2021-04-16T05:31:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="git命令行日常指令">git命令行日常指令</h2>
<p><strong>首先，需要在Github/Coding平台新建一个仓库。</strong></p>
<p>本地新建一个文件夹，打开该文件夹，右键选择“git bash here”进入命令行。</p>
<h3 id="1将项目初次拉取到本地clone">1.将项目初次拉取到本地（clone）</h3>
<pre><code>git clone 项目地址
</code></pre>
<h3 id="2-将本地文件push到远程仓库">2. 将本地文件push到远程仓库</h3>
<pre><code>git init                 #初始化
git add .              #将文件夹内所有文件添加至本地仓库
git commit -m &quot;描述&quot;           #添加本次提交描述
git remote add origin https://github.com/用户名/项目名.git  
git push -u origin master
</code></pre>
<p>ps: git remote add origin...为建立本地与远程依赖，某些情况下需要重置。<br>
清空依赖命令</p>
<pre><code>git remote rm origin
</code></pre>
<h3 id="3删除文件夹">3.删除文件夹</h3>
<pre><code>git pull origin master
git rm -r --cached idea  #删除idea文件夹
git commit -m '删除.idea'
git push -u origin master
</code></pre>
<h3 id="4-git-push-命令使用">4. git push 命令使用</h3>
<p><strong>场景1</strong><br>
场景：当本地的当前分支不是local_branch；<br>
作用：将远程分支拉取到指定本地分支；<br>
例如：当前分支是dev，但是你想把远程master “同步”到本地master，但又不想使checkout切换到master分支；</p>
<pre><code>git pull origin master：master  #将远程master分支拉取到本地master分支
</code></pre>
<p><strong>场景2</strong><br>
场景：在当前分支上进行同步操作；<br>
作用：将指定远程分支同步到当前本地分支；</p>
<pre><code>git pull origin master
</code></pre>
<p><strong>场景3</strong><br>
场景：本地分支已经和想要拉取的分支建立了“关联”关系；<br>
作用：拉取所有远程分支的新版本&quot;坐标&quot;，并同步当前分支的本地代码(具体根据关联分支而定)</p>
<pre><code>git push
</code></pre>
<h3 id="5强制拉取">5.强制拉取</h3>
<pre><code>git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull
</code></pre>
<p><strong>git fetch&amp;&amp;git pull</strong><br>
git pull : 拉取代码并合并<br>
git fetch :拉取代码 (如果需要合并，执行git merge)</p>
<p>git fetch使用方法</p>
<pre><code>git fetch origin master:tmp  // 拉取远程master分支，并放到本地tmp分支上
git diff tmp  //查看当前分支和tmp分支的区别
git merge tmp   // 把tmp分支合并到当前分支
git branch -d tmp   // 删除tmp分支
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式-六大设计原则]]></title>
        <id>https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/</id>
        <link href="https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/">
        </link>
        <updated>2021-04-16T02:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单一职责原则">单一职责原则</h1>
<h2 id="简介">简介</h2>
<p>单一职责原则（SRP，Single Responsesibility Principle）：There should never be  more than one reason for a class to change.(应该有且仅有一个原因引起类的变更)</p>
<h2 id="优势">优势</h2>
<ul>
<li>类的复杂性降低。实现什么职责都有清晰明确的定义</li>
<li>可读性提高，复杂性降低</li>
<li>可维护性提高，可读性提高</li>
<li>变更引起的风险降低</li>
</ul>
<h2 id="注意">注意</h2>
<ul>
<li>单一职责是一个标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是这两者都是不可度量的，因项目和环境而定。</li>
</ul>
<h1 id="里氏替换原则">里氏替换原则</h1>
<h2 id="简介-2">简介</h2>
<p>里氏替换原则（LSP，Liskov Substitution Principle）：</p>
<ul>
<li>If for each object o1 of type S there is an object o2 of type T  suchthat for all programs P defined in terms of T, the behavior of P is  unchangedwhen o1 is substituted for o2 then S is a subtype of  T.（如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。）</li>
<li>functions that use pointers or references to base classes must  beable to use objects of derived classes without knowing  it.（所有引用基类的地方必须能透明地使用其子类的对象。）</li>
<li>理解：只要父类能出现的地方子类就可以出现，即将父类对象调用的行为切换成子类对象调用行为也不会产生任何错误或异常，但是反过来却不行。</li>
</ul>
<h2 id="含义">含义</h2>
<ul>
<li>子类必须完全实现父类的方法</li>
<li>里氏替换原则可以正着用，不能反过来用：子类出现的地方，父类未必可以胜任</li>
<li>覆盖或实现父类的方法时，输入参数可以被放大：如果反过来会引起业务逻辑的错乱。子类中方法的前置条件（参数）必须与超类中被覆写的方法的前置条件相同或更宽松。（如：父类是HashMap，子类是HashMap或Map）</li>
<li>覆写或实现父类的方法时输出结果可以被缩小：里氏替换原则要求S小于等于T，则S和T要么是同一类型，要么S是T的子类。</li>
</ul>
<h2 id="注意-2">注意</h2>
<ul>
<li>在类中调用其他类时必须要使用父类或接口，如果不能使用父类或接口，说明类的设计已经违背了LSP原则</li>
<li>如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生了&quot;畸变&quot;，建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
</ul>
<h1 id="依赖倒置原则">依赖倒置原则</h1>
<h2 id="简介-3">简介</h2>
<p>依赖倒置原则（DIP，Dependence Inversion Principle）：High level modules should  not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions</p>
<ul>
<li>理解：高层模块不应该依赖底层模块，两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象</li>
</ul>
<h2 id="含义-2">含义</h2>
<ul>
<li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象实现的</li>
<li>接口或抽象类不依赖于实现类</li>
<li>实现类依赖接口或抽象类</li>
</ul>
<h2 id="注意-3">注意</h2>
<ul>
<li>Java变量有两种类型：表面类型（定义时候赋予的类型），实际类型（对象的类型）</li>
<li>依赖的三种写法：构造函数传递依赖对象、setter方法传递依赖对象、接口声明依赖对象</li>
<li>依赖倒置原则是实现开闭原则的重要途径。</li>
</ul>
<h2 id="使用">使用</h2>
<p>要想使用这个规则只需要做到一下几点：</p>
<ul>
<li>每个类尽量都有接口或抽象类，或两者皆有</li>
<li>变量的表面类型尽量是接口或抽象类</li>
<li>任何类都不应该从具体类派生</li>
<li>尽量不要覆写基类方法</li>
<li>结合里氏替换原则使用：接口负责定义Public属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化</li>
</ul>
<h1 id="接口隔离原则">接口隔离原则</h1>
<h2 id="简介-4">简介</h2>
<p>接口隔离原则（ISP：Interface Segregation Principle）：</p>
<ul>
<li>Clients should not be forced to depend upon interfaces that they don't use（客户端不应该依赖于它不需要的接口）</li>
<li>The dependency of one class to another one should depend on the smallest possible interface（类间的依赖关系应该建立在最小的接口上）</li>
<li>理解：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化同时接口方法尽量少</li>
</ul>
<h2 id="含义-3">含义</h2>
<ul>
<li>接口尽可能的小：前提是不能违背单一职责原则，优先考虑单一职责原则</li>
<li>接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互</li>
<li>定制服务：单独为一个个体提供优良的服务</li>
<li>接口设计是有限度的</li>
</ul>
<h2 id="注意-4">注意</h2>
<ul>
<li>接口隔离原则和单一职责并不冲突，两者针对的角度不同。单一职责注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少</li>
<li>设计是有限度的，不要无限的考虑未来可能出现的情况</li>
</ul>
<h2 id="使用-2">使用</h2>
<ul>
<li>一个接口只服务于一个子模块或业务逻辑</li>
<li>通过业务逻辑尽量压缩接口中的public方法，并经常回顾接口</li>
<li>如果接口已经被污染，尽量去修改。如果不行，则使用适配器模式进行转换处理</li>
<li>了解环境，根据业务来设计</li>
</ul>
<h1 id="迪米特法则">迪米特法则</h1>
<h2 id="简介-5">简介</h2>
<p>迪米特法则（LoD：Law of Demeter）：一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道的最少</p>
<h2 id="含义-4">含义</h2>
<ul>
<li>只和朋友交流：不要出现getA().getB().getC().getD()的奇葩写法
<ul>
<li>朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类</li>
</ul>
</li>
<li>朋友间也是有距离的：公开的public属性或方法越多，修改时涉及的面也就越大。在设计时候要反复考虑是否可以减少public的方法和属性，将其修改成private等，并且是否可以加上final关键字</li>
<li>是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系也不对本类产生负面影响，就放在本类中</li>
<li>谨慎使用Serializable：由于很容易被发现，所以不必太过在意。</li>
</ul>
<h2 id="注意-5">注意</h2>
<ul>
<li>一个类只和朋友交流不和陌生人交流 ，不要出现getA().getB().getC().getD()的奇葩写法</li>
<li>类与类之间的关系是建立在类间的，而不是方法间的，一个方法尽量不引入一个类中不存在的对象，JDK API提供的除外</li>
<li>尽量不要对外公布太多的public方法和非静态的public变量</li>
<li>如果一个类跳转两次以上才能访问到另外一个类，就需要进行重构了。</li>
</ul>
<h1 id="开闭原则">开闭原则</h1>
<h2 id="简介-6">简介</h2>
<p>开闭原则：Software entities like classes,modules and functions should be  open for extension but closed for  modifications（一个软件实体，如类、模块和函数应该对扩展开发对修改关闭）</p>
<ul>
<li>理解：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。</li>
</ul>
<h2 id="优势-2">优势</h2>
<ul>
<li>使用开闭原则能有效的减少重构时的测试</li>
<li>可以提高复用性</li>
<li>可以提高可维护性</li>
<li>面向对象开发的要求</li>
</ul>
<h2 id="使用-3">使用</h2>
<ul>
<li>抽象约束
<ul>
<li>通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法</li>
<li>参数类型、引用对象尽量使用接口或抽象类，而不是实现类</li>
<li>抽象层尽量保持稳定，一旦确认就不允许修改</li>
</ul>
</li>
<li>元数据控制模块行为：尽量使用元数据来控制程序的行为（描述缓解和数据的数据，通俗的说就是配置）</li>
<li>制定项目章程</li>
<li>封装变化
<ul>
<li>将相同的变化封装到一个接口或抽象类中</li>
<li>将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中</li>
</ul>
</li>
</ul>
<h2 id="注意-6">注意</h2>
<ul>
<li>开闭原则对扩展开放对修改关闭，并不意味着不做任何修改，底层模块的变更，必然有高层模块进行耦合，否则就是无意义的代码</li>
</ul>
]]></content>
    </entry>
</feed>