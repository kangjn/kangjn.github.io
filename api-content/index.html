{"posts":[{"title":"设计模式-六大设计原则","content":"单一职责原则 简介 单一职责原则（SRP，Single Responsesibility Principle）：There should never be more than one reason for a class to change.(应该有且仅有一个原因引起类的变更) 优势 类的复杂性降低。实现什么职责都有清晰明确的定义 可读性提高，复杂性降低 可维护性提高，可读性提高 变更引起的风险降低 注意 单一职责是一个标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是这两者都是不可度量的，因项目和环境而定。 里氏替换原则 简介 里氏替换原则（LSP，Liskov Substitution Principle）： If for each object o1 of type S there is an object o2 of type T suchthat for all programs P defined in terms of T, the behavior of P is unchangedwhen o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。） functions that use pointers or references to base classes must beable to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 理解：只要父类能出现的地方子类就可以出现，即将父类对象调用的行为切换成子类对象调用行为也不会产生任何错误或异常，但是反过来却不行。 含义 子类必须完全实现父类的方法 里氏替换原则可以正着用，不能反过来用：子类出现的地方，父类未必可以胜任 覆盖或实现父类的方法时，输入参数可以被放大：如果反过来会引起业务逻辑的错乱。子类中方法的前置条件（参数）必须与超类中被覆写的方法的前置条件相同或更宽松。（如：父类是HashMap，子类是HashMap或Map） 覆写或实现父类的方法时输出结果可以被缩小：里氏替换原则要求S小于等于T，则S和T要么是同一类型，要么S是T的子类。 注意 在类中调用其他类时必须要使用父类或接口，如果不能使用父类或接口，说明类的设计已经违背了LSP原则 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生了&quot;畸变&quot;，建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 依赖倒置原则 简介 依赖倒置原则（DIP，Dependence Inversion Principle）：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions 理解：高层模块不应该依赖底层模块，两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象 含义 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象实现的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 注意 Java变量有两种类型：表面类型（定义时候赋予的类型），实际类型（对象的类型） 依赖的三种写法：构造函数传递依赖对象、setter方法传递依赖对象、接口声明依赖对象 依赖倒置原则是实现开闭原则的重要途径。 使用 要想使用这个规则只需要做到一下几点： 每个类尽量都有接口或抽象类，或两者皆有 变量的表面类型尽量是接口或抽象类 任何类都不应该从具体类派生 尽量不要覆写基类方法 结合里氏替换原则使用：接口负责定义Public属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化 接口隔离原则 简介 接口隔离原则（ISP：Interface Segregation Principle）： Clients should not be forced to depend upon interfaces that they don't use（客户端不应该依赖于它不需要的接口） The dependency of one class to another one should depend on the smallest possible interface（类间的依赖关系应该建立在最小的接口上） 理解：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化同时接口方法尽量少 含义 接口尽可能的小：前提是不能违背单一职责原则，优先考虑单一职责原则 接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互 定制服务：单独为一个个体提供优良的服务 接口设计是有限度的 注意 接口隔离原则和单一职责并不冲突，两者针对的角度不同。单一职责注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少 设计是有限度的，不要无限的考虑未来可能出现的情况 使用 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑尽量压缩接口中的public方法，并经常回顾接口 如果接口已经被污染，尽量去修改。如果不行，则使用适配器模式进行转换处理 了解环境，根据业务来设计 迪米特法则 简介 迪米特法则（LoD：Law of Demeter）：一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道的最少 含义 只和朋友交流：不要出现getA().getB().getC().getD()的奇葩写法 朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类 朋友间也是有距离的：公开的public属性或方法越多，修改时涉及的面也就越大。在设计时候要反复考虑是否可以减少public的方法和属性，将其修改成private等，并且是否可以加上final关键字 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系也不对本类产生负面影响，就放在本类中 谨慎使用Serializable：由于很容易被发现，所以不必太过在意。 注意 一个类只和朋友交流不和陌生人交流 ，不要出现getA().getB().getC().getD()的奇葩写法 类与类之间的关系是建立在类间的，而不是方法间的，一个方法尽量不引入一个类中不存在的对象，JDK API提供的除外 尽量不要对外公布太多的public方法和非静态的public变量 如果一个类跳转两次以上才能访问到另外一个类，就需要进行重构了。 开闭原则 简介 开闭原则：Software entities like classes,modules and functions should be open for extension but closed for modifications（一个软件实体，如类、模块和函数应该对扩展开发对修改关闭） 理解：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。 优势 使用开闭原则能有效的减少重构时的测试 可以提高复用性 可以提高可维护性 面向对象开发的要求 使用 抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法 参数类型、引用对象尽量使用接口或抽象类，而不是实现类 抽象层尽量保持稳定，一旦确认就不允许修改 元数据控制模块行为：尽量使用元数据来控制程序的行为（描述缓解和数据的数据，通俗的说就是配置） 制定项目章程 封装变化 将相同的变化封装到一个接口或抽象类中 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中 注意 开闭原则对扩展开放对修改关闭，并不意味着不做任何修改，底层模块的变更，必然有高层模块进行耦合，否则就是无意义的代码 ","link":"https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/"},{"title":"《论语》50经典名句","content":"1．朝闻道，夕死可矣。 早上明白知晓了真理，即便晚上死去，也是值得的。 2．见贤思齐焉，见不贤而内自省也。 见到贤人便应考虑怎样才能向他看齐，见到不贤的人便应在内心反省，看自己有没有同样的缺点。 3．己所不欲，勿施于人。 如果不希望他人这样对待自己，自己也不要这样对待他人。 4．不怨天，不尤人。 遇到挫折与失败，绝不抱怨天，不责怪人。 5．不迁怒，不贰过。 不会迁怒于人，不会犯两次同样的错误。 6．过而不改，是谓过矣。 有了过错而不改正，这就是真的过错了。 7．人而无信，不知其可也。 一个人不讲信用，不知他怎样立身处世。 8．有则改之，无则加勉。 别人给自己指出缺点错误，如果有，就改正，如果没有，就用来提醒自己不犯同样的错误。 9．如切如磋，如琢如磨。 完善自身的修养，既像雕琢玉器，又像雕刻石头，都是需要下功夫的。 10．人无远虑，必有近忧。 一个人没有长远的考虑，一定会有眼前的忧患。指智者能不为眼前得失所羁绊，目光长远，判断敏锐。 11．君子求诸己，小人求诸人。 君子哪儿做得不对，会从自己内心去查找原因，要求自己做好，从而修正自己；小人则是向外去查找原因，要求别人做好。 12．君子坦荡荡，小人长戚戚。 君子光明磊落，胸怀坦荡，小人则斤斤计较，患得患失。 13．君子喻于义，小人喻于利。 君子能够领悟的是道义，小人能够领悟的是利益。 14．君子和而不同，小人同而不和。 君子和谐而不同流合污，小人同流合污而不和谐。 15．君子泰而不骄，小人骄而不泰。 君子坦荡舒畅而不骄傲自大，小人骄傲自大而不坦荡舒畅。 16．君子成人之美，不成人之恶。小人反是。 君子成全别人的好事，而不促成别人的坏事。小人则与此相反。 17．君子欲讷于言，而敏于行。 君子说话要谨慎，而行动要敏捷。君子说话要谨慎，是因为“覆水难收”，随心所欲说出口的话，可能对于别人有失尊重。但是一旦君子对于决定的事情，绝不犹豫推托而耽误了时光。这一缓一急之间，正是体现君子有为有守的处世原则。 18．君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。 君子食不追求饱足，居住不追求安逸，对工作勤奋敏捷，说话却谨慎，接近有道德有学问的人并向他学习，纠正自己的缺点，就可以称得上是好学了。 **19．与善人居，如入芝兰之室，久而不闻其香，即与之化矣；与不善人居，如入鲍鱼之肆，久而不闻其臭；亦与之化矣。 ** 常与善人相处，就像生活在种满兰芝仙草的花房，时间长了便察觉不到香味，那是因为已经习惯了善行的芬芳；常与不善的人相处，就像住进了满是臭鱼烂虾的海鲜市场，时间长了便察觉不到腥味，也是因为闻惯了恶行的腐臭。 圣人此言是在告诫我们：与人相处，先看人品。 常跟善良的人在一起，便会耳濡目染地跟着行善事、说善言，久而久之，心胸也会变得更加宽广。 常跟邪恶的人在一起，则会不知不觉地跟做错事、说恶话，久而久之，难免会折损自身的品行。 20．君子有三畏：畏天命，畏大人，畏圣人之言。小人不知天命而不畏也，狎大人，侮圣人之言”。 君子有三件敬畏的事情：敬畏天命，敬畏居高位的人，敬畏圣人的话，小人不知道天所赋予的正理而不敬畏，怠慢轻视高位的人，戏侮圣人的话。 21．学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？ 学过的知识，在适当的时候去复习它，这不是令人感到快乐的事吗？ 有朋友从远方来，这不是件令人感到快乐的事吗？ 别人不了解我，我也不生气，这不也是一种君子风度的表现吗？ 22．三人行，必有我师焉。择其善者而从之，其不善者而改之。 几个人同行，其中必有值得我学习的人，选取他的优点向他学习，对他的缺点引以为戒，有则改之。 23．学而不厌，诲人不倦。 努力学习却不感到满足，教导别人不感到厌倦。 24．学而不思则罔，思而不学则殆。 只学习却不思考就会感到迷茫，只空想却不学习就会疲倦而没有收获。 25．敏而好学，不耻下问，是以谓之文也。 聪明而且好学，不认为向地位比自己低、学识比自己浅的人请教是可耻的事，任何一个能如此作为的人，怎会不能成才？ 26．知之为知之，不知为不知，是知也。 知道就是知道，不知道应当说不知道，这才是明智的行为。 27．温故而知新，可以为师矣。 温习旧知识从而得到新的理解与体会，凭借这一点就可以成为老师了。 28．子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。” 孔子说：“我十五岁时，便立定志向学习；三十岁时，能立身处世；四十岁时，可以免于迷惑；五十岁时，已经能够领悟天命；六十岁时，就可以顺从天命；七十岁时，终于能做到做事随心所欲，却都能合于规矩的境界了。” 29．欲速则不达；见小利则大事不成。 不要求快，不要贪求小利。求快反而达不到目的，贪求小利就做不成大事。 30．小不忍，则乱大谋。 小事不忍耐，就会坏了大事情。 31．知者不惑，仁者不忧，勇者不惧。 有智慧的人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。 32．见义不为，无勇也。 见到应该挺身而出的事情，却袖手旁观，就是怯懦。 33．志士仁人，无求生以害仁，有杀身以成仁。 一位怀有大志和仁德的人，不会贪生怕死而损害仁德，只会不惜牺牲生命而成全仁德。 34．三军可夺帅也，匹夫不可夺志也。 三军可以丧失主帅，一个人的志气与主张却是不能被强迫改变的。 35．士不可以不弘毅，任重而道远。 有志者不可以不心胸开阔，意志坚强，因为担子沉重而且道路遥远。 36．名不正，则言不顺，言不顺，则事不成。 名分不正，所说的话就不合道理。说话不合理，事情就办不成。 37．自古皆有死，民无信不立。 子贡问怎么治理国家。孔子说：“粮食充足，军备充足，人民信任当政者。”子贡说：“如果不得不去掉一项，那么这三项应先去掉哪一项？”孔子说：“去掉军备。”子贡说：“如果不得不再去掉一项，那么这两项应去掉哪一项？”孔子说：“去掉粮食。自古以来人终究是要死的，老百姓如果不信任当政者，那么国家就不能成立了。” 38．其身正，不令而行；其身不正，虽令不从。 自身品行端正，即使不下达命令，百姓也会自觉去做；自身品行不端正，即使下达了命令，百姓也不会服从。 39．不在其位，不谋其政。 不在那个职位上，就不去考虑那个职位上的事。不是事不关己的冷漠，而是行事恪守本分。 40．听其言而观其行。 指听了他的话，还要看他的行动。 指不要只听言论，还要看实际行动。 41．四海之内，皆兄弟也。 司马牛见到师兄子夏后忧愁地说他人皆有兄弟相亲，而唯独我没有兄弟相亲。子夏安慰他说君子和人交往态度恭谨而合乎礼节，那么普天之下到处都是兄弟。 42．与朋友交，言而有信。 与朋友们交往，应该诚实守信，说到做到。 43．礼之用，和为贵。 礼的作用，在于使人的关系变得更加和谐。 44．益者三友，损者三友。友直，友谅，友多闻，益矣；友便辟，友善柔，友便佞，损矣。 有益的朋友有三种，有害的朋友也有三种。与正直的人交朋友，与守信的人交朋友，与见多识广的人交朋友，是有益的。与谄媚逢迎的人交朋友，与两面三刀的人交朋友，与花言巧语的人交朋友，是有害的。 45．道不同，不相为谋。 立场不同、观点不同，也就不要相互商议谋划了。 46．父母在，不远游，游必有方。 父母年迈在世，尽量不长期在外地。不得已，必须告诉父母去哪里，为什么去，什么时候回来，并安排好父母的赡养。 47．是可忍也，孰不可忍也。 孔子谈到季氏说：“他用天子的舞蹈阵容在自己的庭院中舞蹈，如果这样僭礼的事情都可以容忍的话，还有什么事情是不可以容忍的呢？” 48．毋意，毋必，毋因，毋我。 不凭空猜测，不死板，不固执，不自以为是。 49．士志于道，而耻恶衣恶食者，未足与议也。 有志之士，既然存心在道，就不应该贪求享受，如果还以粗糙的衣服和简陋的饮食为耻辱，那就不值得和他说什么了。 50．往者不可谏，来者犹可追。 过去的不可挽回，未来的还可以赶上。 ","link":"https://kangjn.github.io/post/lesslesslun-yu-greatergreater-50-jing-dian-ming-ju/"},{"title":"RabbitMQ使用教程(五)","content":"4.7.主题模式（通配符模式） 4.7.1.图示 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 4.7.2.生产者 package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.zpc.rabbitmq.util.ConnectionUtil; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); // 消息内容 String message = &quot;Hello World!!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 4.7.3.消费者1（前台系统） package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.7.4.消费者2（搜索系统） package com.zpc.rabbitmq.topic; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 5.Springboot集成RabbitMQ springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。 5.1.简单队列 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持 org.springframework.boot spring-boot-starter-amqp 2、配置application.properties文件 配置rabbitmq的安装地址、端口以及账户信息 spring.application.name=spirng-boot-rabbitmq spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin 3、配置队列 package com.zpc.rabbitmq; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitConfig { @Bean public Queue queue() { return new Queue(&quot;q_hello&quot;); } } 4、发送者 package com.zpc.rabbitmq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.text.SimpleDateFormat; import java.util.Date; @Component public class HelloSender { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } } 5、接收者 package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver : &quot; + hello); } } 6、测试 package com.zpc.rabbitmq; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMqHelloTest { @Autowired private HelloSender helloSender; @Test public void hello() throws Exception { helloSender.send(); } } 5.2.多对多使用（Work模式） 注册两个Receiver: package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } @Test public void oneToMany() throws Exception { for (int i=0;i&lt;100;i++){ helloSender.send(i); Thread.sleep(300); } } public void send(int i) { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + i + &quot; &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } 5.3.Topic Exchange（主题模式） topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 首先对topic规则配置，这里使用两个队列(消费者)来演示。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig { final static String message = &quot;q_topic_message&quot;; final static String messages = &quot;q_topic_messages&quot;; @Bean public Queue queueMessage() { return new Queue(TopicRabbitConfig.message); } @Bean public Queue queueMessages() { return new Queue(TopicRabbitConfig.messages); } /** * 声明一个Topic类型的交换机 * @return */ @Bean TopicExchange exchange() { return new TopicExchange(&quot;mybootexchange&quot;); } /** * 绑定Q到交换机,并且指定routingKey * @param queueMessage * @param exchange * @return */ @Bean Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;); } @Bean Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;); } } 2)创建2个消费者 q_topic_message 和q_topic_messages package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_message&quot;) public class Receiver1 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver1 : &quot; + hello); } } package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_messages&quot;) public class Receiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } 3)消息发送者（生产者） package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSender { @Autowired private AmqpTemplate rabbitTemplate; public void send1() { String context = &quot;hi, i am message 1&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context); } public void send2() { String context = &quot;hi, i am messages 2&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context); } } send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。 4)测试 package com.zpc.rabbitmq.topic; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitTopicTest { @Autowired private MsgSender msgSender; @Test public void send1() throws Exception { msgSender.send1(); } @Test public void send2() throws Exception { msgSender.send2(); } } 5.4.Fanout Exchange（订阅模式） Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanoutRabbitConfig { @Bean public Queue aMessage() { return new Queue(&quot;q_fanout_A&quot;); } @Bean public Queue bMessage() { return new Queue(&quot;q_fanout_B&quot;); } @Bean public Queue cMessage() { return new Queue(&quot;q_fanout_C&quot;); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(&quot;mybootfanoutExchange&quot;); } @Bean Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(aMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(bMessage).to(fanoutExchange); } @Bean Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(cMessage).to(fanoutExchange); } } 2）创建3个消费者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_A&quot;) public class ReceiverA { @RabbitHandler public void process(String hello) { System.out.println(&quot;AReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_B&quot;) public class ReceiverB { @RabbitHandler public void process(String hello) { System.out.println(&quot;BReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_C&quot;) public class ReceiverC { @RabbitHandler public void process(String hello) { System.out.println(&quot;CReceiver : &quot; + hello + &quot;/n&quot;); } } 3）生产者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSenderFanout { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String context = &quot;hi, fanout msg &quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context); } } 4）测试 package com.zpc.rabbitmq.fanout; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitFanoutTest { @Autowired private MsgSenderFanout msgSender; @Test public void send1() throws Exception { msgSender.send(); } } 结果如下，三个消费者都收到消息： AReceiver : hi, fanout msg CReceiver : hi, fanout msg BReceiver : hi, fanout msg 6.总结 使用MQ实现商品数据的同步优势： 1、降低系统间耦合度 2、便于管理数据的同步（数据一致性） 推荐阅读 《RabbitMQ详解》 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/"},{"title":"RabbitMQ使用教程(四)","content":"4.4.消息的确认模式 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？ 模式1：自动确认 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。 模式2：手动确认 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。 手动模式： 自动模式： 4.5.订阅模式 4.5.1.图示 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费 4.5.2.消息的生产者（看作是后台系统） 向交换机中发送消息。 package com.zpc.rabbitmq.subscribe; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。 4.5.3.消费者1（看作是前台系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.4.消费者2（看作是搜索系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.5.测试 测试结果： 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 在管理工具中查看队列和交换机的绑定关系： 4.6.路由模式 4.6.1.图示 4.6.2.生产者 4.6.3.消费者1(假设是前台系统) 4.6.4.消费2（假设是搜索系统） ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/"},{"title":"RabbitMQ使用教程(三)","content":"4、学习五种队列 4.1 简单队列 4.1.1.图示 P：消息的生产者 C：消息的消费者 红色：队列 生产者将消息发送到队列，消费者从队列中获取消息。 4.1.2.导入RabbitMQ的客户端依赖 com.rabbitmq amqp-client 3.4.1 4.1.3.获取MQ的连接 package com.zpc.rabbitmq.util; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; public class ConnectionUtil { public static Connection getConnection() throws Exception { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost(&quot;localhost&quot;); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost(&quot;testhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 4.1.4.生产者发送消息到队列 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明（创建）队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); //关闭通道和连接 channel.close(); connection.close(); } } 4.1.5.管理工具中查看消息 点击上面的队列名称，查询具体的队列中的信息： 4.1.6.消费者从队列中获取消息 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); } } } 4.2.Work模式 4.2.1.图示 一个生产者、2个消费者。 一个消息只能被一个消费者获取。 4.2.2.消费者1 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;); //休眠 Thread.sleep(10); // 返回确认状态，注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)； } } } 4.2.3.消费者2 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); // 休眠1秒 Thread.sleep(1000); //下面这行注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.2.4.生产者 向队列中发送100条消息。 package com.zpc.rabbitmq.work; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 100; i++) { // 消息内容 String message = &quot;&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); Thread.sleep(i * 10); } channel.close(); connection.close(); } } 4.2.5.测试 测试结果： 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。 RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。 basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。 2个概念 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 4.3.Work模式的“能者多劳” 打开上述代码的注释： // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); //开启这行 表示使用手动确认模式 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 同时改为手动确认： // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, false, consumer); 测试： 消费者1比消费者2获取的消息更多。 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/"},{"title":"RabbitMQ使用教程(二)","content":"2.4.学习5种队列 2.5.安装文档 3.搭建RabbitMQ环境 3.1.下载 下载地址：http://www.rabbitmq.com/download.html 3.2.windows下安装 3.2.1.安装Erlang 下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装 3.2.2.安装RabbitMQ 3.2.3.启用管理工具 1、双击 2、进入C:\\Program Files (x86)\\RabbitMQ Server\\rabbitmq_server-3.4.1\\sbin输入命令： rabbitmq-plugins enable rabbitmq_management 这样就启动了管理工具，可以试一下命令： 停止：net stop RabbitMQ 启动：net start RabbitMQ 3、在浏览器中输入地址查看：http://127.0.0.1:15672/ 4、使用默认账号登录：guest/ guest 3.3.Linux下安装 3.3.1.安装Erlang 3.3.2.添加yum支持 cd /usr/local/src/ mkdir rabbitmq cd rabbitmq wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc 使用yum安装： sudo yum install erlang 3.3.3.安装RabbitMQ 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/ 安装： rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 3.3.4.启动、停止 service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 3.3.5.设置开机启动 chkconfig rabbitmq-server on 3.3.6.设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 3.3.7.开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 注意要去掉后面的逗号。 3.3.8.开启web界面管理工具 rabbitmq-plugins enable rabbitmq_management service rabbitmq-server restart 3.3.9.防火墙开放15672端口 /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT /etc/rc.d/init.d/iptables save 3.4.安装的注意事项 1、推荐使用默认的安装路径 2、系统用户名必须是英文 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/"},{"title":"RabbitMQ使用教程(一)","content":"1.什么是MQ 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。 其主要用途：不同进程Process/线程Thread之间通信。 为什么会产生消息队列？有几个原因： 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列； 关于消息队列的详细介绍请参阅： 《Java帝国之消息队列》 《一个故事告诉你什么是消息队列》 《到底什么时候该使用MQ》 MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。 2.RabbitMQ 2.1.RabbitMQ的简介 开发语言：Erlang – 面向并发的编程语言。 2.1.1.AMQP AMQP是消息队列的一个协议。 2.2.官网 2.3.MQ的其他产品 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/"},{"title":"前端面试题目（二）","content":"解决HTML5新标签的兼容性： &lt;![if lt IE 9]&gt; //解决IE6-8支持HTML5新元素 //解决IE6-8对css Media Query//媒体查询 &lt;![endif]&gt; a:hover，a:active失效的问题？(lvha) 现象： a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。 解决方式： a:link {color:black} a:visited{color:pink} a:hover {color: blue} a:active {color: green} 将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。 如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。 选择器优先级？ 内联样式&gt;内部样式&gt;外部样式 ！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式 注意： 1、!important声明的样式优先级最高，如果冲突再进行计算。 2、如果优先级相同，则选择最后出现的样式。 3、继承得到的样式的优先级最低。 文本怎么自动换行？ word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。 word-wrap:normal word-wrap:break-word box-sizing模型？ content-box:默认 padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding border-box: padding和border包含在元素的宽度内，元素的实际宽度为：width js中创建自定义对象 ? var f=function(){} new Object() function f() this? 指向调用它的对象，如果没有，就指window HTML5表单新元素？ date time color number range email url search 5种常见的HTTP状态码及意义？ 200:请求成功 301、302：永久重定向/暂时重定向 400：请求格式错误 404：找不到资源 500：服务器内部错误 怎么让一个图片在一个DIV中垂直居中对齐？ 父元素使用相对定位 子元素使用绝对定位 怎么让文字垂直居中对齐？ 一行文字父元素不固定：padding:20px 父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell 如何让图片跟文字在居中显示： 父元素设置为vertical-align:middle 浏览器兼容？ 1、不同的浏览器默认样式不一样：padding margin 2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden 3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距 页面优化/站点优化？ 1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度 2、代码压缩/css/js yui compressor 数组的方法： join concat push pop unshift shift slice splice 正则表达式： \\d数字 \\s空白字符 \\w数字、字母、下划线 ？ 0-1 或 改为懒惰模式 0-n 1-n ^ 开关 $ 结尾 \\b 边界 new 一个对象具体干了什么？ 第一步是建立一个新对象； 第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象； 第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。 如何判断一个对象是否为数组？ typeof &quot;sflkj&quot; typeof无法判断数组跟对象 [] instanceof Array Array.prototype.isPrototypeOf([]) Array.isArray([]) 获取一个选项卡的值？ aa bb function showinfo(){ var sel=document.getElementById(\"s1\"); var i=sel.selectedIndex; var result=sel.options[i].value; } 浏览器对象有哪些？ navigator history window location screen event document window对象的常用方法？ alert confirm prompt close js绑定事件： btnObj.addEventListener(&quot;click&quot;,function(){}) jquery 把变量$的控制权交给其他JS库 jQuery.noConflict(); jQuery(function($){}) jQuery 遍历？（$.each()方法） asdf luili 234 var m=$(\"ul li\"); m.each(function(i){ if(i==0){ $(this).css(\"font-size\",\"18px\") } }) 怎么把一个JSON字符串转换成一个js对象？ var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} 把一个js对象转换成一个josn字符吕？ var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' 表单序列化成字符串：serialize（） 序列化成json对象：serializeArray() 手机端头部怎么写？ 不通过插件实现自响应布局？ CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局 CSS的媒体查询？ @media screen and(min-width:990px){//(一个css文件内) #id{ float:left } } @media screen and(min-width:700px) and (max-width:989px){ #id{ float:left } @media screen and(max-width:699px){ } angularjs？ 采用MVC模式 数据绑定 依赖注入 模块化设计 初始化一个模型数据 ng-bind=&quot;name&quot; ng-repeat=&quot;data in array&quot; angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){ .controller(&quot;myCtrl&quot;,function($scope){ $scope.newsTitle=&quot;hello&quot; }) } 什么是高内聚，低耦合？ 高内聚：一个模块内的元素的关系赵紧密越好 低耦合：不同模块间的关系尽量不要有关联 ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/"},{"title":"前端面试题目（一）","content":"什么是闭包？ 指有权访问另一个函数作用域中变量的函数 null 和undefined的区别？ 共同点：都是原始类型，保存在栈中变量本地 不同点： undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用 null:表示一个变量不再指向任何对象地址 表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用 常见行内元素和块级元素有哪些，他们有什么区别？ 行内元素：span img a u s i input select 块级元素：div ul ol li dt dd h1-h6 块级元素会单独占一行，行内元素会在一行显示。 什么是ajax？ ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。 实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新： 如何创建XMLHttpRequest请求步骤： 1、获取ajax对象 var xhr=new XMLHttpRequest(); 2、创建请求:调用XMLHttpRequest对象的open方法 xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步]) 3、回调函数的处理 xhr.onreadystatechange=function(){ if(xhr.readyState4){ if(xhr.status200){ var txt=xhr.responseText/responseXML } } } 4、发送请求 xhr.send(&quot;name=value$pwd=value&quot;); readyState属性： 0=未初始化 1=正在加载 2=以加载 3=交互中 4=加载完成 Ajax异步请求？ .ajax( { url:&quot;destination.php&quot;, type:&quot;post&quot;, data:(&quot;#id&quot;).val(), dataType:&quot;json&quot;, success:function(data){ console.log(data) } error:function(){ window.alert(&quot;error&quot;) } } ) AJAX的优缺点？ 优点： 页面局部刷新，提高用户体验 减轻服务器负担 具有更迅速的响应能力 能被广泛支持 缺点： 不支持浏览器后退按钮 安全问题 对搜索引擎支持比较弱 html中有哪些定位？ static:默认规则定位。 absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间 relative:相对定位，相对于初始位置定位/占页面空间 fixed:固定定位，相对于浏览器窗口 http 建立TCP连接 发送请求命令 发送请求头部 服务器应答 服务器发送应答头部 服务器发送应答具体信息 关闭连接 如何居中DIV？ 给DIV设置一个宽度，再设置margin为:0 auto; 如何居中一个浮动元素？ 使用一个居中显示的DIV包含些浮动元素。 position:fixed;//固定定位 width: 200px; height: 200px; background: red; margin-left:-100px; margin-top: -100px; left: 50%; top: 50%; 纯CSS实现一个三角形？ width: 0; height: 0; border:25px solid transparent; border-top-color: red; 重写trim()方法 if(String.prototype.trim===undefined){ String.prototype.trim=function () { return this.replace(/^\\s+|\\s+$/g) } } var str=&quot; helloworld &quot;; document.write(&quot;|&quot;+str+&quot;| &quot;); str=str.trim(); document.write(&quot;|&quot;+str+&quot;|&quot;); function trim(str){//同时去掉开头和结尾的空字符 var reg=/^\\s+|\\s+$/g; return str.replace(reg,&quot;&quot;); } var str=&quot; zhang dong &quot;; console.log(ltrim(str));//&quot;zhang dong &quot; console.log(rtrim(str));//&quot; zhang dong&quot; console.log(trim(str));//&quot;zhang dong&quot; 水仙花数 var a,b,c for(var i=100;i&lt;1000;i++){ a=parseInt(i%10); b=parseInt((i/10)%10); c=parseInt(i/100); if(iaaa+bbb+ccc){ console.log(i); } } 判断某一年是不是闰年 function isLeap(year){ console.log(year%40&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;); } isLeap(prompt(&quot;主输入年份&quot;)); 在单词后面加上数字 var str=&quot;one two three four&quot;; var i=4; var reg=/\\b[a-z]+\\b/g; str=str.replace(reg,function(kw){ return kw+i++; }) console.log(str); 判断是不是数组 var str=[] Array.prototype.isPrototypeOf(str);//true Object.prototype.toString.call(str);//[Object Array]; str instanceof Array; Array.isArray([]) 什么是继承？ 父对象已有的成员，子对象不用重复定义，就可以直接使用 什么是原型？ 每个函数都有一个prototype属性，该属性引用的就是原型对象， 原型对象就是保存共有属性和方法的对象 window窗口的全局对象？ history navigator screen location event 动态加载Dom? var frg=document.createDocumentFragment(); var m=document.createElement(&quot;div&quot;); m.innerHTML=&quot;this is first page&quot;; frg.appendChild(m); document.body.appendChild(frg); 数组去重？ var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] function unique(arr){ for(var i=0,arr2={};i&lt;arr.length;i++){ arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1); } var arr=[]; for(var key in arr2){ arr.push(key) } return arr; } console.log(unique(arr)); var arr1=[2,5,9,1,7] function sort(arr){ for(var i=0;iarr[j+1]]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } sort(arr1); console.log(arr1) 数组降维 var arr=[[1,2,3],[1,3,2]]; var res=Array.prototype.concat.apply([],arr) console.log(res); 如何理解HTML语义化？ 可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性 常用的语义化标签： 哪些属性可以继承？ font-size font-family color display:none和visibility:hidden的区别？ display不占据页面空间 visibility仍然占据空间 css3伪类选择器 :enabled :disabled :checked :firtt-child :last-child 为什么建议在设置背景图像的同时还设置背景颜色？ 如果因为各种原因图片无法加载的时候，页面会显示背景颜色。 CSS sprite的优缺点？ 把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位 优点： 减少网页的http请求，提高性能 减少图片的大小 维护更方便，只需要在一张图片上修改就可以。 缺点： 图片合成比较麻烦 背景设置时需要得到每一个图片的精确位置 CSS3新特性 box-shadow border-radius text-shadow ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/"}]}