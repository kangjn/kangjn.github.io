{"posts":[{"title":"理解高性能、高并发(七)：深入操作系统，一文读懂进程、线程、协程","content":"1、什么是进程？ 1.1 基本常识 我们需要明确一下几个常识： 1）计算机的核心是CPU，它承担了所有的计算任务； 2）操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件； 3）应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。 进程一般由程序、数据集合和进程控制块三部分组成： 1）程序用于描述进程要完成的功能，是控制进程执行的指令集； 2）数据集合是程序在执行时所需要的数据和工作区； 3）程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。 进程具有的特征： 1）动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的； 2）并发性：任何进程都可以同其他进程一起并发执行； 3）独立性：进程是系统进行资源分配和调度的一个独立单位； 4）结构性：进程由程序、数据和进程控制块三部分组成。 1.2 为什么要有多进程？ 多进程目的：提高cpu的使用率。 **一个例子：**一个用户现在既想使用打印机，又想玩游戏。 *假设只有一个进程（先不谈多线程）：* 从操作系统的层面看，我们使用打印机的步骤有如下： 1）使用CPU执行程序，去硬盘读取需要打印的文件，然后CPU会长时间的等待，直到硬盘读写完成； 2）使用CPU执行程序，让打印机打印这些内容，然后CPU会长时间的等待，等待打印结束。 **在这样的情况下：**其实CPU的使用率其实非常的低。 打印一个文件从头到尾需要的时间可能是1分钟，而cpu使用的时间总和可能加起来只有几秒钟。而后面如果单进程执行游戏的程序的时候，CPU也同样会有大量的空闲时间。 *使用多进程后：* 当CPU在等待硬盘读写文件，或者在等待打印机打印的时候，CPU可以去执行游戏的程序，这样CPU就能尽可能高的提高使用率。 再具体一点说，其实也提高了效率。因为在等待打印机的时候，这时候显卡也是闲置的，如果用多进程并行的话，游戏进程完全可以并行使用显卡，并且与打印机之间也不会互相影响。 1.3 小结一下 **进程，直观点说：**保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。 2、什么是线程？ 2.1 基本常识 早期：操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。 后来：随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。 线程是程序执行中一个单一的顺序控制流程： 1）是程序执行流的最小单元； 2）是处理器调度和分派的基本单位。 一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。 **如上图所示：**在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。 2.2 任务调度 线程是什么？要理解这个概念，需要先了解一下操作系统的一些相关概念。 大部分操作系统（如Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式。 **在一个进程中：**当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。 **上述过程中：**任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。 这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发（别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行）。 多任务运行过程的示意图如下： ▲ 操作系统中的任务调度 2.3 进程与线程的区别 前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系。 下面就让我们一起来理一理： 1）线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 2）一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 3）进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其它进程不可见； 4）线程上下文切换比进程上下文切换要快得多。 以下线程与进程关系的示意图。 ▲ 进程与线程的资源共享关系 ▲ 单线程与多线程的关系 **总之：**线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程（Lightweight Process，LWP）。 ▲ 早期的操作系统只有进程，没有线程 后来：随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个（也可以是一个）线程。 ▲ 线程的出现，使得一个进程可以有多个线程 2.4 多线程与多核 上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。 那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？ 其实：“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。 ***多核(心)处理器是指：***在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。 内核线程（Kernel Thread，KLT）：就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。 一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器 -&gt; 性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。 ▲ 双核四线程在Windows8下查看的结果 超线程技术：就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术（如双核四线程）由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。 由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。 用户线程与内核线程的对应关系有三种模型： 1）一对一模型； 2）多对一模型； 3）多对多模型。 在下面的文字中，将以4个内核线程、3个用户线程为例对三种模型进行说明。 2.5 一对一模型 **对于一对一模型来说：**一个用户线程就唯一地对应一个内核线程（反过来不一定成立，一个内核线程不一定有对应的用户线程）。 **这样：**如果CPU没有采用超线程技术（如四核四线程的计算机），一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。 一对一模型使用户线程具有与内核线程一样的优点：一个线程因某种原因阻塞时其他线程的执行不受影响（此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现）。 但一对一模型也有两个缺点： 1）许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制； 2）许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。 ▲ 一对一模型 2.6 多对一模型 多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。 因此，相对一对一模型： 1）多对一模型的线程上下文切换速度要快许多； 2）多对一模型对用户线程的数量几乎无限制。 但多对一模型也有两个缺点： 1）如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了； 2）在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。 ▲ 多对一模型 2.7 多对多模型 多对多模型结合了一对一模型和多对一模型的优点：将多个用户线程映射到多个内核线程上，由线程库负责在可用的可调度实体上调度用户线程。 这使得线程的上下文切换非常快：因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。 多对多模型的优点有： 1）一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行； 2）多对多模型对用户线程的数量没有限制； 3）在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。 ▲ 多对多模型 在现在流行的操作系统中，大都采用多对多的模型。 2.8 查看进程与线程 一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？ 在Windows下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按“Ctrl+Alt+Del”或右键快捷工具栏打开任务管理器。 查看进程数和线程数： 在“进程”选项卡下，我们可以看到一个应用程序包含的线程数。 如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google的Chrome浏览器就有多个进程。 同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个cmd窗口，就有两个cmd进程。如果看不到线程数这一列，可以再点击“查看 -&gt; 选择列”菜单，增加监听的列。 查看CPU和内存的使用率：在性能选项卡中，我们可以查看CPU和内存的使用率，根据CPU使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。 ▲ 查看CPU和内存的使用率 2.9 线程的生命周期 当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。 但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。 在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。 我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。 ▲ 早期进程的生命周期 进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。 早期进程的生命周期详细说明如下： 创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。 ▲ 线程的生命周期 线程的生命周期跟进程很类似： 创建：一个新的线程被创建，等待该线程被调用执行； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。 3、什么是协程？ 3.1 基本常识 协程：英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做“用户空间线程”，具有对内核来说不可见的特性。 因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。 3.2 协程的目的 对于Java程序员来说，在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。 如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。 最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。 对于上述问题：现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是 [node.js]以及 Java 里的新秀 [Vert.x]。 而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。 3.3 协程的特点 协程的特点总结一下就是： 1）线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率； 2）线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程； 3）由于在同一个线程上，因此可以避免竞争关系而使用锁； 4）适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。 3.4 协程的原理 当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑。 这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如：Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。 由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。 **因此：**协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。 3.5 协程和线程的比较 4、总结一下 我们总结一下。 进程和线程的区别就是： 1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源； 4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 进程和线程之间的联系就是： 1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 2）资源分配给进程，同一进程的所有线程共享该进程的所有资源； 3）处理机分给线程，即真正在处理机上运行的是线程； 4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 *那么，既然有了线程，为啥还要有协程？* 考虑这一样一种场景： 开发者在每个线程中只做非常轻量的操作，比如访问一个极小的文件，下载一张极小的图片，加载一段极小的文本等。但是，这样”轻量的操作“的量却非常多。 在有大量这样的轻量操作的场景下，即使可以通过使用线程池来避免创建与销毁的开销，但是线程切换的开销也会非常大，甚至于接近操作本身的开销。 对于这些场景，就非常需要一种可以减少这些开销的方式。于是，协程就应景而出，非常适合这样的场景。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-qi-shen-ru-cao-zuo-xi-tong-yi-wen-du-dong-jin-cheng-xian-cheng-xie-cheng/"},{"title":"理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的","content":"1、多进程 历史上最早出现也是最简单的一种并行处理多个请求的方法就是利用[多进程]。 比如在Linux世界中，我们可以使用fork、exec等系统调用创建多个进程，我们可以在父进程中接收用户的连接请求，然后创建子进程去处理用户请求。 就像这样： 这种方法的优点就在于： 1）编程简单，非常容易理解； 2）由于各个进程的地址空间是相互隔离的，因此一个进程崩溃后并不会影响其它进程； 3）充分利用多核资源。 多进程并行处理的优点很明显，但是缺点同样明显： 1）各个进程地址空间相互隔离，这一优点也会变成缺点，那就是进程间要想通信就会变得比较困难，你需要借助进程间通信（IPC，interprocess communications）机制，想一想你现在知道哪些进程间通信机制，然后让你用代码实现呢？显然，进程间通信编程相对复杂，而且性能也是一大问题； 2）我们知道创建进程开销是比线程要大的，频繁的创建销毁进程无疑会加重系统负担。 2、多线程 不是创建进程开销大吗？不是进程间通信困难吗？这些对于线程来说统统不是问题。 由于线程共享进程地址空间，因此线程间通信天然不需要借助任何通信机制，直接读取内存就好了。 线程创建销毁的开销也变小了，要知道线程就像寄居蟹一样，房子（地址空间）都是进程的，自己只是一个租客，因此非常的轻量级，创建销毁的开销也非常小。 我们可以为每个请求创建一个线程，即使一个线程因执行I/O操作——比如读取数据库等——被阻塞暂停运行也不会影响到其它线程。 就像这样： 但线程就是完美的、包治百病的吗，显然，计算机世界从来没有那么简单。 由于线程共享进程地址空间，这在为线程间通信带来便利的同时也带来了无尽的麻烦。 正是由于线程间共享地址空间，因此一个线程崩溃会导致整个进程崩溃退出，同时线程间通信简直太简单了，简单到线程间通信只需要直接读取内存就可以了，也简单到出现问题也极其容易，死锁、线程间的同步互斥、等等，这些极容易产生bug，无数程序员宝贵的时间就有相当一部分用来解决多线程带来的无尽问题。 虽然线程也有缺点，但是相比多进程来说，线程更有优势，但想单纯的利用多线程就能解决高并发问题也是不切实际的。 因为虽然线程创建开销相比进程小，但依然也是有开销的，对于动辄数万数十万的链接的高并发服务器来说，创建数万个线程会有性能问题，这包括内存占用、线程间切换，也就是调度的开销。 3、事件驱动：Event Loop 到目前为止，我们提到“并行”二字就会想到进程、线程。 **但是：**并行编程只能依赖这两项技术吗？并不是这样的！ 还有另一项并行技术广泛应用在GUI编程以及服务器编程中，这就是近几年非常流行的事件驱动编程：event-based concurrency。实际上事件驱动编程原理上非常简单。 这一技术需要两种原料： 1）event； 2）处理event的函数，这一函数通常被称为event handler； 剩下的就简单了：你只需要安静的等待event到来就好，当event到来之后，检查一下event的类型，并根据该类型找到对应的event处理函数，也就是event handler，然后直接调用该event handler就好了。 **从上面可以看到：**我们需要不断的接收event然后处理event，因此我们需要一个循环（用while或者for循环都可以），这个循环被称为Event loop。 使用伪代码表示就是这样： while(true) { event = getEvent(); handler(event); } Event loop中要做的事情其实是非常简单的，只需要等待event的带来，然后调用相应的event处理函数即可。 **注意：**这段代码只需要运行在一个线程或者进程中，只需要这一个event loop就可以同时处理多个用户请求。 **有的可以依然不明白：**为什么这样一个event loop可以同时处理多个请求呢？ **原因很简单：**对于网络通信服务器来说，处理一个用户请求时大部分时间其实都用在了I/O操作上，像数据库读写、文件读写、网络读写等。当一个请求到来，简单处理之后可能就需要查询数据库等I/O操作，我们知道I/O是非常慢的，当发起I/O后我们大可以不用等待该I/O操作完成就可以继续处理接下来的用户请求。 **现在你应该明白了吧：**虽然上一个用户请求还没有处理完我们其实就可以处理下一个用户请求了，这也是并行，这种并行就可以用事件驱动编程来处理。 **这就好比餐厅服务员一样：**一个服务员不可能一直等上一个顾客下单、上菜、吃饭、买单之后才接待下一个顾客，服务员是怎么做的呢？当一个顾客下完单后直接处理下一个顾客，当顾客吃完饭后会自己回来买单结账的。 **看到了吧：**同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event loop只运行在一个线程(进程)中也可以同时处理多个用户请求。 相信你已经对事件驱动编程有一个清晰的认知了，那么接下来的问题就是，这个事件也就是event该怎么获取呢？ 4、事件来源：IO多路复用 在Linux/Unix世界中一切皆文件，而我们的程序都是通过文件描述符来进行I/O操作的，当然对于网络编程中的socket也不例外。 那我们该如何同时处理多个文件描述符呢？ **IO多路复用技术正是用来解决这一问题的：**通过IO多路复用技术，我们一次可以监控多个文件描述，当某个“文件”（实际可能是im网络通信中socket）可读或者可写的时候我们就能得到通知啦。 这样IO多路复用技术就成了event loop的原材料供应商，源源不断的给我们提供各种event，这样关于event来源的问题就解决了。 **至此：**关于利用事件驱动来实现并发编程的所有问题都解决了吗？event的来源问题解决了，当得到event后调用相应的handler，看上去大功告成了。 5、问题：阻塞式IO **现在：**我们可以使用一个线程（进程）就能基于事件驱动进行并行编程，再也没有了多线程中让人恼火的各种锁、同步互斥、死锁等问题了。 **但是：**计算机科学中从来没有出现过一种能解决所有问题的技术，现在没有，在可预期的将来也不会有。 那上述方法有什么问题吗？ 不要忘了，我们event loop是运行在一个线程（进程），这虽然解决了多线程问题，但是如果在处理某个event时需要进行IO操作会怎么样呢？ 我们讲解了最常用的文件读取在底层是如何实现的，程序员最常用的这种IO方式被称为阻塞式IO。 **也就是说：**当我们进行IO操作，比如读取文件时，如果文件没有读取完成，那么我们的程序（线程）会被阻塞而暂停执行，这在多线程中不是问题，因为操作系统还可以调度其它线程。 **但是：**在单线程的event loop中是有问题的，原因就在于当我们在event loop中执行阻塞式IO操作时整个线程（event loop）会被暂停运行，这时操作系统将没有其它线程可以调度，因为系统中只有一个event loop在处理用户请求，这样当event loop线程被阻塞暂停运行时所有用户请求都没有办法被处理。你能想象当服务器在处理其它用户请求读取数据库导致你的请求被暂停吗？ **因此：**在基于事件驱动编程时有一条注意事项，那就是不允许发起阻塞式IO。 有的可能会问，如果不能发起阻塞式IO的话，那么该怎样进行IO操作呢？ **PS：**有阻塞式IO，就有非阻塞式IO。 6、解决方法：非阻塞式IO 为克服阻塞式IO所带来的问题，现代操作系统开始提供一种新的发起IO请求的方法，这种方法就是异步IO。对应的，阻塞式IO就是同步IO。 异步IO时，假设调用aio_read函数（具体的异步IO API请参考具体的操作系统平台），也就是异步读取，当我们调用该函数后可以立即返回，并继续其它事情，虽然此时该文件可能还没有被读取，这样就不会阻塞调用线程了。此外，操作系统还会提供其它方法供调用线程来检测IO操作是否完成。 就这样，在操作系统的帮助下IO的阻塞调用问题也解决了。 7、基于事件驱动并行编程的难点 虽然有异步IO来解决event loop可能被阻塞的问题，但是基于事件编程依然是困难的。 **首先：**我们提到，event loop是运行在一个线程中的，显然一个线程是没有办法充分利用多核资源的，有的同学可能会说那就创建多个event loop实例不就可以了，这样就有多个event loop线程了，但是这样一来多线程问题又会出现。 另一点在于编程方面，异步编程需要结合回调函数（这种编程方式需要把处理逻辑分为两部分：一部分调用方自己处理，另一部分在回调函数中处理），这一编程方式的改变加重了程序员在理解上的负担，基于事件编程的项目后期会很难扩展以及维护。 8、更好的方法 为什么我们要使用异步这种难以理解的方式编程呢？ **是因为：**阻塞式编程虽然容易理解但会导致线程被阻塞而暂停运行。 **那么你一定会问了：**有没有一种方法既能结合同步IO的简单理解又不会因同步调用导致线程被阻塞呢？ **答案是肯定的：**这就是用户态线程（user level thread），也就是协程。 虽然基于事件编程有这样那样的缺点，但是在当今的高性能高并发服务器上基于事件编程方式依然非常流行，但已经不是纯粹的基于单一线程的事件驱动了，而是 event loop + multi thread + user level thread。 9、本文小结 高并发技术从最开始的多进程一路演进到当前的事件驱动，计算机技术就像生物一样也在不断演变进化，但不管怎样，了解历史才能更深刻的理解当下。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-liu-tong-su-yi-dong-gao-xing-neng-fu-wu-qi-dao-di-shi-ru-he-shi-xian-de/"},{"title":"理解高性能、高并发(五)：深入操作系统，理解高并发中的协程","content":"应该如何彻底理解协程。 1、普通的函数 我们先来看一个普通的函数，这个函数非常简单： def func(): print(&quot;a&quot;) print(&quot;b&quot;) print(&quot;c&quot;) 这是一个简单的普通函数，当我们调用这个函数时会发生什么？ 1）调用func； 2）func开始执行，直到return； 3）func执行完成，返回函数A。 是不是很简单，函数func执行直到返回，并打印出： a b c 注意这段代码是用python写的，但本篇关于协程的讨论适用于任何一门语言，因为协程并不是某种语言特有的。而我们只不过恰好使用了python来用作示例，因其足够简单。 那么协程是什么呢？ 2、从普通函数到协程 接下来，我们就要从普通函数过渡到协程了。和普通函数只有一个返回点不同，协程可以有多个返回点。 这是什么意思呢？ void func() { print(&quot;a&quot;) 暂停并返回 print(&quot;b&quot;) 暂停并返回 print(&quot;c&quot;) } 普通函数下，只有当执行完print(&quot;c&quot;)这句话后函数才会返回，但是在协程下当执行完print(&quot;a&quot;)后func就会因“暂停并返回”这段代码返回到调用函数。 有的可能会一脸懵，这有什么神奇的吗？ 我写一个return也能返回，就像这样： void func() { print(&quot;a&quot;) return print(&quot;b&quot;) 暂停并返回 print(&quot;c&quot;) } 直接写一个return语句确实也能返回，但这样写的话return后面的代码都不会被执行到了。 协程之所以神奇就神奇在当我们从协程返回后还能继续调用该协程，并且是从该协程的上一个返回点后继续执行。 就好比孙悟空说一声“定”，函数就被暂停了： void func() { print(&quot;a&quot;) 定 print(&quot;b&quot;) 定 print(&quot;c&quot;) } 这时我们就可以返回到调用函数，当调用函数什么时候想起该协程后可以再次调用该协程，该协程会从上一个返回点继续执行。在编程语言中一般叫做yield（其它语言中可能会有不同的实现，但本质都是一样的）。 需要注意的是：当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的。 接下来，我们就用实际的代码看一看协程。 3、“Talk is cheap，show me the code” 下面我们使用一个真实的例子来讲解，语言采用python. 在python语言中，这个“定”字同样使用关键词yield。 这样我们的func函数就变成了： void func() { print(&quot;a&quot;) yield print(&quot;b&quot;) yield print(&quot;c&quot;) } **注意：**这时我们的func就不再是简简单单的函数了，而是升级成为了协程，那么我们该怎么使用呢？ 很简单： def A(): co =func() # 得到该协程 next(co) # 调用协程 print(&quot;in function A&quot;) # do something next(co) # 再次调用该协程 我们看到虽然func函数没有return语句，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了。 接下来我们调用该协程，使用next(co)，运行函数A看看执行到第3行的结果是什么： a 显然，和我们的预期一样，协程func在print(&quot;a&quot;)后因执行yield而暂停并返回函数A。 接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印： a in function A 接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢？ 如果func是普通函数，那么会执行func的第一行代码，也就是打印a。 但func不是普通函数，而是协程，我们之前说过，协程会在上一个返回点继续运行，因此这里应该执行的是func函数第一个yield之后的代码，也就是 print(&quot;b&quot;)。 a in function A b 看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行。 4、图形化解释 为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍。 首先是普通的函数调用： **在该图中：**方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向。 **从上图中我们可以看到：**我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行。这是普通的函数调用。 接下来是协程： **在这里：**我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程。 **注意：**协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是从上一次的挂起点开始执行，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束。 5、函数只是协程的一种特例 和普通函数不同的是，协程能知道自己上一次执行到了哪里。 现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。 很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。 只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。 这就是为什么有的人说可以把协程理解为用户态线程的原因。 也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。 在协程这件事儿上，调度你说了算。 当你在协程中写下 yield 的时候就是想要暂停该协程，当使用 next() 时就是要再次运行该协程。 现在你应该理解为什么说函数只是协程的一种特例了吧，函数其实只是没有挂起点的协程而已。 6、协程的历史 有的可能认为协程是一种比较新的技术，然而其实协程这种概念早在1958年就已经提出来了，要知道这时线程的概念都还没有提出来。 到了1972年，终于有编程语言实现了这个概念，这两门编程语言就是Simula 67 以及Scheme。 但协程这个概念始终没有流行起来，甚至在1993年还有人考古一样专门写论文挖出协程这种古老的技术。 因为这一时期还没有线程，如果你想在操作系统写出并发程序那么你将不得不使用类似协程这样的技术，后来线程开始出现，操作系统终于开始原生支持程序的并发执行，就这样，协程逐渐淡出了程序员的视线。 直到近些年，随着互联网的发展，尤其是移动互联网时代的到来，服务端对高并发的要求越来越高，协程再一次重回技术主流，各大编程语言都已经支持或计划开始支持协程。 那么协程到底是如何实现的呢？ 7、协程到底是如何实现的？ **让我们从问题的本质出发来思考这个问题：**协程的本质是什么呢？ 其实就是可以被暂停以及可以被恢复运行的函数。那么可以被暂停以及可以被恢复意味着什么呢？ 看过篮球比赛的同学想必都知道（没看过的也能知道），篮球比赛也是可以被随时暂停的，暂停时大家需要记住球在哪一方，各自的站位是什么，等到比赛继续的时候大家回到各自的位置，裁判哨子一响比赛继续，就像比赛没有被暂停过一样。 **看到问题的关键了吗：**比赛之所以可以被暂停也可以继续是因为比赛状态被记录下来了（站位、球在哪一方），这里的状态就是计算机科学中常说的上下文（context）。 回到协程。 协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文（状态）另外：函数运行时所有的状态信息都位于函数运行时栈中。 函数运行时栈就是我们需要保存的状态，也就是所谓的上下文。 如图所示： **从上图中我们可以看出：**该进程中只有一个线程，栈区中有四个栈帧，main函数调用A函数，A函数调用B函数，B函数调用C函数，当C函数在运行时整个进程的状态就如图所示。 **现在：**我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦。 既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？ **想一想这个问题：**整个进程的内存区中哪一块是专门用来长时间(进程生命周期)存储数据的？ **很显然：**这就是堆区啊（heap），我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new。 **我们需要做的就是：**在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态。 再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？ **实际上：**我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如下图所示。 **从上图中我们可以看到：**该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了。 有的可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？ **答案是：**这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的。 现在你应该看到了吧，在上图中实际上共有3个执行流： 1）一个普通线程； 2）两个协程。 虽然有3个执行流但我们创建了几个线程呢？ **答案是：**一个线程。 **现在你应该明白为什么要使用协程了吧：**使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在。 因此：即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的。 这也许是为什么协程这个概念比线程提出的要早的原因，可能是写普通应用的程序员比写操作系统的程序员最先遇到需要多个并行流的需求，那时可能都还没有操作系统的概念，或者操作系统没有并行这种需求，所以非操作系统程序员只能自己动手实现执行流，也就是协程。 8、协程技术概念小结 到底什么是协程呢？ 8.1 协程是比线程更小的执行单元 协程是比线程更小的一种执行单元，你可以认为是轻量级的线程。 **之所以说轻：**其中一方面的原因是协程所持有的栈比线程要小很多，java当中会为每个线程分配1M左右的栈空间，而协程可能只有几十或者几百K，栈主要用来保存函数参数、局部变量和返回地址等信息。 **我们知道：**而线程的调度是在操作系统中进行的，而协程调度则是在用户空间进行的，是开发人员通过调用系统底层的执行上下文相关api来完成的。有些语言，比如nodejs、go在语言层面支持了协程，而有些语言，比如C，需要使用第三方库才可以拥有协程的能力（比如微信开源的Libco库就是这样的）。 由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的。 使用协程是因为线程的切换成本比较高，而协程在这方面很有优势。 8.2 协程的切换到底为什么很廉价？ 关于这个问题，我们回顾一下线程切换的过程： 1）线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读入另外一个线程的数据，这个会花费一些时间； 2）CPU的高速缓存中的数据，也可能失效，需要重新加载； 3）线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都需要执行上千条指令，很耗时。 实际上协程的切换之所以快的原因我认为主要是： 1）在切换的时候，寄存器需要保存和加载的数据量比较小； 2）高速缓存可以有效利用； 3）没有用户模式到内核模式的切换操作； 4）更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的切换（为了尽量让用户感知不到某个线程卡）。 9、写在最后 写到这里，相信你已经理解协程到底是怎么一回事了，关于协程更系统的知识可以自行查阅相关资料。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-wu-shen-ru-cao-zuo-xi-tong-li-jie-gao-bing-fa-zhong-de-xie-cheng/"},{"title":"理解高性能、高并发(四)：深入操作系统，理解同步与异步","content":"1、编程中的同步调用 我们先说同步调用，这是程序员最熟悉的场景。 一般的函数调用都是同步的，就像这样： funcA() { // 等待函数funcB执行完成 funcB(); // 继续接下来的流程 } funcA调用funcB，那么在funcB执行完前，funcA中的后续代码都不会被执行，也就是说funcA必须等待funcB执行完成。 就像下图这样： ​ 从上图中我们可以看到，在funcB运行期间funcA什么都做不了，这就是典型的同步。 注意：一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的，这是最为常见的情况。 **但值得注意的是：**即使运行在两个不能线程中的函数也可以进行同步调用，像我们进行IO操作时实际上底层是通过系统调用的方式向操作系统发出请求的，比如磁盘文件读取： read(file, buf); 这就是我们在《深入操作系统，理解I/O与零拷贝技术》中描述的阻塞式I/O，在read函数返回前程序是无法继续向前推进的： read(file, buf); // 程序暂停运行， // 等待文件读取完成后继续运行 如下图所示： ​ 只有当read函数返回后程序才可以被继续执行。 **注意：**和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。 **因此：**我们可以得出结论，同步调用和函数与被调函数是否运行在同一个线程是没有关系的。 在这里我们还要再次强调：同步方式下函数和被调函数无法同时进行。 同步编程对程序员来说是最自然最容易理解的。 但容易理解的代价就是在一些场景下，同步并不是高效的，原因很简单，因为任务没有办法同时进行。 接下来我们看异步调用。 2、编程中的异步调用 有同步调用就有异步调用。 如果你真的理解了本节到目前为止的内容的话，那么异步调用对你来说不是问题。 **一般来说：**异步调用总是和I/O操作等耗时较高的任务如影随形，像磁盘文件读写、网络数据的收发、数据库操作等。 我们还是以磁盘文件读取为例。 在read函数的同步调用方式下，文件读取完之前调用方是无法继续向前推进的，但如果read函数可以异步调用情况就不一样了。 假如read函数可以异步调用的话，即使文件还没有读取完成，read函数也可以立即返回。 read(file, buff); // read函数立即返回 // 不会阻塞当前程序 就像下图这样： ​ **可以看到：**在异步这种调用方式下，调用方不会被阻塞，函数调用完成后可以立即执行接下来的程序。 这时异步的重点就在于：调用方接下来的程序执行可以和文件读取同时进行，从上图中我们也能看出这一点，这就是异步的高效之处。 **但是：**请注意，异步调用对于程序员来说在理解上是一种负担，代码编写上更是一种负担，总的来说，上帝在为你打开一扇门的时候会适当的关上一扇窗户。 有的可能会问，在同步调用下，调用方不再继续执行而是暂停等待，被调函数执行完后很自然的就是调用方继续执行，那么异步调用下调用方怎知道被调函数是否执行完成呢？ 这就分为了两种情况： 1）调用方根本就不关心执行结果； 2）调用方需要知道执行结果。 第一种情况比较简单，无需讨论。 第二种情况下就比较有趣了，通常有两种实现方式： 1）一种是通知机制：当任务执行完成后发送信号来通知调用方任务完成（这里的信号有很多实现方式：Linux中的signal，或使用信号量等机制都可实现）； 2）一种是回调机制：也就是我们常说的callback（关于回调我们将在下一篇文章中重点讲解，本篇会有简短的讨论）。 接下来我们用一个具体的例子讲解一下同步调用与异步调用。 3、具体的编程例子中理解同步和异步 3.1 一个具体的示例 我们以常见的Web服务来举例说明这一问题。 一般来说Web Server接收到用户请求后会有一些典型的处理逻辑，最常见的就是数据库查询（当然，你也可以把这里的数据库查询换成其它I/O操作，比如磁盘读取、网络通信等），在这里我们假定处理一次用户请求需要经过步骤A、B、C，然后读取数据库，数据库读取完成后需要经过步骤D、E、F。 就像这样： # 处理一次用户请求需要经过的步骤： A; B; C; 数据库读取; D； E； F； **其中：**步骤A、B、C和D、E、F不需要任何I/O，也就是说这六个步骤不需要读取文件、网络通信等，涉及到I/O操作的只有数据库查询这一步。 **一般来说：**这样的Web Server有两个典型的线程：主线程和数据库处理线程（注意：这讨论的只是典型的场景，具体业务实际上可会有差别，但这并不影响我们用两个线程来说明问题）。 首先我们来看下最简单的实现方式，也就是同步。 这种方式最为自然也最为容易理解： // 主线程 main_thread() { A; B; C; 发送数据库查询请求; D; E; F; } // 数据库线程 DataBase_thread() { while(1) { ​ 处理数据库读取请求; ​ 返回结果; } } 这就是最为典型的同步方法：主线程在发出数据库查询请求后就会被阻塞而暂停运行，直到数据库查询完毕后面的D、E、F才可以继续运行。 就像下图这样： ​ **从上图中我们可以看到：**主线程中会有“空隙”，这个空隙就是主线程的“休闲时光”，主线程在这段休闲时光中需要等待数据库查询完成才能继续后续处理流程。 在这里主线程就好比监工的老板，数据库线程就好比苦逼搬砖的程序员，在搬完砖前老板什么都不做只是紧紧的盯着你，等你搬完砖后才去忙其它事情。 **显然：**高效的程序员是不能容忍主线程偷懒的。 是时候祭出大杀器了，这就是异步： 在异步这种实现方案下主线程根本不去等待数据库是否查询完成，而是发送完数据库读写请求后直接处理下一个请求。 **有的同学可能会有疑问：**一个请求需要经过A、B、C、数据库查询、D、E、F这七个步骤，如果主线程在完成A、B、C、数据库查询后直接进行处理接下来的请求，那么上一个请求中剩下的D、E、F几个步骤怎么办呢？ 如果大家还没有忘记上一小节内容的话应该知道，这有两种情况，我们来分别讨论。 3.2 异步情况1：主线程不关心数据库操作结果 在这种情况下，主线程根本就不关心数据库是否查询完毕，数据库查询完毕后自行处理接下来的D、E、F三个步骤。 就像下图这样： ​ 我们说过一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？ 这时，我们的另一个主角回调函数就开始登场啦。 没错，回调函数就是用来解决这一问题的。 我们可以将处理D、E、F这几个步骤封装到一个函数中，假定将该函数命名为handle_DEF_after_DB_query。 伪码如下： void handle_DEF_after_DB_query () { D; E; F; } 这样主线程在发送数据库查询请求的同时将该函数一并当做参数传递过去： DB_query(request, handle_DEF_after_DB_query); 数据库线程处理完后直接调用handle_DEF_after_DB_query就可以了，这就是回调函数的作用。 也有的同学可能会有疑问，为什么这个函数要传递给数据库线程而不是数据库线程自己定义自己调用呢？ 因为从软件组织结构上讲，这不是数据库线程该做的工作。 数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心。 **你可以传入各种各样的回调函数：**也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。 **而从软件开发的角度看：**假设数据库线程逻辑封装为了库提供给其它团队，当数据库团队在研发时怎么可能知道数据库查询后该做什么呢？ 显**然：**只有使用方才知道查询完数据库后该做些什么，因此使用方在使用时简单的传入这个回调函数就可以了。 这样复杂数据库的团队就和使用方团队实现了所谓的解耦。 现在你应该明白回调函数的作用了吧。 **另外：**仔细观察上面两张图，你能看出为什么异步比同步高效吗？ 原因很简单，这也是我们在本篇提到过的，异步天然就无需等待，无依赖。 主线程处理请求和数据库处理查询请求可以同时进行，因此从系统性能上看，这样的设计能更加充分的利用系统资源，更加快速的处理请求；从用户的角度看，系统的响应也会更加迅速。 这就是异步的高效之处。 **但我们应该也可以看出：**异步编程并不如同步来的容易理解，系统可维护性上也不如同步模式。 那么有没有一种方法既能结合同步模式的容易理解又能结合异步模式的高效呢？答案是肯定的。 接下来我们看第二种情况，那就是主线程需要关心数据库查询结果。 3.3 异步情况2：主线程关心数据库操作结果 在这种情况下，数据库线程需要将查询结果利用通知机制发送给主线程，主线程在接收到消息后继续处理上一个请求的后半部分。 就像下图这样： ​ **从这里我们可以看到：**ABCDEF几个步骤全部在主线中处理，同时主线程同样也没有了“休闲时光”，只不过在这种情况下数据库线程是比较清闲的，从这里并没有上一种方法高效，但是依然要比同步模式下要高效。 **最后需要注意的是：**并不是所有的情况下异步都一定比同步高效，还需要结合具体业务以及IO的复杂度具体情况具体分析。 4、本文小结 在这篇文章中我们从各种场景分析了同步与异步这两个概念，但是不管在什么场景下，同步往往意味着双方要相互等待、相互依赖，而异步意味着双方相互独立、各行其是。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-si-shen-ru-cao-zuo-xi-tong-li-jie-tong-bu-yu-yi-bu/"},{"title":"理解高性能、高并发(三)：深入操作系统，彻底理解I/O多路复用","content":"1、什么是文件？ 在正式展开本文的内容之前，我们需要先预习一下文件以及文件描述符的概念。 程序员使用I/O最终都逃不过文件这个概念。 在Linux世界中文件是一个很简单的概念，作为程序员我们只需要将其理解为一个N byte的序列就可以了： b1, b2, b3, b4, ....... bN 实际上所有的I/O设备都被抽象为了文件这个概念，一切皆文件（Everything is File），磁盘、网络数据、终端，甚至进程间通信工具管道pipe等都被当做文件对待。 ​ 所有的I/O操作也都可以通过文件读写来实现，这一非常优雅的抽象可以让程序员使用一套接口就能对所有外设I/O操作。 常用的I/O操作接口一般有以下几类： 1）打开文件，open； 2）改变读写位置，seek； 3）文件读写，read、write； 4）关闭文件，close。 程序员通过这几个接口几乎可以实现所有I/O操作，这就是文件这个概念的强大之处。 2、什么是文件描述符？ 在上一篇《深入操作系统，理解I/O与零拷贝技术》中我们讲到：要想进行I/O读操作，像磁盘数据，我们需要指定一个buff用来装入数据。 一般都是这样写的： read(buff); 但是这里我们忽略了一个关键问题：那就是，虽然我们指定了往哪里写数据，但是我们该从哪里读数据呢？ 从上一节中我们知道，通过文件这个概念我们能实现几乎所有I/O操作，因此这里少的一个主角就是文件。 那么我们一般都怎样使用文件呢？ **举个例子：**如果周末你去比较火的餐厅吃饭应该会有体会，一般周末人气高的餐厅都会排队，然后服务员会给你一个排队序号，通过这个序号服务员就能找到你，这里的好处就是服务员无需记住你是谁、你的名字是什么、来自哪里、喜好是什么、是不是保护环境爱护小动物等等，这里的关键点就是：服务员对你一无所知，但依然可以通过一个号码就能找到你。 **同样的：**在Linux世界要想使用文件，我们也需要借助一个号码，根据“弄不懂原则”，这个号码就被称为了文件描述符（file descriptors），在Linux世界中鼎鼎大名，其道理和上面那个排队号码一样。 **因此：**文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。 ​ 有了文件描述符，进程可以对文件一无所知，比如文件在磁盘的什么位置、加载到内存中又是怎样管理的等等，这些信息统统交由操作系统打理，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。 因此我们来完善上述程序： int fd = open(file_name); // 获取文件描述符 read(fd, buff); 怎么样，是不是非常简单。 3、文件描述符太多了怎么办？ 经过了这么多的铺垫，终于要到高性能、高并发这一主题了。 从前几节我们知道，所有I/O操作都可以通过文件样的概念来进行，这当然包括网络通信。 如果你有一个IM服务器，当三次握手建议长连接成功以后，我们会调用accept来获取一个链接，调用该函数我们同样会得到一个文件描述符，通过这个文件描述符就可以处理客户端发送的聊天消息并且把消息转发给接收者。 也就是说，通过这个描述符我们就可以和客户端进行通信了： // 通过accept获取客户端的文件描述符 int conn_fd = accept(...); Server端的处理逻辑通常是接收客户端消息数据，然后执行转发（给接收者）逻辑： if(read(conn_fd, msg_buff) &gt; 0) { do_transfer(msg_buff); } 是不是非常简单，然而世界终归是复杂的，当然也不是这么简单的。 接下来就是比较复杂的了。 既然我们的主题是高并发，那么Server端就不可能只和一个客户端通信，而是可能会同时和成千上万个客户端进行通信。这时你需要处理不再是一个描述符这么简单，而是有可能要处理成千上万个描述符。 为了不让问题一上来就过于复杂，我们先简单化，假设只同时处理两个客户端的请求。 有的同学可能会说，这还不简单，这样写不就行了： if(read(socket_fd1, buff) &gt; 0) { // 处理第一个 do_transfer(); } if(read(socket_fd2, buff) &gt; 0) { // 处理第二个 do_transfer(); 在《[深入操作系统，理解I/O与零拷贝技术]》中我们讨论过，这是非常典型的阻塞式I/O，如果此时没有数据可读那么进程会被阻塞而暂停运行。这时我们就无法处理第二个请求了，即使第二个请求的数据已经就位，这也就意味着处理某一个客户端时由于进程被阻塞导致剩下的所有其它客户端必须等待，在同时处理几万客户端的server上。这显然是不能容忍的。 聪明的你一定会想到使用多线程：为每个客户端请求开启一个线程，这样一个客户端被阻塞就不会影响到处理其它客户端的线程了。注意：既然是高并发，那么我们要为成千上万个请求开启成千上万个线程吗，大量创建销毁线程会严重影响系统性能。 那么这个问题该怎么解决呢？ **这里的关键点在于：**我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。 因此要优雅的解决这个问题，就要从其它角度来思考这个问题了。 4、“不要打电话给我，有需要我会打给你” 大家生活中肯定会接到过推销电话，而且不止一个，一天下来接上十个八个推销电话你的身体会被掏空的。 这个场景的关键点在于：打电话的人并不知道你是不是要买东西，只能来一遍遍问你。因此一种更好的策略是不要让他们打电话给你，记下他们的电话，有需要的话打给他们，这样推销员就不会一遍一遍的来烦你了（虽然现实生活中这并不可能）。 **在这个例子中：**你，就好比内核，推销者就好比应用程序，电话号码就好比文件描述符，和你用电话沟通就好比I/O。 现在你应该明白了吧，处理多个文件描述符的更好方法其实就存在于推销电话中。 因此相比上一节中：我们通过I/O接口主动问内核这些文件描述符对应的外设是不是已经就绪了，一种更好的方法是，我们把这些感兴趣的文件描述符一股脑扔给内核，并霸气的告诉内核：“我这里有1万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？。。。” **这样：**应用程序就从“繁忙”的主动变为了清闲的被动，反正文件描述可读可写了内核会通知我，能偷懒我才不要那么勤奋。 这是一种更加高效的I/O处理机制，现在我们可以一次处理多路I/O了，为这种机制起一个名字吧，就叫I/O多路复用吧，这就是 I/O multiplexing。 5、I/O多路复用（I/O multiplexing） multiplexing一词其实多用于通信领域，为了充分利用通信线路，希望在一个信道中传输多路信号，要想在一个信道中传输多路信号就需要把这多路信号结合为一路，将多路信号组合成一个信号的设备被称为Multiplexer（多路复用器），显然接收方接收到这一路组合后的信号后要恢复原先的多路信号，这个设备被称为Demultiplexer（多路分用器）。 如下图所示： ​ 回到我们的主题。 所谓I/O多路复用指的是这样一个过程： 1）我们拿到了一堆文件描述符（不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以）； 2）通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回”； 3）当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。 也就是说通过I/O多路复用我们可以同时处理多路I/O。那么有哪些函数可以用来进行I/O多路复用呢？ 以Linux为例，有这样三种机制可以用来进行I/O多路复用： 1）select； 2）poll； 3）epoll。 接下来我们就来介绍一下I/O多路复用三剑客。 6、I/O多路复用三剑客 **本质上：**Linux上的select、poll、epoll都是阻塞式I/O，也就是我们常说的同步I/O。 原因在于：调用这些I/O多路复用函数时如果任何一个需要监视的文件描述符都不可读或者可写那么进程会被阻塞暂停执行，直到有文件描述符可读或者可写才继续运行。 6.1 select：初出茅庐 在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中。 我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个。因此程序员必须再遍历一边找到具体是哪个文件描述符可以读写了。 因此，总结下来select有这样几个特点： 1）我能照看的文件描述符数量有限，不能超过1024个； 2）用户给我的文件描述符需要拷贝的内核中； 3）我只能告诉你有文件描述符满足要求了，但是我不知道是哪个，你自己一个一个去找吧（遍历）。 因此我们可以看到，select机制的这些特性在高并发网络服务器动辄几万几十万并发链接的场景下无疑是低效的。 6.2 poll：小有所成 poll和select是非常相似的。 poll相对于select的优化仅仅在于解决了文件描述符不能超过1024个的限制，select和poll都会随着监控的文件描述数量增加而性能下降，因此不适合高并发场景。 6.3 epoll：独步天下 在select面临的三个问题中，文件描述数量限制已经在poll中解决了，剩下的两个问题呢？ 针对拷贝问题：epoll使用的策略是各个击破与共享内存。 **实际上：**文件描述符集合的变化频率比较低，select和poll频繁的拷贝整个集合，内核都快被烦死了，epoll通过引入epoll_ctl很体贴的做到了只操作那些有变化的文件描述符。同时epoll和内核还成为了好朋友，共享了同一块内存，这块内存中保存的就是那些已经可读或者可写的的文件描述符集合，这样就减少了内核和程序的拷贝开销。 针对需要遍历文件描述符才能知道哪个可读可写这一问题，epoll使用的策略是“当小弟”。 在select和poll机制下：进程要亲自下场去各个文件描述符上等待，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。 但epoll就懂事多了，主动找到进程。 **在这种机制下：**进程不需要亲自下场了，进程只要等待在epoll上，epoll代替进程去各个文件描述符上等待，当哪个文件描述符可读或者可写的时候就告诉epoll，epoll用小本本认真记录下来然后唤醒大哥：“进程大哥，快醒醒，你要处理的文件描述符我都记下来了”，这样进程被唤醒后就无需自己从头到尾检查一遍，因为epoll小弟都已经记下来了。 因此我们可以看到：在epoll这种机制下，实际上利用的就是“不要打电话给我，有需要我会打给你”这种策略，进程不需要一遍一遍麻烦的问各个文件描述符，而是翻身做主人了——“你们这些文件描述符有哪个可读或者可写了主动报上来”。 这种机制实际上就是大名鼎鼎的事件驱动——Event-driven，这也是我们下一篇的主题。 **实际上：**在Linux平台，epoll基本上就是高并发的代名词。 7、本文小结 基于一切皆文件的设计哲学，I/O也可以通过文件的形式实现，高并发场景下要与多个文件交互，这就离不开高效的I/O多路复用技术。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-san-shen-ru-cao-zuo-xi-tong-che-di-li-jie-io-duo-lu-fu-yong/"},{"title":"理解高性能、高并发(二)：深入操作系统，理解I/O与零拷贝技术","content":"1、不能执行I/O的计算机是什么？ 相信对于程序员来说I/O操作是最为熟悉不过的了，比如： 1）当我们使用C语言中的printf、C++中的&quot;&lt;&lt;&quot;，Python中的print，Java中的System.out.println等时； 2）当我们使用各种语言读写文件时； 3）当我们通过TCP/IP进行网络通信时； 4）当我们使用鼠标龙飞凤舞时； 5）当我们拿起键盘在评论区指点江山亦或是埋头苦干努力制造bug时； 6）当我们能看到屏幕上的漂亮的图形界面时等等。 以上这一切，都是I/O！ **想一想：**如果没有I/O计算机该是一种多么枯燥的设备，不能看电影、不能玩游戏，也不能上网，这样的计算机最多就是一个大号的计算器。 既然I/O这么重要，那么到底什么才是I/O呢？ 2、什么是I/O？ I/O就是简单的数据Copy，仅此而已！ 这一点很重要！ 既然是copy数据，那么又是从哪里copy到哪里呢？ 如果数据是从外部设备copy到内存中，这就是Input。 如果数据是从内存copy到外部设备，这就是Output。 内存与外部设备之间不嫌麻烦的来回copy数据就是Input and Output，简称I/O（Input/Output），仅此而已。 3、I/O与CPU 现在我们知道了什么是I/O，接下来就是重点部分了。 我们知道现在的CPU其主频都是数GHz起步，这是什么意思呢？ **简单说就是：**CPU执行机器指令的速度是纳秒级别的，而通常的I/O比如磁盘操作，一次磁盘seek大概在毫秒级别，因此如果我们把CPU的速度比作战斗机的话，那么I/O操作的速度就是肯德鸡。 也就是说当我们的程序跑起来时（CPU执行机器指令），其速度是要远远快于I/O速度的。那么接下来的问题就是二者速度相差这么大，那么我们该如何设计、该如何更加合理的高效利用系统资源呢？ 既然有速度差异，而且进程在执行完I/O操作前不能继续向前推进，那么显然只有一个办法，那就是等待（wait）。 同样是等待，有聪明的等待，也有傻傻的等待，简称傻等，那么是选择聪明的等待呢还是选择傻等呢？ 假设你是一个急性子（CPU），需要等待一个重要的文件，不巧的是这个文件只能快递过来（I/O），那么这时你是选择什么事情都不干了，深情的注视着门口就像盼望着你的哈尼一样专心等待这个快递呢？还是暂时先不要管快递了，玩个游戏看个电影刷会儿短视频等快递来了再说呢？ 很显然，更好的方法就是先去干其它事情，快递来了再说。 **因此：**这里的关键点就是快递没到前手头上的事情可以先暂停，切换到其它任务，等快递过来了再切换回来。 理解了这一点你就能明白执行I/O操作时底层都发生了什么。 接下来让我们以读取磁盘文件为例来讲解这一过程。 4、执行I/O时底层都发生了什么 在支持线程的操作系统中，实际上被调度的是线程而不是进程，为了更加清晰的理解I/O过程，我们暂时假设操作系统只有进程这样的概念，先不去考虑线程，这并不会影响我们的讨论。 现在内存中有两个进程，进程A和进程B，当前进程A正在运行。 如下图所示： 进程A中有一段读取文件的代码，不管在什么语言中通常我们定义一个用来装数据的buff，然后调用read之类的函数。 就像这样： read(buff); 这就是一种典型的I/O操作，当CPU执行到这段代码的时候会向磁盘发送读取请求。 **注意：**与CPU执行指令的速度相比，I/O操作操作是非常慢的，因此操作系统是不可能把宝贵的CPU计算资源浪费在无谓的等待上的，这时重点来了，注意接下来是重点哦。 由于外部设备执行I/O操作是相当慢的，因此在I/O操作完成之前进程是无法继续向前推进的，这就是所谓的阻塞，即通常所说的block。 操作系统检测到进程向I/O设备发起请求后就暂停进程的运行，怎么暂停运行呢？**很简单：**只需要记录下当前进程的运行状态并把CPU的PC寄存器指向其它进程的指令就可以了。 进程有暂停就会有继续执行，因此操作系统必须保存被暂停的进程以备后续继续执行，显然我们可以用队列来保存被暂停执行的进程。 如下图所示，进程A被暂停执行并被放到阻塞队列中（**注意：**不同的操作系统会有不同的实现，可能每个I/O设备都有一个对应的阻塞队列，但这种实现细节上的差异不影响我们的讨论）。 这时操作系统已经向磁盘发送了I/O请求，因此磁盘driver开始将磁盘中的数据copy到进程A的buff中。虽然这时进程A已经被暂停执行了，但这并不妨碍磁盘向内存中copy数据。 **注意：**现代磁盘向内存copy数据时无需借助CPU的帮助，这就是所谓的DMA（Direct Memory Access）。 这个过程如下图所示： 让磁盘先copy着数据，我们接着聊。 **实际上：**操作系统中除了有阻塞队列之外也有就绪队列，所谓就绪队列是指队列里的进程准备就绪可以被CPU执行了。 你可能会问为什么不直接执行非要有个就绪队列呢？**答案很简单：**那就是僧多粥少，在即使只有1个核的机器上也可以创建出成千上万个进程，CPU不可能同时执行这么多的进程，因此必然存在这样的进程，即使其一切准备就绪也不能被分配到计算资源，这样的进程就被放到了就绪队列。 现在进程B就位于就绪队列，万事俱备只欠CPU。 如下图所示： 当进程A被暂停执行后CPU是不可以闲下来的，因为就绪队列中还有嗷嗷待哺的进程B，这时操作系统开始在就绪队列中找下一个可以执行的进程，也就是这里的进程B。 此时操作系统将进程B从就绪队列中取出，找出进程B被暂停时执行到的机器指令的位置，然后将CPU的PC寄存器指向该位置，这样进程B就开始运行啦。 如下图所示： **注意：**接下来的这段是重点中的重点！ **注意观察上图：**此时进程B在被CPU执行，磁盘在向进程A的内存空间中copy数据，看出来了吗——大家都在忙，谁都没有闲着，数据copy和指令执行在同时进行，在操作系统的调度下，CPU、磁盘都得到了充分的利用，这就是程序员的智慧所在。 现在你应该理解为什么操作系统这么重要了吧。 此后磁盘终于将全部数据都copy到了进程A的内存中，这时磁盘通知操作系统任务完成啦，你可能会问怎么通知呢？这就是中断。 操作系统接收到磁盘中断后发现数据copy完毕，进程A重新获得继续运行的资格，这时操作系统小心翼翼的把进程A从阻塞队列放到了就绪队列当中。 如下图所示： **注意：**从前面关于就绪状态的讨论中我们知道，操作系统是不会直接运行进程A的，进程A必须被放到就绪队列中等待，这样对大家都公平。 此后进程B继续执行，进程A继续等待，进程B执行了一会儿后操作系统认为进程B执行的时间够长了，因此把进程B放到就绪队列，把进程A取出并继续执行。 **注意：**操作系统把进程B放到的是就绪队列，因此进程B被暂停运行仅仅是因为时间片到了而不是因为发起I/O请求被阻塞。 如下图所示： 进程A继续执行，此时buff中已经装满了想要的数据，进程A就这样愉快的运行下去了，就好像从来没有被暂停过一样，进程对于自己被暂停一事一无所知，这就是操作系统的魔法。 现在你应该明白了I/O是一个怎样的过程了吧。 这种进程执行I/O操作被阻塞暂停执行的方式被称为阻塞式I/O，blocking I/O，这也是最常见最容易理解的I/O方式，有阻塞式I/O就有非阻塞式I/O，在这里我们暂时先不考虑这种方式。 在本节开头我们说过暂时只考虑进程而不考虑线程，现在我们放宽这个条件，实际上也非常简单，只需要把前图中调度的进程改为线程就可以了，这里的讨论对于线程一样成立。 5、零拷贝（Zero-copy） **最后需要注意的一点就是：**上面的讲解中我们直接把磁盘数据copy到了进程空间中，但实际上一般情况下I/O数据是要首先copy到操作系统内部，然后操作系统再copy到进程空间中。 因此我们可以看到这里其实还有一层经过操作系统的copy，对于性能要求很高的场景其实也是可以绕过操作系统直接进行数据copy的，这也是本文描述的场景，这种绕过操作系统直接进行数据copy的技术被称为Zero-copy，也就零拷贝，高并发、高性能场景下常用的一种技术，原理上很简单吧。 6、本文小结 本文讲解的是程序员常用的I/O（包括所谓的网络I/O），一般来说作为程序员我们无需关心，但是理解I/O背后的底层原理对于设计比如IM这种高性能、高并发系统是极为有益的。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-er-shen-ru-cao-zuo-xi-tong-li-jie-io-yu-ling-kao-bei-ji-zhu/"},{"title":"理解高性能、高并发(一)：深入计算机底层，理解线程与线程池","content":"1、一切要从CPU说起 你可能会有疑问，讲多线程为什么要从CPU说起呢？原因很简单，在这里没有那些时髦的概念，你可以更加清晰的看清问题的本质。 实际情况是：CPU并不知道线程、进程之类的概念。 CPU只知道两件事： 1）从内存中取出指令； 2）执行指令，然后回到 1）。 你看，在这里CPU确实是不知道什么进程、线程之类的概念。 接下来的问题就是CPU从哪里取出指令呢？答案是来自一个被称为Program Counter（简称PC）的寄存器，也就是我们熟知的程序计数器，在这里大家不要把寄存器想的太神秘，你可以简单的把寄存器理解为内存，只不过存取速度更快而已。 PC寄存器中存放的是什么呢？这里存放的是指令在内存中的地址，什么指令呢？是CPU将要执行的下一条指令。 ​ 那么是谁来设置PC寄存器中的指令地址呢？ 原来PC寄存器中的地址默认是自动加1的，这当然是有道理的，因为大部分情况下CPU都是一条接一条顺序执行，当遇到if、else时，这种顺序执行就被打破了，CPU在执行这类指令时会根据计算结果来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。 聪明的你一定会问，那么PC中的初始值是怎么被设置的呢？ 在回答这个问题之前我们需要知道CPU执行的指令来自哪里？是来自内存，废话，内存中的指令是从磁盘中保存的可执行程序加载过来的，磁盘中可执行程序是编译器生成的，编译器又是从哪里生成的机器指令呢？答案就是我们定义的函数。 ​ 注意是函数，函数被编译后才会形成CPU执行的指令，那么很自然的，我们该如何让CPU执行一个函数呢？显然我们只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。 现在你应该知道了吧，我们想要CPU执行一个函数，那么只需要把该函数对应的第一条机器指令的地址写入PC寄存器就可以了，这样我们写的函数就开始被CPU执行起来啦。 你可能会有疑问，这和线程有什么关系呢？ 2、从CPU到操作系统 上一小节中我们明白了CPU的工作原理，我们想让CPU执行某个函数，那么只需要把函数对应的第一条机器执行装入PC寄存器就可以了，这样即使没有操作系统我们也可以让CPU执行程序，虽然可行但这是一个非常繁琐的过程。 我们需要： 1）在内存中找到一块大小合适的区域装入程序； 2）找到函数入口，设置好PC寄存器让CPU开始执行程序。 这两个步骤绝不是那么容易的事情，如果每次在执行程序时程序员自己手动实现上述两个过程会疯掉的，因此聪明的程序员就会想干脆直接写个程序来自动完成上面两个步骤吧。 机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地址并写到PC寄存器中，想一想这是不是需要一个数据结构来记录下这些信息。 数据结构大致如下： struct *** { void* start_addr; intlen; void* start_point; ... }; 接下来就是起名字时刻。 这个数据结构总要有个名字吧，这个结构体用来记录什么信息呢？记录的是程序在被加载到内存中的运行状态，程序从磁盘加载到内存跑起来叫什么好呢？干脆就叫进程（Process）好了，我们的指导原则就是一定要听上去比较神秘，总之大家都不容易弄懂就对了，我将其称为“弄不懂原则”。 就这样进程诞生了。 CPU执行的第一个函数也起个名字，第一个要被执行的函数听起来比较重要，干脆就叫main函数吧。 完成上述两个步骤的程序也要起个名字，根据“弄不懂原则”这个“简单”的程序就叫操作系统（Operating System）好啦。 就这样操作系统诞生了，程序员要想运行程序再也不用自己手动加载一遍了。 现在进程和操作系统都有了，一切看上去都很完美。 3、从单核到多核，如何充分利用多核 人类的一大特点就是生命不息折腾不止，从单核折腾到了多核。 ​ 这时，假设我们想写一个程序并且要分利用多核该怎么办呢？ 有的同学可能会说不是有进程吗，多开几个进程不就可以了？ 听上去似乎很有道理，但是主要存在这样几个问题： 1）进程是需要占用内存空间的(从上一节能看到这一点)，如果多个进程基于同一个可执行程序，那么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费； 2）计算机处理的任务可能是比较复杂的，这就涉及到了进程间通信，由于各个进程处于不同的内存地址空间，进程间通信天然需要借助操作系统，这就在增大编程难度的同时也增加了系统开销。 该怎么办呢？ 4、从进程到线程 让我再来仔细的想一想这个问题，所谓进程无非就是内存中的一段区域，这段区域中保存了CPU执行的机器指令以及函数运行时的堆栈信息，要想让进程运行，就把main函数的第一条机器指令地址写入PC寄存器，这样进程就运行起来了。 ​ 进程的缺点在于只有一个入口函数，也就是main函数，因此进程中的机器指令只能被一个CPU执行，那么有没有办法让多个CPU来执行同一个进程中的机器指令呢？ 聪明的你应该能想到，既然我们可以把main函数的第一条指令地址写入PC寄存器，那么其它函数和main函数又有什么区别呢？ 答案是没什么区别，main函数的特殊之处无非就在于是CPU执行的第一个函数，除此之外再无特别之处，我们可以把PC寄存器指向main函数，就可以把PC寄存器指向任何一个函数。 当我们把PC寄存器指向非main函数时，线程就诞生了。 ​ 至此我们解放了思想，一个进程内可以有多个入口函数，也就是说属于同一个进程中的机器指令可以被多个CPU同时执行。 **注意：**这是一个和进程不同的概念，创建进程时我们需要在内存中找到一块合适的区域以装入进程，然后把CPU的PC寄存器指向main函数，也就是说进程中只有一个执行流。 ​ 但是现在不一样了，多个CPU可以在同一个屋檐下(进程占用的内存区域)同时执行属于该进程的多个入口函数，也就是说现在一个进程内可以有多个执行流了。 ​ 总是叫执行流好像有点太容易理解了，再次祭出”弄不懂原则“，起个不容易懂的名字，就叫线程吧。 这就是线程的由来。 操作系统为每个进程维护了一堆信息，用来记录进程所处的内存空间等，这堆信息记为数据集A。 同样的，操作系统也需要为线程维护一堆信息，用来记录线程的入口函数或者栈信息等，这堆数据记为数据集B。 显然数据集B要比数据A的量要少，同时不像进程，创建一个线程时无需去内存中找一段内存空间，因为线程是运行在所处进程的地址空间的，这块地址空间在程序启动时已经创建完毕，同时线程是程序在运行期间创建的（进程启动后），因此当线程开始运行的时候这块地址空间就已经存在了，线程可以直接使用。这就是为什么各种教材上提的创建线程要比创建进程快的原因（当然还有其它原因）。 值得注意的是，有了线程这个概念后，我们只需要进程开启后创建多个线程就可以让所有CPU都忙起来，这就是所谓高性能、高并发的根本所在。 ​ 很简单，只需要创建出数量合适的线程就可以了。 另外值得注意的一点是：由于各个线程共享进程的内存地址空间，因此线程之间的通信无需借助操作系统，这给程序员带来极大方便的同时也带来了无尽的麻烦，多线程遇到的多数问题都出自于线程间通信简直太方便了以至于非常容易出错。出错的根源在于CPU执行指令时根本没有线程的概念，多线程编程面临的互斥与同步问题需要程序员自己解决，关于互斥与同步问题限于篇幅就不详细展开了，大部分的操作系统资料都有详细讲解。 最后需要提醒的是：虽然前面关于线程讲解使用的图中用了多个CPU，但不是说一定要有多核才能使用多线程，在单核的情况下一样可以创建出多个线程，原因在于线程是操作系统层面的实现，和有多少个核心是没有关系的，CPU在执行机器指令时也意识不到执行的机器指令属于哪个线程。即使在只有一个CPU的情况下，操作系统也可以通过线程调度让各个线程“同时”向前推进，方法就是将CPU的时间片在各个线程之间来回分配，这样多个线程看起来就是“同时”运行了，但实际上任意时刻还是只有一个线程在运行。 5、线程与内存 在前面的讨论中我们知道了线程和CPU的关系，也就是把CPU的PC寄存器指向线程的入口函数，这样线程就可以运行起来了，这就是为什么我们创建线程时必须指定一个入口函数的原因。 无论使用任何编程语言，创建一个线程大体相同： // 设置线程入口函数DoSomething thread = CreateThread(DoSomething); // 让线程运行起来 thread.Run(); 那么线程和内存又有什么关联呢？ 我们知道函数在被执行的时产生的数据包括：函数参数、局部变量、返回地址等信息。这些信息是保存在栈中的，线程这个概念还没有出现时进程中只有一个执行流，因此只有一个栈，这个栈的栈底就是进程的入口函数，也就是main函数。 假设main函数调用了funA，funcA又调用了funcB，如图所示： ​ 那么有了线程以后了呢？ 有了线程以后一个进程中就存在多个执行入口，即同时存在多个执行流，那么只有一个执行流的进程需要一个栈来保存运行时信息，那么很显然有多个执行流时就需要有多个栈来保存各个执行流的信息，也就是说操作系统要为每个线程在进程的地址空间中分配一个栈，即每个线程都有独属于自己的栈，能意识到这一点是极其关键的。 ​ 同时我们也可以看到，创建线程是要消耗进程内存空间的，这一点也值得注意。 6、线程的使用 现在有了线程的概念，那么接下来作为程序员我们该如何使用线程呢？ 从生命周期的角度讲，线程要处理的任务有两类：长任务和短任务。 *1）长任务（long-lived tasks）：* 顾名思义，就是任务存活的时间很长，比如以我们常用的word为例，我们在word中编辑的文字需要保存在磁盘上，往磁盘上写数据就是一个任务，那么这时一个比较好的方法就是专门创建一个写磁盘的线程，该写线程的生命周期和word进程是一样的，只要打开word就要创建出该写线程，当用户关闭word时该线程才会被销毁，这就是长任务。 ​ 这种场景非常适合创建专用的线程来处理某些特定任务，这种情况比较简单。 有长任务，相应的就有短任务。 *2）短任务（short-lived tasks）：* 这个概念也很简单，那就是任务的处理时间很短，比如一次网络请求、一次数据库查询等，这种任务可以在短时间内快速处理完成。因此短任务多见于各种Server，像web server、database server、file server、mail server等，这也是互联网行业的同学最常见的场景，这种场景是我们要重点讨论的。 **这种场景有两个特点：**一个是任务处理所需时间短；另一个是任务数量巨大。 如果让你来处理这种类型的任务该怎么办呢？ 你可能会想，这很简单啊，当server接收到一个请求后就创建一个线程来处理任务，处理完成后销毁该线程即可，So easy。 这种方法通常被称为thread-per-request，也就是说来一个请求就创建一个线程： ​ 如果是长任务，那么这种方法可以工作的很好，但是对于大量的短任务这种方法虽然实现简单但是有缺点。 具体是以下这样的缺点： 1）从前几节我们能看到，线程是操作系统中的概念(这里不讨论用户态线程实现、协程之类)，因此创建线程天然需要借助操作系统来完成，操作系统创建和销毁线程是需要消耗时间的； 2）每个线程需要有自己独立的栈，因此当创建大量线程时会消耗过多的内存等系统资源。 这就好比你是一个工厂老板（想想都很开心有没有），手里有很多订单，每来一批订单就要招一批工人，生产的产品非常简单，工人们很快就能处理完，处理完这批订单后就把这些千辛万苦招过来的工人辞退掉，当有新的订单时你再千辛万苦的招一遍工人，干活儿5分钟招人10小时，如果你不是励志要让企业倒闭的话大概是不会这么做到的。 因此一个更好的策略就是招一批人后就地养着，有订单时处理订单，没有订单时大家可以闲呆着。 这就是线程池的由来。 7、从多线程到线程池 线程池的概念是非常简单的，无非就是创建一批线程，之后就不再释放了，有任务就提交给这些线程处理，因此无需频繁的创建、销毁线程，同时由于线程池中的线程个数通常是固定的，也不会消耗过多的内存，因此这里的思想就是复用、可控。 8、线程池是如何工作的 可能有的同学会问，该怎么给线程池提交任务呢？这些任务又是怎么给到线程池中线程呢？ 很显然，数据结构中的队列天然适合这种场景，提交任务的就是生产者，消费任务的线程就是消费者，实际上这就是经典的生产者-消费者问题。 ​ 现在你应该知道为什么操作系统课程要讲、面试要问这个问题了吧，因为如果你对生产者-消费者问题不理解的话，本质上你是无法正确的写出线程池的。 限于篇幅在这里不打算详细的讲解生产者消费者问题，参考操作系统相关资料就能获取答案。这里我打算讲一讲一般提交给线程池的任务是什么样子的。 一般来说提交给线程池的任务包含两部分： 需要被处理的数据； 处理数据的函数。 伪码描述一下： struct task { void* data; // 任务所携带的数据 handler handle; // 处理数据的方法 } （注意：你也可以把代码中的struct理解成class，也就是对象) 线程池中的线程会阻塞在队列上，当生产者向队列中写入数据后，线程池中的某个线程会被唤醒，该线程从队列中取出上述结构体(或者对象)，以结构体(或者对象)中的数据为参数并调用处理函数。 伪码如下： while(true) { struct task = GetFromQueue(); // 从队列中取出数据 task-&gt;handle(task-&gt;data); // 处理数据 } 以上就是线程池最核心的部分。 理解这些你就能明白线程池是如何工作的了。 9、线程池中线程的数量 现在线程池有了，那么线程池中线程的数量该是多少呢？ 在接着往下看前先自己想一想这个问题。如果你能看到这里说明还没有睡着。 要知道线程池的线程过少就不能充分利用CPU，线程创建的过多反而会造成系统性能下降，内存占用过多，线程切换造成的消耗等等。因此线程的数量既不能太多也不能太少，那到底该是多少呢？ 回答这个问题，你需要知道线程池处理的任务有哪几类，有的同学可能会说你不是说有两类吗？长任务和短任务，这个是从生命周期的角度来看的，那么从处理任务所需要的资源角度看也有两种类型，这就是没事儿找抽型。。。啊不，是CPU密集型和I/O密集型。 *1）CPU密集型：* 所谓CPU密集型就是说处理任务不需要依赖外部I/O，比如科学计算、矩阵运算等等。在这种情况下只要线程的数量和核数基本相同就可以充分利用CPU资源。 ​ *2）I/O密集型：* 这一类任务可能计算部分所占用时间不多，大部分时间都用在了比如磁盘I/O、网络I/O等。 ​ 这种情况下就稍微复杂一些了，你需要利用性能测试工具评估出用在I/O等待上的时间，这里记为WT(wait time)，以及CPU计算所需要的时间，这里记为CT（computing time），那么对于一个N核的系统，合适的线程数大概是 N * (1 + WT/CT) ，假设I/O等待时间和计算时间相同，那么你大概需要2N个线程才能充分利用CPU资源，注意这只是一个理论值，具体设置多少需要根据真实的业务场景进行测试。 当然充分利用CPU不是唯一需要考虑的点，随着线程数量的增多，内存占用、系统调度、打开的文件数量、打开的socker数量以及打开的数据库链接等等是都需要考虑的。 因此这里没有万能公式，要具体情况具体分析。 10、线程池不是万能的 线程池仅仅是多线程的一种使用形式，因此多线程面临的问题线程池同样不能避免，像死锁问题、race condition问题等等，关于这一部分同样可以参考操作系统相关资料就能得到答案。 11、线程池使用的最佳实践 线程池是程序员手中强大的武器，互联网公司的各个server上几乎都能见到线程池的身影。 但使用线程池前你需要考虑： 1）充分理解你的任务，是长任务还是短任务、是CPU密集型还是I/O密集型，如果两种都有，那么一种可能更好的办法是把这两类任务放到不同的线程池中，这样也许可以更好的确定线程数量； 2）如果线程池中的任务有I/O操作，那么务必对此任务设置超时，否则处理该任务的线程可能会一直阻塞下去； 3）线程池中的任务最好不要同步等待其它任务的结果。 12、本文小结 本文我们从CPU开始一路来到常用的线程池，从底层到上层、从硬件到软件。 注意：这里通篇没有出现任何特定的编程语言，线程不是语言层面的概念（依然不考虑用户态线程），但是当你真正理解了线程后，相信你可以在任何一门语言下用好多线程，你需要理解的是道，此后才是术。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-yi-shen-ru-ji-suan-ji-di-ceng-li-jie-xian-cheng-yu-xian-cheng-chi/"},{"title":"Node–异步I/O解析","content":"“异步”这个名词其实在Node之前就已经诞生了。但是在绝大多数高级编程语言中，异步并不多见。在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。 异步I/O、事件驱动和单线程构成了Node的基调，而Nginx与Node的事件驱动、异步I/O设计理念比较相近。Nginx采用纯C编写，性能表现非常优异，具备面向客户端管理连接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。 为什么要异步I/O 为什么异步I/O在Node中如此重要，这是因为Node面向网络设计，在跨网络的结构下，并发已经是现代编程中的标准配备了。 用户体验 《高性能JavaScript》中提到过，如果脚本的执行时间超过100毫秒，用户就会感到页面卡顿，以为页面停止响应。而在B/S模型中，网络速度的限制给网页的实时体验造成很大的麻烦。 如果网页临时需要获取一个资源，通过同步的方式获取，那么JavaScript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI停顿，不响应用户的交互行为。这样用户体验将会极差。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。 同理，前端通过异步可以消除掉UI阻塞现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源消耗M毫秒，第二个资源消耗N毫秒。如果采用同步的方式，获取两个资源消耗的的时间为M+N毫秒。而采用异步的方式，第一个资源的获取并不会阻塞第二个资源的获取，消耗的时间为max(M,N)。 随着网站或应用不断膨胀，M与N的值会线性增长，那么异步的性能将比同步更加优越。 资源分配 假设业务场景中有一组互不相关的任务需要完成，有以下两种主流的方法： 单线程串行一次执行 多线程并行完成 如果创建多线程的开销小于并行执行，那么多线程是首选的，但是多线程在创建线程和执行期线程上下文切换的开销较大，而且多线程编程经常面临锁、状态同步等问题。 单线程顺序执行任务的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行执行的，但是同步的编程模型导致I/O的进行会让后续任务等待，造成资源不能被更好的利用。 Node利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，更好的利用CPU。 异步I/O实现 异步I/O在Node中应用最为广泛，但是它并不是Node的原创。 异步I/O与非阻塞I/O 对于计算机内核I/O而言，异步/同步和阻塞/非阻塞是两码事。 操作系统对于I/O只有两种方式：阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。 阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。 为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回，非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时提升性能是明显的，但是由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前的调用状态。 为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询。 现存的轮询技术主要有read、select、poll、epoll和kqueue。这里只讲一下epoll的轮询原理。 epoll是Linux下效率最高的I/O事件通知机制，在进入轮询的时候，如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件的通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。 轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于程序而言，它仍然算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间等待。等待期间，CPU要么用于遍历文件描述符，要么用于休眠等待时间发生。 现实的异步I/O 通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（虽然这是模拟的） 但是最初，Node在*nix 平台下采用了libeio配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O。 而Windows下的IOCP在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。但是它的内部其实依然是线程池原理，不同之处在于这些线程池有系统内核接手管理。 由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间个字独立。 我们时常提到Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。 Node的异步I/O 完成整个异步I/O环节的有事件循环、观察者和请求对象等。 事件循环 事件循环是Node自身的执行模型，正式它使得回调函数十分普遍。 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者 每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 在Node中，事件主要来源于网络请求、文件I/O等，这些时间对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。 事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。 请求对象 对于Node的异步I/O调用而言，回调函数不由开发者来调用。从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种产物，叫做请求对象 下面用fs.open()方法作为一个小小的例子。 fs.open = function(path,flags,mode,callback){ //... binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback); } fs.open()的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初试操作。JavaScript层面的代码通过调用C++核心模块进行下层的操作。 从事JavaScript调用Node的核心模块，核心模块调用C++模块，内建模块通过libuv进行系统调用，这里是Node里经典的调用方式。这里libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uv_fs_open()的调用过程中，将从JavaScript层传入的参数和当前方法都封装在一个请求对象中，回调函数则被设置在这个对象的属性上。对象包装完毕后，将对象推入线程池等待执行。 至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。 请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。 执行回调 组装好请求对象、送入I/O线程池等待执行，只是完成一部I/O的第一部分，回调通知是第二部分。 线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueueCompletionStatus()通知IOCP，告知当前对象操作已经完成。 至此，整个异步I/O的流程完全结束。 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 小结 整理下来，我们可以提取异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。单线程和线程池看起来有些悖论的样子。因为JavaScript是单线程的，所以很容易理解为它不能充分利用多核CPU。实际上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。还有就是除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）都是可以并行起来的。 ","link":"https://kangjn.github.io/post/node-yi-bu-io-jie-xi/"},{"title":"计算机网络 — TCP的三次握手、四次挥手","content":"TCP 头部标识符意义解读 SYN：建立连接 SYN=1，ACK=0 表示一个连接请求 SYN=1，ACK=1 表示同意建立一个连接 FIN：关闭连接 FIN=1 表示发端完成发送任务 注意：表明发送方已经没有数据发送 但不代表之前的数据发送完毕 ACK：置1时表示确认 seq：发送序列号 ack (number)：确认码 更多关于TCP 和 UDP 的详细内容见 计算机网络系列 -- TCP和UDP TCP 三次握手 过程通俗理解 A—&gt;B B收到，B—&gt;A A收到 过程的详细解读 （1） 第一次握手：客户端发送【SYN = 1，随机序列号seq = x】的数据包到服务器,服务器由【SYN = 1】知道客户端要建立连接；此时客户端进入已发送状态，等待服务器确认 （2） 第二次握手：服务器向客户端发送标【SYN = 1，ACK = 1】和【随机序列号seq = y, 确认码ack number = x+1】的数据包；此时服务器进入已收到状态 （3） 第三次握手：客户端收到后判断【ACK=1】和【收的ack number =发的seq+1】； 若正确，客户端发送标识位【ACK = 1、seq = x + 1】和【确认码ack number = y + 1】（服务器发送的seq+1）到服务器； 服务器收到后判断【ACK=1】和【收的ack number =发的seq+1】是否正确； 若正确则完成建立连接，此包发送完毕。此时客户端和服务器进入已连接状态，完成三次握手，客户端与服务器开始传送数据 TCP 三次握手的目的 建立客户端和服务器之间的连接，确认各自的收发能力是否正常 对准好 TCP 包的序号问题，为保证可靠传送 如果是 https 协议，还会进行解密加密 HTTPS解密解密过程见 计算机网络系列 -- HTTPS加密解密过程 为什么要三次握手而不是两次？ 这句话可以转化为第三次握手的意义是什么？ 第三次握手的意义在于：`让服务器知道客户端也收到了自己的同步信号` 通俗理解 两次握手只能保证`单向`：只知道A能向B发送数据 三次握手能保证`双向`：保证A也能收到B发送的数据 第三次握手失败了怎么办？ server端发送了SYN+ACK报文后就会启动一个定时器，等待client返回的ACK报文。如果第三次握手失败的话client给server返回了ACK报文，server并不能收到这个ACK报文。那么server端就会启动超时重传机制，超过规定时间后重新发送SYN+ACK，重传次数默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，server自动关闭这个连接。但是client认为这个连接已经建立，如果client端向server写数据，server端将发送RTS报文段，以防止syn洪泛攻击。 syn洪泛攻击 通俗的理解是：当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为dos（deny of service）攻击埋下隐患，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，server就会为这些syn包分配资源（但并未使用），就会使server占用大量内存，使server连接环境耗尽，这就是syn洪泛攻击 为什么要三次握手而不是四次？ 四次握手的过程： 第一次：客户端发送【SYN = 1，随机序列号seq = u】到服务器，用来请求开启客户A到服务器B的数据传送； 第二次：服务器B收到这个SYN，它发回【ACK = 1、确认序号ack=u+1】表示同意； 第三次：服务器开启与客户端的连接，发回标识位【SYN = 1，ACK = 1,，确认码ack =u+1】给客户端； 第四次：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。 很明显，第二次和第三次没有分开的必要，可以合并，而且还能提高建立连接时的效率 TCP 四次挥手 过程通俗理解 A：B 啊，我不想玩了 B：好，知道了，等一下哈，我这边还没好 【注意】这时，只是A不想玩了，即不再发送数据。但是B可能还有未发送完的数据，所以需要等待B也主动关闭 B：好的，我弄完了，我也不玩了，拜拜 A：好的，拜拜 [ 过程的详细解读 （1）第一次挥手：客户端发送【FIN = 1，随机序列号seq = u】到服务器，用来主动关闭客户A到服务器B的数据传送；客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN （2）第二次挥手：服务器B收到这个FIN，它发回【ACK = 1、确认序号ack number=u+1】表示同意；客户端进入FIN-WAIT-2状态，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接; （3）第三次挥手：服务器关闭与客户端的连接，发回标识位【FIN = 1，ACK = 1,，确认码ack number=u+1】给客户端；服务器进入LAST_ACK，等待最后一次ACK确认 （4）第四次挥手：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。客户端进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态 TCP 四次挥手的目的 保证客户端、服务器真正断开连接 为什么挥手要四次？而握手只要三次？ B表示收到A的报文之后，可能有未发送完的数据，所以需要把数据全部发送完毕后再来告诉A说可以断开了，所以多了一次 2MSL是什么？目的是什么？ MSL是时间单位 —— 任何报文在网络上存在的最长时间 2MSL目的：保证第四次挥手正常进行 若第4次挥手的报文段丢失了 服务器就会超时重传第3次挥手的报文段 客户端就会重新给服务器发送第4次挥手的报文 最后，客户端、服务器才真正断开连接 为什么客户端关闭后不能再发一下就行？ 不能保证新、老连接端口号一致 ","link":"https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/"},{"title":"算法小记","content":"数组去重 第一种 new Set let ary = [1,2,3,4,2,1,3,4,5,6,4,3,5,6,3] let arr = Array.from(new Set(ary)) 第二种 第二种 拿出当前项和后面内容比较 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary.splice(i,1); // 这个性能不如 新建一个数组好 i--; // 会因为splice造成数组塌陷 } } 第三种 判断是否包含，包含的话 那最后一项把当前项覆盖 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary[i] = ary[ary.length - 1]; ary.length--; i-- } } 第四种 循环遍历是否包含，不包含push let arr = [] for(let i = 0;i &lt; ary.length; i++){ if(arr.indexOf(item) === -1){ arr.push(ary[i]) } } 等等还有很多，比如对象键值对，比如包含置为null 在过滤 数组扁平化 第一种 flat let arr = [ [1,2,3], [3,4,5,6], [6,7,8,9,0,[1],[2,3]],10 ] flat()写 几 就扁平化 几级 Infinity 无限 arr.flat(Infinity) 第二种 reduce function ab(arr){ return arr.reduce((pre,cur) =&gt; { return pre.concat(Array.isArray(cur) ? ab(cur) : cur) },[]) } 第三种 toString arr.toString().split(',').map(itm =&gt; parserFloat(itm)) 第四种 while + reduce + concat while(arr.some(itm =&gt; Array.isArray(itm))){ arr = [].concat(...arr) } 第五种 正则 JSON.stringify(arr).replace(/(\\[|\\])/g,'').split(',').map(itm =&gt;parseFloat(itm)) 斐波那契数列 let arr = [1,1,2,3,5,8,13,21] 当前项 = 当前项的 前面两位相加 可以 实现 传入 number 就能计算出对应斐波那契下标的值 第一种： while循环 function fibonacci(n){ if(n&lt;=1) return 1; let arr = [1,1]; let i = n + 1 -2; // why?因为传入的n是数组下标，所以要+1 减2的话就是因为一开始就有两个所以只需要创建剩下的位数 while(i &gt; 0){ let a = arr[arr.length - 2]; let b = arr[arr.length - 1]; arr.push(a+b); i-- } return arr[arr.length - 1]; } 第二种 递归 count：传进来的number cur：放的最终值 next：每次递归的时候作为下一次 cur 的值，需要每次 cur + next ](https://www.pipipi.net/wp-content/uploads/front-end-baike/01fcb9a1a61742a29a3c276a25a83e5d~tplv-k3u1fbpfcp-watermark.png) || || 搭配食用 || fibonacci(count){ function fn(count,cur = 1,next = 1){ if(count == 0){ return cur }else { return fn(count - 1,next,cur+next) } } return fn(count) } 冒泡排序 相邻两元素之间两两比较，比较出大值进行赋值互换，再依次与相邻的元素比较 必须要明白总共比较几回，一回比较几次！！！ let arr = [1,2,3,5,8,0,10] // 外层控制比较几回 for(let i = 0; i &lt; arr.length - 1; i++){ // 内层控制一回比较几次，并且比较大小 for(let j = 0; j &lt; arr.length -1 -i; j++){ if(arr[j] &gt; arr[j + 1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } 快速排序 分三步 取出数组的中间值 遍历数组，大于的放在右数组，小于的放在左边数组 递归并且用 concat 连接 let arr = [1,5,2,7,9,10,90,29,25,11,45,34]; function fast(arr){ if(arr.length &lt; 1) return arr; let num = Math.floor(arr.length / 2) let idx = arr.splice(num,1)[0]; let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; idx){ left.push(arr[i]) }else { right.push(arr[i]) } } return fast(left).concat(idx,fast(right)) } 插入排序 拿出一个值，作为初始数组的值， 通过循环想要排序的数组 并和新数组的值从后向前比 大于就splice到该项后面 function insert(arr){ let handle = []; // 这是最终成型的数组 handle.push(arr[0]); // 先拿一个值 for(let i = 1; i&lt; arr.length; i++){ let news = arr[i]; for(let j = handle.length - 1; j &gt;= 0; j--){ //从后向前比较 if(news &gt; handle[j]){ handle.splice(j+1,0,news); break; } if(j === 0){ // 比到为0的话直接放到数组头部 handle.unshift(news); } } } return handle } 单链表反转 看到这的话，要明白它反转后是什么样 { a:4, next:{ a:3, next:{ a:2, next:{ a:1, next: null } } } } 看到这，肯定是有个大概的思路，就是节点替换 ](https://www.pipipi.net/wp-content/uploads/front-end-baike/e9030c138fbf4e0e8ba87222f3b66dff~tplv-k3u1fbpfcp-watermark.png) let obj = { a:1, next:{ a:2, next: { a:3, next:{ a:4, next:null } } } } function reverseObj(obj){ let pre = null; // pre 最终的值(包含每一步) let cur = obj while(cur.next !== null){ let context = cur.next; // 首先拿到下一个next的值保存 cur.next = pre === null ? null : pre; // pre是上一项保存的值 pre = cur; // 将 当前项的值赋值给最终的值 cur = context // 拿到下一项next继续重复以商操作 } } ","link":"https://kangjn.github.io/post/suan-fa-xiao-ji/"},{"title":"学习笔记：promise","content":" then接收两个参数, onFulfilled 和 onRejected 检查并处理参数, 如果参数不是function就忽略(原样返回value或者reason) class MyPromise { constructor(fn) { // 初始状态为pending this.status = PENDING;//状态 this.value = null;//成功的值 this.reason = null;//失败的值 try { fn(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 3. 根据当前promise的状态, 调用不同的函数 class MyPromise { ..... //这时候then函数被调用会瞬间就会执行switch判断，那这时候如果status可能还没变成fulfilled或者rejected，很有可能还是pending then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 4、首先要拿到所有的回调, 然后在某个时机去执行他. 需要新建两个数组, 分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组. class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 5、在status状态发生变化的时候调用数组里所有的函数 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; //执行存储的函数 this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.value); }); } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; //执行存储的函数 this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.reason); }); } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 7、then的返回值 情况1：如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则新promise必须reject e class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况2：如果onFulfilled不是函数且promise成功执行，那么新的promise必须返回同样的状态和val 情况3：如果onRejected不是函数且promise拒绝执行，那么新的promise必须返回同样的状态和reason class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); resolve(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); if (this.isFunction(onRejected)) { resolve(); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况4:如果onFulfilled或者onRejected 返回一个值 x ，则运行resolvePromise方法 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { const newPromise = new MyPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MyPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } //检验是否为function isFunction(param) { return typeof param === 'function'; } resolvePromise(newPromise, x, resolve, reject){} } 8、resolvePromise resolvePromise(newPromise, x, resolve, reject) { // 防止死循环 if (newPromise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MPromise) { x.then((y) =&gt; { resolvePromise(newPromise, y, resolve, reject); }, reject); } else if (typeof x === 'object' || this.isFunction(x)) { if (x === null) { return resolve(x); } let then = null; try { then = x.then; } catch (error) { return reject(error); } // 如果 then 是函数 if (this.isFunction(then)) { let called = false; try { then.call( x, (y) =&gt; { if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, (r) =&gt; { if (called) return; called = true; reject(r); }); } catch (error) { if (called) return; reject(error); } } else { resolve(x); } } else { resolve(x); } } 9、onFulfilled 和 onRejected 是微任务 then(onFulfilled, onRejected) { ... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }) }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } }) } switch (this.status) { case FULFILLED: { const newPromise = new MPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } } 10. catch方法 catch (onRejected) { return this.then(null, onRejected); } 11. promise.resolve(静态方法) 将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。 static resolve(param) { if (param instanceof MyPromise) { return param; } return new MyPromise(function (resolve) { resolve(param); }); } 12. promise.reject(静态方法) 返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 static reject(reason) { return new MPromise((resolve, reject) =&gt; { reject(reason); }); } ","link":"https://kangjn.github.io/post/xue-xi-bi-ji-promise/"},{"title":"前端学习-Vue","content":"核心特性 数据驱动视图 数据变化会自动更新到对应元素中，无需手动操作 DOM，这种行为称作单向数据绑定。 对于输入框等可输入元素，可设置双向数据绑定。 双向数据绑定是在数据绑定基础上，可自动将元素输入内容更新给数据， 实现数据与元素内容的双向绑定。 Vue.js 的数据驱动视图是基于 MVVM 模型实现的。 MVVM (Model – View – ViewModel )是一种软件开发思想 Model 层，代表数据 View 层， 代表视图模板 ViewModel 层，代表业务逻辑处理代码 基于MVVM 模型实现的数据驱动视图解放了DOM操作 View 与 Model 处理分离，降低代码耦合度 但双向绑定时的 Bug 调试难度增大 大型项目的 View 与 Model 过多，维护成本高 组件化开发 组件化开发，允许我们将网页功能封装为自定义 HTML 标签，复用时书写自定义标签名即可。 组件不仅可以封装结构，还可以封装样式与逻辑代码，大大提交 了开发效率与可维护性。 基础语法 Vue 实例 通过 Vue 函数创建的对象，是使用 Vue 功能的基础。 new Vue({ //选项对象 }); el 选项 用于选取一个 DOM 元素作为 Vue 实例的挂载目标。 只有挂载元素内部才会被 Vue 进行处理，外部为普通 HTML 元素。 代表 MVVM 中的 View 层(视图)。 可以为 CSS 选择器格式的字符串 或 HTMLElement 实例，但不能为 html 或 body。 var vm = new Vue({ el: '#app' }); var app = document.querySelector('#app'); var vm = new Vue({ el: app }); 挂载完毕后，可以通过 vm.$el 进行访问。 var vm = new Vue({ el: '#app' }); console.log(vm.$el); 未设置 el 的 vue 实例，也可以通过 vm.$mount() 进行挂载，参数形式与 el 规则相同。 var app = document.getElementById('app'); var vm = new Vue({}); vm.$mount(app); 插值表达式 挂载元素可以使用 Vue.js 的模板语法，模板中可以通过插值表达式为元素进行动态内容设置，写法为 {{ }}。 &lt;li&gt;第一段示例内容：{{ 10 + 20 + 30 }}&lt;/li&gt; &lt;li&gt;第二段示例内容：{{ 22 &gt; 3 ? '22比3大' : '3比22大' }}&lt;/li&gt; &lt;!-- 错误写法 --&gt; &lt;!-- &lt;li id=&quot;{{ 1 + 2 }}&quot;&gt;&lt;/li&gt; --&gt; &lt;!-- &lt;li&gt;{{ var num = 100; }}&lt;/li&gt; --&gt; 注意点: 插值表达式只能书写在标签内容区域，可以与其它内容混合。 内部只能书写 JavaScript 表达式，不能书写语句。 data 选项 用于存储 Vue 实例需要使用的数据，值为对象类型。 data 中的数据可以通过 vm.$data.数据 或 vm.数据 访问。 var vm = new Vue({ el: '#app', data: { title: '标题文本' } }); console.log(vm.$data.title); console.log(vm.title); data 中的数据可以直接在视图中通过插值表达式访问。 data 中的数据为响应式数据，在发生改变时，视图会自动更新。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ title }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '标题文本', } }); vm.title = '新的标题内容'; &lt;/script&gt; data 中存在数组时，索引操作与 length 操作无法自动更新视图， 这时可以借助 Vue.set() 方法替代操作。 var vm = new Vue({ el: '#app', data: { arr: ['内容1', '内容2', '内容3'] } }); Vue.set(vm.arr, 0, '新内容'); methods 选项 用于存储需要在 Vue 实例中使用的函数。 methods 中的方法可以通过 vm.方法名 访问。 方法中的 this 为 vm 实例，可以便捷的访问 vm 数据等功能。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ fn(title1) }}&lt;/p&gt; &lt;p&gt;{{ fn(title2) }}&lt;/p&gt; &lt;p&gt;{{ title1.split('-').join('') }}&lt;/p&gt; &lt;p&gt;{{ title2.split('-').join('') }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { prefix: '处理的结果为：', title1: 'a-b-c-d-e', title2: 'x-y-z' }, methods: { fn (value) { // console.log(this); this.fn1(); this.fn2(); return this.prefix + value.split('-').join(''); }, fn1 () { console.log('执行了 fn1 的代码'); }, fn2 () { console.log('执行了 fn2 的代码'); } } }); // console.log(vm) &lt;/script&gt; ","link":"https://kangjn.github.io/post/qian-duan-xue-xi-vue/"},{"title":"springboot-文件上传/下载","content":"springboot-文件上传/下载 代码 application.yml spring: servlet: multipart: max-file-size: 50MB #上传文件最大大小 max-request-size: 50MB #单次请求最大大小 # 自定义文件上传路径 web: upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/ ps : 路径中不能包含中文，不然无法读取 FileUtils (文件上传工具类) package cn.justcoding.util; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; /** * 文件上传工具包 */ public class FileUtils { /** * * @param file 文件 * @param path 文件存放路径 * @param fileName 源文件名 * @return */ public static boolean upload(MultipartFile file, String path, String fileName){ //使用原文件名 String realPath = path + &quot;/&quot; +fileName; File dest = new File(realPath); //判断文件父目录是否存在 if(!dest.getParentFile().exists()){ dest.getParentFile().mkdir(); } try { //保存文件 file.transferTo(dest); return true; } catch (IllegalStateException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } } } TestController(进行测试) @Controller public class TestController { private final ResourceLoader resourceLoader; @Value(&quot;${web.upload-path}&quot;) private String path; @Autowired public TestController(ResourceLoader resourceLoader) { this.resourceLoader = resourceLoader; } /** * 跳转到文件上传页面 * @return */ @RequestMapping(&quot;test&quot;) public String toUpload(){ return &quot;freemarker/test&quot;; } /** * * @param file 要上传的文件 * @return */ @RequestMapping(&quot;fileUpload&quot;) public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){ // 要上传的目标文件存放路径 // String localPath = &quot;/src/main/resources/static/photos&quot;; // 上传成功或者失败的提示 String msg = &quot;&quot;; if (FileUtils.upload(file, path, file.getOriginalFilename())){ // 上传成功，给出页面提示 msg = &quot;上传成功！&quot;; }else { msg = &quot;上传失败！&quot;; } // 显示图片 map.put(&quot;msg&quot;, msg); map.put(&quot;fileName&quot;, file.getOriginalFilename()); return &quot;forward:/test&quot;; } /** * 显示单张图片 * @return */ @RequestMapping(&quot;show&quot;) public ResponseEntity showPhotos(String fileName){ try { // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径 // System.out.println(fileName); return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName)); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @RequestMapping(&quot;batch&quot;) public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) { List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;); MultipartFile file = null; BufferedOutputStream stream = null; String msg = &quot;&quot;; for (int i = 0; i &lt; files.size(); ++i) { file = files.get(i); if (!file.isEmpty()) { try { byte[] bytes = file.getBytes(); stream = new BufferedOutputStream(new FileOutputStream( new File(path + file.getOriginalFilename())));//设置文件路径及名字 stream.write(bytes);// 写入 stream.close(); } catch (Exception e) { stream = null; msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot; + e.getMessage(); } } else { msg= &quot;第 &quot; + i + &quot; 个文件上传失败因为文件为空&quot;; } } msg= &quot;上传成功&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } @RequestMapping(&quot;/download&quot;) public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) { String msg = &quot;&quot;; if (fileName != null) { //设置文件路径 File file = new File(path+fileName); //File file = new File(realPath , fileName); if (file.exists()) { response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开 response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名 byte[] buffer = new byte[1024]; FileInputStream fis = null; BufferedInputStream bis = null; try { fis = new FileInputStream(file); bis = new BufferedInputStream(fis); OutputStream os = response.getOutputStream(); int i = bis.read(buffer); while (i != -1) { os.write(buffer, 0, i); i = bis.read(buffer); } msg = &quot;下载成功&quot;; } catch (Exception e) { e.printStackTrace(); } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } msg = &quot;下载失败&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } } test.ytl (简易freemarker测试模板) &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;图片上传Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 &gt;图片上传Demo&lt;/h1&gt; &lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;#--判断是否上传文件--&gt; &lt;#if msg??&gt; &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt; &lt;#else &gt; &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt; &lt;/#if&gt; &lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt; &lt;#if fileName??&gt; &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt; &lt;#else&gt; &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt; &lt;/#if&gt; &lt;hr/&gt; &lt;p&gt;多文件上传&lt;/p&gt; &lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt; &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;hr/&gt; &lt;p&gt;文件下载&lt;/p&gt; &lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/"},{"title":"springboot-7.快速上手redis","content":"springboot-7.快速上手redis 前言 为什么需要Redis? 在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。 为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。 Redis在java web中的应用场景 存储 缓存用的数据； 需要高速读/写的场合使用它快速读/写； Redis作为缓存的读取逻辑 下载安装redis 下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads 选择最新版下载一个即可，下载完后解压便可使用。 为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件： redis-server redis.windows.conf 这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动： 下载安装redis可视化工具 RedisDesktopManager springboot配置使用redis （1）在pom文件中添加依赖项 &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; (2) 编写application.yml spring: # redis redis: host: 127.0.0.1 port: 6379 timeout: 3000 #连接超时 password: minIdle: 1 #连接池中的最小空闲连接 maxIdle: 10 maxWait: 3 #连接池中的最大阻塞等待时间 maxActive: 8 #连接池最大连接数 (3)新建文件夹和文件，如下所示： (4)Reidis配置文件-RedisConfig.java import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.cache.annotation.CachingConfigurerSupport; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.*; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration @EnableCaching //开启注解 public class RedisConfig extends CachingConfigurerSupport { /** * retemplate相关配置 * @param factory * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 配置连接工厂 template.setConnectionFactory(factory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式） Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常 om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 值采用json序列化 template.setValueSerializer(jacksonSeial); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); // 设置hash key 和value序列化模式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jacksonSeial); template.afterPropertiesSet(); return template; } /** * 对hash类型的数据操作 * * @param redisTemplate * @return */ @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForHash(); } /** * 对redis字符串类型数据操作 * * @param redisTemplate * @return */ @Bean public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForValue(); } /** * 对链表类型的数据操作 * * @param redisTemplate * @return */ @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForList(); } /** * 对无序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForSet(); } /** * 对有序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForZSet(); } } (5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java） 为了测试方便，只放入了get和set方法。 @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } } (6)在controller文件中进行测试 @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Resource private RedisUtil redisUtil; @RequestMapping(&quot;/setRedis&quot;) public boolean redisSet() { return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;); } @RequestMapping(&quot;/getRedis&quot;) public String redisGet() { return redisUtil.get(&quot;username&quot;).toString(); } } (7)预览 ps:记得开启redis（通过startup.cmd） 访问 http://localhost:8080/user/setRedis 返回true说明缓存存储成功，使用工具查看 获取缓存存取的值 访问 http://localhost:8080/user/getRedis 以上便是redis的基本使用 redisUtil.java工具类 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * redisTemplate封装 * * @author yinxp@dist.com.cn */ @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key,long time){ try { if(time&gt;0){ redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key){ return redisTemplate.getExpire(key,TimeUnit.SECONDS); } /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key){ try { return redisTemplate.hasKey(key); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String ... key){ if(key!=null&amp;&amp;key.length&gt;0){ if(key.length==1){ redisTemplate.delete(key[0]); }else{ redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key,Object value,long time){ try { if(time&gt;0){ redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); }else{ set(key, value); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递增因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, delta); } /** * 递减 * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递减因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, -delta); } //================================Map================================= /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key,String item){ return redisTemplate.opsForHash().get(key, item); } /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object,Object&gt; hmget(String key){ return redisTemplate.opsForHash().entries(key); } /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map){ try { redisTemplate.opsForHash().putAll(key, map); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){ try { redisTemplate.opsForHash().putAll(key, map); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value) { try { redisTemplate.opsForHash().put(key, item, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value,long time) { try { redisTemplate.opsForHash().put(key, item, value); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item){ redisTemplate.opsForHash().delete(key,item); } /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item){ return redisTemplate.opsForHash().hasKey(key, item); } /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item, by); } /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item,-by); } //============================set============================= /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key){ try { return redisTemplate.opsForSet().members(key); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key,Object value){ try { return redisTemplate.opsForSet().isMember(key, value); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object...values) { try { return redisTemplate.opsForSet().add(key, values); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key,long time,Object...values) { try { Long count = redisTemplate.opsForSet().add(key, values); if(time&gt;0) { expire(key, time); } return count; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key){ try { return redisTemplate.opsForSet().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object ...values) { try { Long count = redisTemplate.opsForSet().remove(key, values); return count; } catch (Exception e) { e.printStackTrace(); return 0; } } //===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end){ try { return redisTemplate.opsForList().range(key, start, end); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key){ try { return redisTemplate.opsForList().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key,long index){ try { return redisTemplate.opsForList().index(key, index); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) { try { redisTemplate.opsForList().rightPush(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) { try { redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) { try { redisTemplate.opsForList().rightPushAll(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) { try { redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index,Object value) { try { redisTemplate.opsForList().set(key, index, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key,long count,Object value) { try { Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 模糊查询获取key值 * @param pattern * @return */ public Set keys(String pattern){ return redisTemplate.keys(pattern); } /** * 使用Redis的消息队列 * @param channel * @param message 消息内容 */ public void convertAndSend(String channel, Object message){ redisTemplate.convertAndSend(channel,message); } } ","link":"https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/"},{"title":"springboot-6.整合Mybatis","content":"springboot-6.整合Mybatis 一 .解析Java框架中entity层，mapper层，service层各层作用 （1）entity层 别名： model层 ，domain层。 用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应 简单例子：user表的实体User public class User { private int id;//id private String username;//用户名 //……省略set,get方法 } （2）mapper层 别名： dao层 用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作 简单例子： @Mapper public interface UserMapper { public User selectUserById(int id); } (3) service层 业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。 作用：为controller层的类提供接口进行调用。 简单例子： public interface UserService extends Service&lt;User&gt; { } 二.快速使用 （1）添加依赖项 &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; （2）配置application.yml spring: #数据源配置 datasource: url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: ****** driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource connectionProperties: druid.stat.mergeSql=true #为mybatis配置，生产环境可删除 restart: include: mapper: /mapper-[\\\\w-\\\\.]+jar pagehelper: /pagehelper-[\\\\w-\\\\.]+jar pagehelper: auto-dialect: msyql reasonable: true support-methods-arguments: true params: count=countSql (3)编写User.java【entity层】 public class User { private String id; private String username; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } (4)编写UserMapper.java(dao层) @Mapper public interface UserMapper { @Select(&quot;select * from user where id = #{id}&quot;) public User selectUserById(int id); @Select(&quot;select * from user where username = #{username}&quot;) public List&lt;User&gt; selectUserByName(String userName); @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;) public void addUser(User user); @Update(&quot;update user set username=#{username} where id=#{id}&quot;) public void updateUser(User user); @Delete(&quot;delete from user where id=#{id}&quot;) public void deleteUser(int id); } (5)编写userController.java @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Autowired UserMapper userMapper; @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET) public User selectUserById(String id){ User user = userMapper.selectUserById(Integer.parseInt(id)); return user; } @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET) public List&lt;User&gt; selectUserByName(String userName){ return userMapper.selectUserByName(userName); } @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST) public void addUser(User user){ userMapper.addUser(user); } @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST) public void updateUser(User user){ userMapper.updateUser(user); } @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST) public void deleteUser(String id){ userMapper.deleteUser(Integer.parseInt(id)); } } 此时便已经全部配置结束 为了方便测试，忽略了service层，直接调用了mapper层 （6）测试 1. ","link":"https://kangjn.github.io/post/springboot-6zheng-he-mybatis/"},{"title":"springboot-5.全局异常捕获","content":"springboot-5.全局异常捕获 在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。 1 浏览器访问异常时： 2.postman访问异常时： 显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。 正文 1.自定义基础接口类+自定义枚举类 public interface BaseErrorInfoInterface { /** 错误码*/ String getResultCode(); /** 错误描述*/ String getResultMsg(); public enum CommonEnum implements BaseErrorInfoInterface { // 数据操作错误定义 SUCCESS(&quot;200&quot;, &quot;成功!&quot;), BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;), SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;), NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;), INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;), SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;) ; /** 错误码 */ private String resultCode; /** 错误描述 */ private String resultMsg; CommonEnum(String resultCode, String resultMsg) { this.resultCode = resultCode; this.resultMsg = resultMsg; } @Override public String getResultCode() { return resultCode; } @Override public String getResultMsg() { return resultMsg; } } } 2.自定义异常类 public class BizException extends RuntimeException { private static final long serialVersionUID = 1L; /** * 错误码 */ protected String errorCode; /** * 错误信息 */ protected String errorMsg; public BizException() { super(); } public BizException(BaseErrorInfoInterface errorInfoInterface) { super(errorInfoInterface.getResultCode()); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) { super(errorInfoInterface.getResultCode(), cause); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(String errorMsg) { super(errorMsg); this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg) { super(errorCode); this.errorCode = errorCode; this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg, Throwable cause) { super(errorCode, cause); this.errorCode = errorCode; this.errorMsg = errorMsg; } public String getErrorCode() { return errorCode; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public String getErrorMsg() { return errorMsg; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public String getMessage() { return errorMsg; } @Override public Throwable fillInStackTrace() { return this; } } 3.自定义数据格式 public class ResultBody { /** * 响应代码 */ private String code; /** * 响应消息 */ private String message; /** * 响应结果 */ private Object result; public ResultBody() { } public ResultBody(BaseErrorInfoInterface errorInfo) { this.code = errorInfo.getResultCode(); this.message = errorInfo.getResultMsg(); } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Object getResult() { return result; } public void setResult(Object result) { this.result = result; } /** * 成功 * * @return */ public static ResultBody success() { return success(null); } /** * 成功 * @param data * @return */ public static ResultBody success(Object data) { ResultBody rb = new ResultBody(); rb.setCode(CommonEnum.SUCCESS.getResultCode()); rb.setMessage(CommonEnum.SUCCESS.getResultMsg()); rb.setResult(data); return rb; } /** * 失败 */ public static ResultBody error(BaseErrorInfoInterface errorInfo) { ResultBody rb = new ResultBody(); rb.setCode(errorInfo.getResultCode()); rb.setMessage(errorInfo.getResultMsg()); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error(String code, String message) { ResultBody rb = new ResultBody(); rb.setCode(code); rb.setMessage(message); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error( String message) { ResultBody rb = new ResultBody(); rb.setCode(&quot;-1&quot;); rb.setMessage(message); rb.setResult(null); return rb; } @Override public String toString() { return JSONObject.toJSONString(this); } } 4.自定义全局异常处理类 @RestControllerAdvice public class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); public static final String Demo_View = &quot;error&quot;; /** * 处理自定义的业务异常 * @param req * @param e * @return */ @ExceptionHandler(value = BizException.class) public Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,e.getErrorCode()); mav.setViewName(Demo_View); return mav; } } /** * 处理空指针的异常 * @param req * @param e * @return */ @ExceptionHandler(value =NullPointerException.class) @ResponseBody public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){ logger.error(&quot;发生空指针异常！原因是:&quot;,e); return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH); } /** * 处理其他异常 * @param req * @param e * @return */ @ExceptionHandler(value =Exception.class) public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR); mav.setViewName(Demo_View); return mav; } } //判断是否是ajax请求 public static boolean isAjax(HttpServletRequest httpRequest) { return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString())); } } 5.编写前端异常显示页面 ps:名称对应步骤4里的String Demo_View 为了测试，快速建立一个html &lt;!doctype html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 此时全局异常捕获已经建立完毕，接下来进行测试 测试 1.web页面跳转 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;/error&quot;) public String error() { int a = 1 / 0; //除以0，产生异常 return &quot;error&quot;; } } 此时访问web页面： 2.ajax形式跳转 更改controller文件 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;&quot;) public String err() { return &quot;thymeleaf/ajaxerror&quot;; } @RequestMapping(&quot;getAjaxError&quot;) public jsonResult ajaxError() { int a = 1/0; return jsonResult.ok(200); } } 新建一个ajaxerror.html文件于thymeleaf文件夹下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ajax测试&lt;/title&gt; &lt;/head&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt; &lt;/body&gt; &lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt; &lt;/html&gt; 新建一个ajax.js文件编写ajax请求 $(&quot;#test&quot;).click(function() { $.ajax({ url: &quot;/err/getAjaxError&quot;, type: &quot;POST&quot;, async: false, success: function (data) { if (data.status == 200 &amp;&amp; data.msg == 'OK') { alert(&quot;success&quot;); } else { alert(&quot;发生异常&quot; + data.msg); } }, error: function (response, ajaxOption, thrownError) { alert(&quot;error&quot;); } }); }); 记得在application文件夹添加静态文件路径配置 mvc: static-path-pattern: /static/** 此时访问 3.测试自定义异常 新建一个controller文件 @Controller @RequestMapping(value = &quot;/api&quot;) public class UserRestController { @RequestMapping(&quot;&quot;) public String api(ModelMap map) { User u = new User(); map.addAttribute(&quot;user&quot;,u); return &quot;thymeleaf/api&quot;; } @PostMapping(&quot;/user&quot;) public boolean insert(User user) { System.out.println(&quot;开始新增...&quot;); //如果姓名为空就手动抛出一个自定义的异常！ if (user.getUsername() == null) { throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;); } return true; } } 新建一个api.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 访问 3.测试自定义异常 @RequestMapping(&quot;/error&quot;) public String error() { throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;); } 尾言 按照步骤添加即可完成操作~ User类自行添加或者浏览前文即可。 其他 1.SpringBoot异常处理-自定义错误页面 (1) 在Spring Boot中一共提供了几种处理异常的方式？ SpringBoot 中对于异常处理提供了五种处理方式： 自定义错误页面； @ExceptionHandle 注解处理异常； @ControllerAdvice+@ExceptionHandler 注解处理异常； 配置 SimpleMappingExceptionResolver 处理异常； 自定义 HandlerExceptionResolver 类处理异常 (2) 什么是自定义错误页面方式？ SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫 BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。 (3) 自义定错误页面应该放到项目的什么位置？ 放在一般网页资源存放的位置 即src/main/resources/templates 2.SpringBoot异常处理-@ControlleAdvice (1) @ControllerAdvice注解的作用是什么？ 需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。 (2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？ 是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。 ","link":"https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/"},{"title":"springboot-4.模板引擎","content":"springboot-4.模板引擎 前言 关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。 freemarker (1)在pom文件中添加依赖项 &lt;!-- freemarker 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加freemarker相关配置 spring: http: encoding: force: true charset: UTF-8 freemarker: allow-request-override: false cache: false check-template-location: true charset: UTF-8 content-type: text/html; charset=utf-8 expose-request-attributes: false expose-session-attributes: false expose-spring-macro-helpers: false suffix: .ftl template-loader-path: classpath:/templates (3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl 文件树结构： 快速创建一个网页模板进行测试，内容如下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;${host}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ps：其中host的值通过后台读取。 （4）在controller文件夹下新建一个freemarkerController.java文件 @Controller public class freemarkerController { @RequestMapping(&quot;/&quot;) public String index(ModelMap map) { map.addAttribute(&quot;host&quot;,&quot;ericam&quot;); return &quot;freemarker/center&quot;; } } ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl） (5)预览 此时打开浏览器可以看到如下内容： 接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf） Thymeleaf 一. 快速入门使用 （1）在pom文件夹添加项目依赖 &lt;!-- ThymeLeaf 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加themeleaf相关配置 spring: thymeleaf: cache: false # 开发时关闭缓存,不然没法看到实时页面 mode: HTML # 用非严格的 HTML encoding: UTF-8 servlet: content-type: text/html (3) 在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html 文件树： 新建一个User.java文件 文件树： (4)编写User.java文件 为了方便测试，用户具备如下属性： id 用户名 年龄 创建时间 用户简介 public class User { private String id; private int age; private String username; private Date createTime; private String desc; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } //请读者自行补充 构造器和 get/set方法.. public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } (5)新建一个themeleafController.java进行测试 @Controller public class themeleafController { @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); //这里的user对应html里的user return &quot;thymeleaf/test&quot;; } } (6)最后我们进行编写test.html文件 &lt;div&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt; &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt; &lt;/div&gt; ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。 (7)预览 二.Thymeleaf常用标签-方法 （1）上述test.html的等同写法 &lt;div th:object=&quot;${user}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt; &lt;/div&gt; 这样可以简化内容，使用更加广泛。 （2）表单的提交 我们在test.html里添加如下内容 &lt;div&gt; &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/div&gt; ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username 接着在themeleafController添加如下内容 @PostMapping(&quot;/postform&quot;) public String postform(User u) //前端传入了一个User对象 { System.out.println(u.getUsername()); return &quot;redirect:/test&quot;; //重定向（等于转向/test地址 } （3）th:if标签 &lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt; 利用if判断变量是否为空，非空时显示 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; if / else 的实现 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt; (4)th:selected标签 &lt;select&gt; &lt;option &gt;选择框&lt;/option&gt; &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt; &lt;/select&gt; (5)table表单 &lt;table&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;person:${userlist}&quot;&gt; &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在这里我们需要修改下themeleafController文件，为其添加一个userlist。 @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); List&lt;User&gt; userlist = new ArrayList&lt;&gt;(); //添加一个userlist userlist.add(u); u = new User(); u.setId(&quot;234&quot;); u.setUsername(&quot;ericam&quot;); u.setCreateTime(new Date(2020-1900,5-1,12)); u.setAge(3); userlist.add(u); map.addAttribute(&quot;userlist&quot;,userlist); return &quot;thymeleaf/test&quot;; } (6)th:switch &lt;div th:switch=&quot;${user.username}&quot;&gt; &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 备注：常用标签的效果可以自行去测试 ","link":"https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/"},{"title":"springboot-3.资源文件属性配置","content":"springboot-3.资源文件属性配置 前言 为什么要进行资源文件属性配置呢？可以想象成就是一个设置文件。比如设置好数据库密码.port端口后，在其他地方只需要用名字引用即可。 举个例子： 我们设置以下项目的持有者名称为ericam demo: name: &quot;ericam&quot; 那么在其他地方只需要引用name名称即可，然后如果整个项目需要多次引用，后期我们只需要在一个配置文件里更改下名称即可，不必多次操作。 Spring Boot可使用注解的方式将自定义的properties文件映射到实体bean中，比如application.properties文件 或者application.yml 正文 （1）首先，在pom文件中添加依赖项 &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; （2）修改application.yml文件，添加如下内容 demo: name: &quot;ericam&quot; （3）新建一个Resource.java文件 package cn.ericam.nndemo; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; @Configuration //使用配置注解 ，表示这个类是配置文件 @ConfigurationProperties(prefix = &quot;demo&quot;) //prefix 指定配置文件里的前缀 @PropertySource(value = &quot;classpath:application.yml&quot;) public class Resource { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } ps：ConfigurationProperties是一个注解，可以标注在一个Class上，这样Spring Boot会从Environment中获取其属性对应的属性值给其进行注入。 （4）接下来，我们开始引用一波尝试，打开helloController.java文件 @RestController public class helloController { @Autowired private Resource resource; //构建一个Resource类对象，通过autowired自动赋值 @RequestMapping(&quot;/getR&quot;) public jsonResult gr() { Resource b = new Resource(); BeanUtils.copyProperties(resource,b); //将resource的值拷贝复制给b return jsonResult.ok(b); } } ps:@Autowired 注释可以对类成员变量、方法及构造函数进行标注，完成自动装配。 通过 @Autowired的使用来消除 set、get方法。 打开浏览器 application.yml文件中重要属性 server: port: 8080 #端口 servlet: context-path: /demo #配置路径，此后访问http://localhost:****/demo/**** ","link":"https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/"},{"title":"springboot-2.利用接口返回数据（json）","content":"springboot-2.利用接口返回数据（json） 前言 项目前后台交互存在两种方式 一种普通整体页面提交，比如form提交； 还有一种局部刷新，或者叫做异步刷新，ajax提交； @Controller就是整体页面刷新提交的处理注解 @RestController就是ajax提交，一般返回json格式，相当于我们经常使用的@ResponseBody+@Controller组合 正文 新建文件夹controller 然后在该文件夹下新建 控制类.java文件 [![cWWn9x.png]((https://gitee.com/kangjun/MyBlogImage/raw/master/cWWn9x.png) 1.最简单的数据返回 @RestController public class helloController { @RequestMapping(&quot;/&quot;) public String hello() { return &quot;hello&quot;; } } 【@RequestMapping作用】 处理请求地址的映射 用于类和方法上，类上的 “请求地址” 是方法上的 “请求地址” 的父地址 [ 2.返回类对象信息 为了演示，我们新建一个文件夹User，然后在该文件夹下新建一个文件User.java [ 内容如下： public class User { private String name; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 然后在controller文件夹下新建一个userController.java文件 (记得自行import需要的文件) [ @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public User getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return u; } } 3.返回封装的类对象信息 解释一下该处和2处的区别： @Description: 自定义响应数据结构这个类是提供给门户，ios，安卓，微信商城用的门户接受此类数据后需要使用本类的方法转换成对于的数据类型格式（类，或者list）其他自行处理 200：表示成功 500：表示错误，错误信息在msg字段中 501：bean验证错误，不管多少个错误都以map形式返回 502：拦截器拦截到用户token出错 555：异常抛出信息 简单来说，就是当前台提交用户信息给后台时，后台会返回一个json数据，其中包含状态码（200等），message（“ok”或者“failure”），然后再包含一个用户信息列表。 首先，在pom文件中添加依赖项 jackson-databind jackson-core 新建一个jsonResult.java文件 package cn.ericam.nndemo.Json; public class jsonResult { // 响应业务状态 private Integer status; // 响应消息 private String msg; // 响应中的数据 private Object data; public static jsonResult ok(Object data) { return new jsonResult(data); } //类含参初始化1 public jsonResult(Integer status, String msg, Object data) { this.status = status; this.msg = msg; this.data = data; } //类含参初始化2 public jsonResult(Object data) { this.status = 200; this.msg = &quot;OK&quot;; this.data = data; } //get和set方法 public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } 然后在userController.java下修改为如下代码： @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public jsonResult getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return jsonResult.ok(u); } } [ 【ps：IDEA利用ctrl+insert可以快速生成get和set方法】 ","link":"https://kangjn.github.io/post/springboot-2li-yong-jie-kou-fan-hui-shu-ju-json/"},{"title":"springboot-1.简约版创建第一个应用","content":"springboot-1.简约版创建第一个应用 勾选依赖项 由于只是体验搭建一个springboot项目，因此依赖项只需要勾选一个spring web 创建成功后项目列表如下图所示 其中 DemoApplication.java:关键的启动类（程序的入口） pom.xml:Maven构建说明文件 DemoApplicationTests.java:一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文 application.properties:一个空的properties文件，根据需要添加配置属性 为了演示简单，不再新建控制类，而是直接在这个入口类(DemoApplication.java)中编写，添加@RestController以及index方法，如下： 红色框内 内容需要添加 ps:@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 运行项目 浏览器访问http://localhost:8080/ 至此第一个springboot项目已经创建完毕 端口被占用 由于项目需要运行在端口8080，当端口被占用时，需要杀死该端口上运行的进程 进入命令行 netstat -o -n -a | findstr :8080 # TCP 0.0.0.0:3000 0.0.0.0:0 LISTENING 3116 taskkill /F /PID 3116 实现热启动 热启动：修改代码保存时会自动重新启动项目 1.修改pom.xml文件(添加spring-boot-devtools包) &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 修改spring-boot-maven-plugin插件 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork:设置True，否则可能devtools不会起作用--&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2.修改IDEA配置 打开 File -&gt; Settings -&gt;Build,Executions,Deployment -&gt; Compiler ，勾选 然后，Ctrl + Shift + Alt + / 打开 勾选该选项 热更新完成！ ","link":"https://kangjn.github.io/post/springboot-1jian-yue-ban-chuang-jian-di-yi-ge-ying-yong/"},{"title":"git命令行常用指令","content":"git命令行日常指令 首先，需要在Github/Coding平台新建一个仓库。 本地新建一个文件夹，打开该文件夹，右键选择“git bash here”进入命令行。 1.将项目初次拉取到本地（clone） git clone 项目地址 2. 将本地文件push到远程仓库 git init #初始化 git add . #将文件夹内所有文件添加至本地仓库 git commit -m &quot;描述&quot; #添加本次提交描述 git remote add origin https://github.com/用户名/项目名.git git push -u origin master ps: git remote add origin...为建立本地与远程依赖，某些情况下需要重置。 清空依赖命令 git remote rm origin 3.删除文件夹 git pull origin master git rm -r --cached idea #删除idea文件夹 git commit -m '删除.idea' git push -u origin master 4. git push 命令使用 场景1 场景：当本地的当前分支不是local_branch； 作用：将远程分支拉取到指定本地分支； 例如：当前分支是dev，但是你想把远程master “同步”到本地master，但又不想使checkout切换到master分支； git pull origin master：master #将远程master分支拉取到本地master分支 场景2 场景：在当前分支上进行同步操作； 作用：将指定远程分支同步到当前本地分支； git pull origin master 场景3 场景：本地分支已经和想要拉取的分支建立了“关联”关系； 作用：拉取所有远程分支的新版本&quot;坐标&quot;，并同步当前分支的本地代码(具体根据关联分支而定) git push 5.强制拉取 git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull git fetch&amp;&amp;git pull git pull : 拉取代码并合并 git fetch :拉取代码 (如果需要合并，执行git merge) git fetch使用方法 git fetch origin master:tmp // 拉取远程master分支，并放到本地tmp分支上 git diff tmp //查看当前分支和tmp分支的区别 git merge tmp // 把tmp分支合并到当前分支 git branch -d tmp // 删除tmp分支 ","link":"https://kangjn.github.io/post/git-ming-ling-xing-chang-yong-zhi-ling/"},{"title":"设计模式-六大设计原则","content":"单一职责原则 简介 单一职责原则（SRP，Single Responsesibility Principle）：There should never be more than one reason for a class to change.(应该有且仅有一个原因引起类的变更) 优势 类的复杂性降低。实现什么职责都有清晰明确的定义 可读性提高，复杂性降低 可维护性提高，可读性提高 变更引起的风险降低 注意 单一职责是一个标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是这两者都是不可度量的，因项目和环境而定。 里氏替换原则 简介 里氏替换原则（LSP，Liskov Substitution Principle）： If for each object o1 of type S there is an object o2 of type T suchthat for all programs P defined in terms of T, the behavior of P is unchangedwhen o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。） functions that use pointers or references to base classes must beable to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 理解：只要父类能出现的地方子类就可以出现，即将父类对象调用的行为切换成子类对象调用行为也不会产生任何错误或异常，但是反过来却不行。 含义 子类必须完全实现父类的方法 里氏替换原则可以正着用，不能反过来用：子类出现的地方，父类未必可以胜任 覆盖或实现父类的方法时，输入参数可以被放大：如果反过来会引起业务逻辑的错乱。子类中方法的前置条件（参数）必须与超类中被覆写的方法的前置条件相同或更宽松。（如：父类是HashMap，子类是HashMap或Map） 覆写或实现父类的方法时输出结果可以被缩小：里氏替换原则要求S小于等于T，则S和T要么是同一类型，要么S是T的子类。 注意 在类中调用其他类时必须要使用父类或接口，如果不能使用父类或接口，说明类的设计已经违背了LSP原则 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生了&quot;畸变&quot;，建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 依赖倒置原则 简介 依赖倒置原则（DIP，Dependence Inversion Principle）：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions 理解：高层模块不应该依赖底层模块，两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象 含义 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象实现的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 注意 Java变量有两种类型：表面类型（定义时候赋予的类型），实际类型（对象的类型） 依赖的三种写法：构造函数传递依赖对象、setter方法传递依赖对象、接口声明依赖对象 依赖倒置原则是实现开闭原则的重要途径。 使用 要想使用这个规则只需要做到一下几点： 每个类尽量都有接口或抽象类，或两者皆有 变量的表面类型尽量是接口或抽象类 任何类都不应该从具体类派生 尽量不要覆写基类方法 结合里氏替换原则使用：接口负责定义Public属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化 接口隔离原则 简介 接口隔离原则（ISP：Interface Segregation Principle）： Clients should not be forced to depend upon interfaces that they don't use（客户端不应该依赖于它不需要的接口） The dependency of one class to another one should depend on the smallest possible interface（类间的依赖关系应该建立在最小的接口上） 理解：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化同时接口方法尽量少 含义 接口尽可能的小：前提是不能违背单一职责原则，优先考虑单一职责原则 接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互 定制服务：单独为一个个体提供优良的服务 接口设计是有限度的 注意 接口隔离原则和单一职责并不冲突，两者针对的角度不同。单一职责注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少 设计是有限度的，不要无限的考虑未来可能出现的情况 使用 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑尽量压缩接口中的public方法，并经常回顾接口 如果接口已经被污染，尽量去修改。如果不行，则使用适配器模式进行转换处理 了解环境，根据业务来设计 迪米特法则 简介 迪米特法则（LoD：Law of Demeter）：一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道的最少 含义 只和朋友交流：不要出现getA().getB().getC().getD()的奇葩写法 朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类 朋友间也是有距离的：公开的public属性或方法越多，修改时涉及的面也就越大。在设计时候要反复考虑是否可以减少public的方法和属性，将其修改成private等，并且是否可以加上final关键字 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系也不对本类产生负面影响，就放在本类中 谨慎使用Serializable：由于很容易被发现，所以不必太过在意。 注意 一个类只和朋友交流不和陌生人交流 ，不要出现getA().getB().getC().getD()的奇葩写法 类与类之间的关系是建立在类间的，而不是方法间的，一个方法尽量不引入一个类中不存在的对象，JDK API提供的除外 尽量不要对外公布太多的public方法和非静态的public变量 如果一个类跳转两次以上才能访问到另外一个类，就需要进行重构了。 开闭原则 简介 开闭原则：Software entities like classes,modules and functions should be open for extension but closed for modifications（一个软件实体，如类、模块和函数应该对扩展开发对修改关闭） 理解：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。 优势 使用开闭原则能有效的减少重构时的测试 可以提高复用性 可以提高可维护性 面向对象开发的要求 使用 抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法 参数类型、引用对象尽量使用接口或抽象类，而不是实现类 抽象层尽量保持稳定，一旦确认就不允许修改 元数据控制模块行为：尽量使用元数据来控制程序的行为（描述缓解和数据的数据，通俗的说就是配置） 制定项目章程 封装变化 将相同的变化封装到一个接口或抽象类中 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中 注意 开闭原则对扩展开放对修改关闭，并不意味着不做任何修改，底层模块的变更，必然有高层模块进行耦合，否则就是无意义的代码 ","link":"https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/"},{"title":"《论语》50经典名句","content":"1．朝闻道，夕死可矣。 早上明白知晓了真理，即便晚上死去，也是值得的。 2．见贤思齐焉，见不贤而内自省也。 见到贤人便应考虑怎样才能向他看齐，见到不贤的人便应在内心反省，看自己有没有同样的缺点。 3．己所不欲，勿施于人。 如果不希望他人这样对待自己，自己也不要这样对待他人。 4．不怨天，不尤人。 遇到挫折与失败，绝不抱怨天，不责怪人。 5．不迁怒，不贰过。 不会迁怒于人，不会犯两次同样的错误。 6．过而不改，是谓过矣。 有了过错而不改正，这就是真的过错了。 7．人而无信，不知其可也。 一个人不讲信用，不知他怎样立身处世。 8．有则改之，无则加勉。 别人给自己指出缺点错误，如果有，就改正，如果没有，就用来提醒自己不犯同样的错误。 9．如切如磋，如琢如磨。 完善自身的修养，既像雕琢玉器，又像雕刻石头，都是需要下功夫的。 10．人无远虑，必有近忧。 一个人没有长远的考虑，一定会有眼前的忧患。指智者能不为眼前得失所羁绊，目光长远，判断敏锐。 11．君子求诸己，小人求诸人。 君子哪儿做得不对，会从自己内心去查找原因，要求自己做好，从而修正自己；小人则是向外去查找原因，要求别人做好。 12．君子坦荡荡，小人长戚戚。 君子光明磊落，胸怀坦荡，小人则斤斤计较，患得患失。 13．君子喻于义，小人喻于利。 君子能够领悟的是道义，小人能够领悟的是利益。 14．君子和而不同，小人同而不和。 君子和谐而不同流合污，小人同流合污而不和谐。 15．君子泰而不骄，小人骄而不泰。 君子坦荡舒畅而不骄傲自大，小人骄傲自大而不坦荡舒畅。 16．君子成人之美，不成人之恶。小人反是。 君子成全别人的好事，而不促成别人的坏事。小人则与此相反。 17．君子欲讷于言，而敏于行。 君子说话要谨慎，而行动要敏捷。君子说话要谨慎，是因为“覆水难收”，随心所欲说出口的话，可能对于别人有失尊重。但是一旦君子对于决定的事情，绝不犹豫推托而耽误了时光。这一缓一急之间，正是体现君子有为有守的处世原则。 18．君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。 君子食不追求饱足，居住不追求安逸，对工作勤奋敏捷，说话却谨慎，接近有道德有学问的人并向他学习，纠正自己的缺点，就可以称得上是好学了。 **19．与善人居，如入芝兰之室，久而不闻其香，即与之化矣；与不善人居，如入鲍鱼之肆，久而不闻其臭；亦与之化矣。 ** 常与善人相处，就像生活在种满兰芝仙草的花房，时间长了便察觉不到香味，那是因为已经习惯了善行的芬芳；常与不善的人相处，就像住进了满是臭鱼烂虾的海鲜市场，时间长了便察觉不到腥味，也是因为闻惯了恶行的腐臭。 圣人此言是在告诫我们：与人相处，先看人品。 常跟善良的人在一起，便会耳濡目染地跟着行善事、说善言，久而久之，心胸也会变得更加宽广。 常跟邪恶的人在一起，则会不知不觉地跟做错事、说恶话，久而久之，难免会折损自身的品行。 20．君子有三畏：畏天命，畏大人，畏圣人之言。小人不知天命而不畏也，狎大人，侮圣人之言”。 君子有三件敬畏的事情：敬畏天命，敬畏居高位的人，敬畏圣人的话，小人不知道天所赋予的正理而不敬畏，怠慢轻视高位的人，戏侮圣人的话。 21．学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？ 学过的知识，在适当的时候去复习它，这不是令人感到快乐的事吗？ 有朋友从远方来，这不是件令人感到快乐的事吗？ 别人不了解我，我也不生气，这不也是一种君子风度的表现吗？ 22．三人行，必有我师焉。择其善者而从之，其不善者而改之。 几个人同行，其中必有值得我学习的人，选取他的优点向他学习，对他的缺点引以为戒，有则改之。 23．学而不厌，诲人不倦。 努力学习却不感到满足，教导别人不感到厌倦。 24．学而不思则罔，思而不学则殆。 只学习却不思考就会感到迷茫，只空想却不学习就会疲倦而没有收获。 25．敏而好学，不耻下问，是以谓之文也。 聪明而且好学，不认为向地位比自己低、学识比自己浅的人请教是可耻的事，任何一个能如此作为的人，怎会不能成才？ 26．知之为知之，不知为不知，是知也。 知道就是知道，不知道应当说不知道，这才是明智的行为。 27．温故而知新，可以为师矣。 温习旧知识从而得到新的理解与体会，凭借这一点就可以成为老师了。 28．子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。” 孔子说：“我十五岁时，便立定志向学习；三十岁时，能立身处世；四十岁时，可以免于迷惑；五十岁时，已经能够领悟天命；六十岁时，就可以顺从天命；七十岁时，终于能做到做事随心所欲，却都能合于规矩的境界了。” 29．欲速则不达；见小利则大事不成。 不要求快，不要贪求小利。求快反而达不到目的，贪求小利就做不成大事。 30．小不忍，则乱大谋。 小事不忍耐，就会坏了大事情。 31．知者不惑，仁者不忧，勇者不惧。 有智慧的人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。 32．见义不为，无勇也。 见到应该挺身而出的事情，却袖手旁观，就是怯懦。 33．志士仁人，无求生以害仁，有杀身以成仁。 一位怀有大志和仁德的人，不会贪生怕死而损害仁德，只会不惜牺牲生命而成全仁德。 34．三军可夺帅也，匹夫不可夺志也。 三军可以丧失主帅，一个人的志气与主张却是不能被强迫改变的。 35．士不可以不弘毅，任重而道远。 有志者不可以不心胸开阔，意志坚强，因为担子沉重而且道路遥远。 36．名不正，则言不顺，言不顺，则事不成。 名分不正，所说的话就不合道理。说话不合理，事情就办不成。 37．自古皆有死，民无信不立。 子贡问怎么治理国家。孔子说：“粮食充足，军备充足，人民信任当政者。”子贡说：“如果不得不去掉一项，那么这三项应先去掉哪一项？”孔子说：“去掉军备。”子贡说：“如果不得不再去掉一项，那么这两项应去掉哪一项？”孔子说：“去掉粮食。自古以来人终究是要死的，老百姓如果不信任当政者，那么国家就不能成立了。” 38．其身正，不令而行；其身不正，虽令不从。 自身品行端正，即使不下达命令，百姓也会自觉去做；自身品行不端正，即使下达了命令，百姓也不会服从。 39．不在其位，不谋其政。 不在那个职位上，就不去考虑那个职位上的事。不是事不关己的冷漠，而是行事恪守本分。 40．听其言而观其行。 指听了他的话，还要看他的行动。 指不要只听言论，还要看实际行动。 41．四海之内，皆兄弟也。 司马牛见到师兄子夏后忧愁地说他人皆有兄弟相亲，而唯独我没有兄弟相亲。子夏安慰他说君子和人交往态度恭谨而合乎礼节，那么普天之下到处都是兄弟。 42．与朋友交，言而有信。 与朋友们交往，应该诚实守信，说到做到。 43．礼之用，和为贵。 礼的作用，在于使人的关系变得更加和谐。 44．益者三友，损者三友。友直，友谅，友多闻，益矣；友便辟，友善柔，友便佞，损矣。 有益的朋友有三种，有害的朋友也有三种。与正直的人交朋友，与守信的人交朋友，与见多识广的人交朋友，是有益的。与谄媚逢迎的人交朋友，与两面三刀的人交朋友，与花言巧语的人交朋友，是有害的。 45．道不同，不相为谋。 立场不同、观点不同，也就不要相互商议谋划了。 46．父母在，不远游，游必有方。 父母年迈在世，尽量不长期在外地。不得已，必须告诉父母去哪里，为什么去，什么时候回来，并安排好父母的赡养。 47．是可忍也，孰不可忍也。 孔子谈到季氏说：“他用天子的舞蹈阵容在自己的庭院中舞蹈，如果这样僭礼的事情都可以容忍的话，还有什么事情是不可以容忍的呢？” 48．毋意，毋必，毋因，毋我。 不凭空猜测，不死板，不固执，不自以为是。 49．士志于道，而耻恶衣恶食者，未足与议也。 有志之士，既然存心在道，就不应该贪求享受，如果还以粗糙的衣服和简陋的饮食为耻辱，那就不值得和他说什么了。 50．往者不可谏，来者犹可追。 过去的不可挽回，未来的还可以赶上。 ","link":"https://kangjn.github.io/post/lesslesslun-yu-greatergreater-50-jing-dian-ming-ju/"},{"title":"RabbitMQ使用教程(五)","content":"4.7.主题模式（通配符模式） 4.7.1.图示 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 4.7.2.生产者 package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.zpc.rabbitmq.util.ConnectionUtil; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); // 消息内容 String message = &quot;Hello World!!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 4.7.3.消费者1（前台系统） package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.7.4.消费者2（搜索系统） package com.zpc.rabbitmq.topic; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 5.Springboot集成RabbitMQ springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。 5.1.简单队列 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持 org.springframework.boot spring-boot-starter-amqp 2、配置application.properties文件 配置rabbitmq的安装地址、端口以及账户信息 spring.application.name=spirng-boot-rabbitmq spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin 3、配置队列 package com.zpc.rabbitmq; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitConfig { @Bean public Queue queue() { return new Queue(&quot;q_hello&quot;); } } 4、发送者 package com.zpc.rabbitmq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.text.SimpleDateFormat; import java.util.Date; @Component public class HelloSender { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } } 5、接收者 package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver : &quot; + hello); } } 6、测试 package com.zpc.rabbitmq; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMqHelloTest { @Autowired private HelloSender helloSender; @Test public void hello() throws Exception { helloSender.send(); } } 5.2.多对多使用（Work模式） 注册两个Receiver: package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } @Test public void oneToMany() throws Exception { for (int i=0;i&lt;100;i++){ helloSender.send(i); Thread.sleep(300); } } public void send(int i) { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + i + &quot; &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } 5.3.Topic Exchange（主题模式） topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 首先对topic规则配置，这里使用两个队列(消费者)来演示。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig { final static String message = &quot;q_topic_message&quot;; final static String messages = &quot;q_topic_messages&quot;; @Bean public Queue queueMessage() { return new Queue(TopicRabbitConfig.message); } @Bean public Queue queueMessages() { return new Queue(TopicRabbitConfig.messages); } /** * 声明一个Topic类型的交换机 * @return */ @Bean TopicExchange exchange() { return new TopicExchange(&quot;mybootexchange&quot;); } /** * 绑定Q到交换机,并且指定routingKey * @param queueMessage * @param exchange * @return */ @Bean Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;); } @Bean Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;); } } 2)创建2个消费者 q_topic_message 和q_topic_messages package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_message&quot;) public class Receiver1 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver1 : &quot; + hello); } } package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_messages&quot;) public class Receiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } 3)消息发送者（生产者） package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSender { @Autowired private AmqpTemplate rabbitTemplate; public void send1() { String context = &quot;hi, i am message 1&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context); } public void send2() { String context = &quot;hi, i am messages 2&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context); } } send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。 4)测试 package com.zpc.rabbitmq.topic; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitTopicTest { @Autowired private MsgSender msgSender; @Test public void send1() throws Exception { msgSender.send1(); } @Test public void send2() throws Exception { msgSender.send2(); } } 5.4.Fanout Exchange（订阅模式） Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanoutRabbitConfig { @Bean public Queue aMessage() { return new Queue(&quot;q_fanout_A&quot;); } @Bean public Queue bMessage() { return new Queue(&quot;q_fanout_B&quot;); } @Bean public Queue cMessage() { return new Queue(&quot;q_fanout_C&quot;); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(&quot;mybootfanoutExchange&quot;); } @Bean Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(aMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(bMessage).to(fanoutExchange); } @Bean Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(cMessage).to(fanoutExchange); } } 2）创建3个消费者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_A&quot;) public class ReceiverA { @RabbitHandler public void process(String hello) { System.out.println(&quot;AReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_B&quot;) public class ReceiverB { @RabbitHandler public void process(String hello) { System.out.println(&quot;BReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_C&quot;) public class ReceiverC { @RabbitHandler public void process(String hello) { System.out.println(&quot;CReceiver : &quot; + hello + &quot;/n&quot;); } } 3）生产者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSenderFanout { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String context = &quot;hi, fanout msg &quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context); } } 4）测试 package com.zpc.rabbitmq.fanout; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitFanoutTest { @Autowired private MsgSenderFanout msgSender; @Test public void send1() throws Exception { msgSender.send(); } } 结果如下，三个消费者都收到消息： AReceiver : hi, fanout msg CReceiver : hi, fanout msg BReceiver : hi, fanout msg 6.总结 使用MQ实现商品数据的同步优势： 1、降低系统间耦合度 2、便于管理数据的同步（数据一致性） 推荐阅读 《RabbitMQ详解》 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/"},{"title":"RabbitMQ使用教程(四)","content":"4.4.消息的确认模式 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？ 模式1：自动确认 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。 模式2：手动确认 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。 手动模式： 自动模式： 4.5.订阅模式 4.5.1.图示 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费 4.5.2.消息的生产者（看作是后台系统） 向交换机中发送消息。 package com.zpc.rabbitmq.subscribe; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。 4.5.3.消费者1（看作是前台系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.4.消费者2（看作是搜索系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.5.测试 测试结果： 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 在管理工具中查看队列和交换机的绑定关系： 4.6.路由模式 4.6.1.图示 4.6.2.生产者 4.6.3.消费者1(假设是前台系统) 4.6.4.消费2（假设是搜索系统） ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/"},{"title":"RabbitMQ使用教程(三)","content":"4、学习五种队列 4.1 简单队列 4.1.1.图示 P：消息的生产者 C：消息的消费者 红色：队列 生产者将消息发送到队列，消费者从队列中获取消息。 4.1.2.导入RabbitMQ的客户端依赖 com.rabbitmq amqp-client 3.4.1 4.1.3.获取MQ的连接 package com.zpc.rabbitmq.util; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; public class ConnectionUtil { public static Connection getConnection() throws Exception { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost(&quot;localhost&quot;); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost(&quot;testhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 4.1.4.生产者发送消息到队列 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明（创建）队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); //关闭通道和连接 channel.close(); connection.close(); } } 4.1.5.管理工具中查看消息 点击上面的队列名称，查询具体的队列中的信息： 4.1.6.消费者从队列中获取消息 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); } } } 4.2.Work模式 4.2.1.图示 一个生产者、2个消费者。 一个消息只能被一个消费者获取。 4.2.2.消费者1 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;); //休眠 Thread.sleep(10); // 返回确认状态，注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)； } } } 4.2.3.消费者2 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); // 休眠1秒 Thread.sleep(1000); //下面这行注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.2.4.生产者 向队列中发送100条消息。 package com.zpc.rabbitmq.work; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 100; i++) { // 消息内容 String message = &quot;&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); Thread.sleep(i * 10); } channel.close(); connection.close(); } } 4.2.5.测试 测试结果： 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。 RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。 basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。 2个概念 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 4.3.Work模式的“能者多劳” 打开上述代码的注释： // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); //开启这行 表示使用手动确认模式 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 同时改为手动确认： // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, false, consumer); 测试： 消费者1比消费者2获取的消息更多。 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/"},{"title":"RabbitMQ使用教程(二)","content":"2.4.学习5种队列 2.5.安装文档 3.搭建RabbitMQ环境 3.1.下载 下载地址：http://www.rabbitmq.com/download.html 3.2.windows下安装 3.2.1.安装Erlang 下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装 3.2.2.安装RabbitMQ 3.2.3.启用管理工具 1、双击 2、进入C:\\Program Files (x86)\\RabbitMQ Server\\rabbitmq_server-3.4.1\\sbin输入命令： rabbitmq-plugins enable rabbitmq_management 这样就启动了管理工具，可以试一下命令： 停止：net stop RabbitMQ 启动：net start RabbitMQ 3、在浏览器中输入地址查看：http://127.0.0.1:15672/ 4、使用默认账号登录：guest/ guest 3.3.Linux下安装 3.3.1.安装Erlang 3.3.2.添加yum支持 cd /usr/local/src/ mkdir rabbitmq cd rabbitmq wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc 使用yum安装： sudo yum install erlang 3.3.3.安装RabbitMQ 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/ 安装： rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 3.3.4.启动、停止 service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 3.3.5.设置开机启动 chkconfig rabbitmq-server on 3.3.6.设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 3.3.7.开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 注意要去掉后面的逗号。 3.3.8.开启web界面管理工具 rabbitmq-plugins enable rabbitmq_management service rabbitmq-server restart 3.3.9.防火墙开放15672端口 /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT /etc/rc.d/init.d/iptables save 3.4.安装的注意事项 1、推荐使用默认的安装路径 2、系统用户名必须是英文 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/"},{"title":"RabbitMQ使用教程(一)","content":"1.什么是MQ 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。 其主要用途：不同进程Process/线程Thread之间通信。 为什么会产生消息队列？有几个原因： 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列； 关于消息队列的详细介绍请参阅： 《Java帝国之消息队列》 《一个故事告诉你什么是消息队列》 《到底什么时候该使用MQ》 MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。 2.RabbitMQ 2.1.RabbitMQ的简介 开发语言：Erlang – 面向并发的编程语言。 2.1.1.AMQP AMQP是消息队列的一个协议。 2.2.官网 2.3.MQ的其他产品 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/"},{"title":"前端面试题目（二）","content":"解决HTML5新标签的兼容性： &lt;![if lt IE 9]&gt; //解决IE6-8支持HTML5新元素 //解决IE6-8对css Media Query//媒体查询 &lt;![endif]&gt; a:hover，a:active失效的问题？(lvha) 现象： a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。 解决方式： a:link {color:black} a:visited{color:pink} a:hover {color: blue} a:active {color: green} 将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。 如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。 选择器优先级？ 内联样式&gt;内部样式&gt;外部样式 ！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式 注意： 1、!important声明的样式优先级最高，如果冲突再进行计算。 2、如果优先级相同，则选择最后出现的样式。 3、继承得到的样式的优先级最低。 文本怎么自动换行？ word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。 word-wrap:normal word-wrap:break-word box-sizing模型？ content-box:默认 padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding border-box: padding和border包含在元素的宽度内，元素的实际宽度为：width js中创建自定义对象 ? var f=function(){} new Object() function f() this? 指向调用它的对象，如果没有，就指window HTML5表单新元素？ date time color number range email url search 5种常见的HTTP状态码及意义？ 200:请求成功 301、302：永久重定向/暂时重定向 400：请求格式错误 404：找不到资源 500：服务器内部错误 怎么让一个图片在一个DIV中垂直居中对齐？ 父元素使用相对定位 子元素使用绝对定位 怎么让文字垂直居中对齐？ 一行文字父元素不固定：padding:20px 父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell 如何让图片跟文字在居中显示： 父元素设置为vertical-align:middle 浏览器兼容？ 1、不同的浏览器默认样式不一样：padding margin 2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden 3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距 页面优化/站点优化？ 1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度 2、代码压缩/css/js yui compressor 数组的方法： join concat push pop unshift shift slice splice 正则表达式： \\d数字 \\s空白字符 \\w数字、字母、下划线 ？ 0-1 或 改为懒惰模式 0-n 1-n ^ 开关 $ 结尾 \\b 边界 new 一个对象具体干了什么？ 第一步是建立一个新对象； 第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象； 第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。 如何判断一个对象是否为数组？ typeof &quot;sflkj&quot; typeof无法判断数组跟对象 [] instanceof Array Array.prototype.isPrototypeOf([]) Array.isArray([]) 获取一个选项卡的值？ aa bb function showinfo(){ var sel=document.getElementById(\"s1\"); var i=sel.selectedIndex; var result=sel.options[i].value; } 浏览器对象有哪些？ navigator history window location screen event document window对象的常用方法？ alert confirm prompt close js绑定事件： btnObj.addEventListener(&quot;click&quot;,function(){}) jquery 把变量$的控制权交给其他JS库 jQuery.noConflict(); jQuery(function($){}) jQuery 遍历？（$.each()方法） asdf luili 234 var m=$(\"ul li\"); m.each(function(i){ if(i==0){ $(this).css(\"font-size\",\"18px\") } }) 怎么把一个JSON字符串转换成一个js对象？ var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} 把一个js对象转换成一个josn字符吕？ var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' 表单序列化成字符串：serialize（） 序列化成json对象：serializeArray() 手机端头部怎么写？ 不通过插件实现自响应布局？ CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局 CSS的媒体查询？ @media screen and(min-width:990px){//(一个css文件内) #id{ float:left } } @media screen and(min-width:700px) and (max-width:989px){ #id{ float:left } @media screen and(max-width:699px){ } angularjs？ 采用MVC模式 数据绑定 依赖注入 模块化设计 初始化一个模型数据 ng-bind=&quot;name&quot; ng-repeat=&quot;data in array&quot; angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){ .controller(&quot;myCtrl&quot;,function($scope){ $scope.newsTitle=&quot;hello&quot; }) } 什么是高内聚，低耦合？ 高内聚：一个模块内的元素的关系赵紧密越好 低耦合：不同模块间的关系尽量不要有关联 ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/"},{"title":"前端面试题目（一）","content":"什么是闭包？ 指有权访问另一个函数作用域中变量的函数 null 和undefined的区别？ 共同点：都是原始类型，保存在栈中变量本地 不同点： undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用 null:表示一个变量不再指向任何对象地址 表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用 常见行内元素和块级元素有哪些，他们有什么区别？ 行内元素：span img a u s i input select 块级元素：div ul ol li dt dd h1-h6 块级元素会单独占一行，行内元素会在一行显示。 什么是ajax？ ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。 实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新： 如何创建XMLHttpRequest请求步骤： 1、获取ajax对象 var xhr=new XMLHttpRequest(); 2、创建请求:调用XMLHttpRequest对象的open方法 xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步]) 3、回调函数的处理 xhr.onreadystatechange=function(){ if(xhr.readyState4){ if(xhr.status200){ var txt=xhr.responseText/responseXML } } } 4、发送请求 xhr.send(&quot;name=value$pwd=value&quot;); readyState属性： 0=未初始化 1=正在加载 2=以加载 3=交互中 4=加载完成 Ajax异步请求？ .ajax( { url:&quot;destination.php&quot;, type:&quot;post&quot;, data:(&quot;#id&quot;).val(), dataType:&quot;json&quot;, success:function(data){ console.log(data) } error:function(){ window.alert(&quot;error&quot;) } } ) AJAX的优缺点？ 优点： 页面局部刷新，提高用户体验 减轻服务器负担 具有更迅速的响应能力 能被广泛支持 缺点： 不支持浏览器后退按钮 安全问题 对搜索引擎支持比较弱 html中有哪些定位？ static:默认规则定位。 absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间 relative:相对定位，相对于初始位置定位/占页面空间 fixed:固定定位，相对于浏览器窗口 http 建立TCP连接 发送请求命令 发送请求头部 服务器应答 服务器发送应答头部 服务器发送应答具体信息 关闭连接 如何居中DIV？ 给DIV设置一个宽度，再设置margin为:0 auto; 如何居中一个浮动元素？ 使用一个居中显示的DIV包含些浮动元素。 position:fixed;//固定定位 width: 200px; height: 200px; background: red; margin-left:-100px; margin-top: -100px; left: 50%; top: 50%; 纯CSS实现一个三角形？ width: 0; height: 0; border:25px solid transparent; border-top-color: red; 重写trim()方法 if(String.prototype.trim===undefined){ String.prototype.trim=function () { return this.replace(/^\\s+|\\s+$/g) } } var str=&quot; helloworld &quot;; document.write(&quot;|&quot;+str+&quot;| &quot;); str=str.trim(); document.write(&quot;|&quot;+str+&quot;|&quot;); function trim(str){//同时去掉开头和结尾的空字符 var reg=/^\\s+|\\s+$/g; return str.replace(reg,&quot;&quot;); } var str=&quot; zhang dong &quot;; console.log(ltrim(str));//&quot;zhang dong &quot; console.log(rtrim(str));//&quot; zhang dong&quot; console.log(trim(str));//&quot;zhang dong&quot; 水仙花数 var a,b,c for(var i=100;i&lt;1000;i++){ a=parseInt(i%10); b=parseInt((i/10)%10); c=parseInt(i/100); if(iaaa+bbb+ccc){ console.log(i); } } 判断某一年是不是闰年 function isLeap(year){ console.log(year%40&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;); } isLeap(prompt(&quot;主输入年份&quot;)); 在单词后面加上数字 var str=&quot;one two three four&quot;; var i=4; var reg=/\\b[a-z]+\\b/g; str=str.replace(reg,function(kw){ return kw+i++; }) console.log(str); 判断是不是数组 var str=[] Array.prototype.isPrototypeOf(str);//true Object.prototype.toString.call(str);//[Object Array]; str instanceof Array; Array.isArray([]) 什么是继承？ 父对象已有的成员，子对象不用重复定义，就可以直接使用 什么是原型？ 每个函数都有一个prototype属性，该属性引用的就是原型对象， 原型对象就是保存共有属性和方法的对象 window窗口的全局对象？ history navigator screen location event 动态加载Dom? var frg=document.createDocumentFragment(); var m=document.createElement(&quot;div&quot;); m.innerHTML=&quot;this is first page&quot;; frg.appendChild(m); document.body.appendChild(frg); 数组去重？ var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] function unique(arr){ for(var i=0,arr2={};i&lt;arr.length;i++){ arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1); } var arr=[]; for(var key in arr2){ arr.push(key) } return arr; } console.log(unique(arr)); var arr1=[2,5,9,1,7] function sort(arr){ for(var i=0;iarr[j+1]]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } sort(arr1); console.log(arr1) 数组降维 var arr=[[1,2,3],[1,3,2]]; var res=Array.prototype.concat.apply([],arr) console.log(res); 如何理解HTML语义化？ 可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性 常用的语义化标签： 哪些属性可以继承？ font-size font-family color display:none和visibility:hidden的区别？ display不占据页面空间 visibility仍然占据空间 css3伪类选择器 :enabled :disabled :checked :firtt-child :last-child 为什么建议在设置背景图像的同时还设置背景颜色？ 如果因为各种原因图片无法加载的时候，页面会显示背景颜色。 CSS sprite的优缺点？ 把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位 优点： 减少网页的http请求，提高性能 减少图片的大小 维护更方便，只需要在一张图片上修改就可以。 缺点： 图片合成比较麻烦 背景设置时需要得到每一个图片的精确位置 CSS3新特性 box-shadow border-radius text-shadow ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/"}]}