{"posts":[{"title":" 灵性成长（二）","content":"**- 这门功课修得如何取决于你所获得的结果。 你越成长，就感觉越不需要成长。 你越精进，就越不想更精进。 不去亲证就无法学会任何事，想要获得智慧就只能去亲证。 研究幻象会让你误以为真实。如果你想知道真相，就不要研究假象。 成长的整个过程就是释放念头。当念头被完全清除，就只剩下真我。 它太简单，所以不要把它搞复杂了。 我们只能超越小我。真我就是超越了小我。 成长是释放你所不是的样子。 随着你成长，整个世界都会向你开放，你将经验更多。但是，即使你拥有全世界，你也只是拥有一个小点。拿下整个宇宙吧！ 对自由的渴望是关键。一旦你得到自由，你就会被它永远带走。 在达到自由或开悟的过程中，我们获得多少帮助取决于我们帮助别人多少。 成长吧，把你的注意力从自己身上移开，转到其他人身上。 为什么不应该是此时此地所有人都成大师，我们所有人？ 当我们下定决心成为真我的那一刻，我们就是真我！ 你的境界越高，就越无分别心。你接纳所有宗教。 在顺境中感到平静，并不表明你的境界有多高，这只是逃避。 如果不成长，就只会退转。 -你应该感谢那些反对你的人，因为他们给了你不寻常的成长机会。 当我们关注其他人在做什么时，我们就得以把注意力从自己身上移开。 你需要不断确认，直到你不再需要确认为止。 坚持不懈是必需的。 逆境促使成长。 这个世界越陷入危机，我们就越有机会成长。 如果人们不断强烈地质问“我是什么”，成长就会非常迅速。 当你找到“我是什么”的答案时，你就能控制自己的身体和心智。 如果你不喜欢什么，那就改变你自己。 你可能已经看到你是谁，但却无法持住。我们可以瞥见无限的真我，在那待一会儿，但突然间感觉我们已经失去了它。因为头脑还未被清除。全然地进入真我时，头脑在那一刻退居幕后，但是潜意识里的那些限制性念头依然还在。你尚未清除头脑，只是暂时释放了它。它会再次出现，小我再次接管，你都不明白刚刚（进入真我）发生了什么，然后再次被带回沉重的现实。我们要做的就是重新进入真我，一次又一次地，直到能永久地待在那里。每次我们这么做时，都能烧掉更多的头脑，直到头脑彻底灰飞烟灭。此时我们便能永久地待在真我中。你只是旁观着，头脑依然还在，但你已不是那头脑；身体依然还在，你也不再是那身体。只要你知道你既非那头脑，亦非那身体，它们便无法再触碰你。 ** ","link":"https://kangjn.github.io/post/ling-xing-cheng-chang-er/"},{"title":"灵性成长（一）","content":"**- 灵性道路的唯一目的就是释放小我。剩下的就是你的真我。 只有一种成长，那就是消除小我。 小我就是这样一种感觉：我是与一切万有相分离的个体。到了极致就是自我中心。 成长就是超越你自己-----习惯性的自己，那正是小我。 成长就是小我从它的痛苦中解脱出来。 认出所有的喜悦都只不过是你的真我 如果你不经验你的真我，就不会有真正的幸福可言。当你明白这一点，道路是非常直接的。你不再追寻海市蜃楼，而是奔幸福而去。你知道了幸福在哪里，它就在你内。 你所追寻的一切，其实你本自具足，却非常愚蠢地说“我不是”。这是个迷。每个人所苦苦求索的，其实本自具足，甚至更多。 这就是你，当你说：“我”，这就是指那无限的本质。有趣的是，作为无限的你，却在寻找你所是的真我。 谁若说他自己不是个大师，他就是在撒谎。 你的努力应该用在合适的身份认同上，认同你真我的身份。 灵性成长的衡量标准是你有多认同你真我的身份。 小我非常狡猾，它经常把我们从灵性道路上拉出去一段时间，有时甚至很久。一旦我们陷入小我的陷阱，我们通常很难逃脱。所以你必须提防小我，它是我们的一部分。不管我们在灵性道路上有多精进，小我总是像个变节的同伴，把我们带离觉醒之路，有时甚至是终生。 以下是我们要提防的：小我始终抓着我们，对我们不离不弃，它会说：我就是上帝。以此来阻碍我们进一步的成长。 当你发现小我在抗拒时，你可以释放抗拒的感觉。经过不断的练习，这会变得容易。当你释放掉了足够的小我，就能自然地感觉到真我的平静和喜悦。 这真的是一条能够逐渐呈现你那无限本质的道路。你放下限制、放下痛苦，但你永远不会失去任何有价值的、美好的东西。 在这条路上，你会不断地脱离麻烦。 痛苦是我们的第一位老师。它第一个推动我们去寻找出路。 我们走上道途一开始源于躲避痛苦。接着我们尝到了真我的滋味并且想要继续体味，因为它实在太美妙。 在这条路上你永远不会失去任何东西，你只会拥有越来越多你真正想要的，直到你拥有全部。 去品尝你内的甜蜜，而不是逃离你外的痛苦。 我们发现在灵性道路上永远不会失去什么，除了我们给自己强加的伤痛和绷带。 若你对灵性道路没兴趣，那么只会执着于感官世界（物质世界）。 为什么你不能？因为你认为你不能。 你之所以认为你做不了，仅仅是因为你认为你做不了。 那些认为自己做不了的人，实际上是不想做。 你是否能够成长只取决于你自己。 只要你能做，它就会发生。 唯一想要改变你的人，是你自己。 愿望和企图都没用，你必须行动！ 美好的意图抵不上正确的行动。 想要改变更快发生，那就想象它发生！ 若你想改变，意愿必须非常强烈，因为你长期受到习气的控制，以致于就像一个溺水者渴望空气一样。想要摆脱习气的控制，那你必须对体悟真我的渴望就同溺水者渴望空气一样 你的成功取决于你对成功的渴望程度。如果你失去勇气，那意味着你对成功没有了兴趣。 你唯一的朋友是你自己。你唯一的敌人也是你自己。你越限制你自己，你就越是自己的敌人。相反地，你越放开你自己，你就越是自己的朋友。 你要做的工作是回归无限的真我。只有你自己才能完成。你限制了自己，你必须亲自解除这个限制。 灵性道路就是自助的道路。 做能做到的事，并尽力去做。 每个经历都是为了祝福你，而非伤害你。若能一直遵循（灵性）法则，你将去往更高的境界。 生命中的每个地方，每种状况，都是成长的契机。 成长的最佳地点就是此地，最佳时间就是此时。 对成长的各种机会心怀感恩。 测试的最佳地点是待在家里，和你的原生家庭一起。因此，家是绝佳的成长地点。 通过练习对伴侣和家人无私的爱，可以获得很大的灵性成长。 人们说你坏话，这给了你成长的机会，让你练习如何才能真爱，如何才能真平静。因为他们只是用他们的嘴巴发出声音，你没有任何理由对此感觉不好。被反对是件好事，它激发并巩固成长。 -有必要记住每个人都是我们的老师。如果我们对赞美起反应，那是在助长小我；同样地，若对批评感到沮丧，那也是小我。当我们成为真我，就不再起反应。 -没有什么事是毫无用处的。每个意外都可以被视为老师。 每一天的每一分钟都可以用来成长。 如果我们想象我们在那里，但我们是在这里。命运很快会把我们拉回此时此地。 如果你告诉其他人有关你的高峰体验，有关你的成长收获，人们会因为嫉妒而说“你以为你是谁”。这往往很容易把你拖回来。 每当你吹牛时，你都是在邀请考验。所以，我警告你，除非你确定你自己是知道借由吹牛的体验你不会失去什么，否则就不要吹牛。 -为你的灵性成果感到骄傲，欢喜。 当你对自己的灵性成长不诚实时，你就是在邀请挑战 有必要消除疑虑。 灵性成长不仅需要信仰，还需要了解。从信仰开始，但必须转到了解。因为你必须通过检验才能明了。 为了真正了悟，就必须去了解。 当你去经历时，就不再停留在头脑层面。 开悟无需阐释的能力。 灵性开悟是唯一的成熟。 要站出来，变得与众不同，不要再让他人将你拉回原地。这不容易，需要刚毅。 我们应该努力走完全程，因为我们被赋予这种能力。我们有可能走完全程，直达源头。 期待无限。也只能期待无限。 沿着道途走到终点。你越沿着道途走，就能越快到达终点。 每个收获都是永恒的。每一个向前的步伐也是永恒的。 我们爬梯子时，每当上了一个阶梯就会忘了下面的。当我们到达顶端时，干脆踢了梯子。 ** ","link":"https://kangjn.github.io/post/ling-xing-cheng-chang-yi/"},{"title":"docker命令大全","content":"*一、基本命令： 查看镜像：docker images 搜索镜像：docker search mysql:5.7.0 (5.7.0：搜索指定的版本) 列出当前运行的容器：docker ps 列出所有的容器（包括已停止的）：docker ps -a 停止容器 ：docker stop 5d034c6ea010 （5d034c6ea010 : 容器id） 进入容器： docker exec -it 容器id /bin/bash 下载镜像：docker pull ubuntu（默认latest,最新版） 下载带版本的镜像：docker pull ubuntu:13.10 创建容器时，设置自动启动容器：docker run --restart=always 容器id（或者容器名称）如果创建时未指定 --restart=always , ​ 可通过update 命令设置：docker update --restart=always 容器id（或者容器名称） 查看docker信息：docker info 查看容器的日志：docker logs -f 容器ID（-f：可以滚动查看日志的最后几行） 查看我们的容器与基础镜像有什么不同：docker container diff sample A代表新增文件 C代表修改过的文件 D代表被删除的文件 将修改过的容器导出为自己的镜像：docker container commit sample my-alpine 看本地镜像runoob/ubuntu:v3的创建历史：docker history runoob/ubuntu:v3 将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档： docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3（-o :输出到的文件） 导入使用 docker save 命令导出的镜像： docker load &lt; busybox.tar.gz 从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4： docker import my_ubuntu_v3.tar runoob/ubuntu:v4 创建容器：docker run -i -t -v /root/software/:/mnt/software/ 9f38484d220f /bin/bash （-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;） 运行容器：docker run --rm -t -i ubuntu:15.10 /bin/bash （/bin/bash：交互式 Shell，-t: 表示容器启动后会进入其命令行，-i: 表示以“交互模式”运行容器， --rm:停止容器后直接删除容器） 数据拷贝： docker cp，此命令用于容器与宿主机之间进行数据拷贝,如 docker cp 5d034c6ea010: /etc/nginx/nginx.conf /dockerData/nginx/conf/nginx.conf 将容器的目录文件拷贝到宿主机指定位置,容器ID可以替换成容器名 删除镜像：docker rmi 镜像名/镜像id 删除容器： docker rm 容器id (必须是未启动的容器 ) 强制删除容器 db01、db02：docker rm -f db01 db02 删除容器 nginx01, 并删除容器挂载的数据卷：docker rm -v nginx01 移除所有的容器：docker rm -f (docker container ls -aq) 杀掉一个运行中的容器:docker kill -s KILL mynginx（-s :向容器发送一个信号） 更新镜像: 1.从已经创建的容器中更新镜像，并且提交这个镜像，使用 yum update 更新镜像,在完成操作之后，输入 exit 命令来退出这个容器。 提交镜像： docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2，其中： -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名 2、使用 Dockerfile 指令来创建一个新的镜像 设置镜像标签： docker tag 860c279d2fec ubuntu:dev 查询最后一次创建的容器： docker ps -l 容器命名： docker run -d -P --name runoob training/webapp python app.py(--name命令:定义容器别名，其中runoob ：容器名，training/webapp：容器所属的镜像名，python：为启动的容器创建的别名) 新建网络：docker network create -d bridge test-net，参数说明：-d：参数指定 Docker 网络类型，有 bridge、overlay，其中 overlay 网络类型用于 Swarm mode 登录docker远程镜像仓库： sudo docker login --username=qweads registry.cn-hangzhou.aliyuncs.com 退出docker远程镜像仓库：docker logout 推送镜像到远程仓库：docker push 镜像名/镜像id 导出容器：docker export 容器id&gt; /地址/容器别名.tar， 导入容器：cat docker/ubuntu.tar | docker import - test/ubuntu:v1 (将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1) 查看镜像或容器的详细信息：docker inspect 容器id (可以加-f参数只查看某一项信息) 查看容器IP： docker inspect --format='{{.NetworkSettings.IPAddress}}'CONTAINER_ID/NAME 查看容器数据卷挂载目录：docker inspect container_id | grep Mounts -A 20 手动创建数据卷： docker volume create shared-data 删除数据卷： docker volume rm my-data 列出目前已有的volume：docker volume ls 与磁盘空间使用情况相关的命令：docker system df 移除所有不在运行状态的容器：docker container prune 清除未被使用到的镜像：docker image prune --force --all 清除未被使用到的数据卷：docker volume prune 创建一个自定的网络：docker network create --driver bridge sample-net 查看所有网络 ：docker network ls 删除所有未被任何容器或者服务连接的网络：docker network prune 查看该网络的详细情况：docker network inspect test-network 将一个容器连接到多个网络： 第一步：docker run -itd --name test --network test-net mysql /bin/bash ping 127.0.0.1 第二步：docker network connect test-net mysql 从网络中移除容器：docker network disconnect 网络名/id mysql 删除网络：docker network rm my-network1（删除前,必须确认没有容器在使用该网络） 修改已启动容器的端口号： ​ docker ps 查看 Container 的 id ​ docker stop {container_id} ​ 3.找到 /var/lib/docker/containers/{container_id}/hostconfig.json 修改 ​ sudo service docker restart 重启docker ​ docker start {container_id} 重新启动 container 二、dockerfile: 1、创建Dockerfile文件：mkdir Dockerfile 2、编辑文件 ：vi Dockerfile 3、添加脚本如： FROM nginx RUN echo '这是一个本地构建的nginx镜像' &gt; /usr/share/nginx/html/index.html 介绍： FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。 RUN：用于执行后面跟着的命令行命令。有以下俩种格式： shell 格式：RUN &lt;命令行命令&gt;，&lt;命令行命令&gt; 等同于，在终端操作的 shell命令。 exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 例如：#RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于RUN ./test.php dev offline ​ 指令详解 ​ 1》COPY ​ 复制指令，从上下文目录中复制文件或者目录到容器里指定路径： ​ COPY . /app #将上下文目录中所有文件或目录递归拷贝到容器的/app目录下 ​ COPY ./web /app/web #将上下文目录中的web目录下的内容拷贝到容器的/app/web目录下 ​ COPY sample.txt /data/my-sample.txt #拷贝单个文件并重命名 ​ ADD sample.tar /app/bin/ #解压tar包内的文件到指定目录 ​ ADD http://example.com/sample.txt /data/ #拷贝远程文件到指定目录 ​ COPY ./sample* /mydir/ #支持源路径中使用通配符 ​ 2》WORKDIR ​ WORKDIR用来定义工作目录或者上下文目录。常见的问题： ​ （WORKDIR 指定的工作目录，必须是提前创建好的）。 ​ 由于每执行一次RUN，都是在原有镜像上添加一个新层，因此上面的命令只是在root目录下新建了sample.txt文件。 ​ 正确的切换至一个目录下，并新建文件，命令如下： ​ WORKDIR /app/bin ​ RUN touch sample.txt ​ 3》CMD ​ 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: ​ CMD 在docker run 时运行。 ​ RUN 是在 docker build。 ​ 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 ​ 如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 ​ CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&quot;,&quot;&quot;,...] ​ CMD [&quot;&quot;,&quot;&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 ​ 4》ENTRYPOINT ​ 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。 ​ 但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。 ​ 假设已通过 Dockerfile 构建了 nginx:test 镜像： ​ FROM nginx ​ ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参 ​ CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 ​ 1、不传参运行 ​ docker run nginx:test ​ 容器内会默认运行以下命令，启动主进程。 ​ nginx -c /etc/nginx/nginx.conf ​ 2、传参运行 ​ docker run nginx:test -c /etc/nginx/new.conf ​ 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件) ​ nginx -c /etc/nginx/new.conf ​ Dockerfile构建镜像命令：docker build -t nginx:test . （. 代表Dockerfile文件的路径） ​ 当你的配置文件不是默认的名字时，可以使用-f参数指定： docker build -t nginx:test -f my-Dockerfile . 三、docker-compose: docker-compose.yml 配置文件： # yaml 配置 version: '3' services: webapp: build: ./dir ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; 介绍： docker-compose命令需在docker-compose.yml 所在目录下才能运行 启动应用程序：docker-compose up -d (-d:在后台启动) 指定使用的 Compose 模板文件，默认为 docker-compose.yml： docker-compose -f docker-compose.yml up -d 停用移除所有容器以及网络相关：docker-compose down docker-compose logs：docker-compose logs 列出所有容器：docker-compose ps 构建（重新构建）项目中的服务容器：docker-compose build 拉取服务依赖的镜像：docker-compose pull 列出指定服务的容器：docker-compose ps eureka 删除指定服务的容器：docker-compose rm eureka 启动指定服务已存在的容器：docker-compose start eureka 在一个服务上执行一个命令：docker-compose run web bash（这样即可启动一个web服务，同时执行bash命令） 停止已运行的容器：docker-compose stop eureka 通过发送SIGKILL 信号停止指定服务的容器：docker-compose kill eureka 一个web服务形成瓶颈的时候，我们可以快速地的扩充几个web服务出来 ： docker-compose up --scale web=3（ports:需要修改为随即映射端口，如 -5000） version：指定本 yml 依从的 compose 哪个版本制定的。 build：指定为从上下文路径 ./dir/Dockerfile 所构建的镜像, 或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args： version: &quot;3.7&quot; services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 labels: - &quot;com.example.description=Accounting webapp&quot; - &quot;com.example.department=Finance&quot; - &quot;com.example.label-with-empty-value&quot; target: prod context：上下文路径。 dockerfile：指定构建镜像的 Dockerfile 文件名。 args：添加构建参数，这是只能在构建过程中访问的环境变量。 labels：设置构建镜像的标签。 target：多层构建，可以指定构建哪一层。 ​ depends_on 设置依赖关系: ​ docker-compose up ：以依赖性顺序启动服务 ​ docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。 ​ docker-compose stop ：按依赖关系顺序停止服务。 ​ docker-compose.yml： ​ version: &quot;3.7&quot; ​ services: ​ web: ​ build: . ​ depends_on: ​ - db ​ - redis ​ redis: ​ image: redis ​ db: ​ image: postgres ​ 注意：web 服务不会等待 redis db 完全启动 之后才启动。 deploy：指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。 docker-compose.yml： version: &quot;3.7&quot; services: redis: image: redis:alpine deploy: mode：replicated replicas: 6 endpoint_mode: dnsrr labels: description: &quot;This redis service label&quot; resources: limits: cpus: '0.50' memory: 50M reservations: cpus: '0.25' memory: 20M restart_policy: condition: on-failure delay: 5s max_attempts: 3 window: 120s endpoint_mode：访问集群服务的方式： vip：集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。 dnsrr：DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。 labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。 mode：指定服务提供的模式： replicated：复制服务，复制指定服务到集群的机器上 global：全局服务，服务将部署至集群的每个节点。 replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。 resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。 restart_policy：配置如何在退出容器时重新启动容器。 condition：可选 none，on-failure 或者 any（默认值：any）。 delay：设置多久之后重启（默认值：0）。 max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默 认值：一直重试）。 window：设置容器重启超时时间（默认值：0）。 四、docker-machine： 列出可用的机器：docker-machine ls 创建一台名为 test 的机器：docker-machine create --driver virtualbox test（--driver：指定用来创建机器的驱动类型。） 查看机器的 ip：docker-machine ip test 停止机器： docker-machine stop test 启动机器：docker-machine start test 进入机器：docker-machine ssh test 查看当前激活状态的 Docker 主机：docker-machine active 查看某一个docker vm主机的信息：docker-machine env test 删除某台 Docker 主机，对应的虚拟机也会被删除:：docker-machine rm test 以 json 格式输出指定Docker的详细信息：docker-machine inspect test 设置当前的环境变量为某一个主机的信息：eval (docker-machine env test) 取消当前环境变量：eval(docker-machine env -u) 通过 SSH 连接到主机上，执行命令：docker-machine ssh swarm-manager 五、docker swarm： Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。 swarm 集群由管理节点（manager）和工作节点（work node）构成。 swarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。 work node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。 1、创建 swarm 集群管理节点（manager） 创建 docker 机器： docker-machine create -d virtualbox swarm-manager 连接到主机上：docker-machine ssh swarm-manager 初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点: docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。 会输出： docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377 查看集群节点信息: docker node ls 2、创建 swarm 集群工作节点（worker） 使用docker-machine 创建swarm-worker1 和 swarm-worker2 两台机器。 docker-machine create -d virtualbox worker1 docker-machine create -d virtualbox worker2 docker-machine ssh swarm-worker1进入机器里 添加上一步输出的内容。 3、查看集群信息 docker-machine ssh swarm-manager进入集群管理节点,执行docker info 可以查看当前集群的信息（Swarm:active,Managers:1,Nodes:3,有三个节点,其中有一个是管理节点） 4、部署服务到集群中 注意：跟集群管理有关的任何操作，都是在管理节点上操作的。 在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：docker service create --replicas 1 --name helloworld alpine ping docker.com 命令解释： docker service create 命令创建一个服务 --name 服务名称命名为 helloworld --replicas 设置启动的示例数 alpine指的是使用的镜像名称，ping docker.com指的是容器运行的bash 5、查看服务部署情况 查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点： docker service ps helloworld 查看 helloworld 部署的具体信息：docker service inspect --pretty helloworld 6、扩展集群服务 将上述的 helloworld 服务扩展到俩个节点：docker service scale helloworld=2 可以看到已经从一个节点，扩展到两个节点：docker service ps helloworld 7、删除服务：docker service rm helloworld 查看是否已删除：docker service ps helloworld 8、滚动升级服务 介绍 redis 版本如何滚动升级至更高版本 创建一个 3.0.6 版本的 redis。 docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6 滚动升级 redis docker service update --image redis:3.0.7 redis 9、停止某个节点接收新的任务 查看所有的节点：docker node ls 可以看到目前所有的节点都是 Active, 可以接收新的任务分配。 停止节点 swarm-worker1： docker node update --availability drain swarm-worker1 （Drain：节点状态） 重新激活swarm-worker1： docker node update --availability active swarm-worker1（active ：活跃状态） 10.退出 Swarm 集群 如果 Manager 想要退出 Swarm 集群， 在 Manager Node 上执行如下命令： docker swarm leave 就可以退出集群，如果集群中还存在其它的 Worker Node，还希望 Manager 退出集群，则加上一个强制选项，命令行如下所示：docker swarm leave --force 在 Worker2 上进行退出测试，登录 worker2 节点： docker-machine ssh worker2 执行退出命令：docker swarm leave 11.重新搭建命令 使用 VirtualBox 做测试的时候，如果想重复实验可以将实验节点删掉再重来。 停止虚拟机：docker-machine stop manager1 worker1 worker2 移除虚拟机：docker-machine rm manager1 worker1 worker2 停止、删除虚拟主机后，再重新创建即可。 ","link":"https://kangjn.github.io/post/docker-ming-ling-da-quan/"},{"title":"一个WEB程序员发展历程","content":"做一个静态网页： HTML：用来布局网页 CSS：用来美化网页 JavaScript：用来做点击跳转，窗口弹出 真正开发时需要用一些开发框架和组件来快速开发： JQUERY：极大简化了JavaScript的编程方式 BootStrap.js：可直接套用其好看的样式进行快速开发 浏览器兼容 谷歌浏览器 火狐浏览器 IE6,7,8,9浏览器 360安全浏览器 360极速浏览器 网页是静态，需要改成动态的... Ajax，用来进行前端调后端接口 Json，后端接口返回的数据的一种格式 Spring：轻量级的快速开发框架 Spring MVC：一个快速开发Web应用框架 FreeMarker：一种服务端模板引擎 HttpClient：一个Java实现的Http请求客户端 Mybatis：一款优秀的持久层框架 Mysql：一个国内最流行的数据库软件 Maven：一个项目管理工具，可以对 Java 项目进行构建、依赖管理 Tomcat：使用得最多的Servlet容器，可以用来接收浏览器请求 管理工具 Git：一个代码版本管理工具 GitLab：一个项目管理和代码托管平台 Nexus：一个强大的Maven仓库管理器，它极大地简化了自己内部仓库的维护和外部仓库的访问 禅道：第一款国产的开源项目管理软件，完整地覆盖了项目管理的核心流程 jira：Jira融合了项目管理、任务管理和缺陷管理，许多著名的开源项目都采用了JIRA 有了这些管理工具，还需要一些自动化构建工具，这样能使得开发测试上线更加顺利： Docker：一个开源的应用容器引擎 Jenkins：一个开源的、提供友好操作界面的持续集成(CI)工具 一套自动化开发测试搭建起来了，有了这一整套项目开发管理工具，可以进行小团队合作 为了上线之后能够有保障的运行，我们需要给我们的网站配套一套监控和日志系统： Prometheus：一个开源的服务监控系统和时间序列数据库 Grafana：一个开源的、功能齐全的度量仪表盘和图形编辑器 Zabbix：一个企业级分布式开源监控解决方案 ElasticSearch：一个实时的分布式搜索分析引擎 Kibana：一个能对日志进行高效的搜索、可视化、分析等各种操作的平台 LogStash：一个应用程序日志、事件的传输、处理、管理和搜索的平台 Log4j：一个可以控制日志信息输送的目的地的开源组件 Logback：og4j创始人设计的另外一个开源日志组件 搭完这一套，网站上线了，一段时间后，网站的用户慢慢在增多，我们通过我们的监控系统，发现有几个核心应用压力在不停地增加，要做负载均衡了： nginx：一个高性能的HTTP和反向代理web服务器 lvs：一个虚拟的服务器集群系统 keepalive：一个可以检测web服务器的状态的服务 最后通过使用nginx并增加几台服务器来做了负载均衡，仅仅做负载均衡还不够，可以把热门商品给提前缓存起来： Redis：一个高性能的key-value数据库，对关系数据库起到很好的补充作用 Jedis：一个Redis 官方首选的 Java 客户端开发包 Redisson：一个在NIO的基础上，为使用者提供了一系列具有分布式特性的常用工具类 这样，我们的网站访问速度提升了，要做一个订单状态变更短信通知的功能，用消息队列来做，： RabbitMQ：是一款高性能、搞健壮性以及高伸缩性的消息队列中间件 Kafka：是一种高吞吐量的分布式发布订阅消息系统 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务 最后，选了阿里的RocketMQ 随着业务的发展，要对我们的项目做一次重构，改成分布式微服务架构： Dubbo：阿里开源的高性能RPC调用框架 Spring Cloud：一个为开发人员快速构建微服务架构的开发框架 Zookeeper：一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供组服务 Netty：一个高性能网络应用框架 Xxl-Job：一个轻量级分布式任务调度平台 Elastic-Job：一个分布式调度解决方案 选用Spring Cloud，他所提供的几个组件太强大了，比如： Nacos：一个动态服务发现、配置和服务管理平台 Ribbon：一个在客户侧提供软件负载均衡算法的组件 Feign：一个更强大好用的Java HTTP 客户端库 Sentinel：一个面向分布式服务架构的高可用流量防护组件 进入了高速发展期： 敏捷开发：一种新型的互联网开发模式 迭代：敏捷开发过程中的周期概念 看板：敏捷开发过程中最重要的效能工具 DDD：一种微服务拆分设计思想 等等开发设计理念... 直到有一天，出事了...，我们网站瘫痪了，一看监控，数据库压力爆了，通过调整限流等措施，暂时得到了缓解，需要分库分表了： Mycat：一个彻底开源的，面向企业应用开发的数据库中间件产品 ShardingSphere：一套开源的分布式数据库中间件解决方案组成的生态圈 还要做到自动扩缩容： kubernetes：一个来自 Google 云平台的开源容器集群管理系统 openshift：一个由红帽推出的面向开发人员的Paas 一些概念： ServiceMesh架构：下一代微服务架构 Serverless架构：用来构建和运行不需要服务器管理的应用程序 云原生架构：一种结合云环境，充分利用云资源的架构 进入了平稳期 ","link":"https://kangjn.github.io/post/yi-ge-web-cheng-xu-yuan-fa-zhan-li-cheng/"},{"title":"分布式锁 三种实现方式","content":"一、为什么要使用分布式锁 我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的Java多线程的18般武艺进行处理，并且可以完美的运行，毫无Bug！ 注意这是单机应用，也就是所有的请求都会分配到当前服务器的JVM内部，然后映射为操作系统的线程进行处理！而这个共享变量只是在这个JVM内部的一块内存空间！ 后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做[负载均衡]，大致如下图： 上图可以看到，变量A存在JVM1、JVM2、JVM3三个JVM内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象，例如：UserController控制器中的一个整形类型的成员变量)，如果不加任何控制的话，变量A同时都会在JVM分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同JVM内存区域的数据，变量A之间不存在共享，也不具有可见性，处理的结果也是不对的！ 如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！ 为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 二、分布式锁应该具备哪些条件 在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件： 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 三、分布式锁的三种实现方式 目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。 在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。 基于缓存（Redis等）实现分布式锁； 基于数据库实现分布式锁； 基于Zookeeper实现分布式锁； 基于 Redis 的分布式锁 利用 SETNX 和 SETEX 基本命令主要有： SETNX(SET If Not Exists)：当且仅当 Key 不存在时，则可以设置，否则不做任何动作。 SETEX：可以设置超时时间 其原理为：通过 SETNX 设置 Key-Value 来获得锁，随即进入死循环，每次循环判断，如果存在 Key 则继续循环，如果不存在 Key，则跳出循环，当前任务执行完成后，删除 Key 以释放锁。 这种方式可能会导致死锁，为了避免这种情况，需要设置超时时间。 下面，请看具体的实现步骤。 1.创建一个 Maven 工程并在 pom.xml 加入以下依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 开启web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.创建启动类 Application.java： @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } } 3.添加配置文件 application.yml： server: port: 8080 spring: redis: host: localhost port: 6379 4.创建全局锁类 Lock.java： /** * 全局锁，包括锁的名称 */ public class Lock { private String name; private String value; public Lock(String name, String value) { this.name = name; this.value = value; } public String getName() { return name; } public String getValue() { return value; } } 5.创建分布式锁类 DistributedLockHandler.java： @Component public class DistributedLockHandler { private static final Logger logger = LoggerFactory.getLogger(DistributedLockHandler.class); private final static long LOCK_EXPIRE = 30 * 1000L;//单个业务持有锁的时间30s，防止死锁 private final static long LOCK_TRY_INTERVAL = 30L;//默认30ms尝试一次 private final static long LOCK_TRY_TIMEOUT = 20 * 1000L;//默认尝试20s @Autowired private StringRedisTemplate template; /** * 尝试获取全局锁 * * @param lock 锁的名称 * @return true 获取成功，false获取失败 */ public boolean tryLock(Lock lock) { return getLock(lock, LOCK_TRY_TIMEOUT, LOCK_TRY_INTERVAL, LOCK_EXPIRE); } /** * 尝试获取全局锁 * * @param lock 锁的名称 * @param timeout 获取超时时间 单位ms * @return true 获取成功，false获取失败 */ public boolean tryLock(Lock lock, long timeout) { return getLock(lock, timeout, LOCK_TRY_INTERVAL, LOCK_EXPIRE); } /** * 尝试获取全局锁 * * @param lock 锁的名称 * @param timeout 获取锁的超时时间 * @param tryInterval 多少毫秒尝试获取一次 * @return true 获取成功，false获取失败 */ public boolean tryLock(Lock lock, long timeout, long tryInterval) { return getLock(lock, timeout, tryInterval, LOCK_EXPIRE); } /** * 尝试获取全局锁 * * @param lock 锁的名称 * @param timeout 获取锁的超时时间 * @param tryInterval 多少毫秒尝试获取一次 * @param lockExpireTime 锁的过期 * @return true 获取成功，false获取失败 */ public boolean tryLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) { return getLock(lock, timeout, tryInterval, lockExpireTime); } /** * 操作redis获取全局锁 * * @param lock 锁的名称 * @param timeout 获取的超时时间 * @param tryInterval 多少ms尝试一次 * @param lockExpireTime 获取成功后锁的过期时间 * @return true 获取成功，false获取失败 */ public boolean getLock(Lock lock, long timeout, long tryInterval, long lockExpireTime) { try { if (StringUtils.isEmpty(lock.getName()) || StringUtils.isEmpty(lock.getValue())) { return false; } long startTime = System.currentTimeMillis(); do{ if (!template.hasKey(lock.getName())) { ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(lock.getName(), lock.getValue(), lockExpireTime, TimeUnit.MILLISECONDS); return true; } else {//存在锁 logger.debug(&quot;lock is exist!！！&quot;); } if (System.currentTimeMillis() - startTime &gt; timeout) {//尝试超过了设定值之后直接跳出循环 return false; } Thread.sleep(tryInterval); } while (template.hasKey(lock.getName())) ; } catch (InterruptedException e) { logger.error(e.getMessage()); return false; } return false; } /** * 释放锁 */ public void releaseLock(Lock lock) { if (!StringUtils.isEmpty(lock.getName())) { template.delete(lock.getName()); } } } 6.最后创建 HelloController 来测试分布式锁。 @RestController public class HelloController { @Autowired private DistributedLockHandler distributedLockHandler; @RequestMapping(&quot;index&quot;) public String index(){ Lock lock=new Lock(&quot;lynn&quot;,&quot;min&quot;); if(distributedLockHandler.tryLock(lock)){ try { //为了演示锁的效果，这里睡眠5000毫秒 System.out.println(&quot;执行方法&quot;); Thread.sleep(5000); }catch (Exception e){ e.printStackTrace(); } distributedLockHandler.releaseLock(lock); } return &quot;hello world!&quot;; } } 7.测试。 启动 Application.java，连续访问两次浏览器：http://localhost:8080/index，控制台可以发现先打印了一次“执行方法”，说明后面一个线程被锁住了，5秒后又再次打印了“执行方法”，说明锁被成功释放。 通过这种方式创建的分布式锁存在以下问题： 高并发的情况下，如果两个线程同时进入循环，可能导致加锁失败。 SETNX 是一个耗时操作，因为它需要判断 Key 是否存在，因为会存在性能问题。 因此，Redis 官方推荐 Redlock 来实现分布式锁。 利用 Redlock 通过 Redlock 实现分布式锁比其他算法更加可靠，继续改造上一例的代码。 1.pom.xml 增加以下依赖： &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; 2.增加以下几个类： /** * 获取锁后需要处理的逻辑 */ public interface AquiredLockWorker&lt;T&gt; { T invokeAfterLockAquire() throws Exception; } /** * 获取锁管理类 */ public interface DistributedLocker { /** * 获取锁 * @param resourceName 锁的名称 * @param worker 获取锁后的处理类 * @param &lt;T&gt; * @return 处理完具体的业务逻辑要返回的数据 * @throws UnableToAquireLockException * @throws Exception */ &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws UnableToAquireLockException, Exception; &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception; } /** * 异常类 */ public class UnableToAquireLockException extends RuntimeException { public UnableToAquireLockException() { } public UnableToAquireLockException(String message) { super(message); } public UnableToAquireLockException(String message, Throwable cause) { super(message, cause); } } /** * 获取RedissonClient连接类 */ @Component public class RedissonConnector { RedissonClient redisson; @PostConstruct public void init(){ redisson = Redisson.create(); } public RedissonClient getClient(){ return redisson; } } @Component public class RedisLocker implements DistributedLocker{ private final static String LOCKER_PREFIX = &quot;lock:&quot;; @Autowired RedissonConnector redissonConnector; @Override public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws InterruptedException, UnableToAquireLockException, Exception { return lock(resourceName, worker, 100); } @Override public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception { RedissonClient redisson= redissonConnector.getClient(); RLock lock = redisson.getLock(LOCKER_PREFIX + resourceName); // Wait for 100 seconds seconds and automatically unlock it after lockTime seconds boolean success = lock.tryLock(100, lockTime, TimeUnit.SECONDS); if (success) { try { return worker.invokeAfterLockAquire(); } finally { lock.unlock(); } } throw new UnableToAquireLockException(); } } 3.修改 HelloController： @RestController public class HelloController { @Autowired private DistributedLocker distributedLocker; @RequestMapping(&quot;index&quot;) public String index()throws Exception{ distributedLocker.lock(&quot;test&quot;,new AquiredLockWorker&lt;Object&gt;() { @Override public Object invokeAfterLockAquire() { try { System.out.println(&quot;执行方法！&quot;); Thread.sleep(5000); }catch (Exception e){ e.printStackTrace(); } return null; } }); return &quot;hello world!&quot;; } } 4.按照上节的测试方法进行测试，我们发现分布式锁也生效了。 Redlock 是 Redis 官方推荐的一种方案，因此可靠性比较高。 基于数据库的分布式锁 基于数据库表 它的基本原理和 Redis 的 SETNX 类似，其实就是创建一个分布式锁表，加锁后，我们就在表增加一条记录，释放锁即把该数据删掉，具体实现，我这里就不再一一举出。 它同样存在一些问题： 没有失效时间，容易导致死锁； 依赖数据库的可用性，一旦数据库挂掉，锁就马上不可用； 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作； 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库中数据已经存在了。 乐观锁 基本原理为：乐观锁一般通过 version 来实现，也就是在数据库表创建一个 version 字段，每次更新成功，则 version+1，读取数据时，我们将 version 字段一并读出，每次更新时将会对版本号进行比较，如果一致则执行此操作，否则更新失败！ 悲观锁（排他锁） 实现步骤见下面说明。 1.创建一张数据库表： CREATE TABLE `methodLock` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名', `desc` varchar(1024) NOT NULL DEFAULT '备注信息', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成', PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法'; 2.通过数据库的排他锁来实现分布式锁。 基于MySQL 的 InnoDB 引擎，可以使用以下方法来实现加锁操作： public boolean lock(){ connection.setAutoCommit(false) while(true){ try{ result = select * from methodLock where method_name=xxx for update; if(result==null){ return true; } }catch(Exception e){ } sleep(1000); } return false; } 3.我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁： public void unlock(){ connection.commit(); } 基于 Zookeeper 的分布式锁 ZooKeeper 简介 ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google Chubby 的一个开源实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 分布式锁实现原理 实现原理为： 建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent） 每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（EPHEMERAL_SEQUENTIAL），通过组成特定的名字 name+lock+顺序号。 在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。 假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件。同时在这里阻塞。等待监听事件的发生，获得锁控制权。 当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。 实现的分布式锁是严格的按照顺序访问的并发锁。 代码实现 我们继续改造本文的工程。 1.创建 DistributedLock 类： public class DistributedLock implements Lock, Watcher{ private ZooKeeper zk; private String root = &quot;/locks&quot;;//根 private String lockName;//竞争资源的标志 private String waitNode;//等待前一个锁 private String myZnode;//当前锁 private CountDownLatch latch;//计数器 private CountDownLatch connectedSignal=new CountDownLatch(1); private int sessionTimeout = 30000; /** * 创建分布式锁,使用前请确认config配置的zookeeper服务可用 * @param config localhost:2181 * @param lockName 竞争资源标志,lockName中不能包含单词_lock_ */ public DistributedLock(String config, String lockName){ this.lockName = lockName; // 创建一个与服务器的连接 try { zk = new ZooKeeper(config, sessionTimeout, this); connectedSignal.await(); Stat stat = zk.exists(root, false);//此去不执行 Watcher if(stat == null){ // 创建根节点 zk.create(root, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } } catch (IOException e) { throw new LockException(e); } catch (KeeperException e) { throw new LockException(e); } catch (InterruptedException e) { throw new LockException(e); } } /** * zookeeper节点的监视器 */ public void process(WatchedEvent event) { //建立连接用 if(event.getState()== Event.KeeperState.SyncConnected){ connectedSignal.countDown(); return; } //其他线程放弃锁的标志 if(this.latch != null) { this.latch.countDown(); } } public void lock() { try { if(this.tryLock()){ System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; &quot; +myZnode + &quot; get lock true&quot;); return; } else{ waitForLock(waitNode, sessionTimeout);//等待锁 } } catch (KeeperException e) { throw new LockException(e); } catch (InterruptedException e) { throw new LockException(e); } } public boolean tryLock() { try { String splitStr = &quot;_lock_&quot;; if(lockName.contains(splitStr)) throw new LockException(&quot;lockName can not contains \\\\u000B&quot;); //创建临时子节点 myZnode = zk.create(root + &quot;/&quot; + lockName + splitStr, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(myZnode + &quot; is created &quot;); //取出所有子节点 List&lt;String&gt; subNodes = zk.getChildren(root, false); //取出所有lockName的锁 List&lt;String&gt; lockObjNodes = new ArrayList&lt;String&gt;(); for (String node : subNodes) { String _node = node.split(splitStr)[0]; if(_node.equals(lockName)){ lockObjNodes.add(node); } } Collections.sort(lockObjNodes); if(myZnode.equals(root+&quot;/&quot;+lockObjNodes.get(0))){ //如果是最小的节点,则表示取得锁 System.out.println(myZnode + &quot;==&quot; + lockObjNodes.get(0)); return true; } //如果不是最小的节点，找到比自己小1的节点 String subMyZnode = myZnode.substring(myZnode.lastIndexOf(&quot;/&quot;) + 1); waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - 1);//找到前一个子节点 } catch (KeeperException e) { throw new LockException(e); } catch (InterruptedException e) { throw new LockException(e); } return false; } public boolean tryLock(long time, TimeUnit unit) { try { if(this.tryLock()){ return true; } return waitForLock(waitNode,time); } catch (Exception e) { e.printStackTrace(); } return false; } private boolean waitForLock(String lower, long waitTime) throws InterruptedException, KeeperException { Stat stat = zk.exists(root + &quot;/&quot; + lower,true);//同时注册监听。 //判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听 if(stat != null){ System.out.println(&quot;Thread &quot; + Thread.currentThread().getId() + &quot; waiting for &quot; + root + &quot;/&quot; + lower); this.latch = new CountDownLatch(1); this.latch.await(waitTime, TimeUnit.MILLISECONDS);//等待，这里应该一直等待其他线程释放锁 this.latch = null; } return true; } public void unlock() { try { System.out.println(&quot;unlock &quot; + myZnode); zk.delete(myZnode,-1); myZnode = null; zk.close(); } catch (InterruptedException e) { e.printStackTrace(); } catch (KeeperException e) { e.printStackTrace(); } } public void lockInterruptibly() throws InterruptedException { this.lock(); } public Condition newCondition() { return null; } public class LockException extends RuntimeException { private static final long serialVersionUID = 1L; public LockException(String e){ super(e); } public LockException(Exception e){ super(e); } } } 2.改造 HelloController.java： @RestController public class HelloController { @RequestMapping(&quot;index&quot;) public String index()throws Exception{ DistributedLock lock = new DistributedLock(&quot;localhost:2181&quot;,&quot;lock&quot;); lock.lock(); //共享资源 if(lock != null){ System.out.println(&quot;执行方法&quot;); Thread.sleep(5000); lock.unlock(); } return &quot;hello world!&quot;; } } 3.按照本文 Redis 分布式锁的方法测试，我们发现同样成功加锁了。 总结 通过以上的实例可以得出以下结论： 通过数据库实现分布式锁是最不可靠的一种方式，对数据库依赖较大，性能较低，不利于处理高并发的场景。 通过 Redis 的 Redlock 和 ZooKeeper 来加锁，性能有了比较大的提升。 针对 Redlock，曾经有位大神对其实现的分布式锁提出了质疑，但是 Redis 官方却不认可其说法，所谓公说公有理婆说婆有理，对于分布式锁的解决方案，没有最好，只有最适合的，根据不同的项目采取不同方案才是最合理的。 最后的最后说明一下： 上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。 下面是从各个方面进行三种实现方式的对比 从理解的难易程度角度（从低到高） 数据库 &gt; 缓存 &gt; Zookeeper 从实现的复杂性角度（从低到高） Zookeeper &gt;= 缓存 &gt; 数据库 从性能角度（从高到低） 缓存 &gt; Zookeeper &gt;= 数据库 从可靠性角度（从高到低） Zookeeper &gt; 缓存 &gt; 数据库 ","link":"https://kangjn.github.io/post/fen-bu-shi-suo-san-chong-shi-xian-fang-shi/"},{"title":"炼金术秘籍《翠玉录》","content":"1. 当我走进洞穴，我看到了一块翠玉，上面写着字，那是从赫尔墨斯的双手间被书写出来。从那里我发现了以下这些文字： When I entered into the cave,I received the tablet zaradi,which was inscribed,from between the hands of Hermes,in which I discovered these word: 2. 真实不虚，永不说谎，必然带来真实： This true without lying, certain &amp; most true: 3. 下如同上，上如同下；依此成全太一的奇迹。 That which is below is like that which is above and that which is above is like that which is below to do ye miracles of one only thing. 4. 万物本是太一，藉由分化从太一创造出来。 And as all things have been and arose from one by ye mediation of one: so all things have their birth from this one thing by adaptation. 翠玉录开篇提出了大宇宙和小宇宙的呼应关系，这是炼金术宇宙观的核心。《墨子》提出一个类似的说法“上同下比”，但墨子的意思是人的思想行为要比照天、比照神明，顺应天道。赫耳墨斯的意思则是，理念、宇宙、自然这个大宇宙，跟个人、心灵、灵魂这个小宇宙是一种一体、和谐、映射的关系，利用炼金的转变过程将性灵从物质中解放出来，既重造物质、又重塑心灵，将可重现宇宙太一亦即道、“一切万有”创造的奇迹。太一创造的方式就是新柏拉图主义的“发散”说法，就是从一个一体而充盈的最高实在，象太阳放射光芒一样层层分化出了理性、灵魂和物质世界，而无损于太一的圆满。 5. 太阳为父，月亮为母，从风孕育，从地养护。 The Sun is its father, the moon its mother, the wind hath carried it in its belly, the earth its nourse. 6. 世间一切完美之源就在此处；其能力在地上最为完全。 The father of all perfection in ye whole world is here. Its force or power is entire if it be converted into earth. 这里的主语说的是完善的性灵，太阳指的是不朽的精神或高层次的自我——心性，太阴即月亮则是低层次的自我，是高我的投影。风是指灵性的生命力，地是指物质的躯体。神性与躯体的联合、精神和物质的统一，是创造奇迹的源泉，实际上也是神秘体验的普遍原则。《道德经》说，“道生之，德蓄之，物形之，势成之”，“之”指的也是生命、性灵，道与德就像太阳、月亮，而形、成大略也跟孕育和养护有一定的对应。 7. 分土于火，萃精于糙，谨慎行之。 Separate thou ye earth from ye fire, ye subtile from the gross sweetly wth great indoustry. 8. 从地升天，又从天而降，获得其上、其下之能力。 It ascends from ye earth to ye heaven &amp; again it desends to ye earth and receives ye force of things superior &amp; inferior. 9. 如此可得世界的荣耀、远离黑暗蒙昧。 By this means you shall have ye glory of ye whole world &amp; thereby all obscurity shall fly from you. 这里是说，在追求上述阴阳联合之前，必须分清属物和属灵的东西，分清灵性的呼唤和物质的欲望，才能体现真我的光辉。当一个人超越了阴与阳、自我与心性的对立，寻求到不朽的灵性，就从现实的存在中觉醒，获得通觉智慧、找到光明。再回到现实生活，一切都了然。 10. 此为万力之力，摧坚拔韧。 Its force is above all force, for it vanquishes every subtile thing &amp; penetrates every solid thing. 11.世界即如此创造，依此可达奇迹。 So was ye world created. From this are &amp; do come admirable adaptations whereof ye process is here in this. 12.我被称为三重伟大的赫尔墨斯，因我拥有世界三部分的智慧。 Hence I am called Hermes Trismegist, having the three parts of ye philosophy of ye whole world. 13.这就是我所说的伟大工作。 That which I have said of ye operation of ye Sun is accomplished &amp; ended. 这里所说的“力”，就是在炼金成功后所获得的贯通上下的能力，是最具有创造力的，因为他明了所经历的人生正像内在宇宙的外在投射。通过澈悟而达到的精神永恒，也将超越时间的局限，而时间是物质世界一切限制中最坚不可摧的。而赫耳墨斯号称拥有世界三部分的智慧，可能是因为他是埃及透特、希腊赫耳墨斯、罗马墨丘利三位同类神祗的融合，但更可能说是对理念、灵魂和物质这三个层面而言。翠玉录所谓伟大的工作，就是指从启蒙到开悟的漫长而宏伟的旅 ","link":"https://kangjn.github.io/post/lian-jin-zhu-mi-ji-lesslesscui-yu-lu-greatergreater-niu-dun-fan-yi-ban-ben/"},{"title":"Java后端学习路线","content":"后端技术学习路线思维导图框架： 图中的每一个节点都可以点开，我都做了细分，在后面章节逐个展开介绍。 计算机基础 不管是后端开发还是前端开发，说到底我们所有的软件开发都是在计算上编写程序，虽然对于大部分人来说，真正开始写代码的时候很少会让你去解决计算机底层的问题，不接触不代表不重要，计算机基础是最重要的。 后端开发工作中经常用到 Java、C++、Python、Golang 这些语言称为高级编程语言，称为高级是它们接近我们日常交流的自然语言，离计算机底层远，但所有的高级语言最终都会转化成汇编-&gt;计算机指令-&gt;控制流操控计算机硬件，所以学习计算机构成和工作原理、操作系统这些基础知识，能够加深我们队高级语言的理解。 中科大的计算机技术本科主要课程结构安排。 一流大学的计算机专业要学什么可以对照着看下，从学科数学理论基础、计算机体系结构、软件工程方法等等维度展开。 那如果你不是计算机相关专业的想转行，也不要被吓到了，毕竟这是人家四年时间的学习内容，本科的培养目标不仅仅是培养出一个软件工程师，本科学习还是面向硕士博士的基础培养，注意是计算机科学专业，名字里有个词叫「科学」，我这篇文章要说的 BAT 公司后台软件开发，可以认为是「工学」方向，更多的是服务于工程开发。 如果只是面向后台开发和工作面试，或者你是非计算机专业想转行，社畜没有太多时间去学习大学那些理论课程，那帮我把计算机基础的范围缩小到下面这 4 门专业课：计算机组成原理、计算机网路、操作系统、数据结构。 计算机组成原理 这门课程让你了解计算机的组成和工作原理，要学习的内容包括： 数据在计算机中的表示和运算（柠檬说：计算机不识数，只认得高低电平，所以数据在计算机内部都用二进制的0和1表示） 存储系统（柠檬说：数据和程序指令都要存储下来，学习计算机的存储层次，内存、外存、高速缓存、虚拟存储技术） 指令系统（柠檬说：写的代码最终都要被翻译成计算机指令，指令格式和寻址方式有多种，控制器来控制指令执行） 中央处理器（也就是 CPU 计算机的大脑，主要构成是运算器和控制器） 总线（柠檬说：计算机的血管动脉，连接计算机各功能组件，用来传输数据、地址信号、控制信号） 输入输出系统（柠檬说：Input/Output 也叫 IO 系统，连接和管理各种外部设备比如键盘、显示器等等） 计算机网络 世界上第一台通用计算机「ENIAC」于 1946 被发明出来，如其名字一样仅仅是用于计算，在后来计算机越来越多，如果没有网络每台计算机都将成为一个孤岛，也不会有现在互联网的繁荣，「计算机网络」这门课程的学习路线非常清晰，就是围绕着如何让地理位置上不同的计算机连接起来，并高效可靠的交换数据信息，实现人在家中做，天下事尽知。 计算机网络有分层次，根据各层属性和特点，分为： 物理层 数据链路层 网络层 传输层 应用层 这个层次划分从上到下就是一个网络数据包的接收路径，反之就是发送路径。既然要交换信息肯定得商量一套通用的协议，就像我们和老外交流，要么他们学中文要么我们学英文，反正得统一出一个标准语言出来，这在计算机网络中称之为「通信协议」。如上述的网络分层，每层都有各自适配的协议，所以计算机网络的学习基本就是围绕着分层协议的学习。 操作系统 操作系统也是一种软件。你熟悉的微软Windos操作系统，后台开发熟悉的各种发行版的 Linux 系统，都是通过软件的形式安装在计算机上。 只不过这个软件和我们平常接触的应用程序软件不同，它比较特殊，因为它向下和计算机硬件（就是我们在计算机组成原理中学习的那些硬件）打交道，向上给其他应用程序和用户提供通用的交互的接口，说白了操作系统就是个中介和管家的角色。它帮我们做了下面这些事情： 进程管理（柠檬说：你写的程序运行起来才能干活，运行起来的程序称为进程，进程是资源的最小单位） 内存管理（柠檬说：计算机内存又贵又少，动不动又要来个高并发，内存管理大有学问） 文件管理（柠檬说：计算机中的资料和信息需要通过文件系统来保存、管理） 输入输出管理（柠檬说：各种外部设备如何接入计算机和接入之后又如何管理） 数据结构 数据结构大家最熟悉，即使毫无计算机基础或是想转行计算机，第一个遇到的就是数据结构，因为面试刷的算法题本质上就是对各种数据结构的运用。所以单纯对面试功利的角度来说，数据结构也是必须要掌握的计算机基础，数据结构要学到： 线性表（链表、数组、循环链表） 栈和队列 树和各种二叉树（二叉排序树、平衡二叉树、哈夫曼树、B树、B+树、Trie树） 图（图的存储结构、BFS、DFS、最短路径、最小生成树、拓扑排序、关键路径） 查找算法（二分查找、B树查找、HASH表、KMP字符串模式匹配） 排序算法（插入排序、冒泡排序、归并排序、基数排序、堆排序） 贪心算法 位运算 分治算法 动态规划 好了，计算机基础四大专业课已经大概过了一遍，当然这是我给没有计算机基础同学的实用主义建议，等你学完这四门课程也只能够说入门计算机了，不过这已经比很多人厉害了。如果想真正的了解计算机这门学科，可以等学完了这 4 门基础课程之后，再花写时间挑一些上面培养方案中的课程去学习，做一个知识体系完备的计算机软件后端开发工程师。 Linux 在后台开发领域，你所能接触到的后端服务不敢说 100%，至少也有 90% 以上是运行在 Linux 系统之上，因为它开源、便利、功能强大，需要学习以下技术点： Linux系统使用 所以如果你想走后端开发这条路线，我建议你趁早使用 Linux ，越早越好。可以是在个人 PC 上装 Linux 虚拟机，或者装个双系统贵。 Linux 高级编程 Linux「高级编程」的意思是比上面的 Linux 基础操作更深入一个层次。 学会了 Linux 的使用还不算是一个真正的开发人员，使用系统是成为开发者最基本要求，会操作Linux 就像使用 Windows 系统一样，只不过是学习成本的问题，如果这个世界没有 Window 系统，你女朋友花点时间也能掌握 Linux 系统基本操作。 要想进阶成为后端开发人员，就要懂得如何使用 Linux 系统提供的各种系统API（系统调用接口）进行编程开发，程序员用你写的代码来控制系统，普通用户只会用鼠标操纵。这个阶段需要学习： Unix 系统实现 Linux、基本系统数据类型 文件操作函数: open 、read close write dup fcntl ioctl stat chmod``access chdir ... 系统编程接口的基本特性和高级特性 Linux进程环境、如何创建进程、线程，程序的存储空间分配、环境变量 进程组、会话以及任务控制、进程优先级和调度 动态库和静态库 进程间通信：管道和FIFO、消息队列、信号量、共享内存、内存映射 套接字和网络编程 总之，这一阶段需要学习的是在 Linux 环境下的高级编程技巧，通过对这些内容的学习也能让你更深入的理解 Linux 系统是如何工作和运行的，并且真正的踏入 Linux 系统编程大门。 网络编程 网络编程是通过网络套接字 socket 方式实现的通信，所以也属于进程间通信 IPC（Inter-Process Communication）。 由于现在的后台服务基于服务端/客户端模型，两者之间基于网络通信，你在家用手机点个外卖的服务请求，也是通过网络通信发给某团的后台服务器，所以后台服务开发，说到底还是网络编程，以及建立在网络编程数据之上的应用层开发。 网络编程学什么： 什么是socket套接字 套接字选项 TCP/UDP 套接字编程 Unix domain 协议和编程 原始套接字编程 IO多路复用：select 、poll、epoll、kqueue 序列化技术 零拷贝技术 开源网络库：muduo、libevent 学完以上内容你大概可以写一个类似QQ一样的网络聊天小工具。 不在在工作中，都有成熟的网络框架或网络通信库，大公司比如鹅厂大部分是自研网络通信框架，小公司用开源项目，这让很多后台开发人员不必关心底层的网络通信细节，除了部分基础架构的开发同学，大部分后台开发同学工作都是在做业务系统的开发。 但了解底层网络编程原理，是后台开发人员的核心能力，这点对于 C/C++ 后台开发程序员尤为重要。它能拔高你看问题的高度，不了解底层原理，就像是在黑盒编程一样，出了问题无从下手排查。 学完了以上内容，基本是具备了从事后台开发的基础能力，也能开发出一个简单的后台服务器了。 数据库 除非是单纯的转发路由类后台服务，一般来说后台开发的web服务器后台程序，后台服务程序说白了就是个死循环： 接收客户端数据包 -&gt; 处理数据包 -&gt; 业务逻辑处理 -&gt; 保存必要的数据 -&gt; 回复响应数据给客户端 这其中会伴随对各种数据的处理，比如电商系统会处理订单数据、用户数据，游戏后台会处理角色数据和装备数据等等，有数据就会涉及到存储系统，数据一般都存储到数据库。 主要学习 2 大类数据库： 关系型数据库是指采用了关系模型来组织数据的数据库，简单理解就是二维表格模型。 非关系型数据库一般指的是 key-value 形式存储数据的 NoSQL 数据库，数据和键值是简单的映射关系。 关系型数据库 MySQL 数据库架构 MySQL索引使用和优化 innoDB存储引擎 查询性能优化 聚集索引、非聚集索引 事务隔离，ACID，MVCC 锁机制，乐观锁、悲观锁、读锁、写锁、意向锁 日志 数据备份与恢复 非关系型数据库 redis 基本操作和使用 redis 设计与实现原理 MongoDB levelDB memcache HBase CKV+ 腾讯自研 后台开发服务还需要学会解决三高问题：高并发、高可用、高性能。 高并发 利用到目前为止学习的内容，我们的开发的后台服务器应付一些小并发场景绰绰有余，但是随着互联网应用业务量的上涨，对后台服务端的请求数剧增，高并发需求随之而来，高并发指的就是高 TPS 和高 QPS TPS (Transactions Per Second)每秒事务数 QPS（Query Per Second）每秒查询数等。 对于高并发服务必须改变传统的单进程模型，才能处理的过来如此海量的请求。 多进程 对于高并发的服务请求，由于后台服务一般都是 IO 密集型应用，IO 密集型应用就是大部分 CPU 时间用在网络 IO 上，相对的是 CPU 密集型应用大部分时间花在数据计算上。 大多数的后台服务程序都是 IO 密集型的应用，网络 IO 的时候 CPU 等待白白浪费时间， 这就告诉我们 CPU 的潜力还没有完全发挥，所以当一个进程的处理能力达到上限，我们可以多创建几个进程，这就是多进程模型。 多线程 多线程与多进程类似，实际在Linux系统中线程是由轻量级的进程 LWP（Light-weight process）实现，多线程方式实现的后台服务相对于多进程更加轻量，因为多线程是在同一个进程内部实现。 不过多线程也会带来新的问题，比如全局数据竞争和同步问题，引入线程锁还要防止死锁的发生。 协程 那什么是协程呢？协程 Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。 异步回调 所谓异步回调就是，服务端发起 IO 请求的线程不等网络 IO 线程操作完成，就继续执行随后的代码，一般请求线程需要先注册一个回调函数，当IO 完成之后网络IO线程通过调用之前注册的回调函数来通知发起 IO 请求的线程，这样发起请求的线程就不会阻塞住等待结果，提高了服务处理性能。 高性能 按以上服务模型可以提高服务本身处理能力，高性能后台服务往往还会利用多种技术、从多个维度优化提高性能。比如采用CDN（Content Delivery Network）内容分发网络，存储和分发使用户就近获取内容，缩短响应时间；采用池化技术，避免频繁的资源分配与回收；采用服务集群，横向扩展服务能力；采用缓存技术，热点数据加入缓存，减少数据库访问。 CND 内容分发技术 池化技术：数据库连接池，线程池 集群化 缓存技术 高可用 高可用即保证服务的稳定性，不出现重大问题或宕机，常见的解决高可用思路是冗余和负载均衡。冗余的意思就是多部署几台服务器，当其中一台挂掉另外一台能顶上。通过负载均衡技术实现对流量的动态调配，不至于出现大量流量冲击某台机器出现请求不均匀，软件负载均衡技术可以通过DNS、Nginx、LVS等技术实现。这里主要学习的技术有： 负载均衡技术，软硬件负载均衡 限流隔离降级技术 应用层容灾，资源隔离熔断 异地多活 设计模式 设计模式代表着软件开发的一种最佳实践。已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计，当设计大规模软件时遵循必要的设计模式能让写出的代码更加健壮和可扩展。 设计模式 6 大原则： 开闭原则：对扩展开放，对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象，不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口，比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合，而不是使用继承。 常见设计模式分类 工厂模式 单例模式 建造者模式 适配器模式 桥接模式 过滤器模式 装饰器模式 外观模式 享元模式 代理模式 责任链模式 解释器模式 迭代器模式 观察者模式 ... 分布式 为什么会出现分布式？随着业务的体量不断增长，单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议。这里需要学习的内容包括： 分布式一致性算法：PAXOS、Raft、Zab 分布式事务：2PC、3PC、TCC 分布式唯一 ID 生成：雪花算法、UUID、淘宝 TDDL SEQUENCE方案、美团 Leaf 一致性HASH算法 扩展性设计，设计可扩展的软件架构 分布式文件系统：HDFS、FastDFS 微服务架构设计，服务注册、服务发现、服务路由 安全 本质上后台服务在网络上运行，需要和各种网络环境交互，在正常情况下能够工作，但互联网中有很多针对后台服务的恶意攻击，因此网络安全也是后台开发工程师需要学习的内容。这里主要包括： web安全：CSRF、SQL注入、XSS DDos防范 加解密算法：对称加密、哈希算法、非对称加密 网络隔离：内外网分离、跳板机 授权认证算法：OAuth2.0、OIDC、2FA、单点登录SSO 监控与统计 后台服务运行我们如何了解其运行状态和健康度？如果只是开发小玩具监控和统计大可不必，只需记录本地日志即可，对于成熟的大型后台服务系统，监控、统计、追踪必不可少，无监控，不运营。 开源的监控软件有：Prometheus、Zabbix、Open-Falcon。 追踪系统也非常重要，特别是目前微服务化，一次服务请求需要经历多个不同的微服务处理，给分布式追踪带来新的挑战，主要包含以下三个方面： 通过收集日志（Logging），记录程序的调试信息或错误信息，对系统和各个服务的运行状态进行监控 通过收集量度（Metrics），比如累加量，对系统和各个服务的性能进行监控 通过分布式追踪（Tracing ），追踪服务请求是如何在各个分布的组件中进行处理的细节 业界也有一些成熟的开源软件用于监控与追踪：SkyWalking、Pinpoint、Zipkin、CAT大众点评开源。不过大公司一般都有自研的一套监控与追踪系统，比如腾讯内部就有多套自研监控与调用链追踪系统。 搜索引擎 我们讨论的是全文搜索引擎，什么是全文搜索引擎？ 全文搜索引擎是目前广泛应用的主流搜索引擎。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。 数据分为结构化数据与非结构化数据 像数据库表这种的数据是结构化数据；而对于像HTML、XML、文档这样不定长度且无固定格式的数据我们称之为非结构化数据。非结构化数据也称为全文数据，对非结构化数据的搜索可以用全文检索的方式， 目前两大主流的全文搜索引擎「Solr」和「Elasticsearch」都是基于 Lucene 建立。搜索引擎需要学习的内容： 搜索引擎原理，搜索引擎利用倒排索引技术来实现对全文数据的高效检索。 Lucene，Apache Lucene 是一个开源的全文搜索引擎工具包。 Elasticsearch 原理与使用 Solr 原理与使用 大数据 大数据，又称为巨量资料，指的是在传统数据处理应用软件不足以处理的大或复杂的数据集的术语。随着后台服务用户数增加和数据的积累，产生海量有待挖掘价值的数据，分析利用这些数据可以反馈线上决策，优化运营策略，产生数据价值。 海量数据也可以定义为来自各种来源的大量非结构化或结构化数据。 在软件开发领域的大数据概念自 20 世纪 90 年代的数据仓库开始，对于大数据的处理也导致各种海量数据的统计和处理技术发展。 主要包含以下的技术点需要学习：数据存储、离线分析、流式计算。 大数据存储：Hadoop 框架，HDFS、HBase、YARN 架构、Apache Kudu 离线分析：Hive、MapReduce、Spark 流式计算：Flink、Storm、Kafka Stream、Spark Streaming 虚拟化 虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。 虚拟化的好处 灵活性：在同一硬件上同时运行多个操作系统 敏捷性：移动操作系统的方式与将文件或图片从一台物理服务器移动到另一台物理服务器的方式相同。 容错：当物理服务器出现故障时，管理软件会自动将实例迁移到可用服务器，甚至无感知物理硬件故障。 降低成本：您不再需要过多的物理服务器，操作和维护所需的费用也随之减少。 常见的虚拟化技术：KVM、Xen、OpenVZ、Docker 虽然对于大多数后台服务程序来说， 很多服务都是部署在 Docker 容器里，但 Docker 共用了底层系统的 kernel，所有容器共用一部分的运行库，因此隔离性相比 KVM 之类的虚拟化技术差一点，KVM 与 Docker 有各自的使用场景，未来很长一段时间是共存状态。 OpenStack 管理 VM（Virtual Machine）虚拟机的工具；Kubernetes 简称 K8s ，是管理 container 容器的工具。 中间件 在后端开发中你可能经常听说到「中间件」这个词，那什么是中间件？看下Wiki上的定义： 中间件技术创建在对应用软件部分常用功能的抽象上，将常用且重要的过程调用、分布式组件、消息队列、事务、安全、链接器、商业流程、网络并发、HTTP 服务器、Web Service 等功能集于一身或者分别在不同品牌的不同产品中分别完成。 中国科学院软件所研究员仲萃豪把中间件定义为「平台＋通信」。这个定义限定了只有用于分布式系统中的此类软件才能被称为中间件，同时此定义也把中间件与实际应用的应用软件区分开来。 大白话来说，中间件就是把分布式系统中一些通用功能的抽象出来提供服务的一类软件统称。它屏蔽掉了底层操作系统的复杂性，向上提供一个统一的开发环境，降低了软件系统开发的复杂度，由于中间件是介于操作系统和应用软件之间，为应用软件提供服务功能的软件，由于介于两种软件之间，所以称为中间件。 常见的的开源中间件有下面几种，组合起来就能搭建一个完整的分布式后台服务系统： web server 中间件，Nginx、OpenResty、Tomcat... 缓存中间件，服务端缓存包括 Redis、Memcached... 消息队列中间件，Kafka、RabbitMQ、ActiveMQ... RPC框架，Tars、Dubbo、gRPC、Thrift 数据库中间件，Sharding jdbc 日志系统中间件，ELK B指的是一套解决方案，是 Elasticsearch、Logstash 、 Kibana、Beats 是这 4 种软件产品的首字母缩写。 配置中心中间件，Apollo、zookeeper统一配置管理 API网关，开源项目有 Tyk、kong、zuul、orange... 版本控制 大型软件项目的代码量巨大，如何有效组织和管理源码和版本，于是产生了版本控制系统。版本控制系统就是我们常说的SVN 或 Git，用来追踪、维护源码、文件以及配置文件等等的改动，并且提供控制这些改动控制权的程序。 常见的版本控制系统分为两大类：集中式版本控制和分布式版本控制。作为后端开发工程师，版本控制系统的使用也是必须掌握的基础技能，不过这些系统一般都是边使用边熟悉，刚开始熟悉一些常用操作就好。 常见的有集中式版本控制系统，代表是SVN； 分布式版本控制系统，代表是Git 工具 一些和后端开发或者说软件开发相关的工具推荐，主要是编辑器和 IDE。 编辑器 在 Linux 下开发肯定离不开 Vim 或者 Emacs，这两个都是常用的编辑器，已经形成了两大爱好者阵营。特别是 Vim 编辑器，学习成本有点高，配合上各种插件和配置，有些 Vim 爱好者已经把它当成 IDE 来用了，一旦掌握可以大幅提升工作效率，值得你去学习。 当然除了 Vim 如果是文字编辑工作，比如写 README 文档或者写技术博客，那么强烈推荐学习下 Markdown 语法，这是一种种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，注重内容本身不用过多的调整排版。Markdown 编辑器推荐 Typora 、有道云笔记 Markdown 编辑器、VSCode Markdown插件。 IDE 编辑器作为小工程还可以胜任，不过后端开发工作中，一般都是大型的软件工程项目，所以不大可能用编辑器来管理，这时候就需要学习使用专业的集成开发工具。 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。 磨刀不误砍柴工，挑一把趁手的兵器再去编程世界遨游。各语言 IDE 五花八门，推荐 JetBrains 系列和 VS Code ，JetBrains 产品包括各语言开发的一系列的 IDE，特别是Java 的Intellij IDEA 口碑非常不错，部分对应的产品系列如下。 CLion - 跨平台的C/C++ IDE 开发工具，支持C++11 、C++14、libc++以及Boost。 GoLand - Go语言的集成开发环境。 IntelliJ IDEA - 2001年发布。一套智能的 Java 集成开发环境，特别专注与强调程序师的开发撰写效率提升。 PhpStorm - PHP IDE开发工具。 PyCharm - 一款结合了Django框架的Python IDE开发工具。 AppCode - Swift 和 Objective-C IDE开发工具。 Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统的免费代码编辑器，它支持测试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。 在2019年的 Stack Overflow 组织的开发者调研中，VS Code被认为是最受开发者欢迎的开发环境。 测试 软件工程师不仅要写代码，还要做测试，软件测试和软件开发是相伴相生，测试能让保证我们写出代码更加健壮和可维护。 TDD是测试驱动开发（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，根据测试代码确定需要编写什么产品代码。需要掌握和了解以下测试技术和方法。 单元测试 压力测试 全链路测试 A/B 测试，灰度发布，蓝绿部署 学习顺序 总结下，后端技术学习的内容还是很多的，不可能一蹴而就。 把以上技术路线学习优先级做个排序，你照着学就行，排序规则： 星级越高，排名越靠前，重要程度越高，优先安排时间学习。 计算机基础 5星 Linux 5 星 数据库 5 星 设计模式 5 星 工具 5 星 中间件 4 星 分布式 4 星 高并发、高可用、高性能 4 星 搜索引擎 4 星 测试 3 星 监控与统计 3 星 虚拟化 3 星 安全 3 星 大数据 3 星 ","link":"https://kangjn.github.io/post/java-hou-duan-xue-xi-lu-xian/"},{"title":"Java 技术书籍大全","content":"涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&amp;领导力&amp;流程，职业素养与个人成长，格局与视野，面试参考书等。 https://github.com/sorenduan/awesome-java-books 目录： 入门书籍 基础书籍 多线程与并发 网络编程 数据结构 语言基础 进阶 性能优化 响应式编程 JVM虚拟机 代码&amp;设计优化 设计模式 框架与中间件 数据库 缓存与NoSQL 消息队列 ORM框架 Spring家族 高并发 分布式 搜索引擎 大数据 架构 分布式架构 微服务架构 架构方法论 JVM周边语言 项目管理&amp;领导力&amp;流程 项目管理 团队管理 数学与算法 数学 算法 职业素养与个人成长 职业素养提升 个人软技能 大厂出品 阿里巴巴技术丛书 京东技术丛书 工具书 面试求职 格局与视野 Java之外 网络知识 安全知识 工具 运维&amp;DevOps TOC generated by simple-php-github-toc 入门书籍 《明解Java》 《Java从入门到精通（第4版 附光盘）》 《入门很简单丛书：Java Web开发入门很简单》 《程序员炼成记 从小白到工程师》 《Java从小白到大牛》 《JavaWeb项目开发实战入门（全彩版）》 《Java精彩编程200例（全彩版）》 《Java轻松学》 《大话Java：程序设计从入门到精通（含DVD光盘1张）》 《Java语言袖珍指南（第二版）》 基础书籍 [《Java编程思想（第4版） thinking in java]》 《Java核心技术 卷I：基础知识（原书第10版）》 《Java核心技术卷II：高级特性（原书第10版）》 多线程与并发 《华章专业开发者丛书·Java并发编程实战》 《Java多线程编程实战指南（设计模式篇）》 《图解Java多线程设计模式》 《实战Java高并发程序设计》 《Java高并发编程详解：多线程与架构设计》 [《Java核心技术系列：Java多线程编程核心技术 Java Multi-thread Programming]》 《Java并发编程：核心方法与框架》 《Java多线程与Socket：实战微服务框架》 《NIO与Socket编程技术指南》 《Java并发编程之美》 《实战Java高并发程序设计（第2版）》 网络编程 [《Java网络编程（第四版） Java network programming, forth edition]》 数据结构 《数据结构与算法分析：Java语言描述（原书第3版）》 《图解数据结构：使用Java》 《数据结构与算法Java语言描述》 语言基础 《Java 8实战》 《Java函数式编程》 《Java编程的逻辑》 《O'Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》 《写给大忙人看的Java核心技术》 [《精通lambda表达式：Java多核编程 Mastering Lambdas: Java Programming in a Multicore]》 《Java 9模块化开发：核心原则与实践》 《Java JDK 9学习笔记》 [《Java 9编程参考官方大全（第10版） Java：Thte Complete Reference，Tenth Edition]》 《写给大忙人的Java SE 9核心技术》 进阶 《深入分析Java Web技术内幕（修订版）》 《Java RESTful Web Service实战（第2版）》 性能优化 [《Java性能优化权威指南 Java performance]》 《Java程序性能优化：让你的Java程序更快、更稳定》 《Java性能权威指南》 《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》 《Java性能调优指南》 《大话Java性能优化》 响应式编程 《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 《RxJava响应式编程》 《RxJava 2.x 实战》 JVM虚拟机 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 [《Java核心技术系列：Java虚拟机规范（Java SE 8版） The Java Virtual Machine Specification Jave SE 8 Edition]》 《揭秘Java虚拟机：JVM设计原理与实现》 《HotSpot实战》 《Java从入门到动手写虚拟机1（套装共2册）》 代码&amp;设计优化 《重构 改善既有代码的设计 Java语言版》 《代码大全（第2版）》 《Effective Java中文版（原书第3版）》 《代码整洁之道 程序员的职业素养》 [《代码整洁之道 Clean Code A Handbook of Agile Software Craftsmanship]》 《Spring实战（第4版）》 《代码不朽：编写可维护软件的10大要则（Java版）》 《Java代码与架构之完美优化 实战经典》 设计模式 《反应式设计模式》 《O'Reilly：Head First设计模式（中文版）》 《设计模式：可复用面向对象软件的基础》 [《实现领域驱动设计 Implementing Domain-Driven Design]》 《原创精品系列：设计模式之禅（第2版）》 《图解设计模式》 《大话设计模式》 《领域驱动设计 软件核心复杂性应对之道 修订版》 《Java测试驱动开发》 框架与中间件 数据库 《高性能MySQL（第3版）》 《MySQL技术内幕：InnoDB存储引擎（第2版）》 《大型网站系统与Java中间件实践》 《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 《PostgreSQL修炼之道：从小工到专家》 《PostgreSQL技术内幕：查询优化深度探索》 缓存与NoSQL 《Redis 深度历险：核心原理与应用实践》 《Redis实战》 《Redis入门指南（第2版）》 《深入分布式缓存：从原理到实践》 《人人都是架构师：分布式系统架构落地与瓶颈突破》 《MongoDB应用设计模式》 《MongoDB实战 架构、开发与管理》 《NoSQL数据库入门与实践（基于MongoDB、Redis）》 消息队列 《RabbitMQ实战指南》 《Kafka权威指南》 《Kafka入门与实践》 《RocketMQ实战与原理解析》 《Kafka技术内幕 图文详解Kafka源码设计与实现》 《深入理解Kafka：核心设计与实践原理》 《分布式消息中间件实践》 ORM框架 《MyBatis从入门到精通》 Spring家族 《Spring微服务实战》 《Spring Cloud微服务实战》 《深入理解Spring Cloud与微服务构建》 《MyBatis技术内幕》 《Spring Boot实战》 《深入浅出Spring Boot 2.x》 《JavaEE开发的颠覆者：Spring Boot实战》 《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》 《Spring Boot 2精髓：从构建小系统到架构分布式大系统》 《Spring 5开发大全》 《Spring Cloud微服务架构进阶》 《Spring源码深度解析 第2版》 《Spring MVC实战》 《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》 《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》 《Spring学习指南 第3版》 《精通Spring MVC 4》 高并发 《Netty实战》 《七周七并发模型》 《Netty权威指南（第2版）》 《Netty进阶之路：跟着案例学Netty》 分布式 《从Paxos到Zookeeper分布式一致性原理与实践》 《ZooKeeper：分布式过程协同技术详解》 搜索引擎 《从Lucene到Elasticsearch：全文检索实战》 大数据 《Hadoop权威指南：大数据的存储与分析(第4版)》 《Hadoop构建数据仓库实践》 [《HBase权威指南 HBase： The Definitive Guide]》 《图解Spark：核心技术与案例实战》 [《Hive编程指南 Programming Hive]》 - 《HBase应用架构》 架构 《Web性能权威指南》 《从零开始学架构：照着做，你也能成为架构师》 《Java应用架构设计：模块化模式与OSGi》 《大型网站技术架构演进与性能优化》 《高可用架构（第1卷）》 《Java架构师指南》 《大话代码架构（项目实战版）》 《小团队构建大网站：中小研发团队架构实践》 《未来架构 从服务化到云原生(限量签名 随机发放)》 分布式架构 《可伸缩架构：面向增长应用的高可用》 《分布式服务架构：原理、设计与实战》 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》 《大型分布式网站架构设计与实践》 《可伸缩服务架构：框架与中间件》 《架构探险：从零开始写分布式服务框架》 《Cloud Native分布式架构原理与实践》 《分布式系统常用技术及案例分析（第2版）》 《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》 微服务架构 《微服务设计》 《生产微服务》 《架构解密：从分布式到微服务》 《Java微服务》 《Spring Cloud 微服务架构开发实战（全新升级版）》 《微服务实践》 架构方法论 《架构整洁之道》 - 豆瓣评分 8.8 [《企业应用架构模式 Patterns of Enterprise Application Architecture]》 《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》 《聊聊“架构”》 - 豆瓣评分 7.6 《架构真经：互联网技术架构的设计原则（原书第2版）》 《软件架构设计：程序员向架构师转型必备（第2版）》 [《恰如其分的软件架构 Just Enough Software Architecture]》 《软件架构设计：大型网站技术架构与业务架构融合之道》 JVM周边语言 《Scala编程（第3版）》 《Groovy程序设计》 《快学Scala（第2版）》 《Kotlin极简教程》 《Scala集合技术手册》 项目管理&amp;领导力&amp;流程 《构建之法 现代软件工程（第三版）》 《精益思想（白金版）》 《给产品经理讲技术》 项目管理 《持续交付：发布可靠软件的系统方法》 [《名家经典系列：人件（原书第3版） Peopleware: Productive Projects and Teams]》 《硝烟中的Scrum和XP：我们如何实施Scrum》 《敏捷软件开发实践 估算与计划》 [《人月神话（40周年中文纪念版） The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》 《Scrum敏捷软件开发》 [《用户故事与敏捷方法 User Stories Applied:For Agile Software Development]》 [《用户故事地图 User Story Mapping]》 《知行合一 实现价值驱动的敏捷和精益开发》 《互联网项目管理实践精粹》 团队管理 [《卓有成效的管理者（珍藏版） The Effective Executive]》 《跃迁：从技术到管理的硅谷路径》 《告别失控 软件开发团队管理必读》 [《赋能：打造应对不确定性的敏捷团队 Team of Teams]》 [《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 Radical Focus]》 《CTO说》 《轻流程 IT团队的积分式绩效管理》 《技术领导力：程序员如何才能带团队》 [《敏捷文化：如何打造优秀的高效能团队 The Agile Culture: Leading through Trust and Owner]》 数学与算法 数学 《数学之美（第二版）》 《程序员的数学2 概率统计》 《程序员的数学3 线性代数》 《程序员的数学》 《程序员的数学思维修炼（趣味解读）》 《统计之美：人工智能时代的科学思维》 《统计思维：程序员数学之概率统计（第2版）》 算法 [《算法导论（原书第3版）/计算机科学丛书 Introduction to Algorithms, third edition]》 - 《算法图解》 《漫画算法：小灰的算法之旅（全彩）》 职业素养与个人成长 《我编程，我快乐：程序员职业规划之道》 《程序员的自我修养》 职业素养提升 《码农翻身：用故事给技术加点料》 《程序员修炼之道：从小工到专家》 《极客与团队：软件工程师的团队生存秘笈》 《程序员思维修炼(修订版)》 《高效能程序员的修炼》 [《O'Reilly：卓有成效的程序员 Productive programmer]》 《Java工程师修炼之道》 《程序员的成长课》 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》 《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》 《软件开发本质论：追求简约、体现价值、逐步构建》 《内外兼修：程序员的成长之路》 个人软技能 《把时间当作朋友（第3版 全彩）》 《暗时间》 [《关键对话：如何高效能沟通（原书第2版） Crucial Conversations: Tools for Talking When Stak]》 《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》 《软技能 代码之外的生存指南》 《程序员健康指南》 [《如何把事情做到最好：改变全球9800万人的人生指导书 Mastery]》 《程序员的英语》 《高效能人士的七个习惯（30周年纪念版）》 大厂出品 阿里巴巴技术丛书 《码出高效：Java开发手册》 《大数据之路 阿里巴巴大数据实践》 《技术之瞳 阿里巴巴技术笔试心得》 《淘宝技术这十年》 《尽在双11 阿里巴巴技术演进与超越》 《逆流而上：阿里巴巴技术成长之路》 京东技术丛书 《京东基础架构建设之路（全彩）》 《京东系统质量保障技术实战》 《京东技术解密》 工具书 《Linux命令行与shell脚本编程大全（第3版）》 《阿里巴巴Java开发手册》 《SQL即查即用 （全彩版）》 《Linux命令速查手册（第三版）》 面试求职 《剑指Offer：名企面试官精讲典型编程题（第2版）》 《编程之美：微软技术面试心得》 《Java程序员面试笔试宝典》 《Java程序员面试宝典（第4版）》 《编程之法：面试和算法心得》 《Java程序员面试算法宝典》 《Java程序员面试笔试真题库》 《Java程序员面试笔试真题与解析》 《Java核心技术及面试指南》 《解忧程序员：高薪编程、求职面试与成长转型宝典》 格局与视野 《全球科技通史》 《浪潮之巅 第三版 套装上下册》 [《黑客与画家：硅谷创业之父Paul Graham文集 Hackers and Painters Big Ldeas From the Computer Age]》 《软件随想录 卷1》 《软件随想录 卷2》 《编程人生：15位软件先驱访谈录》 [《大教堂与集市（最新版） The Cathedral &amp; the Bazaar]》 《硅谷之谜：浪潮之巅 续集》 [《原则 Principles]》 《精益创业》 《态度：吴军博士新书》 《见识》 《极限创新 35岁之前改变世界的全球科技精英》 《大学的终结：泛在大学与高等教育革命》 《未来版图 全球聪明公司的科技创新趋势和商业化路径》 《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》 《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》 《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》 《大师访谈录：成就非凡的软件人生》 Java之外 《计算机科学丛书：计算机程序的构造和解释（原书第2版）》 [《计算机科学丛书：编译原理（第2版） Compilers:Principle,Techniques and Tools]》 《一个APP的诞生——从零开始设计你的手机应用》 《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》 网络知识 《图解HTTP》 《图解TCP/IP 第5版》 安全知识 《白帽子讲Web安全（纪念版）》 4 《Web安全攻防：渗透测试实战指南》 工具 《Maven实战》 《大象：Thinking in UML（第2版）》 《Git学习指南》 《UML基础、案例与应用（第3版 修订版）》 运维&amp;DevOps [《编码：隐匿在计算机软硬件背后的语言 Code:The Hidden Language of Computer Hardware and Software]》 《DevOps实践指南》 《性能之巅：洞悉系统、企业与云计算》 《鸟哥的Linux私房菜 基础学习篇 第四版》 - 《DevOps开发运维训练营》 ","link":"https://kangjn.github.io/post/java-ji-zhu-shu-ji-da-quan/"},{"title":"后端架构师技术图谱","content":"成为一名架构师所需要的知识储备，比如：数据结构、常用算法、并发、操作系统、设计模式、运维、统计、技术支持、中间件、网络、数据库、搜索引擎、性能、大数据、安全、常用开源框架、分布式设计、设计思想、开发模式；针对不同职业规划和成长方向所涉及到的项目管理、通用业务术语、技术趋势、政策和法规、架构师素质、团队管理等。 https://github.com/xingshaocheng/architect-awesome 数据结构 二叉树 完全二叉树 平衡二叉树 二叉查找树（BST） 红黑树 B，B+，B*树 LSM 树 队列 集合 链表、数组 字典、关联数组 栈 树 BitSet 常用算法 KMP 算法 选择排序 冒泡排序 插入排序 快速排序 归并排序 希尔排序 堆排序 计数排序 桶排序 基数排序 二分查找 Java 中的排序工具 排序、查找算法 布隆过滤器 字符串比较 深度优先、广度优先 贪心算法 回溯算法 剪枝算法 动态规划 朴素贝叶斯 推荐算法 最小生成树算法 最短路径算法 并发 Java中的锁和同步类 公平锁 &amp; 非公平锁 悲观锁 乐观锁 &amp; CAS ABA 问题 CopyOnWrite容器 RingBuffer 可重入锁 &amp; 不可重入锁 互斥锁 &amp; 共享锁 死锁 事务 ACID 特性 事务的隔离级别 MVCC Java 并发 多线程 线程安全 一致性、事务 锁 操作系统 多级缓存 计算机原理 CPU 进程 线程 协程 Linux 设计模式 康威定律 设计模式的六大原则 23种常见设计模式 应用场景 单例模式 责任链模式 MVC IOC AOP UML 微服务思想 运维 &amp; 统计 &amp; 技术支持 OpenStack Docker KVM Xen OpenVZ TDD 理论 单元测试 压力测试 全链路压测 A/B 、灰度、蓝绿测试 Ansible puppet chef Jenkins 环境分离 常规监控 APM 统计分析 持续集成(CI/CD) 自动化运维 测试 虚拟化 容器技术 云技术 DevOps 文档管理 中间件 日志搜集 Sharding Jdbc Dubbo Thrift gRPC 单机定时调度 分布式定时调度 消息总线 消息的顺序 RabbitMQ RocketMQ ActiveMQ Kafka Redis 消息推送 ZeroMQ Web缓存 Memcached Redis Tair 架构 回收策略 本地缓存 Nginx OpenResty Tengine Apache Httpd Tomcat Jetty 架构原理 调优方案 Web Server 缓存 客户端缓存 服务端缓存 消息队列 定时调度 RPC 数据库中间件 日志系统 配置中心 API 网关 网络 Hessian Protobuf Epoll Java NIO kqueue OSI 七层协议 TCP/IP HTTP HTTP2.0 HTTPS 协议 网络模型 连接和短连接 框架 零拷贝（Zero-copy） 序列化(二进制协议) 数据库 MongoDB Hbase 原理 InnoDB 优化 索引 explain 聚集索引, 非聚集索引 复合索引 自适应哈希索引(AHI) 数据库设计的三大范式 基础理论 MySQL NoSQL 搜索引擎 搜索引擎原理 Lucene Elasticsearch Solr sphinx 性能 性能优化方法论 容量评估 CDN 网络 连接池 性能调优 大数据 HDFS MapReduce Yarn Storm Flink Kafka Stream 应用场景 流式计算 Hadoop Spark 安全 RBAC OAuth2.0 双因素认证（2FA） 单点登录(SSO) 内外网分离 登录跳板机 数据备份 对称加密 哈希算法 非对称加密 XSS CSRF SQL 注入 Hash Dos 脚本注入 漏洞扫描工具 验证码 web 安全 DDoS 防范 用户隐私信息保护 序列化漏洞 加密解密 服务器安全 数据安全 网络隔离 授权、认证 常用开源框架 Spring 家族 Log4j、Log4j2 Logback 开源协议 日志框架 ORM 网络框架 Web 框架 工具框架 分布式设计 全局唯一ID CAP 与 BASE 理论 分布式锁 分布式一致性算法 幂等 分布式一致方案 分布式 Leader 节点选举 TCC(Try/Confirm/Cancel) 柔性事务 PAXOS Zab Raft Gossip 两阶段提交、多阶段提交 服务注册与发现 服务路由控制 读写分离模式 分片模式 硬件负载均衡 软件负载均衡 限流 应用层容灾 跨机房容灾 容灾演练流程 平滑启动 扩展性设计 稳定性 &amp; 高可用 数据库扩展 服务治理 分布式一致 分布式文件系统 唯一ID 生成 一致性Hash算法 设计思想 &amp; 开发模式 Reactor RxJava Vert.x 命令查询职责分离(CQRS) 贫血，充血模型 DDD(Domain-driven Design - 领域驱动设计) Actor 模式 响应式编程 DODAF2.0 Serverless Service Mesh 项目管理 架构评审 重构 代码规范 代码 Review RUP 看板管理 SCRUM 敏捷开发 极限编程（XP） 结对编程 PDCA 循环质量管理 FMEA管理模式 通用业务术语 技术趋势 政策、法规 严格遵守刑法253法条 法律 架构师素质 团队管理 招聘 资讯 在线电子书 纸质书 开发方面 架构方面 技术管理方面 基础理论 工具方面 大数据方面 团队博客 个人博客 行业资讯 公众号列表 博客 综合门户、社区 问答、讨论类社区 行业数据分析 专项网站 其他类 推荐参考书 技术资源 VPS 开源资源 手册、文档、教程 在线课堂 会议、活动 常用APP 找工作 工具 代码托管 文件服务 综合云服务商 （Toc generated by simple-php-github-toc ） 数据结构 队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解--什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树 二叉树 每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST） 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B，B+，B*树 MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。 LSM 树 LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet 经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一侧都大或小。 归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序 按照个位、十位、百位、...依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。 Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器 常用于大数据的排重，比如email，url 等。 核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。 优点：空间和时间效率都很高。 缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 -- 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较 KMP 算法 KMP：Knuth-Morris-Pratt算法（简称KMP） 核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论--最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发 Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务 事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT ... FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁 Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁 公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁 悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题 由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器 可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁 互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。 共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统 计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU 多级缓存 典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程----从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式 设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 《设计模式类图与示例》 应用场景 《细数JDK里的设计模式》 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 结构型模式： 创建模式: 行为模式： 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式 MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持 常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APM APM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离 开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维 Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试 TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术 Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术 OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件 Web Server Nginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 agentzh 的 Nginx 教程 Tengine 官方网站 Apache Httpd 官方网站 Tomcat 架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存 Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 [《memcached全面剖析》](https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth Login Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=) Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存--序列3--原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线 消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ 支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQ Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ 纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka 高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送 生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ 定时调度 单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 ---- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 ** SPI ** Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC 服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件 Sharding Jdbc 官网 源码解析 日志系统 日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关 主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络 协议 OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议) Hessian 《Hessian原理分析》 Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》 Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库 基础理论 数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL 原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引 聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。 文中有一处错误： 《MySQL查询where条件的顺序对查询效率的影响》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQL MongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎 搜索引擎原理 《倒排索引--搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能 性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据 流式计算 Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景 例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 《子雨大数据之Spark入门教程(Python版)》 安全 web 安全 XSS 《xss攻击原理与解决方法》 CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密 对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全 数据备份 网络隔离 内外网分离 登录跳板机 在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证 RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA） 2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架 开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架 Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架 Web 框架 Spring 家族 Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计 扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）--网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》 轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路 1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》 推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》 Java、Spring、Dubbo 优雅关闭方式。 数据库扩展 读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理 服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致 CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法 PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos--&gt;Fast Paxos--&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统---幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成 全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + &quot;REPLACE INTO XXX:SELECT LAST_INSERT_ID();&quot; UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式 DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS) CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式 响应式编程 Reactor RxJava Vert.x DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless 无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 项目管理 架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review 制度还是制度! 另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUM SCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3---敏捷方法之scrum》 敏捷开发 极限编程（XP） XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 是一种指导开发人员的方法论。 4大价值： 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程 边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理 P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式 政策、法规 法律 《中华人民共和国网络安全法》 2016年11月7日发布，自2017年6月1日起施行 《个人信息保护法》 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。 《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”； 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上； 3、对于其他公民个人信息，标准为 5000条以上。 《解释》共十三条，自2017年6月1日起施行 《中华人民共和国电子商务法》 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行 解读电子商务法（一）什么是电商 解读电子商务法（二）电商经营者 解读电子商务法（三）电商行为规范 解读电子商务法（四）电商的法律关系 解读电子商务法（外传）电商挣钱的秘密 解读电子商务法（外传）电商模式 程序员需要知道的法律常识 白话法律42讲-为程序员打造的专属法律武器 严格遵守刑法253法条 我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 避风港原则 “避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。 《避风港原则》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 资讯 行业资讯 36kr Techweb 公众号列表 博客 团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm's Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区 国内： CSDN 老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 InfoQ 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: 运维派 Abcdocker Java: 英文博客 专注于 Java 技术分享 ImportNew HowToDoInJava 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： Linux 主题社区 专注于 Docker 应用及咨询、教程的网站 偏重于基础架构、运维方向 InfoQ DockerInfo Linux公社 其他类 程序员技能图谱 推荐参考书 在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书 更多架构方面书籍参考: awesome-java-books 开发方面 《阿里巴巴Java开发手册》详情 架构方面 《软件架构师的12项修炼：技术技能篇》详情 《架构之美》详情 《分布式服务架构》详情 《聊聊架构》 详情 《云原生应用架构实践》详情 《亿级流量网站架构核心技术》详情 《淘宝技术这十年》详情 《企业IT架构转型之道-中台战略思想与架构实战》 详情 《高可用架构（第1卷）》详情 技术管理方面 《CTO说》详情 《技术管理之巅》详情 《网易一千零一夜：互联网产品项目管理实战》详情 基础理论 《数学之美》详情 《编程珠玑》详情 工具方面 大数据方面 技术资源 开源资源 github Apache 软件基金会 手册、文档、教程 国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode DigitalOcean Vultr ","link":"https://kangjn.github.io/post/github-hou-duan-jia-gou-shi-ji-zhu-tu-pu/"},{"title":"Vue PC端框架 ","content":"1. Element Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 2. iView 一套基于 Vue.js 的高质量UI 组件库 3. vue-element-admin vue-element-admin是基于 Vue2.0，配合使用 Element UI 组件库的一个前端管理后台集成解决方案。它使用了最新的前端技术栈，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。 4. Vue Material 通过Vue Material和Vue 2.0建立精美的app应用 5. VueStrap 基于 Vue.js 构建的 Bootstrap 组件。该仓库包含一系列基于 Bootstrap 标记和 CSS 的本地 Vue.js 组件。所以不需要 jQuery 和 Bootstrap 的 JavaScript 文件，唯一需要依赖的是: Vue.js (要求版本为 ^0.12，基于 0.12.10 版本做的测试) Bootstrap CSS (需要版本为 3.x.x， 基于 3.3.5 版本做的测试)。 VueStrap 不依赖某个非常精确的 Bootstrap 版本。 6. Keen UI 由Vue编写的基本UI组件的轻量级集合，并受Material Design的启发。 7. Radon UI 一个帮助你快速开发产品的Vue组件库，简洁好用，效率高，让你摆脱各种定制化的烦恼。 8. N3-components N3组件库是基于Vue.js构建的，让前端工程师和全栈工程师能快速构建页面和应用。致力于构建良好的Vue开发者生态圈，提供良好的开发体验。 9. Muse-UI 基于 Vue 2.0 优雅的 Material Design UI 组件库 10. Vue Antd 这里是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 11. Vuetify Vuetify是一个渐进式的框架，试图推动前端开发发展到一个新的水平。Vuetify 支持SSR（服务端渲染），SPA（单页应用程序），PWA（渐进式Web应用程序）和标准HTML页面。 12. Buefy Buefy 基于 Bulma 和 Vue.js 的轻量级UI组件，它提供了即装即用的轻量级组件。 13. Vue Beauty 基于 ant design 的漂亮的 vue 组件库；vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库，旨在帮助开发者提升产品体验和开发效率、降低维护成本。 ","link":"https://kangjn.github.io/post/vue-pc-duan-kuang-jia/"},{"title":"mysql开发规则","content":"(一)核心规则 (1)不在数据库做运算 cpu计算务必移至业务层； (2)控制单表数据量 int型不超过1000w，含char则不超过500w； 合理分表； 限制单库表数量在300以内； (3)控制列数量 字段少而精，字段数建议在20以内； (4)平衡范式与冗余 效率优先； 往往牺牲范式； (5)拒绝3B 拒绝大sql语句：big sql 拒绝大事物：big transaction 拒绝大批量：big batch (二)字段类规则 (6)用好数值类型 tinyint(1Byte) smallint(2Byte) mediumint(3Byte) int(4Byte) bigint(8Byte) bad case：int(1)/int(11) (7)字符转化为数字 用int而不是char(15)存储ip (8)优先使用enum或set 例如：sex enum (‘F’, ‘M’) (9)避免使用NULL字段 NULL字段很难查询优化； NULL字段的索引需要额外空间； NULL字段的复合索引无效； bad case： name char(32) default null age int not null good case： age int not null default 0 (10)少用text/blob varchar的性能会比text高很多； 实在避免不了blob，请拆表； (11)不在数据库里存图片 (三)索引类规则 (12)谨慎合理使用索引 改善查询、减慢更新； 索引一定不是越多越好(能不加就不加，要加的一定得加)； 覆盖记录条数过多不适合建索引，例如“性别”； (13)字符字段必须建前缀索引 (14)不在索引做列运算 ！！！不只是索引，都不能做列运算吧！！！ bad case： select id where age +1 = 10; (15)innodb主键推荐使用自增列； 主键建立聚簇索引； 主键不应该被修改； 字符串不应该做主键； 如果不指定主键，innodb会使用唯一且非空值索引代替； (16)不用外键 请由程序保证约束； (四)sql类规则 (17)sql语句尽可能简单 一条sql只能在一个cpu运算； 大语句拆小语句，减少锁时间； 一条大sql可以堵死整个库； (18)简单的事务 事务时间尽可能短； bad case： 上传图片事务 (19)避免使用trig/func 触发器、函数不用； 客户端程序取而代之； (20)不用select * 消耗cpu，io，内存，带宽； 这种程序不具有扩展性； (21)OR改写为IN() or的效率是n级别； in的消息时log(n)级别； in的个数建议控制在200以内； select id from t where phone=’159′ or phone=’136′; =&gt; select id from t where phone in (’159′, ’136′); (22)OR改写为UNION mysql的索引合并很弱智 select id from t where phone = ’159′ or name = ‘john’; =&gt; select id from t where phone=’159′ union select id from t where name=’jonh’ (23)避免负向% (24)慎用count(*) (25)同上 (26)limit高效分页 limit越大，效率越低 select id from t limit 10000, 10; =&gt; select id from t where id &gt; 10000 limit 10; (27)使用union all替代union union有去重开销 (28)少用连接join (29)使用group by 分组； 自动排序； (30)请使用同类型比较 (31)使用load data导数据 load data比insert快约20倍； (32)打散批量更新 (33)新能分析工具 show profile; mysqlsla; mysqldumpslow; explain; show slow log; show processlist; show query_response_time(percona); ","link":"https://kangjn.github.io/post/mysql-kai-fa-gui-ze/"},{"title":"国外程序员整理的Java资源大全 ","content":"构建 这里搜集了用来构建应用程序的工具。 Apache Maven：Maven使用声明进行构建并进行依赖管理，偏向于使用约定而不是配置进行构建。Maven优于Apache Ant。后者采用了一种过程化的方式进行配置，所以维护起来相当困难。 Gradle：Gradle采用增量构建。Gradle通过Groovy编程而不是传统的XML声明进行配置。Gradle可以很好地配合Maven进行依赖管理，并且把Ant脚本当作头等公民。 字节码操作 编程操作Java字节码的函数库。 ASM：通用底层字节码操作及分析。 Javassist：尝试简化字节码编辑。 Byte Buddy：使用“流式API”进一步简化字节码生成。 代码分析 软件度量和质量评估工具。 Checkstyle：对编程规范和标准进行静态分析。 FindBugs：通过字节码静态分析找出潜在Bug。 PMD：对源代码中不良编程习惯进行分析。 SonarQube：通过插件集成其它分析组件，提供评估最终结果报告。 编译器 创建分析器、解释器和编译器的框架。 ANTLR：功能完备的自顶向下分析复杂框架。 JavaCC：相对ANTLR更具体，上手略为简单。支持语法语法超前预测（syntactic lookahead）。 持续集成 支持持续集成、测试和应用发布的工具。 Bamboo：Atlassian的持续集成（CI）解决方案，包含很多其它产品。 CircleCI：提供托管服务，可免费试用。 Codeship：提供托管服务，提供有限免费计划。 Go：ThoughtWork开源持续集成解决方案。 Jenkins：提供基于服务器的部署服务。 TeamCity：JetBrain持续集成方案，提供免费版。 Travis：提供托管服务，常用于开源项目。 数据库 简化数据库交互的工具、库。 Flyway：使用Java API轻松完成数据库迁移。 H2：小型SQL数据库，以内存操作著称。 JDBI：便捷的JDBC抽象。 jOOQ：基于SQL schema生成类型安全代码。 Presto：针对大数据的分布式SQL查询引擎。 Querydsl：针对Java的类型安全统一查询。 日期和时间 处理日期和时间的函数库。 Joda-Time：Java 8出现之前，它是日期、时间处理的标准函数库。 Time4J：Java高级日期、时间函数库。 依赖注入 帮助代码实现控制反转模式的函数库。 Dagger ：编译期的注入框架，没有使用反射，主要用于Android开发。 Guice：轻量级注入框架，功能强大可与Dagger媲美。 开发库 从基础层次上改进开发流程。 AspectJ：面向切面编程扩展，与程序无缝连接。 Auto：源代码生成器集合。 DCEVM：通过修改JVM，在运行时可无限次重定义已加载的类。OpenJDK 7、8已提供支持，详情可查看这个分支（fork）。 JRebel：商用软件，无需重新部署可即时重新加载代码及配置。 Lombok：代码生成器，旨在减少Java冗余代码。 RxJava：使用JVM中可观察序列，创建异步、基于事件应用程序的函数库。 Spring Loaded：另一个JVM类重载代理。 vert.x：JVM多语言事件驱动应用框架。 分布式应用 用来开发分布式、具有容错性应用程序的函数库和框架。 Akka：构建并发、分布式和具有容错功能的事件驱动应用程序所需的工具包和运行时。 Apache Storm：分布式实时计算系统。 Apache ZooKeeper：为大型分布式系统，使用分布式配置、同步和命名注册提供协调服务。 Hazelcast：分布式、高可扩展性内存网格。 Hystrix：为分布式系统提供延迟和容错处理。 JGroups：一组提供可靠消息传输的工具包，可用来创建集群。集群中的节点可互相发送消息。 Quasar：为JVM提供轻量级线程和Actor。 发布 使用本机格式分发Java应用程序的工具。 Bintray：对二进制发布进行版本控制，可与Maven或Gradle配合使用。 IzPack：为跨平台部署建立授权工具。 Launch4j：将JAR包装为小巧的Windows可执行文件。 packr：将程序JAR、资源和JVM打包成Windows、Linux和Mac OS X的本机文件。 文档处理 用来处理Office格式文档的函数库。 Apache POI：支持OOXML （XLSX、DOCX、PPTX）以及 OLE2 （XLS, DOC or PPT）格式的文档。 jOpenDocument：处理OpenDocument格式文档。 游戏开发 游戏开发框架。 jMonkeyEngine：支持现代3D开发的游戏引擎。 libGDX：全面的跨平台高级开发框架。 LWJGL：抽象了OpenGL、CL、AL等函数库的健壮框架。 GUI 用来创建现代图形用户界面的函数库。 JavaFX：Swing的继承者。 Scene Builder：JavaFX虚拟布局工具。 高性能 与高性能计算有关的资源，包括集合以及很多具体功能的函数库。 Disruptor：线程间消息函数库。 fastutil：快速紧凑的Java类型安全集合。 GS Collections：受Smalltalk启发的集合框架。 hftc：Hash set和hash map。 HPPC：基本类型集合。 Javolution：针对实时嵌入式系统的函数库。 Trove：基本类型集合。 IDE 视图简化开发的集成开发环境。 Eclipse：后台做了很多工作，以其丰富插件著称。 IntelliJ IDEA：支持很多JVM语言，为Android开发提供了很多不错的选项。其商业版本主要面向企业用户。 NetBeans：集成了很多Java SE和Java EE特性，包括数据库访问、服务器、HTML5以及AngularJS。 图像处理 用来帮助创建、评估或操作图形的函数库。 Picasso：Android下载图像和图像缓存函数库。 ZXing：多种格式的一维、二维条形码处理函数库。 JSON 简化JSON处理的函数库。 Gson：将Java对象序列化为JSON及反向操作。使用时提供了很好的性能。 Jackson：与GSON类似，但如果需要频繁初始化Jackson库会带来性能问题。 JVM和JDK 目前的JVM、JDK实现。 JDK 9：JDK 9早期访问版本。 OpenJDK：开源实现。 日志 记录应用程序的日志函数库。 Apache Log4j 2：对之前版本进行了完全重写。现在的版本具备一个强大的插件和配置架构。 kibana：对日志进行分析并进行可视化。 Logback：Log4j原班人马作品。被证明是一个强健的日志函数库，通过Groovy提供了很多有意思的配置选项。 logstash：日志文件管理工具。 SLF4J：日志抽象层，需要与某个具体日志框架配合使用。 机器学习 提供具体统计算法的工具。其算法可从数据中学习。 Apache Hadoop：对商用硬件集群上大规模数据存储和处理的开源软件框架。 Apache Mahout：专注协同过滤、聚类和分类的可扩展算法。 Apache Spark：开源数据分析集群计算框架。 h2o：用作大数据统计的分析引擎。 Weka：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。 消息 在客户端之间进行消息传递，确保协议独立性的工具。 Apache ActiveMQ：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。 Apache Kafka：高吞吐量分布式消息系统。 JBoss HornetQ：清晰、准确、模块化且方便嵌入的消息工具。 JeroMQ：ZeroMQ的纯Java实现。 其它 其它资源。 Design Patterns：实现并解释了最常见的设计模式。 Jimfs：内存文件系统。 Lanterna：类似curses的简单console文本GUI函数库。 LightAdmin：可插入式CRUD UI函数库，可用于快速应用开发。 Metrics：创建自己的软件度量或者为支持框架添加度量信息，通过JMX或HTTP进行发布或者发送到数据库。 OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。 RoboVM：Java编写原生iOS应用。 自然语言处理 用来专门处理文本的函数库。 Apache OpenNL：处理类似分词等常见任务的工具。 CoreNLP：斯坦佛的CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。 LingPipe：一组可以处理各种任务的工具集，支持POS标签、情感分析等。 Mallet：统计学自然语言处理、文档分类、聚类、主题建模等。 网络 网络编程函数库。 Netty：构建高性能网络应用程序开发框架。 OkHttp ：一个Android和Java应用的HTTP+SPDY客户端。 ORM 处理对象持久化的API。 EclipseLink：支持许多持久化标准，JPA、JAXB、JCA和SDO。 Hibernate：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。 Ebean：支持快速数据访问和编码的ORM框架。 PDF 用来帮助创建PDF文件的资源。 Apache FOP：从XSL-FO创建PDF。 Apache PDFBox：用来创建和操作PDF的工具集。 DynamicReports：JasperReports的精简版。 iText：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。 JasperReports：一个复杂的报表引擎。 REST框架 用来创建RESTful 服务的框架。 Dropwizard：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。 Jersey：JAX-RS参考实现。 RESTEasy：经过JAX-RS规范完全认证的可移植实现。 Retrofit：一个Java类型安全的REST客户端。 Spark：受到Sinatra启发的Java REST框架。 Swagger：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。 科学 用于科学计算和分析的函数库。 SCaVis：用于科学计算、数据分析和数据可视化环境。 搜索 文档索引引擎，用于搜索和分析。 Apache Solr ：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。 Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。 安全 用于处理安全、认证、授权或会话管理的函数库。 Apache Shiro：执行认证、授权、加密和会话管理。 Cryptomator：在云上进行客户端跨平台透明加密。 Keycloak：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。 PicketLink：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。 Spring Security：专注认证、授权和多维度攻击防护框架。 序列化 用来高效处理序列化的函数库。 FlatBuffers：序列化函数库，高效利用内存，无需解包和解析即可高效访问序列化数据。 Kryo：快速和高效的对象图形序列化框架。 MessagePack：一种高效的二进制序列化格式。 服务器 用来部署应用程序的服务器。 Apache Tomcat：针对Servlet和JSP的应用服务器，健壮性好且适用性强。 Apache TomEE：Tomcat加Java EE。 GlassFish：Java EE开源参考实现，由Oracle资助开发。 Jetty：轻量级、小巧的应用服务器，通常会嵌入到项目中。 WildFly：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。 模版引擎 对模板中表达式进行替换的工具。 Apache Velocity：提供HTML页面模板、email模板和通用开源代码生成器模板。 FreeMarker：通用模板引擎，不需要任何重量级或自己使用的依赖关系。 Handlebars.java：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。 JavaServer Pages：通用网站模板，支持自定义标签库。 Thymeleaf：旨在替换JSP，支持XML文件。 测试 测试内容从对象到接口，涵盖性能测试和基准测试工具。 Apache JMeter：功能性测试和性能评测。 Arquillian：集成测试和功能行测试平台，集成Java EE容器。 AssertJ：支持流式断言提高测试的可读性。 JMH：JVM微基准测试工具。 JUnit：通用测试框架。 Mockito：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。 Selenium：为Web应用程序提供可移植软件测试框架。 Selenide：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。 TestNG ：测试框架。 VisualVM：提供可视化方式查看运行中的应用程序信息。 工具类 通用工具类函数库。 Apache Commons：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。 Guava：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。 javatuples：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。 网络爬虫 用于分析网站内容的函数库。 Apache Nutch ：可用于生产环境的高度可扩展、可伸缩的网络爬虫。 Crawler4j：简单的轻量级爬虫。 JSoup ：刮取、解析、操作和清理HTML。 Web框架 用于处理Web应用程序不同层次间通讯的框架。 Apache Tapestry：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。 Apache Wicket：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。 Google Web Toolkit：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP API、JUnit集成、国际化支持和GUI控件。 Grails：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。 Play： 使用约定而非配置，支持代码热加载并在浏览器中显示错误。 PrimeFaces：JSF框架，提供免费版和带技术支持的商业版。包含一些前端组件。 Spring Boot：微框架，简化了Spring新程序的开发过程。 Spring：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。 Vaadin：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。 Ninja：Java全栈Web开发框架。非常稳固、快速和高效。 Ratpack：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。 资源 社区 活跃的讨论区。 r/java：Java社区的Subreddit。 stackoverflow：问答平台。 有影响的书籍 具有广泛影响且值得阅读的Java经典书籍。 Effective Java (2nd Edition) Java Concurrency in Practice | Java并发编程实战 Thinking in Java | 中文版 播客 可以一边编程一边听的东西。 The Java Posse Twitter 值得关注的帐号。 Adam Bien：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。 Antonio Goncalves：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。 Arun Gupta：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。 Bruno Borges：Oracle产品经理、Java Jock。 Ed Burns：Oracle技术团队顾问。 Eugen Paraschiv：Spring安全课程作者。 James Weaver：Java、JavaFX、IoT开发者、作者和演讲者。 Java EE：Java EE Twitter官方账号。 Java Magazine：Java杂志官方账号。 Java.net：Java.net官方账号。 Java：Java Twitter官方账号。 Javin Paul：知名Java博客作者。 Lukas Eder：Data Geekery（jOOQ）创始人兼CEO。 Mario Fusco：RedHatter、JUG协调、活跃讲师和作者。 Mark Reinhold：Oracle首席架构师、Java平台开发组。 Martijn Verburg：London JUG co-leader、演讲者、作家、Java Champion等。 OpenJDK：OpenJDK官方账号。 Reza Rahman：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。 Simon Maple：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。 Stephen Colebourne： Java Champion、演讲者。 Tim Boudreau：作家、NetBeans大牛。 Trisha Gee：Java Champion、演讲者。 网站 值得阅读的网站。 Google Java Style InfoQ Java Code Geeks Java.net Javalobby JavaWorld RebelLabs The Java Specialist’ Newsletter TheServerSide.com Thoughts On Java ImportNew（ImportNew 专注 Java 技术） ","link":"https://kangjn.github.io/post/guo-wai-cheng-xu-yuan-zheng-li-de-java-zi-yuan-da-quan/"},{"title":"在自己的应用中加入支付功能","content":"在自己的应用中如何加入对支付功能的支持。 1、项目名称：龙果支付系统 roncoo-pay **项目简介：**龙果支付系统核心目标是汇聚所有主流支付渠道，打造一款轻量、便捷、易用，且集支付、资金对账、资金清结算于一体的支付系统，满足互联网业务系统的收款和业务资金管理需求。 主要特点： 具备支付系统通用的支付、对账、清算、资金账户管理、支付订单管理等功能； 目前已接通“支付宝即时到账”和“微信扫码支付”通道； 支持直连和间连两种支付模式，任君选择； 通过支付网关，业务系统可以轻松实现统一支付接入； 搭配运营后台，支付数据的监控和管理可以兼得； 配套完善的系统使用文档，可轻松嵌入任何需要支付的场景； **项目地址：**https://gitee.com/roncoocom/roncoo-pay 2、项目名称：聚合支付系统 XxPay **项目简介：**XxPay 聚合支付使用 Java 开发，包括spring-cloud、dubbo、spring-boot三个架构版本，已接入微信、支付宝等主流支付渠道，可直接用于生产环境。 目前已经接入支付渠道：微信(公众号支付、扫码支付、APP支付、H5支付)、支付宝(电脑网站支付、手机网站支付、APP支付、当面付)。 **项目地址：**https://gitee.com/jmdhappy/xxpay-master 3、项目名称：常用支付接口 IJPay **项目简介：**IJPay 封装了微信支付、支付宝支付、银联支付常用的支付方式以及各种常用的接口。不依赖任何第三方 mvc 框架，仅仅作为工具使用简单快速完成支付模块的开发，可轻松嵌入到任何系统里。 项目地址：https://gitee.com/javen205/IJPay 4、项目名称：基于 Java 的支付开发工具包 **项目简介：**优雅的轻量级支付模块，集成微信支付、支付宝、银联、友店、富友、跨境支付等。付与业务完全剥离，简单几行代码即可实现支付，简单快速完成支付模块的开发，可轻松嵌入到任何系统里。 目前仅是一个开发工具包（即SDK），只提供简单 Web 实现，建议使用 maven 或 gradle 引用本项目即可使用本 SDK 提供的各种支付相关的功能。 **项目地址：**https://gitee.com/egzosn/pay-java-parent 5、项目名称：轻量级支付系统 Fastpay **项目简介：**Fastpay 的目标是打造一款开源的、轻量级的、微服务化的、可共私有云部署的、可定制化的集成聚合支付和资金清结算于一体的统一支付系统，满足互联网企业业务系统的收款和资金处理等需求。 在支付系统上实施微服务架构，使用最流行的Spring Cloud做服务化。 设计天生可伸缩的数据存储，直接使用分库分表。 使用缓存进行加速交易过程，提高用户体验。 将回调通知、入账等异步化，提高用户响应能力。 使用分布式定时任务系统将任务调度与交易隔离。 使用当前最先进的单元化架构实现可水平伸缩。 **项目地址：**https://gitee.com/robertleepeak/fastpay 6、项目名称：支付 SDK 扩展包 easyPay **项目简介：**本项目根据支付宝、微信最新 API 开发而成，高度抽象的类，免去各种拼 json 与 xml 的痛苦；符合 PSR 标准，你可以各种方便的与你的框架集成；文件结构清晰易理解，可以随心所欲添加本项目中没有的支付网关；方法使用更优雅，不必再去研究那些奇怪的的方法名或者类名是做啥用的。 **项目地址：**https://gitee.com/yansongda/pay 7、项目名称：互联网金融支付系统 aaden-pay **项目简介：**基于互联网金融理财环境下产生的支付系统，特点为： 同卡进出，用户先实名绑定银行卡，后交易，不支持手机扫码交易。 提供统一的支付框架，只需少量代码就可快速接入新渠道，提供一个稳定的支付解决方法，节约程序员时间。 **项目地址：**https://gitee.com/aaden/aaden-pay 8、项目名称：基于 PHP 的支付 SDK **项目简介：**Payment 是一个 PHP 版本的支付聚合第三方 SDK，集成了微信支付、支付宝支付、招商一网通支付。提供统一的调用接口，方便快速接入各种支付、查询、退款、转账能力。 **项目地址：**https://gitee.com/helei112g/payment 9、项目名称：基于 .NET Core 的支付 SDK 集 **项目简介：**本项目是基于 .NET Core / ASP.NET Core 开发的跨平台支付 SDK 集，简化了 API 调用及相关通知的处理流程。 目前支持：支付宝(Alipay)、微信支付(WeChatPay)、QQ钱包(QPay)、京东支付(JDPay)、连连支付(LianLianPay)、银联支付(UnionPay)。 **项目地址：**https://gitee.com/Essensoft/Payment ","link":"https://kangjn.github.io/post/zai-zi-ji-de-ying-yong-zhong-jia-ru-zhi-fu-gong-neng/"},{"title":"在VS code中提交项目到码云","content":"在VS code中提交项目 首先在VS code中进入到要上传的项目内，比如我的是Angular项目，就是这个样子： 然后依次执行如下语句： 初始化： git init 定向到你的代码仓库： git remote add origin https://gitee.com/用户个性地址/HelloGitee.git 上传并添加评论： git add . git commit -m &quot;第一次提交&quot; git push origin master ——这里注意，如果你项目中有redme文件而且在码云网站上创建仓库时也生成了redme文件话要加上 -f 将代码放到码云 到码云里新建一个仓库，完成后码云会有一个命令教程按上面的来就行了 码云中的使用教程： Git 全局设置: git config --global user.name &quot;ASxx&quot; git config --global user.email &quot;123456789@qq.com&quot; 创建 git 仓库: mkdir wap // 项目在本地的路径 cd wap git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://git.oschina.net/name/package.git // 远程仓库地址 git push -u origin master 已有项目： cd existing_git_repo git remote add origin https://git.oschina.net/name/package.git git push -u origin master 下面说下详细的本地操作步骤： 1、用vs打开你的项目文件夹 2、配置git 打开Git Bash输入以下命令 如果还没输入全局配置就先把这个全局配置输入上去 Git 全局设置: git config --global user.name &quot;ASxx&quot; git config --global user.email &quot;123456789@qq.com&quot; 然后开始做提交代码到码云的配置 cd d:/wamp/www/mall360/wap //首先指定到你的项目目录下 git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://git.oschina.net/name/package.git //用你仓库的url git push -u origin master //提交到你的仓库 正常情况下上面的命令执行完成后，本地文件夹会有一个隐藏的.git文件夹，云端你的仓库里应该会有一个README.md文件。 3、在vscode中提交代码到仓库 回到vs code打开git工作区就会看到所有代码显示在这里 点击+号，把所有文件提交到暂存区。 然后打开菜单选择--提交已暂存的 然后按提示随便在消息框里输入一个消息，再按ctrl+enter提交 然后把所有暂存的代码push云端， 点击后，会弹出让你输入账号密码，把你托管平台的账号密码输入上去就行了。。。 不出问题的话你整个项目就会提交到云端上了。 在vs中每次更新代码都会要输入账号密码，方便起见，可以配置一下让GIT记住密码账号。 git config --global credential.helper store //在Git Bash输入这个命令就可以了 ","link":"https://kangjn.github.io/post/zai-vs-code-zhong-ti-jiao-xiang-mu-dao-ma-yun/"},{"title":"刻在骨子里的“教养”","content":"不责人小过，不发人阴私，不念人旧恶。 前苏联教育家苏霍姆林斯基曾说： “在人类心灵的花园中，最质朴、最美丽和最平凡的花朵，是人的教养。” 那什么是教养？ 教养是一个人文化品德的修养，是一个人从小就习得的一种规矩，是待人接物处事的一种敬重态度。 丰一吟在《回忆父亲丰子恺》中说： “生而养之，养而教之。教养，是一个家庭传承给孩子的最好礼物。” 【01】教养，是教育和养成。 教养，是教育和养成，是文化的传承和后天学习的规范。 一个人的教养，不是先天就拥有的，而是后天的学习教育和周身氛围所养成的良好品质和行为习惯，是经过人生历练和修行所沉淀下的德性。 当我们呱呱坠地，生而一张白纸，往后一生的精彩都由自己去涂鸦，而一个人的教养则以自身的学习和规范养成的。 人都说父母是孩子的第一任老师，而家庭是孩子成长的摇篮。 家庭环境是孩子健康成长的基本因素，而父母的品行更是影响孩子的教养。 《三字经》中言，养不教，父之过；教不严，师之惰，人若没有教养，便是父母老师的不称职。 “昔孟母，择邻处”只为孩子远离那些不良因素，为其创造一个良好的教育环境。 胡适先生回忆母亲时曾说：“如果我学得了一丝一毫的好脾气，如果我学得了一点点待人接物的和气，如果我能宽恕人，体谅人——我都得感谢我的慈母。” 可见，自身所处的家庭氛围与父母的品行和行为举止，都会在生活中慢慢渗透于孩子的品行和教养中。 英国切斯特菲尔德说： “所谓良好教养，它们在几乎所有国家中乃至于一个地区里，都不尽相同；每一个明辨事理的人都会模仿他所在之地的良好教养，并与之看齐。” 正所谓：“玉不琢，不成器；人不学，不知义。” 人要明辨是非就得学习，做一个品德高尚的人也要学习，而做一个有教养的人更要学习，学习端正己身，立身处世，待人接物。 【02】教养，是由内散发的文化修养。 德米特里．利哈乔夫在《论教养》中说：“良好的教养不仅来自家庭和学校，而且可以得之于自身。” 但是前提是必须了解，什么是真正的教养。 教养，是发自于内心，是以成长环境，教育基础，自身经历等所综合成一种内在素质。 一个人是否有教养，不止是行为上彬彬有礼，更注重于其文化内涵和道德修养。 其中，文化，不单单指文化学识，更是一种以行为习惯和精神价值结合成的意识。 作家梁晓声说：“文化是根植于内心的修养，无需自觉提醒的自觉；以约束为前提的自由；为别人着想的善良。” 文化修养是一种由内散发的一种气质，是从自我认知，自我教育，自我学习，且沉淀到一定程度所散发出的一股无形力量。 一个人有没有文化，不在于其学历高低，而是是否具有这种无形中所沉淀下来的气质修养。 有文化修养的人，总能发现事物中的美好和希望，更是对光明的未来充满着极大的向往。 【03】教养，是有别于礼貌却依托于礼貌。 教养，是发自于内心，是一种经过时间的磨练和规范后综合的内在品质素养，是待人处事上的行为习惯。 礼貌，是外在的行为，是在模仿和刻意下也能假装出来的一种谦恭有礼的行为表现，它不一定发自于内心。 有教养的人，总表现的很有礼貌。 有礼貌的的人却未必是有教养的人。 一个人若是金玉其外败絮其中，不能内外兼修，这样的人不是有教养，只能称其“伪君子”。 一个人牙尖嘴利，却背地里又做好事，我们不能说这样的人有教养，只能说其有一副好心肠，刀子嘴豆腐心。 日常生活中，吵架后，我们总能听到劝架的人说：“你别跟他一般见识，他人就那样，嘴巴坏但心地善良，你也别太介意。”等等之类的。 但他忘了，说者无心，听者有意，伤人往往也就在那一两句话中，伤过之后便是千疮百孔。 “良言一句三冬暖，恶语伤人六月寒”，有教养的人不会口无遮拦，也不会以嘴毒心肠好为借口的；反之，有教养的人相处起来是舒服的。 歌德说：“没有一种礼貌会在外表上叫人一眼就看出教养的不足，正确的教养在于使外表上的彬彬有礼和人的高尚的教养同时表现出来。” 【04】教养，是自我的约束和将心比心。 《菜根谭》：“有教养的人，不责人小过，不发人阴私，不念人旧恶。” 有教养的人不责难别人的小过错，不随便揭露别人的隐私，不念叨别人过去的坏处。 教养，体现于细节。 它不是看笑话，更不是让别人感到难堪或轻视。 洛克说：“教养的本质是在交往中对于任何人不表示任何轻视或侮蔑。” 有教养的人，不会让别人觉着尴尬困窘，在冒犯了他人后，懂得及时反省自身以及调整自己的行为。 当你在图书馆看书时，你可以选择自己喜欢的去看，但不能大声喧哗，这是你的个人教养。 当公共区域有人休息时，你不能总弄出动静，影响他人。不然这就是你素质低，没教养了。 一个人是否拥有最高级的教养，就看他懂不懂顾忌别人的感受，懂不懂将心比心，会不会让与之交往的人感到亲切舒适和满足。 格里美尔斯豪森言道：“没有教养、没有学识、没有实践的人的心灵好比一块田地，这块田地即使天生肥沃，但倘若不经耕耘和播种，也是结不出果实来的” 一个人的教养，是他立足社会的根基。 内在的修养让人吸引着志同道合的人，外在的行为礼仪拉近彼此距离，而内外兼修的教养，是稳固所有关系的壁垒。 教养是人生的一大课题，需要我们用一生的时间都去研修。 ","link":"https://kangjn.github.io/post/ke-zai-gu-zi-li-de-jiao-yang/"},{"title":"微服务拆分","content":"一、拆分 **1、新浪微博微服务从纵横两个维度来划分，简单粗暴： 1.1 纵向拆分 从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。 1.2 横向拆分 从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。 纵向以业务为基准，关系铁的在一起；横向功能独立的在一起。 2.1 服务拆分要迎合业务的需要 充分考虑业务独立性和专业性，避免以团队来定义服务边界，从而出现“土匪”抢地盘，影响团队信任。 这个维度和上面的类似，但是强调的是业务和团队成员的各自独立性，对上面是一种很好的补充。 2.2 拆分后的维护成本要低于拆分前 这里的维护成本包括：人力、物力、时间。 这里的成本对大部分中小团队来说都是必须要考虑的重要环节，如果投入和收益不能成正比，或者超出领导的预算或者市场窗口，那么先进的技术就是绊脚石，千万不要迷恋技术，所谓工程师思维千万要不得。 2.3 拆分不仅仅是架构的调整，组织结构上也要做响应的适应性优化 确保拆分后的服务由相对独立的团队负责维护。 这句话怎么理解呢？传统的团队划分是按照产品部、前端、后端横向划分，微服务化以后的团队可能就会是吃一张披萨饼的人数，产品、前端、后端被归类到服务里面，以服务为中心来分配人数。 把具有不同扩展性要求的服务拆分出来，分别进行部署，降低成本，提高效率。比如全文搜索服务。 这点和上面的按功能独立性来拆分有点类似，功能独立其实就是面向可扩展性。 2.5 考虑软件发布频率 比如把20%经常变动的部分进行抽离，80%不经常变动的单独部署和管理。说白了就是按照8/2原则进行拆分。这个拆分的好处很明显，可以尽可能的减少发布产生的后遗症，比如用户体验、服务相互干扰等。 但是这里有一个问题，假如20%的服务分属于不同的业务层面，那该怎么办？所以这里的拆分应该有个优先级，在拆分相互冲突的时候应该要优先考虑权重比较高的那个。 **3、另一种拆分： 3.1 基于业务逻辑 将系统中的业务按照职责范围进行识别，职责相同的划分为一个单独的服务。这种业务优先的方式在前面两种姿势当中都出现过，可见是最基本，最重要的划分方式（没有之一）。 3.2 基于稳定性 将系统中的业务模块按照稳定性进行排序。稳定的、不经常修改的划分一块；将不稳定的，经常修改的划分为一个独立服务。比如日志服务、监控服务都是相对稳定的服务，可以归到一起。这个很类似上面提到的2/8原则，80%的业务是稳定的。 至此你会发现服务的拆分真的没有绝对的标准，只有合理才是标准。 3.3 基于可靠性 同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求比较高的核心模块归在一起，对可靠性要求不高的非核心模块归在一块。 这种拆分的高明可以很好的规避因为一颗老鼠屎坏了一锅粥的单体弊端，同时将来要做高可用方案也能很好的节省机器或带宽的成本。 3.4 基于高性能 同上，将系统中的业务模块按照对性能的要求进行优先级排序。把对性能要求较高的模块独立成一个服务，对性能要求不高的放在一起。比如全文搜索，商品查询和分类，秒杀就属于高性能的核心模块。 4、盘点 以上不同拆分各有千秋，异曲同工！ 对业务逻辑均不约而同的放在第一位。 对业务模块的稳定性和可靠性，对功能的独立性、可扩展性都有相似的看法 强调拆分应该是多选，而不是单选。具体情况具体分析，可以自由灵活排列组合。 **二、题外话 如果你把上面的划分角度背下来了拿去现场套，可能还会遇到矛盾或争议。 1、业务矛盾 假如我们按照业务来划分，根据粒度大小，可能存在以下两种： 第一种分为商品、交易、用户3个服务； 第二种分为商品、订单、支付、物流、买家、卖家6个服务。 3 VS 6，这该怎么办？ 如果你的团队只有9个人，那么分成3个是合理的，如果有18个人，那么6个服务是合理的。这里引入团队成员进行协助拆分。 可见拆分的姿势不是单选，而是多选的。这个时候必须要考虑团队成员数量。 在拆分遇到争议的时候，一般情况下我们增加一项拆分条件，虽然不是充要条件，但至少我们的答案会更加接近真理。 除了业务可能存在争议，其他的划分也会有争议，比如一个独立的服务到底需要多少人员的配置？ 2、三个火枪手(人员配置) 上面提到的人员数量配置，这里为什么是9和18呢？(这里的团队配置参考李云华前辈提到的三个火枪手的观点) 换一种问法，为什么说是三个人分配一个服务（当然，成员主要是后端人员）？ 假设是1个人，请个假、生个病都不行。一个人会遇到单点的问题，所以不合理。 假设是2个人，终于有备份了，但是抽离一个后，剩下1个压力还是很大，不合理。 假设是3个人，抽离一个还有2个在。而且数字3是个稳定而神奇数字，用得好事半功倍。特别是遇到技术讨论，3个人相对周全，如果是2个可能会各持己见，带有自我的偏见和盲区。 那么这个3是不是就是稳定的数量呢？ 假设你做的是边开飞机边换引擎的重写工作，那么前期3个人都可能捉襟见肘。但是到了服务后期，你可能1个就够了。 所以3在我的理解应该是一个基准线，不同的时间段会有上下波动，但是相对稳定。 ","link":"https://kangjn.github.io/post/wei-fu-wu-chai-fen/"},{"title":"一份微服务架构手稿图","content":"什么是微服务？ 微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下： 就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。 但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。 服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。 另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。 根据马丁.福勒的描述，我总结了以下几点： ①小服务 小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。 ②进程独立 每一组服务都是独立运行的，可能我这个服务运行在 Tomcat 容器，而另一个服务运行在 Jetty 上。可以通过进程方式，不断的横向扩展整个服务。 ③通信 过去的协议都是很重的，就像 ESB，就像 SOAP，轻通信，这意味着相比过去更智能更轻量的服务相互调用，就所谓 smart endpoints and dumb pipes。 这些 Endpoint 都是解耦的，完成一个业务通信调用串起这些 Micro Service 就像是 Linux 系统中通过管道串起一系列命令业务。 过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。 ④部署 不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维职责。 ⑤管理 传统的企业级 SOA 服务往往很大，不易于管理，耦合性高，团队开发成本比较大。 微服务，可以让团队各思其政的选择技术实现，不同的 Service 可以根据各自的需要选择不同的技术栈来实现其业务逻辑。 微服务的利与弊 为什么用微服务呢？因为好玩？不是的。下面是我从网络上找到说的比较全的优点： 优点是每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。 开发简单、开发效率提高，一个服务可能就是专一的只干一件事。 微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。 微服务能使用不同的语言开发。 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins，Hudson，bamboo。 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。 微服务只是业务逻辑的代码，不会和 HTML，CSS 或其他界面组件混合。 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库。 总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。 但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。 什么组织适合使用微服务？ 微服务带了种种优点，种种弊端，那么什么组织适合使用微服务？ ①墨菲定律（设计系统）和康威定律（系统划分） 康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是： Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. -Melvin Conway(1967) 中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。 ②架构演化 架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。[淘宝千万并发，14 次架构演进]，推荐大家看下。 [] 传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。 我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。 使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用 API 方式发布他们的功能，而平台使用他们的功能发布产品。 微服务技术架构体系 下面我分享一下大部分公司都使用的微服务技术架构体系： 服务发现 主流的服务发现，分为三种： 第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过 DNS 就能找到我们对应的服务。 缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。 第二种，是目前普遍的做法。可以参考 Zuul 网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。 缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在 Spring Cloud 上的。 第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。 [这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。] [网关] 微服务的网关是什么？我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。 将生活实际联系到微服务上，就不难理解网关的意思了： 网关的作用如下： 反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务调用。 安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。 限流熔断：当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题。 日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息。 灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行 A/B testing。即让一部分用户继续用产品特性 A，一部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。 [开源网关 Zuul 架构：] Zuul 网关核心其实是一个 Servlet，所有请求都会经过 Zuul Servlet 传到 ZuulFilter Runner，然后分发到三种过滤器。 先说说架构图左半部分，分别是使用 Groovy 实现的前置路由过滤器，路由过滤器，后置路由过滤器。 一般请求都会先经过前置路由过滤器处理，一般的自定义 Java 封装逻辑也会在这里实现。 路由过滤器，实现的是找到对应的微服务进行调用。调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。 可以说 Zuul 网关最大的特色就是它的三层过滤器。是 Zuul 网关设计的自定义过滤器加载机制。 网关内部会有生产者消费者模型，自动的将过滤器脚本发布到 Zuul 网关读取加载运行。 配置中心 以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。 一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。 因此就有配置中心这个喽！现在的开源中心有百度配置中心 Disconf，Spring Cloud Config，Apollo。 今天重点说说现在应用质量不错的配置中心，携程开源的阿波罗（Apollo）： Apollo 的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。关注微信公众号：Java技术栈，在后台回复：架构，可以获取我整理的 N 篇最新架构干货。 通讯方式 关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格： 监控预警 监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。 一般监控分为如下层次： 从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。 总体来说，微服务可分为 5 个监控点： 日志监控 Metrics 监控 健康检查 调用链检查 告警系统 ①监控架构 下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。 同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。关注微信公众号：Java技术栈，在后台回复：架构，可以获取我整理的 N 篇最新架构干货。 ②调用链监控 APM 很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的 Cat，大部分调用链监控（没错，我指的 Zipkin）架构是这样的： 当请求进入 Web 容器的时候，会经过创建 Tracer，连接 Spans（模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过 HTTP Headers）。 Spans 有一个上下文，其中包含 Tracer 标识符，将其放在表示分布式操作的树的正确位置。 当我们把图中的各种 Span 放到后端的时候，我们的服务调用链会动态的生成调用链。 下面是一些市场上用的比较多的调用链监控对比： 熔断、隔离、限流、降级 面对巨大的突发流量下，大型公司一般会采用一系列的熔断（系统自动将服务关闭防止让出现的问题最大化）、隔离（将服务和服务隔离，防止一个服务挂了其他服务不能访问）、限流（单位时间内之允许一定数量用户访问）、降级（当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务或任务进行服务的延迟使用或暂停使用）措施。 下面介绍一下 Hystrix 的运行流程： Hystrix 停止开发，Spring Cloud 何去何从？ 每一个微服务调用时，都会使用 Hystrix 的 Command 方式（上图的左上角那个），然后使用 Command 同步的，或者是响应式的，或者是异步的，判断电路是否熔断（顺着图从左往右看），如果断路则走降级 Fallback。 如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施（看图的第 5 步）。 如果走完了，执行成功了，则走 run() 方法，获取 Response，但是这个过程如果出错了，则继续走降级 Fallback。 同时，看图最上面有一个后缀是 Health 的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。 容器与服务编排引擎 从物理机到虚拟机，从虚拟机到容器；从物理集群到 OpenStack，OpenStack 到 Kubernetes；科技不断的变化，我们的认知也没刷新。 我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。 虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。 虚拟机依赖于 Hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致 Hypervisor 在某些方面被认为是一种操作系统。 一旦 Hypervisor 安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载（应用程序）。 简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层 Runtime，然后供应用程序运行。 对于容器环境来说，不需要安装主机操作系统，直接将容器层（比如 LXC 或 Libcontainer）安装在主机操作系统（通常是 Linux 变种）之上。 在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。 但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。 相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味着相比于虚拟机，单个操作系统能够承载更多的容器。 云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。 此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。 因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。 我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。 正因为如此，容器才拥有极为出色的轻量化特性。我们最常用的容器是 Docker。 ①容器编排 过去虚拟机可以通过云平台 OpenStack 管理虚拟化，容器时代如何管理容器呢？这就要看看容器编排引擎了。 Apache Mesos：Mesos 是基于 Master，Slave 架构，框架决定如何利用资源，Master 负责管理机器，Slave 会定期的将机器情况报告给 Master，Master 再将信息给框架。Master 是高可用的，因为 ZK，也有 Leader 的存在。 下面是架构图： Kubernetes：Kubernetes 是最近十分火热的开源容器编排引擎 Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，先说说每一个 Kubernetes 节点内部，kubelet 管理全局全局 pod，而每一个 pod 承载着一个或多个容器，kube-proxy 负责网络代理和负载均衡。 Kubernetes 节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。 ②服务网格化 关于服务网络化，后面会更加深入的为大家进行讲解。 ","link":"https://kangjn.github.io/post/yi-fen-wei-fu-wu-jia-gou-shou-gao-tu/"},{"title":"微服务介绍","content":" 微服务是什么 为什么要采用微服务 微服务架构 架构设计模式 服务拆分 微服务框架 架构模式有很多，微服务不是唯一的选择也不是什么银弹。 “你必须长的足够高才能使用微服务”。微服务基础设施，尤其是容器技术、自动化部署、自动化测试这些不完备，微服务形同虚设，不会带来什么质的提升。 微服务架构的关键不在于具体的实现，而在于如何合理地划分服务边界以及组织架构是否相匹配。不考虑研发团队的规模和组成就盲目上微服务是不良的技术选型。 Spring Boot 是 Spring 全家桶的上层封装，并不是什么崭新的技术，也不是什么值得成为自己杀手锏的技术。 Spring Cloud 中 Spring Cloud Netflix 的组件是经过生产环境验证的，其他的则建议慎重选择。 微服务是什么 微服务起源于 2005 年 Peter Rodgers 博士在云端运算博览会提出的微 Web 服务(Micro-Web-Service)，根本思想类似于 Unix 的管道设计理念。 2014 年，由 Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯（HTTP API）。 关键的三点是： small automated lightweight 对比 SOA，微服务可以看做是 SOA 的子集，是轻量级的 SOA，粒度更细的服务，独立进程、数据分离，更注重敏捷、持续交付、DevOps 以及去中心化实践。 其共同的架构原理： 单一职责 关注分离：控制与逻辑相分离 模块化和分而治之 特点： 用服务进行组件化 围绕业务能力进行组织 是产品而非项目 端点智能化和哑管道: 控制逻辑都在端点，管道仅仅是传输 全自动化部署 语言和数据的去中心化控制 面向失败设计 渐进式设计 综合来看，其优缺点如下： 优点： 模块的强边界；独立部署；技术选型的多样性。 缺点： 分布式带来编程复杂度，远程调用的消耗；舍弃强一致性，实现最终一致性；操作复杂性要求有一个成熟的运维团队或者运维基础设施。 为什么要采用微服务 是否选择微服务取决于你要设计的系统的复杂度。微服务是用来把控复杂系统的，但是随之而来的就是引入了微服务本身的复杂度。 需要解决包括自动化部署、监控、容错处理、最终一致性等其他分布式系统面临的问题。即使已经有一些普遍使用的解决方案，但是仍然是有不小的成本的。 生产力和复杂度的关系如图所示，可见系统越复杂，微服务带来的收益越大。此外，无论是单体应用还是微服务，团队的技能都需要能够把控住。 马丁·福勒的一个观点是： 除非管理单体应用的成本已经太复杂了（太大导致很难修改和部署），否则都不要考虑微服务。 大部分应用都应该选择单体架构，做好单体应用的模块化而不是拆分成服务。 因此，系统一开始采用单体架构，做好模块化，之后随着系统变得越来越复杂、模块/服务间的边界越来越清晰，再重构为微服务架构是一个合理的架构演化路径。 四个可以考虑上微服务的情况： 多人开发一个模块/项目，提交代码频繁出现大量冲突。 模块间严重耦合，互相依赖，每次变动需要牵扯多个团队，单次上线需求太多，风险大。 主要业务和次要业务耦合，横向扩展流程复杂。 熔断降级全靠 if-else。 微服务的三个阶段： 微服务 1.0： 仅使用注册发现，基于 Spring Cloud 或者 Dubbo 进行开发。 微服务 2.0： 使用了熔断、限流、降级等服务治理策略，并配备完整服务工具和平台。 微服务 3.0： Service Mesh 将服务治理作为通用组件，下沉到平台层实现，应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现 AIOps 和智能调度。 微服务架构 先决条件 微服务的先决条件如下： 快速的环境提供能力： 依赖于云计算、容器技术，快速交付环境。 基本的监控能力： 包括基础的技术监控和业务监控。 快速的应用部署能力： 需要部署管道提供快速的部署能力。 Devops 文化： 需要具有良好的持续交付能力，包括全链路追踪、快速环境提供和部署等，还需要快速的反应能力（对问题、故障的快速响应），开发和运维的协同工作。 此外，根据康威定律和逆康威定律（技术架构倒逼组织架构改进），组织架构也是一个很关键的因素。 对应于微服务架构，组织架构需要遵循以下原则： 一个微服务由一个团队维护，团队成员以三人为宜。 单个团队的任务和发展是独立的，不受其他因素影响。 团队是功能齐全、全栈、自治的，扁平、自我管理。 基础设施 微服务的推行需要依赖于很多底层基础设施，包括提供微服务的编译、集成、打包、部署、配置等工作，采用 PaaS 平台解决微服务从开发到运行的全生命周期管理，同时提供异构环境管理、容器资源隔离与互通、服务伸缩漂移、服务升级与回退、服务熔断与降级、服务注册与发现。 ①最基本的基础设施 进程间通讯机制： 微服务是独立进程的，需要确定之间的通讯方式。 服务发现+服务路由： 提供服务注册中心，服务提供者和消费者通过服务发现获取服务的信息从而调用服务，实现服务的负载均衡等。 服务容错： 微服务架构中，由于服务非常多，往往是一个服务挂了，整个请求链路的服务都受到影响。 因此需要服务容错，在服务调用失败的时候能够处理错误或者快速失败，包括熔断、Fallback、重试、流控和服务隔离等。 分布式事务支持： 随着业务拆分为服务，那么有时候不开避免的就是跨服务的事务，即分布式事务的问题。 原则是尽量避免分布式事务，如果无法避免那么可以使用消息系统或者 CQRS 和 Event Sourcing 方案来实现最终一致性。 如果需要强一致性，则有两阶段提交、三阶段提交、TCC 等分布式事务解决方案。 ②提升外部服务对接效率和内部开发效率 API 网关： 负责外部系统的访问，跨横切面的公共层面的工作，包括安全、日志、权限控制、传输加密、请求转发、流量控制等。 典型的网关功能即对外暴露一个域名 xx.com，根据第一级目录做反向路由 xx.com/user，xx.com/trade。 每一级目录，如 user、trade 对应一个服务的域名。此外，API 网关也可以有服务编排的功能（不推荐）。 接口框架： 规范服务之间通讯使用的数据格式、解析包、自解释文档，便于服务使用方快速上手等。 ③提升测试和运维效率 配置中心: 运行时配置管理能够解决动态修改配置并批量生效的问题。包括配置版本管理、配置项管理、节点管理、配置同步等。 持续交付： 包括持续集成、自动化部署等流程。目的就是小步迭代，快速交付。 持续集成： 这一部分并非是微服务特定的，对于之前的单体应用，此部分一般来说也是必要的。 主要是指通过自动化手段，持续地对代码进程编译构建、自动化测试，以得到快速有效的质量反馈，从而保证代码的顺利交付。 自动化测试包括代码级别的单元测试、单个系统的集成测试、系统间的接口测试。 自动化部署： 微服务架构，节点数动辄上百上千，自动化部署能够提高部署速度和部署频率，从而保证持续交付。 包括版本管理、资源管理、部署操作、回滚操作等功能。而对于微服务的部署方式，包括蓝绿部署、滚动部署以及金丝雀部署。 ④进一步提升运维效率 服务监控： 微服务架构下节点数目众多，需要监控的机器、网络、进程、接口等的数量大大增加，需要一个强大的监控系统，能够提供实时搜集信息进行分析以及实时分析之上的预警。 包括监控服务的请求次数、响应时间分布、最大/最小响应值、错误码分布等。 服务跟踪： 跟踪一个请求的完整路径，包括请求发起时间、响应时间、响应码、请求参数、返回结果等信息，也叫做全链路跟踪。 通常的服务可以和服务监控做在一起，宏观信息由服务跟踪呈现，微观单个服务/节点的信息由服务监控呈现。服务跟踪目前的实现理论基本都是 Google 的 Dapper 论文。 服务安全： 内网之间的微服务调用原则上讲应该是都可以互相访问写，一般并不需要权限控制，但有时候限于业务要求，会对接口、数据等方面有安全控制的要求。 此部分可以以配置的方式存在于服务注册中心中，和服务绑定，在请求时由做为服务提供者的服务节点进行安全策略控制。配置则可以存储在配置中心以方便动态修改。 在微服务数量很少的情况下，以上基础设施的优先级自上而下降低。否则，仅仅依赖人工操作，则投入产出比会很低。 还需要提到的是 Docker 容器技术。虽然这个对于微服务并不是必须的，但是容器技术轻量级、灵活、与应用依存、屏蔽环境差异的特性对于持续交付的实现是至关重要的，即使对于传统的单体应用也能够给其带来交付效率的大幅提升。 架构设计模式 在引入微服务之后，传统的单体应用变为了一个一个服务，之前一个应用直接提供接口给客户端访问的架构不再适用。 微服务架构下，针对不同设备的接口做为 BFF 层（Backend For Frontend），也叫做用户体验适配层，负责聚合、编排微服务的数据转换成前端需要的数据。 服务之间的调用则在允许的情况下（允许延迟）尽可能使用异步消息传递方式，如此形成面向用户体验的微服务架构设计模式。 如下图所示： Client→API Gateway→BFF（Backend For Frontend）→Downstream Microservices： 后台采用微服务架构，微服务可以采用不同的编程语言和不同的存储机制。 前台采用 BFF 模式对不同的用户体验（如桌面浏览器，Native App，平板响应式 Web）进行适配。 BFF、API Orchestration Layer，Edge Service Layer，Device Wrapper Layer 是相同的概念。 BFF 不能过多，过多会造成代码逻辑重复冗余。 可以将网关承担的功能，如 Geoip、限流、安全认证等跨横切面功能和 BFF 做在同一层，虽然增加了 BFF 层的复杂性，但能够得到性能优势。 服务拆分 微服务架构最核心的环节，主要是对服务的横向拆分。服务拆分就是将一个完整的业务系统解耦为服务，服务需要职责单一，之间没有耦合关系，能够独立开发和维护。 服务拆分不是一蹴而就的，需要在开发过程中不断地理清边界。在完全理清服务之前，尽量推迟对服务的拆分，尤其是对数据库的拆分。 拆分方法如下： 基于业务逻辑拆分 基于可扩展拆分 基于可靠性拆分 基于性能拆分 其中，对于无法修改的遗留系统，采用绞杀者模式：在遗留系统外面增加新的功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。 拆分过程需要遵守的规范如下： 先少后多、先粗后细（粒度） 服务纵向拆分最多三层，两次调用：Controller、组合服务、基础服务 仅仅单向调用，禁止循环调用 串行调用改为并行调用或者异步化 接口应该幂等 接口数据定义严禁内嵌，透传 规范化工程名 先拆分服务，等服务粒度确定后再拆分数据库。 微服务框架 上面讲述了微服务架构的众多基础设施，如果每一个基础设施都需要自己开发的话是非常巨大的开发工作。目前市面上已经有不少开源的微服务框架可以选择。 Spring Boot Spring Boot 是用来简化新 Spring 应用的初始搭建以及开发过程的。其虽然不是微服务框架，但其设计的初衷本质就是微应用的底层框架，因此非常适合用于微服务基础设施的开发以及微服务的应用开发。 尤其对于 Spring 技术栈的团队来说，基于 Spring Boot 开发微服务框架和应用是自然而然的一个选择。关注微信公众号：Java技术栈，在后台回复：boot，可以获取我整理的 N 篇最新 Spring Boot 教程，都是干货。 Dubbo&amp;Motan Dubbo 是阿里开源的服务治理框架。其出现在微服务理念兴起之前，可以看做是 SOA 框架的集大成之作。 但其仅仅包含了微服务基础设施的部分功能，诸如熔断、服务跟踪、网关等都没有实现： 服务发现： 服务发布、订阅、通知。 高可用策略： 失败重试（Failover）、快速失败（Failfast）、资源隔离 - 负载均衡 ：最少活跃连接、一致性 Hash、随机请求、轮询等。 扩展性 ： 支持 SPI 扩展（service provider interface）。 其他 ： 调用统计、访问日志等。 Motan 则是微博开源的类似 Dubbo 的 RPC 框架，与 Dubbo 相比更轻量级。 Spring Cloud Spring Cloud 是基于 Spring Boot 实现的微服务框架，也可以看做一套微服务实现规范。关注微信公众号：Java技术栈，在后台回复：cloud，可以获取我整理的 N 篇最新 Spring Cloud 教程，都是干货。 基本涵盖了微服务基础设施的方方面面，包括配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等。 其基于 Spring 生态，社区支持非常好。但其很多组件都没有经过生产环境验证，需要慎重选择。 Spring Cloud Netflix 是 Spring Cloud 的一个子项目，是 Spring 对 Netflix OSS 的集成实现。 基于 Netflix 的大规模使用，其中的已经被广泛使用的组件包括： Eureka： 服务注册和服务发现 Ribbon： 弹性而智能的进程间和服务通讯机制，客户端负载均衡 Hystrix： 熔断器，在运行时提供延迟和容错的隔离 Zuul： 服务网关 此外，另一个子项目 Spring Cloud Alibaba 则是 Alibaba 开源的基于 Spring Boot 的微服务框架，主要是对阿里云服务的支持。 Service Mesh 上述的微服务框架都是侵入式的，服务化的过程都需要进行代码改造。Service Mesh 则是下一代微服务架构，最明显的特征就是无入侵。采用 Sidecar 模式来解决系统架构微服务化后的服务间通信和治理问题。 如下图所示： 目前主流的开源实现包括： Linkerd 和 Envoy： 以 Sidecar 为核心，关注如何做好 Proxy，并完成一些通用控制平面的功能。缺乏对这些 Sidecar 的管理和控制。 Istio 和 Conduit： 目前最为流行的 Service Mesh 实现方案，集中在更加强大的控制平面(Sidecar 被称为数据平面)功能。 前者由 Google 和 IBM 合作，并使用了 Envoy 作为 Sidecar 部分的实现；后者则是 Linkerd 作者的作品。 相比起来，Istio 有巨头背景，功能强大，但可用性和易用性一直不高，Conduit 则相对简单、功能聚焦。 限于 Service Mesh 带来的性能延迟的开销以及 Sidecar 对分布复杂性的增加，其对大规模部署(微服务数目多)、异构复杂(交互协议/开发语言类型多)的微服务架构带来的收益会更大。 Sofastack 蚂蚁金服开源的构建金融级分布式架构的一套中间件。包括微服务开发框架、RPC 框架、服务注册中心、全链路追踪、服务监控、Service Mesh 等一整套分布式应用开发工具。 特别值得一提的是 SOFAMesh。其实对下一代微服务架构 Service Mesh 的大规模落地方案实践，基于 Istio 改进和扩展而来，应该是国内最为成熟的开源 Service Mesh 方案。 此外，需要提到 Kubernetes（K8s），其本身提供了部分的微服务特性支持（通过域名做服务发现），对代码无侵入。但服务调用、熔断这些都需要自己实现。 综上，目前公司技术团队技术栈是 Spring，并且已有服务的实现都是基于 Dubbo。 因此选择 Spring Cloud Netflix 做为基础的微服务框架，对其中不成熟或者缺乏的组件，选择业界更为成熟的组件替代即可： API 网关： Zuul。 服务注册中心： Dubbo。 配置中心： Disconf。 服务监控&amp;全链路追踪： CAT。 服务开发框架： Spring Boot。 日志监控、告警： ELK+Elasalert。 流量控制： Sentinel。 消息队列： Kafka。 ","link":"https://kangjn.github.io/post/wei-fu-wu-jie-shao/"},{"title":"微服务设计 10 大反模式和陷阱","content":"O’Reilly的电子书《Microservices AntiPatterns and Pitfalls》讲述了在微服务设计实现时十种最常见的反模式和陷阱。本文基于此书，将这十个点列出。 数据驱动迁移反模式（Data-Driven Migration） 如上图所示，此种反模式的问题在于微服务的粒度没有最终确定之前就做了数据迁移，如此当不断的调整服务粒度时，那么数据库就免不了频繁迁移，带来极大的成本。更好的方式如下图所示： 即先分离功能，数据库先保持之前的单体，等到服务粒度最终确定之后，再分离数据库。 超时反模式（The Timeout） 微服务架构是由一系列分离的服务组成的，这些服务之间通过一些远程协议进行互相之间的通信。其中牵扯到了服务的可用性和响应性问题。如下图所示： 可用性：服务消费方能够连接服务方，并可以向其发送请求。 响应性：服务方能够在消费方期望时间内给予请求响应。 为了防止服务的不可用和无法响应，通常的做法就是设置一个调用超时。此种做法表面上看是没问题的，但是试想一下如下情景：发起一个购买100个商品的请求，请求成功返回一个确认号。如果当请求超时但是请求在服务端已经成功执行了，此时这个交易实际是完成的，但是消费方没有拿到确认号，如果重试请求，那么服务方需要一个复杂的机制判断这是否一次重复提交。 一种解决此问题的方案是设置一个较长的超时时间，如一个服务的通常响应耗时需要2s，最大耗时需要5s，那么超时时间可以设置为10s。但这样的问题就是如果服务不可用，所有消费方都得等待10s，这个是非常损耗性能的。 解决超时反模式的方案就是使用“断路器模式”。就类似于房屋中的电源断路器，当断路器关闭，电流可以通过，当断路器打开，那么电流中断一直到断路器关闭。断路器模式就是说当检测到服务方无法响应时就打开，后续的请求都会被拒绝掉。一旦服务方可响应了，那么断路器关闭，恢复请求。其工作模式如下图所示： 断路器会持续地监测远程服务，确保其是可响应的。只要服务可响应，那么断路器会一直关闭，允许请求通过。如果服务突然不可响应，那么断路器打开，拒绝后续的请求。而后续如果断路器又检测到服务恢复了，那么断路器会自动关闭，请求也就恢复了。此种方案与超时时间相比，最大的优势就是一旦服务不可响应，那么断路器模式可以让请求立刻返回而不是需要等待一定的时间。 [Hystrix]的Netflix是此种断路器模式的一种开源实现。此外，Akka中也包含了一个断路器实现：Akka CircuitBreaker类。 共享反模式（“I Was Taught to Share”） 微服务被普遍认为是一种不共享任何东西的架构。但实际上只能是尽可能地少共享，毕竟在某些层面代码被多个服务共享也能带来一定好处。 例如，与单独部署一套安全服务（认证和授权）其他所有服务都通过远程访问此服务相比，把安全相关的功能封装成jar包（security.jar），然后其他服务都集成此jar包，就能够避免每次都要发起对安全服务的访问，从而提高性能和可靠性。但后面的方案带来的问题就是依赖噩梦：每一个服务都依赖多个自定义的jar包。如此不仅打破了服务之间的边界上下文，同时也引入了诸如总体可靠性、变更控制、易测试性、部署等问题。 在一个使用面向对象编程语言的单体应用中，使用abstract类和接口实现代码复用和共享是一个良好的实践。但当从单体切换到微服务架构时，对于很多自定义的共享类和工具类（日期、字符串、计算）的处理要考虑到微服务间共享的东西越少越有利于保持服务间的边界上下文，从而更利于快速测试和部署。以下是几种推荐的方式，也是解决“共享反模式”的方案： 共享项目 将共享的代码作为一个项目在编译期与各个服务集成。此种方式便于变更和开发软件，但是最大的问题在于很难发觉哪一个共享模块被修改以及修改的原因，也无法确定自己的服务是否需要这些变更。尤其是在服务发布前期发现某一个共享模块发生了变动的话需要再一次的测试才能走后续流程。 共享库 此种方式即将共享的代码作为类库集成到服务中。如此每次共享的库有改动，服务都需要重新打包、测试、重启。但相比起第一种，其有版本标记，能够更好地控制服务的部署和开发，服务开发者可以自己控制何时将共享库的改动集成进来。 更进一步的，如果采用此种方案，一定要避免把所有共享的代码都打包进一个jar包中如common.jar。否则会很难确定何时要把库的变动集成到服务中。更好的做法是将共享代码分成几个单独上下文的库，如：security.jar、dateutils.jar、persistence.jar等，如此会比较容易的确定何时去集成共享库的变动。 冗余 此种方案违反DRY原则，在每一服务中都冗余一份共享代码，能够避免依赖共享也能够保持边界上下文。但是一旦共享的代码有变动，那么所有服务都需要改动。因此，此种方案适用于共享模块非常稳定，极小可能变动的情况。 服务合并 当多个服务共享的代码变动比较频繁时可以采用此种方案合并成一个服务，如此就避免了多了服务频繁的测试和部署，也避免了依赖共享库。 可达性报告反模式（Reach-in Reporting） 微服务中各个服务以及其相应的数据都是包含在一个单独的边界上下文中的，也就是说数据是隔离到多个数据库中的。因此，这也会使得收集微服务的各种数据生成报告变得相对困难。一般来说有四种方案解决这个问题。其中，前三种都是从各个微服务中拉取数据，是这里所说的反模式，被称作“Reach-in Reporting”。 数据库拉取模式 报告服务直接从各个服务的数据库中拉取数据从而生成各种报告。此种方式简单迅速，但是会让报告服务和业务服务相互依赖，是一种数据库共享集成风格（通过共享的数据库将多个应用耦合在一起）。如此一旦数据库有改动，所有相关服务都要改动，也就打破了微服务中极为重要的边界上下文。 HTTP拉取模式 与数据库拉取模式相比，此种方式不再是直接去访问服务的数据库，而是通过HTTP接口去请求服务的数据。此种方式能够保持服务的边界上下文，但是性能比较慢，而且HTTP请求无法很好的承载大数据。 批量拉取模式 此种方式会有一个单独的报告数据库/数据仓库来存储各个服务的聚合数据。会通过一个批量任务（离线或者基于增量实时）将服务更新的数据导入到报告数据库/数据仓库中。与数据库拉取模式一样，此种方式这也是一种数据库共享集成风格，会打破服务的边界上下文。 异步事件推送模式 此种方式即解决“Reach-in Reporting”反模式的方案。每个服务都把自己的发生的事件异步推送到一个数据捕获服务，后续数据捕获服务会将数据解析存储到报告数据库中。此种方式实现起来较复杂，需要在服务和数据捕获服务之间制定一种协议用于异步传输事件数据。但其能够保持服务的边界上下文，同时也能保证数据的时效性。 沙粒陷阱（Grains of Sand） 微服务实现中最有挑战的问题在于如何拆分service，如何控制服务的粒度，而正确的服务粒度则决定了微服务是否能够成功实现。服务粒度也能够影响到性能、健壮性、可靠性、易测试性、部署等。 “沙粒陷阱”即把服务拆分的太细。其中的一个原因就是很多时候开发者会把一个class与一个服务等同。合理的，应该是一个服务组件（Service component）对应一个服务。一个服务组件具有清晰、简洁的角色、职责，具有一组定义好的操作。其一般通过多个模块（Java Class）实现。如果组件和模块是一对一的关系，那么不仅仅会造成服务粒度过细同时也是一种不好的编程实践：服务的实现都是通过一个Class，那么此Class会非常大并且承担太多的责任，不利于测试和维护。 更进一步的，服务的粒度并不应该受其中实现类的数目影响：有些服务可能只需要一个类就可以实现，而有些服务会需要多个类来实现。 为了避免“沙粒陷阱”，可以通过以下三种测试来判断服务粒度是否合理： 分析服务范围和功能 要明确服务用来干什么？有哪些操作？一般通过使用文档或者语言来描述服务的范围和功能就能够看出来服务是否做的工作太多。如果在描述中使用了“和”（“and”）或者“此外”（“in addition”）之类的词，很有可能就是此服务职责太多。 服务的高内聚是一种良好的实践，其明确一个服务提供的操作之间必须要是有关联的。如对于一个顾客服务，有以下操作： 添加顾客 更新顾客信息 获取顾客信息 通知顾客 记录顾客评论 获取顾客评论 其中的前三个操作都是对顾客的CRUD操作，是相关联的。而后三者则无关。为了实现服务的高内聚，合理的应该是把此服务拆分成三个服务：顾客维护、顾客通知、顾客评论。 如此，以粗粒度的服务开始，然后逐渐拆分成细粒度的服务有利于对微服务的拆分。 分析数据库事务 传统的关系型数据库都提供了ACID事务特性用于把多个更新操作打包成一个整体提交，要么都成功，要么都失败。而在微服务中，由于服务都是一个个分离的应用，很难实现ACID，一般实现BASE事务（basic availability、soft state、eventual consistence）即可。但是无法避免的，仍然会有一些场景是需要ACID的。因此，当你不断的需要在BASE和ACID事务做判断和取舍的时候，很有可能就是服务粒度过细。 如果业务场景无法接受最终一致性，那么最好就是将服务粒度粗化一些，把多个更新操作放到一个服务中。 分析服务编排 这里主要说的是服务之间的互相通信。由于对服务的调用都是一次远程调用，因此服务编排会非常大的影响微应用总体的性能。此外，它也会影响系统整体的健壮性和可靠性，越多的远程调用，那么越高的几率会有失败或者超时的请求出现。 如果发现完成一次业务逻辑需要调用太多的远程服务，就说明服务的粒度可能太细了。这时候就需要将服务粗化。而合并细粒度服务还能够提高性能，提升总体的健壮性和可靠性。同时也减少了多个服务间的依赖，更利于测试和部署。 此外，使用响应式编程技术异步并行调用远程服务也是一种提升性能和可靠性的方案。 无因的开发者陷阱（Developer Without a Cause） 此陷阱主要讲的是开发者或者架构师在做设计时很多时候是拍脑袋在做，没有任何合理的原因或者原因是错误的，也不会做取舍。而想要解决此问题，不仅仅是架构师，开发者也需要同时了解技术带来的好处以及缺陷，从中做权衡。 了解业务驱动是避免此陷阱的关键一步。每一个开发者和架构师都应该清楚的了解下面这些问题的答案： 为什么要使用微服务？ 最重要的业务驱动是什么？ 架构中的哪一点是最为重要的？ 假如易部署性、性能、健壮性、可扩展性是系统最看重的特性，那么对于不同的业务侧重点，微服务的粒度需求也是不同的。细粒度的服务能够达到更好的易测试性和易部署性，而粗粒度的服务则有更好的性能、健壮性以及可靠性。 追随流行陷阱（Jump on the Bandwagon） 微服务是目前非常流行的架构理念，越来越多的公司也都在紧跟这个潮流纷纷转型微服务架构，而不管到底自己是否真的需要。为了避免此陷阱，需要首先了解微服务的优点和缺点。 优点： 易部署：容易部署是微服务的一个很大的优点。毕竟相比起一个庞大的单体应用，一个小并且职责单一的微服务的部署非常简单并且带来的风险也会小很多。而持续部署技术则进一步放大了这个优点。 易测试：职责单一、共享依赖少使得测试一个微服务是很容易的。而基于微服务做回归测试与单体大应用相比也是很容易的。 控制变更：每个服务的范围和边界上下文使得很容易控制服务的功能变动。 模块化：微服务就是一个高度模块化的架构风格。这种风格也是一种敏捷方式的表达，能够很快的响应变化。一个系统模块化程度越高，就越容易测试、部署和发布变更。一个服务粒度划分合理的微服务系统是所有架构中模块化程度最高的架构形式。 可扩展性：由于每一个服务都是一个职责单一的细粒度服务，因此此种架构风格是所有架构分隔中可扩展性最高的。其非常容易扩展某一个或者某几个功能从而满足整体系统的需求。而得益于服务的容器化特性以及各种运维监控工具，服务也能够自动化进行启动和关闭。 缺点： 组织变动：微服务需要组织在很多层面进行变动。研发团队需要包含UI、后端开发、规则处理、数据库处理建模等多种职位，从而使得一个小的团队能够具有实现微服务的所有技术栈。同时，传统的单体、分层应用架构的软件发布流程也需要更新为自动化、高效的部署流水线。 性能：由于服务都是隔离的，因此发起对服务的远程调用肯定是会影响性能的。服务编排、运行环境都是影响性能的很大因素。了解远程调用的延迟、需要与多少服务通信都是与性能相关的需要掌握的信息。 可靠性：和性能一样。服务的远程调用越多，那么失败的几率就越高，总体的可靠性就会越低。 DevOps：随着微服务架构而来的是成千上百的服务。手动管理这么多的服务是很不现实的。这就对于自动化运维部署、协作提出了很高的挑战。需要依赖非常多的操作工具和实践，是一个非常复杂的工作。目前差不多有12种类型的操作工具（监控工具、服务注册、发现工具、部署工具等）和框架在微服务架构中被使用，其中每一种又包含了很多具体的工具和产品供选择。对于这些工具和框架的选择一般都会需要将近数月的研究、测试、权衡分析才能做出最适合的技术选型。 了解了微服务的优缺点后，下一步则需要根据实际的业务来分析微服务是不是解决这些问题的最佳方案。可以采取以下问题： 业务和技术的目标是什么？ 使用微服务是为了完成什么？ 目前和可预知的痛点是什么？ 应用的最关键的技术特性是什么？（性能、易部署性、易测试性、可扩展性） 回答这些问题再结合微服务的优缺点能够让你明确现在是否是使用微服务的适当时机。 除了微服务以外，还有其他7种比较普遍使用的架构供选择： 基于服务的架构（Service-Based） 面向服务的架构（Service-Oriented） 分层架构（Layered） 微内核架构（Microkernel） 基于空间的架构（Space-Based） 事件驱动架构（Event-Driven） 流水线架构（Pipeline） 静态合约陷阱（The Static Contract） 微服务的消费方和服务提供方之间会有一个合约/协议用来规定输入输出数据的格式、操作名称等等。一般情况下这个合约是不变的。但是如果没有使用版本号来管理服务接口，那么就会进入“静态合约”陷阱。 给合约打上版本标记不仅仅能够避免巨大的变动（服务提供方修改合约使得所有消费方也都得修改），还能够提供向后兼容性。这里有两种技术可以实现合约的版本号： 在头部信息附加版本号 此种方式即在远程访问协议的头部添加版本信息。而如果远程协议使用的是REST，那么还可以使用vendor mime type（vnd）来指定合约的版本号。如下： POST /trade/buy Accept: application/vnd.svc.trade.v2+json 服务接受到请求，能够通过正则等手段简单解析出其中的合约版本号再根据版本号做相应的处理。 如果使用消息队列，那么可以将版本号放置在属性部分(Property section)。JMS的一个例子如下： String msg = createJSON(&quot;acct&quot;,&quot;12345&quot;,&quot;sedol&quot;,&quot;2046251&quot;,&quot;shares&quot;,&quot;1000&quot;); jsmContext.createProducer() .setProperty(&quot;version&quot;,2) .send(queue,msg); 在合约本身中附加版本号 此种方式版本号独立于远程访问协议，与头部信息版本号相比，这也是其最大的优点。但与此同时，其缺点比较多。首先要从请求信息主体中解析版本号，会出现很多解析的问题。其次，合约的模式可能会非常复杂，使得很难做数据转换。最后，服务还要引入对模式的验证逻辑。 我们到了吗陷阱（Are We There Yet） 微服务架构中，各个服务都是独立的个体，也就意味着所有客户端或者API层和服务之间的通信都是一次远程调用。如果对这些远程调用的耗时没有什么概念，那么就陷入了“Are We There Yet”陷阱。合理的做法需要去测试远程访问的平均延迟、长尾延迟（95%、99%、99.%之外的请求延迟）等指标。而很多时候即使有很好的平均延迟，但是较差的长尾延迟会造成非常大的破坏。 在生产环境或者准生产环境测试有助于去了解应用的真实性能。例如，一个业务请求需要调用四个服务，假设一个服务调用的延迟是100毫秒，那么加上业务请求本身的延迟，完成此次业务请求共需要500毫秒的延迟。这和单单从代码上去看得出的结论是不一样的。 了解目前所用协议的平均延迟是一方面，另一方面则需要对比其他远程协议的延迟，从而在合适的地方使用合适的协议。如：JMS、AMQP、MSMQ。 AMQP协议的性能是最好的。那么结合业务场景，就可以选择REST作为客户端与服务间的通信协议，AMQP做为服务之间的通信协议以提高应用的性能。 当然，性能并非在选择远程协议时唯一考虑的因素。下一节中就会考虑利用消息队列的一些额外功能。 REST使用陷阱（Give It a Rest） REST现在是微服务中用的最多的通信协议。流行的开发框架如DropWizard、Spring Boot都提供了REST支持。但是如果只选择REST这一种协议，不去考虑其他诸如消息队列的优势，那么就陷入了“REST使用”陷阱。毕竟异步通信、广播、合并请求事务这些需求，REST是很难实现的。 消息队列标准目前包括平台特定和平台无关两种。前者包括Java平台中的JMS和C#平台的MSMQ，后者则是AMQP。对于平台特定的消息标准JMS，其规范了API，因此切换broker实现（ActiveMQ、HornetQ）时无需修改API，但由于底层通信协议是不同的，集成的客户端或者服务端jar包需要随着修改。 对于平台无关的消息标准，其规范了协议实现标准，并没有规范API。使得不同平台之间都可以互相通信，而不管实际产品是什么。如一个使用了RabbitMQ的客户端可以很容易地与一个StormMQ通信（假设使用的协议相同）。也就是其独立于平台的特性使得RabbitMQ成为微服务架构中最流行的消息队列。 异步请求 异步通信是消息队列适用的场景之一。服务消费者发起请求后无需等待服务方响应能够提高总体的性能，同时调用方无需担心调用超时，也就无需使用断路器，从而提高了系统的可靠性。 广播 将消息广播给多个service是消息队列的又一个适用场景。一个消息生产者向多个消息接受者发送消息，无需知道谁在接受消息以及如何处理它。 事务请求 消息系统提供了对事务消息的支持：如果多个消息被发送到了在一个交易上下文的多个队列或者主题中时，那么直到消息发送者commit，服务才会真正的接受到相应的所有消息（在commit之前会一直保存在队列中）。 因此对于服务消费者需要合并多个远程请求到一个事务中的场景可以选择事务消息。 ","link":"https://kangjn.github.io/post/wei-fu-wu-she-ji-10-da-fan-mo-shi-he-xian-jing/"},{"title":"Java 多线程","content":"线程 线程的概念，百度是这样解释的： 线程（英语：Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（Lightweight Processes），但轻量进程更多指内核线程（Kernel Thread），而把用户线程（User Thread）称为线程。 1.1 线程与进程的区别 进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。 线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。 也就是，进程可以包含多个线程，而线程是程序执行的最小单位。 1.2 线程的状态 NEW：线程刚创建 RUNNABLE: 在JVM中正在运行的线程，其中运行状态可以有运行中RUNNING和READY两种状态，由系统调度进行状态改变。 BLOCKED：线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行 WAITING : 等待状态 TIMED_WAITING: 调用sleep() join() wait()方法可能导致线程处于等待状态 TERMINATED: 线程执行完毕，已经退出 1.3 Notify和Wait ： Notify和Wait 的作用 首先看源码给出的解释，这里翻译了一下： Notify：唤醒一个正在等待这个对象的线程监控。如果有任何线程正在等待这个对象，那么它们中的一个被选择被唤醒。选择是任意的，发生在执行的酌情权。一个线程等待一个对象通过调用一个{@code wait}方法进行监视。 Notify()需要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁 Wait：导致当前线程等待，直到另一个线程调用{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法。 换句话说，这个方法的行为就像它简单一样执行调用{@code wait(0)}。当前线程必须拥有该对象的监视器。 线程释放此监视器的所有权，并等待另一个线程通知等待该对象的监视器的线程，唤醒通过调用{@code notify}方法或{@code notifyAll}方法。然后线程等待，直到它可以重新取得监视器的所有权，然后继续执行。 Wait()的作用是使当前执行代码的线程进行等待，它是Object类的方法，该方法用来将当前线程置入预执行队列中，并且在Wait所在的代码行处停止执行，直到接到通知或被中断为止。 在调用Wait方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用Wait方法。 Wait和Sleep的区别： 它们最大本质的区别是，Sleep()不释放同步锁，Wait()释放同步锁。 还有用法的上的不同是：Sleep(milliseconds)可以用时间指定来使他自动醒过来，如果时间不到你只能调用Interreput()来强行打断；Wait()可以用Notify()直接唤起。 这两个方法来自不同的类分别是Thread和Object 最主要是Sleep方法没有释放锁，而Wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 1.4 Thread.sleep() 和Thread.yield()的异同 相同 ：Sleep()和yield()都会释放CPU。 不同：Sleep()使当前线程进入停滞状态，所以执行Sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。Sleep()可使优先级低的线程得到执行的机会，当然也可以让同优先级和高优先级的线程有执行的机会；yield()只能使同优先级的线程有执行的机会。 1.5 补充：死锁的概念 死锁：指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 死锁产生的四个必要条件（缺一不可）： 互斥条件：顾名思义，线程对资源的访问是排他性，当该线程释放资源后下一线程才可进行占用。 请求和保持：简单来说就是自己拿的不放手又等待新的资源到手。线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。 不可剥夺：在没有使用完资源时，其他线性不能进行剥夺。 循环等待：一直等待对方线程释放资源。 我们可以根据死锁的四个必要条件破坏死锁的形成。 1.6 补充：并发和并行的区别 并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。在一个时间段的线程代码运行时，其它线程处于挂起状。 并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，CPU同时处理这些线程请求的能力。 区别就在于CPU是否能同时处理所有任务，并发不能，并行能。 1.7 补充：线程安全三要素 原子性：Atomic包、CAS算法、Synchronized、Lock。 可见性：Synchronized、Volatile（不能保证原子性）。 有序性：Happens-before规则。 1.8 补充：如何实现线程安全 互斥同步：Synchronized、Lock。 非阻塞同步：CAS。 无需同步的方案：如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性。 1.9 补充：保证线程安全的机制： [Synchronized]关键字 [Lock] [CAS]、原子变量 [ThreadLocal]：简单来说就是让每个线程，对同一个变量，都有自己的独有副本，每个线程实际访问的对象都是自己的，自然也就不存在线程安全问题了。 [Volatile] [CopyOnWrite]写时复制 随着CPU核心的增多以及互联网迅速发展，单线程的程序处理速度越来越跟不上发展速度和大数据量的增长速度，多线程应运而生，充分利用CPU资源的同时，极大提高了程序处理速度。 创建线程的方法 继承Thread类： public class ThreadCreateTest { public static void main(String\\[\\] args) { new MyThread().start(); } } class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;\\\\t&quot; + Thread.currentThread().getId()); } } 实现Runable接口： public class RunableCreateTest { public static void main(String\\[\\] args) { MyRunnable runnable = new MyRunnable(); new Thread(runnable).start(); } } class MyRunnable implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;\\\\t&quot; + Thread.currentThread().getId()); } } 通过Callable和Future创建线程： public class CallableCreateTest { public static void main(String [] args) throws Exception { // 将Callable包装成FutureTask，FutureTask也是一种Runnable MyCallable callable = new MyCallable(); FutureTask futureTask = new FutureTask&lt;&gt;(callable); new Thread(futureTask).start(); // get方法会阻塞调用的线程 Integer sum = futureTask.get(); System.out.println(Thread.currentThread().getName() + Thread.currentThread().getId() + &quot;=&quot; + sum); } } class MyCallable implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { System.out.println(Thread.currentThread().getName() + &quot;\\\\t&quot; + Thread.currentThread().getId() + &quot;\\\\t&quot; + new Date() + &quot; \\\\tstarting...&quot;); int sum = 0; for (int i = 0; i &lt;= 100000; i++) { sum += i; } Thread.sleep(5000); System.out.println(Thread.currentThread().getName() + &quot;\\\\t&quot; + Thread.currentThread().getId() + &quot;\\\\t&quot; + new Date() + &quot; \\\\tover...&quot;); return sum; } } 线程池方式创建： 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承，但可以多实现啊），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 2.1 线程池创建线程 线程池，顾名思义，线程存放的地方。和数据库连接池一样，存在的目的就是为了较少系统开销，主要由以下几个特点： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗（主要）。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。 Java提供四种线程池创建方式： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。 通过源码我们得知ThreadPoolExecutor继承自AbstractExecutorService，而AbstractExecutorService实现了ExecutorService。 public class ThreadPoolExecutor extends AbstractExecutorService public abstract class AbstractExecutorService implements ExecutorService 2.2 ThreadPoolExecutor介绍 实际项目中，用的最多的就是ThreadPoolExecutor这个类，而《阿里巴巴Java开发手册》中强制线程池不允许使用Executors去创建，而是通过New ThreadPoolExecutor实例的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 我们从ThreadPoolExecutor入手多线程创建方式，先看一下线程池创建的最全参数。 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 参数说明如下： corePoolSize：线程池的核心线程数，即便线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。 maximumPoolSize：最大线程数，不管提交多少任务，线程池里最多工作线程数就是maximumPoolSize。 keepAliveTime：线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。 Unit：这个用来指定keepAliveTime的单位，比如秒：TimeUnit.SECONDS。 BlockingQueue：一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。 handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。 2.2.1BlockingQueue 对于BlockingQueue个人感觉还需要单独拿出来说一下。 BlockingQueue：阻塞队列，有先进先出（注重公平性）和先进后出（注重时效性）两种，常见的有两种阻塞队列：ArrayBlockingQueue和LinkedBlockingQueue 队列的数据结构大致如图： 队列一端进入，一端输出。而当队列满时，阻塞。BlockingQueue核心方法：1. 放入数据put2. 获取数据take。常见的两种Queue： 2.2.2 ArrayBlockingQueue 基于数组实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。 一段代码来验证一下： package map; import java.util.concurrent.*; public class MyTestMap { // 定义阻塞队列大小 private static final int maxSize = 5; public static void main(String\\[\\] args){ ArrayBlockingQueue queue = new ArrayBlockingQueue(maxSize); new Thread(new Productor(queue)).start(); new Thread(new Customer(queue)).start(); } } class Customer implements Runnable { private BlockingQueue queue; Customer(BlockingQueue queue) { this.queue = queue; } @Override public void run() { this.cusume(); } private void cusume() { while (true) { try { int count = (int) queue.take(); System.out.println(&quot;customer正在消费第&quot; + count + &quot;个商品===&quot;); // 只是为了方便观察输出结果 Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Productor implements Runnable { private BlockingQueue queue; private int count = 1; Productor(BlockingQueue queue) { this.queue = queue; } @Override public void run() { this.product(); } private void product() { while (true) { try { queue.put(count); System.out.println(&quot;生产者正在生产第&quot; + count + &quot;个商品&quot;); count++; } catch (InterruptedException e) { e.printStackTrace(); } } } } 输出如下： 生产者正在生产第1个商品 生产者正在生产第2个商品 生产者正在生产第3个商品 生产者正在生产第4个商品 生产者正在生产第5个商品 customer正在消费第1个商品=== 2.2.3 LinkedBlockingQueue 基于链表的阻塞队列，内部也维护了一个数据缓冲队列。需要我们注意的是如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小。 LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。 2.2.4 LinkedBlockingQueue和ArrayBlockingQueue的主要区别 ArrayBlockingQueue的初始化必须传入队列大小，LinkedBlockingQueue则可以不传入。 ArrayBlockingQueue用一把锁控制并发，LinkedBlockingQueue俩把锁控制并发，锁的细粒度更细。即前者生产者消费者进出都是一把锁，后者生产者生产进入是一把锁，消费者消费是另一把锁。 ArrayBlockingQueue采用数组的方式存取，LinkedBlockingQueue用Node链表方式存取。 2.2.5handler拒绝策略 Java提供了4种丢弃处理的方法，当然你也可以自己实现，主要是要实现接口：RejectedExecutionHandler中的方法。 AbortPolicy：不处理，直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务，即提交任务的线程。 DiscardOldestPolicy：LRU策略，丢弃队列里最近最久不使用的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉，不抛出异常。 2.2.6线程池五种状态 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; RUNNING：在这个状态的线程池能判断接受新提交的任务，并且也能处理阻塞队列中的任务。 SHUTDOWN：处于关闭的状态，该线程池不能接受新提交的任务，但是可以处理阻塞队列中已经保存的任务，在线程处于RUNNING状态，调用shutdown()方法能切换为该状态。 STOP：线程池处于该状态时既不能接受新的任务也不能处理阻塞队列中的任务，并且能中断现在线程中的任务。当线程处于RUNNING和SHUTDOWN状态，调用shutdownNow()方法就可以使线程变为该状态。 TIDYING：在SHUTDOWN状态下阻塞队列为空，且线程中的工作线程数量为0就会进入该状态，当在STOP状态下时，只要线程中的工作线程数量为0就会进入该状态。 TERMINATED：在TIDYING状态下调用terminated()方法就会进入该状态。可以认为该状态是最终的终止状态。 回到线程池创建ThreadPoolExecutor，我们了解了这些参数，再来看看ThreadPoolExecutor的内部工作原理： 判断核心线程是否已满，是进入队列，否：创建线程 判断等待队列是否已满，是：查看线程池是否已满，否：进入等待队列 查看线程池是否已满，是：拒绝，否创建线程 2.3深入理解ThreadPoolExecutor 进入Execute方法可以看到： public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); //判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务 if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } //如果不小于corePoolSize，则将任务添加到workQueue队列。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } //如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。 else if (!addWorker(command, false)) reject(command); } AddWorker方法： 创建Worker对象，同时也会实例化一个Thread对象。在创建Worker时会调用threadFactory来创建一个线程。 然后启动这个线程。 2.3.1线程池中CTL属性的作用是什么？ CTL属性包含两个概念： private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int ctlOf(int rs, int wc) { return rs | wc; } runState：即rs 表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying。 workerCount：即wc表明当前有效的线程数。 我们点击workerCount即工作状态记录值，以RUNNING为例，RUNNING = -1 &lt;&lt; COUNT_BITS;，即-1无符号左移COUNT_BITS位，进一步我们得知COUNT_BITS位29，因为Integer位数为31位（2的五次方减一） private static final int COUNT_BITS = Integer.SIZE - 3; 既然是29位那么就是Running的值为： 1110 0000 0000 0000 0000 0000 0000 0000 ||| 31~29位 那低28位呢，就是记录当前线程的总线数啦： // Packing and unpacking ctl private static int runStateOf(int c) { return c &amp; ~CAPACITY; } private static int workerCountOf(int c) { return c &amp; CAPACITY; } private static int ctlOf(int rs, int wc) { return rs | wc; } 从上述代码可以看到workerCountOf这个函数传入ctl之后，是通过CTL&amp;CAPACITY操作来获取当前运行线程总数的。 也就是RunningState|WorkCount&amp;CAPACITY，算出来的就是低28位的值。因为CAPACITY得到的就是高3位（29-31位）位0，低28位（0-28位）都是1，所以得到的就是ctl中低28位的值。 而runStateOf这个方法的话，算的就是RunningState|WorkCount&amp;CAPACITY，高3位的值，因为CAPACITY是CAPACITY的取反，所以得到的就是高3位（29-31位）为1，低28位（0-28位）为0，所以通过&amp;运算后，所得到的值就是高3为的值。 简单来说就是ctl中是高3位作为状态值，低28位作为线程总数值来进行存储。 2.3.2 shutdownNow和shutdown的区别 看源码发现有两种近乎一样的方法，shutdownNow和shutdown，设计者这么设计自然是有它的道理，那么这两个方法的区别在哪呢？ shutdown会把线程池的状态改为SHUTDOWN，而shutdownNow把当前线程池状态改为STOP。 shutdown只会中断所有空闲的线程，而shutdownNow会中断所有的线程。 shutdown返回方法为空，会将当前任务队列中的所有任务执行完毕；而shutdownNow把任务队列中的所有任务都取出来返回。 2.3.3 线程复用原理 final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 就是任务在并不只执行创建时指定的firstTask第一任务，还会从任务队列的中自己主动取任务执行，而且是有或者无时间限定的阻塞等待，以保证线程的存活。 默认的是不允许。 2.4 CountDownLatch和CyclicBarrier区别 countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次。 CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供Reset功能，可以多次使用。 3. 多线程间通信的几种方式 提及多线程又不得不提及多线程通信的机制。首先，要短信线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析： 题目：有两个线程A、B，A线程向一个集合里面依次添加元素”abc”字符串，一共添加十次，当添加到第五次的时候，希望B线程能够收到A线程的通知，然后B线程执行相关的业务操作。 3.1使用volatile关键字 package thread; /** * * @author hxz * @description 多线程测试类 * @version 1.0 * @data 2020年2月15日 上午9:10:09 */ public class MyThreadTest { public static void main(String\\[\\] args) throws Exception { notifyThreadWithVolatile(); } /** * 定义一个测试 */ private static volatile boolean flag = false; /** * 计算I++，当I==5时，通知线程B * @throws Exception */ private static void notifyThreadWithVolatile() throws Exception { Thread thc = new Thread(&quot;线程A&quot;){ @Override public void run() { for (int i = 0; i &lt; 10; i++) { if (i == 5) { flag = true; try { Thread.sleep(500L); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } break; } System.out.println(Thread.currentThread().getName() + &quot;====&quot; + i); } } }; Thread thd = new Thread(&quot;线程B&quot;) { @Override public void run() { while (true) { // 防止伪唤醒 所以使用了while while (flag) { System.out.println(Thread.currentThread().getName() + &quot;收到通知&quot;); System.out.println(&quot;do something&quot;); try { Thread.sleep(500L); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } return ; } } } }; thd.start(); Thread.sleep(1000L); thc.start(); } } 个人认为这是基本上最好的通信方式，因为A发出通知B能够立马接受并Do Something。 ","link":"https://kangjn.github.io/post/java-duo-xian-cheng/"},{"title":"使用Springboot+mockito进行单元测试","content":"​ 简介： ## SpringBoot应用测试 测试Springboot应用需要依赖一个非常重要的注解@SpringBootTest，这个注解会为测试用例构建Spring容器。@SpringBootTest注解修饰的测试用例默认不会启动web容器，如果需要启动web容器需要设置webEnvironment属性： * MOCK(默认)：会启动一个mock的web server，可以配合@AutoConfig SpringBoot应用测试 测试Springboot应用需要依赖一个非常重要的注解@SpringBootTest，这个注解会为测试用例构建Spring容器。@SpringBootTest注解修饰的测试用例默认不会启动web容器，如果需要启动web容器需要设置webEnvironment属性： MOCK(默认)：会启动一个mock的web server，可以配合@AutoConfigureMockMvc注解对web应用进行测试(后面会举例) RANDOM_PORT：创建ApplicationContext上下文，启动一个真实的Web容器，监听一个随机的端口。 DEFINED_PORT：创建ApplicationContext上下文，启动一个真实的Web容器，监听SpringBoot配置配置文件中指定的端口，默认是8080端口。 NONE：只是启动ApplicationContext，不会启动任何(Mock或者非Mock)web容器。 如果是使用Junit来进行单元测试，再增加一个@RunWith(SpringRunner.class)或者@RunWith(SpringJUnit4ClassRunner.class)注解。 利用模拟Web容器来测试Restful接口 当测试用例使用@SpringBootTest注解修饰并将webEnvironment属性设置MOCK之后，测试用例在执行的过程中，就会创建一个模拟的web容器。为了让测试用例能够访问这个模拟的web容器，还需要增加@AutoConfigureMockMvc注解，这样就可以把MockMvc对象利用@Autowired注解注入到测试用例的属性中。MockMvc类的作用就是可以访问模拟的Web容器。接下来我们看一下使用MockMvc配合MockMvcRequestBuilders及MockMvcResultMatchers来访问模拟的Web容器进行测试Rest接口的例子： GET请求 @Test public void testCase() throws Exception { MvcResult result = mvc.perform(MockMvcRequestBuilders.get(&quot;/testQueryData.json?id=6&quot;)) .andExpect( MockMvcResultMatchers.status().isOk()).andReturn(); Assert.assertNotNull(result.getResponse().getContentAsString()); } POST请求提交表单 @Test public void testCase() throws Exception { UrlEncodedFormEntity formData = new UrlEncodedFormEntity(Arrays.asList( new BasicNameValuePair(&quot;param1&quot;, &quot;xxxxxxx&quot;), new BasicNameValuePair(&quot;param2&quot;, &quot;xxxxxxx&quot;) ), &quot;utf-8&quot;); MvcResult result = mvc.perform(MockMvcRequestBuilders.post(&quot;/testPostData.json&quot;) .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE) .content(EntityUtils.toString(formData))).andExpect(MockMvcResultMatchers.status().isOk()).andReturn(); Assert.assertNotNull(result.getResponse().getContentAsString()); } DELETE请求 @Test public void testCase() throws Exception { mvc.perform(MockMvcRequestBuilders.delete(&quot;/testDeleteData.json?id=1&quot;)) .andExpect( MockMvcResultMatchers.status().isOk()); } PUT请求类似POST @Test public void testCase() throws Exception { MvcResult result = mvc.perform(MockMvcRequestBuilders.put(&quot;/testPutData&quot;)) .andExpect( MockMvcResultMatchers.status().isOk()).andReturn(); Assert.assertNotNull(result.getResponse().getContentAsString()); } 利用TestRestTemplate测试真实的Restful接口 Springboot提供了专门用来测试Restful接口的工具类TestRestTemplate，这个类对RestTemplate进行了封装，可以让用户很快捷的编写出http客户端测试代码。 实例如下： GET请求 public void testCase() throws Exception { String restUrl = &quot;http://localhost:8080/xxxxx/xxxxx.json?id=xxx&quot;; ResponseEntity&lt;RegcoreResp&gt; response = testRestTemplate.getForEntity(restUrl, RegcoreResp.class); //RegcoreResp是用户自行定义的返回的数据封装Bean， System.out.println(response.getBody()); } POST请求并采用表单方式提交数据 public void testCase() throws Exception { String restUrl = &quot;http://localhost:8080/xxxxx/xxxxx.json&quot;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;String, String&gt;(); params.add(&quot;name&quot;, &quot;testName&quot;); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(params, headers); ResponseEntity&lt;RegcoreResp&gt; response = testRestTemplate.postForEntity(restUrl, requestEntity, RegcoreResp.class); } POST请求并采用request Body方式传输数据 public void testCase() throws Exception { String restUrl = &quot;http://localhost:8080/xxxxx/xxxxx.json&quot;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String body = &quot;{\\&quot;id\\&quot;:\\&quot;xxxxxx\\&quot;,\\&quot;status\\&quot;:\\&quot;xxxxx\\&quot;}&quot;; HttpEntity&lt;String&gt; requestEntity = new HttpEntity&lt;String&gt;(body, headers); ResponseEntity&lt;BaseFacadeResp&gt; response = testRestTemplate.postForEntity(restUrl, requestEntity, BaseFacadeResp.class); } DELETE public void testCase() throws Exception { String restUrl = &quot;http://localhost:8080/xxxxx/xxxxx.json&quot;; testRestTemplate.delete(restUrl); //delete方法没有返回值 } PUT方式与POST类似 public void testCase() throws Exception { String restUrl = &quot;http://localhost:8080/xxxxx/xxxxx.json&quot;; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); String body = &quot;{\\&quot;id\\&quot;:\\&quot;xxxxxx\\&quot;,\\&quot;status\\&quot;:\\&quot;xxxxx\\&quot;}&quot;; HttpEntity&lt;String&gt; requestEntity = new HttpEntity&lt;String&gt;(body, headers); testRestTemplate.put(restUrl, requestEntity); //put方法没有返回值 } Mock与Spy Mock利用动态代理对一个接口或者类的所有方法进行模拟。 Spy同样利用动态代理，与Mock不同的是Spy针对于一个真实对象进行模拟并可以对被监控对象中某个方法进行打桩(stubed)控制该方法的执行情况，其他没有打桩的方法则按照对象本身的实际逻辑执行。 SpringBoot对Mock Spy的支持 在测试SpringBoot应用过程中，某些环境依赖问题可能导致无法调用真实Bean逻辑，比如：某些外部依赖的接口没有准备好。这个时候需要使用Mock、Spy来对Bean进行模拟。SpringBoot提供了@MockBean和@SpyBean两个注解来实现Mock与Spy能力。由于底层还是使用Mockito，用法上与Mockito没有区别。 示例： @RunWith(SpringRunner.class) @SpringBootTest public class MyTests { @MockBean private RemoteService remoteService; @Autowired private Reverser reverser; @Test public void exampleTest() { // RemoteService has been injected into the reverser bean given(this.remoteService.someCall()).willReturn(&quot;mock&quot;); String reverse = reverser.reverseSomeCall(); assertThat(reverse).isEqualTo(&quot;kcom&quot;); } } 如何Mock方法模拟内部逻辑? 一般来说mock最典型的用法就是对一个方法的返回值(输出)进行模拟。如果想模拟方法内部逻辑，比如方法对入参进行修改或者对入参对象的某个方法进行回调如何利用mock来实现呢？ 下面举一个实际的场景，比如有这样一段被测试代码： testDOMapper.insert(testBeanDO); if(testBeanDO.getId()==null) { throw new RuntimeException(); } 插入数据之后数据库中新纪录的id会回填到templateDO.id这个属性，这个特性是mybatis的一种常用的用法。但是如果我们用Mock如果来实现测试代码执行过testDOMapper.insert(templateDO)之后将templateDO.id属性附上值，如何实现呢？这里要用Answer这个接口 Mockito.when(testDOMapper.insert(Mockito.any(TestBeanDO.class))).thenAnswer(new Answer&lt;Integer&gt;() { @Override public Integer answer(InvocationOnMock invocation) throws Throwable { TestBeanDO arg = invocation.getArgumentAt(0, TestBeanDO.class); arg.setId(1L); return 1; } }); 上面的代码可以看到answer可以模拟调用insert()方法时方法体如何执行。answer的入参InvocationOnMock对象可以获取实际的入参的对象，这样只要在answer方法体里对入参属性进行修改就可以实现我们想要达到的效果了。 类似的方法还可以使用 ArgumentMatcher 来实现对参数进行捕获修改，这里给出示例就不再具体说明了。 Mockito.when(testDOMapper.insert(Mockito.argThat(new ArgumentMatcher&lt;TestBeanDO&gt;() { @Override public boolean matches(Object argument) { ((TestBeanDO) argument).setId(1L); return true; } }))).thenReturn(1); 给Spy的对象进行打桩 spy一般对监控一个真实的对象，按照之前mock的常见用法： Mockito.when(spyObj.method()).thenReturn(xxxx); 其实是不会按照thenReturn()指定的结果返回的，这一点要特别的注意，容易采坑。如果想按照用户自己的定义对spy对象进行打桩的正确方式是： Mockito.doReturn(xxxx).when(sypObj).method(); 提前设置好方法被调用之后的表现doReturn()返回结果还是doThrow()抛出异常，之后再使用when(spyObj)对spy的对象进行包装之后设置调用的方法就可以了。 ","link":"https://kangjn.github.io/post/shi-yong-springbootmockito-jin-xing-dan-yuan-ce-shi/"},{"title":"了解Java异步编程","content":"了解Java异步编程 随着RxJava、Reactor等异步框架的流行，异步编程受到了越来越多的关注，尤其是在IO密集型的业务场景中，相比传统的同步开发模式，异步编程的优势越来越明显。 那到底什么是异步编程？异步化真正的好处又是什么？如何选择适合自己团队的异步技术？在实施异步框架落地的过程中有哪些需要注意的地方？ 使用RxJava异步改造后的效果 什么是异步编程？异步实现原理 异步技术选型参考 异步化真正的好处是什么？ 异步化落地的难点及解决方案 扩展:异步其他解决方案-协程 使用RxJava异步改造后的效果 下图是我们后端java项目使用RxJava改造成异步前后的RT(响应时长)效果对比： 统计数据基于App端的gateway，以75线为准，还有80、85、90、99线，从图中可以看出改成异步后接口整体的平均响应时长降低了**40%**左右。 (响应时间是以发送请求到收到后端接口响应数据的时长，上图改造的这个后端java接口内部流程比较复杂，因为公司都是微服务架构，该接口内部又调用了6个其他服务的接口，最后把这些接口的数据汇总在一起返回给前端) 这张图是同步接口和改造成异步接口前后的CPU负载情况对比 改造前cpu load : 35.46 改造后cpu load : 14.25 改成异步后CPU的负载情况也有明显下降，但CPU使用率并无影响(一般情况下异步化后cpu的利用率会有所提高，但要看具体的业务场景) CPU LoadAverage是指：一段时间内处于可运行状态和不可中断状态的进程平均数量。(可运行分为正在运行进程和正在等待CPU的进程；不可中断则是它正在做某些工作不能被中断比如等待磁盘IO、网络IO等) 而我们的服务业务场景大部分都是IO密集型业务，功能实现很多需要依赖底层接口，会进行频繁的IO操作。 下图是2019年在全球架构师峰会上阿里分享的异步化改造后的RT和QPS效果： 什么是异步编程？ 响应式编程 + NIO 1. 异步和同步的区别： 我们先从I/O的角度看下同步模式下接口A调用接口B的交互流程: 下图是传统的同步模式下io线程的交互流程，可以看出io是阻塞的，即bio的运行模式 接口A发起调用接口B后，这段时间什么事情也不能做，主线程阻塞一直等到接口B数据返回，然后才能进行其他操作，可想而知如果接口A调用的接口不止B的话(A-&gt;B-&gt;C-&gt;D-&gt;E。。。)，那么等待的时间也是递增的，而且这期间CPU也要一直占用着，白白浪费资源，也就是上图看到的 cpu load 高的原因。 而且还有一个隐患就是如果调用的其他服务中的接口比如C超时，或接口C挂掉了，那么对调用方服务A来说，剩余的接口比如D、E都会无限等待下去。。。 其实大部分情况下我们收到数据后内部的处理逻辑耗时都很短，这个可以通过埋点执行时间统计，大部分时间都浪费在了IO等待上。 下面这个视频演示了同步模式下我们线上环境真实的接口调用情况，即接口调用的线程执行和变化情况，(使用的工具是JDK自带的jvisual来监控线程变化情况) 这里先交代下大致背景：服务端api接口A内部一共调用了6个其他服务的接口，大致交互是这样的： A接口（B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G）返回聚合数据 背景：使用Jemter测试工具压测100个线程并发请求接口，以观察线程的运行情况（可以全屏观看）： http-nio-8080-exec*开头的是tomcat线程池中的线程，即前端请求我们后端接口时要通过tomcat服务器接收和转发的线程，因为我们后端api接口内部又调用了其他服务的6个接口（B、C、D、E、F、G），同步模式下需要等待上一个接口返回数据才能继续调用下一个接口，所以可以从视频中看出，大部分的http线程耗时都在8秒以上(绿色线条代表线程是”运行中”状态，8秒包括等待接口返回的时间和我们内部逻辑处理的总时间，因为是本地环境测试，受机器和网络影响较大) 然后我们再看下异步模式的交互流程，即nio方式： 大致流程就是接口A发起调用接口B的请求后就立即返回，而不用阻塞等待接口B响应，这样的好处是http-nio-8080-exec*线程可以马上得到复用，接着处理下一个前端请求的任务，如果接口B处理完返回数据后，会有一个回调线程池处理真正的响应，即这种模式下我们的业务流程是http线程只处理请求，回调线程处理接口响应。 nio模式下虽然http-nio-8080-exec*线程和回调线程AsfThread-executor-*的运行时间都很短，但是从http线程开始到asf回调处理完返回给前端结果的时间和bio即同步模式下的时间差异不大（在相同的逻辑流程下），并不是nio模式下服务响应的整体时间就会缩短，而是会提升****CPU的利用率，因为CPU不再会阻塞等待（不可中断状态减少），这样CPU就能有更多的资源来处理其他的请求任务，相同单位时间内能处理更多的任务，所以nio模式带来的好处是： 提升QPS（用更少的线程资源实现更高的并发能力） 降低CPU负荷,提高利用率 2. Nio原理 结合上面的接口交互图可知，接口B通过网络返回数据给调用方(接口A)这一过程，对应底层实现就是网卡接收到返回数据后，通过自身的DMA（直接内存访问）将数据拷贝到内核缓冲区，这一步不需要CPU参与操作，也就是把原先CPU等待的事情交给了底层网卡去处理，这样CPU就可以专注于我们的应用程序即接口内部的逻辑运算。 3. Nio In Java nio在java里的实现主要是上图中的几个核心组件：channel、buffer、selector，这些组件组合起来即实现了上面所讲的多路复用机制，如下图所示： 响应式编程 1. 什么是响应式编程？它和传统的编程方式有什么区别？ 响应式可以简单的理解为收到某个事件或通知后采取的一系列动作，如上文中所说的响应操作系统的网络数据通知，然后以回调的方式处理数据。 传统的命令式编程主要由：顺序、分支、循环 等控制流来完成不同的行为 响应式编程的特点是： 以逻辑为中心转换为以数据为中心 从命令式到声明式的转换 2. Java.Util.Concurrent.Future 在Java使用nio后无法立即拿到真实的数据，而且先得到一个”future“，可以理解为邮戳或快递单，为了获悉真正的数据我们需要不停的通过快递单号查询快递进度，所以 J.U.C 中的 Future 是Java对异步编程的第一个解决方案，通常和线程池结合使用，伪代码形式如下： ExecutorService executor = Executors.newCachedThreadPool(); // 线程池 Future&lt;String&gt; future = executor.submit(() -&gt;{ Thread.sleep(200); // 模拟接口调用，耗时200ms return &quot;hello world&quot;; }); // 在输出下面异步结果时主线程可以不阻塞的做其他事情 // TODO 其他业务逻辑 System.out.println(&quot;异步结果:&quot;+future.get()); //主线程获取异步结果 Future的缺点很明显： 无法方便得知任务何时完成 无法方便获得任务结果 在主线程获得任务结果会导致主线程阻塞 3. ListenableFuture Google并发包下的listenableFuture对Java原生的future做了扩展，顾名思义就是使用监听器模式实现的回调机制，所以叫可监听的future。 Futures.addCallback(listenableFuture, new FutureCallback&lt;String&gt;() { @Override public void onSuccess(String result) { System.out.println(&quot;异步结果:&quot; + result); } @Override public void onFailure(Throwable t) { t.printStackTrace(); } }, executor); 回调机制的最大问题是：Callback Hell（回调地狱） 代码的字面形式和其所表达的业务含义不匹配 业务的先后关系在代码层面变成了包含和被包含的关系 大量使用 Callback 机制，使应该是先后的业务逻辑在代码形式上表现为层层嵌套,这会导致代码难以理解和维护。 那么如何解决 Callback Hell 问题呢？ 响应式编程 其实主要是以下两种解决方式： 事件驱动机制 链式调用(Lambda) 4. CompletableFuture Java8里的CompletableFuture和Java9的Flow Api勉强算是上面问题的解决方案： CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &quot;hello&quot; ); // f2依赖f1的结果做转换 CompletableFuture&lt;String&gt; f2 = f1.thenApplyAsync(t -&gt; t + &quot; world&quot; ); System.out.println(&quot;异步结果:&quot; + f2.get()); 但CompletableFuture处理简单的任务可以使用，但并不是一个完整的反应式编程解决方案，在服务调用复杂的情况下，存在服务编排、上下文传递、柔性限流(背压)方面的不足 如果使用CompletableFuture面对这些问题可能需要自己额外造一些轮子，Java9的Flow虽然是基于 Reactive Streams 规范实现的，但没有RxJava、Project Reactor这些异步框架丰富和强大和完整的解决方案。 当然如果接口逻辑比较简单，完全可以使用listenableFuture或CompletableFuture 5. Reactive Streams 在网飞推出RxJava1.0并在Android端普及流行开后，响应式编程的规范也呼之欲出： 包括后来的RxJava2.0、Project Reactor都是基于Reactive Streams规范实现的。 关于他们和listenableFuture、 CompletableFuture的区别通过下面的例子大家应该就会清楚。 比如下面的基于回调的代码示例：获取用户的5个收藏列表功能 图中标注序号的步骤对应如下： 根据uid调用用户收藏列表接口userService.getFavorites 成功的回调逻辑 如果用户收藏列表为空 调用推荐服务suggestionService.getSuggestions 推荐服务成功后的回调逻辑 取前5条推荐并展示(Java8 Stream api) 推荐服务失败的回调,展示错误信息 如果用户收藏列表有数据返回 取前5条循环调用详情接口favoriteService.getDetails 成功回调则展示详情,失败回调则展示错误信息 可以看出主要逻辑都是在回调函数（onSuccess()、onError()）中处理的，在可读性和后期维护成本上比较大。 基于Reactive Streams规范实现的响应式编程解决方案如下： 调用用户收藏列表接口 压平数据流调用详情接口 如果收藏列表为空调用推荐接口 取前5条 切换成异步线程处理上述声明接口返回结果) 成功则展示正常数据,错误展示错误信息 可以看出因为这些异步框架提供了丰富的api，所以我们可以把主要精力放在数据的流转上，而不是原来的逻辑控制上。这也是异步编程带来的思想上的转变。 下图是RxJava的operator api： （如果这些操作符满足不了你的需求，你也可以自定义操作符） 所以说异步最吸引人的地方在于资源的充分利用，不把资源浪费在等待的时间上(nio)，代价是增加了程序的复杂度，而Reactive Program封装了这些复杂性，使其变得简单。 所以我们无论使用哪种异步框架，尽量使用框架提供的api，而不是像上图那种基于回调业务的代码，把业务逻辑都写在onSuccess、onError等回调方法里，这样无法发挥异步框架的真正作用： Codes Like Sync，Works Like Async 即以同步的方式编码，达到异步的效果与性能,兼顾可维护性与可伸缩性。 异步框架技术选型 如果是我个人更愿意选择Project Reactor作为首选异步框架，，还有一点是因为Netflix推出的开源产品渐渐都不维护了，而且Project Reactor提供了reactor-adapter组件，可以方便的和RxJava的api转换。 其实还有Vert.x也算异步框架 (底层使用netty实现nio, 最新版已支持reactive stream规范) 异步化真正的好处 Scalability 伸缩性主要体现在以下两个方面： elastic 弹性 resilient 容错性 （异步化在平时不会明显降低 RT、提高 QPS，文章开头的数据也是在大促这种流量高峰下的体现出的异步效果） 从架构和应用等更高纬度看待异步带来的好处则会提升系统的两大能力：弹性 和 容错性 前者反映了系统应对压力的表现，后者反映了系统应对故障的表现 1. 容错性 像RxJava，Reactor这些异步框架处理回调数据时一般会切换线程上下文，其实就是使用不同的线程池来隔离不同的数据流处理逻辑，下图说明了这一特性的好处： 即利用异步框架支持线程池切换的特性实现服务/接口隔离，进而提高系统的高可用。 2. 弹性 back-pressure是一种重要的反馈机制，相比于传统的熔断限流等方式，是一种更加柔性的自适应限流。使得系统得以优雅地响应负载，而不是在负载下崩溃。 异步化落地的难点及解决方案 还是先看下淘宝总结的异步改造中难点问题： 中间件全异步牵涉到到公司中台化战略或框架部门的支持，包括公司内部常用的中间件比如MQ、redis、dal等。 这里主要说下上下文传递和阻塞检测的问题： 1. 上下文传递 改造成异步服务后，不能再使用ThreadLocal传递上下文context，因为异步框架比如RxJava一般在收到通知后会先调用observeOn()方法切换成另外一个线程处理回调，比如我们在请求接口时在ThreadLocal的context里设置了一个值，在回调线程里从context里取不到这个值的，因为此时已经不是同一个ThreadLocal了，所以需要我们手动在切换上下文的时候传递context从一个线程到另一个线程环境，伪代码如下： Context context = ThreadLocalUtils.get(); // 获取当前线程的上下文 single.observeOn(scheduler).doOnEvent((data, error) -&gt; ThreadLocalUtils.set(context)); // 切换线程后在doOnEvent里重新给新的线程赋值context 在observeOn()方法切换成另外一个线程后调用doOnEvent方法将原来的context赋给新的线程ThreadLocal 注意：这里的代码只是提供一种解决思路，实际在使用前和使用后还要考虑清空ThreadLocal，因为线程有可能会回收到线程池下次复用，而不是立即清理，这样就会污染上下文环境。 可以将传递上下文的方法封装成公共方法，不需要每次都手动切换。 2. 阻塞检测 阻塞检测主要是要能及时发现我们某个异步任务长时间阻塞的发生，比如异步线程执行时间过长进而影响整个接口的响应，原来同步场景下我们的日志都是串行记录到ES或Cat上的，现在改成异步后，每次处理接口数据的逻辑可能在不同的线程中完成，这样记录的日志就需要我们主动去合并（依据具体的业务场景而定），如果日志无法关联起来，对我们排查问题会增加很多难度。所幸的是随着异步的流行，现在很多日志和监控系统都已支持异步了。 Project Reactor 自己也有阻塞检测功能 3. 其他问题 除了上面提到的两个问题外，还有一些比如RxJava2.0之后不支持返回null，如果我们原来的代码或编程习惯所致返回结果有null的情况，可以考虑使用java8的Optional.ofNullable()包装一下，然后返回的RxJava类型是这样的：Single&lt;Optional&gt;，其他异步框架如果有类似的问题同理。 异步其他解决方案：纤程/协程 Quasar Kilim Kotlin Open JDK Loom AJDK wisp2 协程并不是什么新技术，它在很多语言中都有实现，比如 Python、Lua、Go 都支持协程。 协程与线程不同之处在于，线程由内核调度，而协程的调度是进程自身完成的。这样就可以不受操作系统对线程数量的限制，一个线程内部可以创建成千上万个协程。因为上文讲到的异步技术都是基于线程的操作和封装，Java中的线程概念对应的就是操作系统的线程。 1. Quasar、Kilim 开源的Java轻量级线程（协程）框架，通过利用Java instrument技术对字节码进行修改，使方法挂起前后可以保存和恢复JVM栈帧，方法内部已执行到的字节码位置也通过增加状态机的方式记录，在下次恢复执行可直接跳转至最新位置。 2. Kotlin Kotlin Coroutine 协程库，因为 Kotlin 的运行依赖于 JVM，不能对 JVM 进行修改，因此Kotlin不能在底层支持协程。同时Kotlin 是一门编程语言，需要在语言层面支持协程，所以Kotlin 对协程支持最核心的部分是在编译器中完成，这一点其实和Quasar、Kilim实现原理类似，都是在编译期通过修改字节码的方式实现协程 3. Project Loom Project Loom 发起的原因是因为长期以来Java 的线程是与操作系统的线程一一对应的，这限制了 Java 平台并发能力提升，Project Loom 是从 JVM 层面对多线程技术进行彻底的改变。 OpenJDK 在2018年创建了 Loom 项目，目标是在JVM上实现轻量级的线程，并解除JVM线程与内核线程的映射。其实 Loom 项目的核心开发人员正是从Quasar项目过来的，目的也很明确，就是要将这项技术集成到底层JVM里，所以Quasar项目目前已经不维护了。。。 4. AJDK Wisp2 Alibaba Dragonwell 是阿里巴巴的 Open JDK 发行版，提供长期支持。dragonwell8已开源协程功能（之前的版本是不支持的），开启jvm命令：-XX:+UseWisp2 即支持协程。 总结 Future 在异步方面支持有限 Callback 在编排能力方面有 Callback Hell 的短板 Project Loom 最新支持的Open JDK版本是16，目前还在测试中 AJDK wisp2 需要换掉整个JVM，需要考虑改动成本和收益比 所以目前实现异步化比较成熟的方案是 Reactive Streams ","link":"https://kangjn.github.io/post/liao-jie-java-yi-bu-bian-cheng/"},{"title":"解析springcloud分布式微服务的实现","content":"分布式系统 微服务就是原来臃肿的项目拆分为多个模块互不关联。如：按照子服务拆分、数据库、接口，依次往下就更加细粒度，当然运维也就越来越难受了。 分布式则是偏向与机器将诺大的系统划分为多个模块部署在不同服务器上。 微服务和分布式就是作用的“目标不一样”。 微服务与Cloud 微服务是一种概念，spring-cloud是微服务的实现。 微服务也不一定必须使用cloud来实现，只是微服务中有许多问题，如：负载均衡、服务注册与发现、路由等等。 而cloud则是将这些处理问题的技术整合了。 Spring-Cloud 组件 Eureka Eureka是Netifix的子模块之一，Eureka有2个组件，一个EurekaServer 实现中间层服务器的负载均衡和故障转移，一个EurekaClient它使得与server交互变得简单。 Spring-Cloud封装了Netifix公司开发的Eureka模块来实现服务注册和发现。 通过Eureka的客户端 Eureka Server维持心跳连接，维护可以更方便监控各个微服务的运行。 角色关系图 Eureka使用 客户端 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; server: port: 4001 eureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/ #eureka服务端提供的注册地址 参考服务端配置的这个路径 instance: instance-id: admin-1 #此实例注册到eureka服务端的唯一的实例ID prefer-ip-address: true #是否显示IP地址 leaseRenewalIntervalInSeconds: 10 #eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着,默认为30 秒 (与下面配置的单位都是秒) leaseExpirationDurationInSeconds: 30 #Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒 spring: application: name: server-admin #此实例注册到eureka服务端的name 服务端 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter- netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; yml文件声明 server: port: 3000 eureka: server: enable-self-preservation: false #关闭自我保护机制 eviction-interval-timer-in-ms: 4000 #设置清理间隔 （单位：毫秒 默认是60*1000） instance: hostname: localhost client: registerWithEureka: false #不把自己作为一个客户端注册到自己身上 fetchRegistry: false #不需要从服务端获取注册信息 （因为在这里自己就是服务端，而且已经禁用自己注册了） serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka 在SpringBoot 启动项目中加入注解:@EnableEurekaServer 就可以启动项目了，访问对应地址就可以看到界面。 Eureka 集群 服务启动后Eureka Server会向其他服务server 同步，当消费者要调用服务提供者，则向服务注册中心获取服务提供者的地址，然后将提供者的地址缓存到本地，下次调用时候直接从本地缓存中获取 yml 服务端 server: port: 3000 eureka: server: enable-self-preservation: false #关闭自我保护机制 eviction-interval-timer-in-ms: 4000 #设置清理间隔 （单位：毫秒 默认是60*1000） instance: hostname: eureka3000.com client: registerWithEureka: false #不把自己作为一个客户端 注册到自己身上 fetchRegistry: false #不需要从服务端获取注册信息 （因为在这里自己就是服务端，而且已经禁用自己注册了） serviceUrl: defaultZone: http://eureka3001.com:3001/eureka, http://eureka3002.com:3002/eureka (这里不注册自己，注册到其他服务上面以为会同步。) yml 客户端 server: port: 4001 eureka: client: serviceUrl: defaultZone:http://localhost:3000/eureka/,http:// eureka3001.com:3001/eureka,http://eureka3002.com:3 002 /eureka #eureka服务端提供的注册地址 参考服务端配置的这个路径 instance: instance-id: admin-1 #此实例注册到eureka服务端的唯一的实例ID prefer-ip-address: true #是否显示IP地址 leaseRenewalIntervalInSeconds: 10 #eureka客户需要多长时间发 送心跳给eureka服务器，表明它仍然活着,默认为30 秒 (与下面配置的单位都是秒) leaseExpirationDurationInSeconds: 30 #Eureka服务器在 接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒 spring: application: name: server-admin #此实例注册到eureka服务端的name CAP定理 C：Consistency 一致性 A：Availability 可用性 P：Partition tolerance 分区容错性 这三个指标不能同时达到 Partition tolerance 分区容错性，大多数分布式系统都部署在多个子网络。每一个网络是一个区。区间的通信是可能失败的如一个在本地，一个在外地，他们之间是无法通信的。分布式系统在设计的时候必须要考虑这种情况。 Consistency 一致性，写操作后的读取，必须返回该值。如：服务器A1和服务器A2，现在发起操作将A1中V0改为V1，用户去读取的时候读到服务器A1得到V1，如果读到A2服务器但是服务器 还是V0，读到的数据就不对，这就不满足一致性。 所以让A2返回的数据也对，的让A1给A2发送一条消息，把A2的V0变为V1，这时候不管从哪里读取都是修改后的数据。 Availability 可用性就是用户只要给出请求就必须回应，不管是本地服务器还是外地服务器只要接收到就必须做出回应，不管数据是否是最新必须做出回应，负责就不是可用性。 C与A矛盾 一致性和可用性不能同时成立，存在分区容错性，通信可能失败。 如果保证一致性，A1在写操作时，A2的读写只能被锁定，只有等数据同步了才能读写，在锁定期间是不能读写的就不符合可用性。 如果保持可用性，那么A2就不会被锁定，所以一致性就不能成立。 综上 无法做到一致性和可用性，所以系统在设计的时候就只能选其一。 Eureka与Zookeeper Zookeeper遵循的是CP原则保持了一致性，所以在master节点因为网络故障与剩余“跟随者”接点失去联系时会重新选举“领导者”，选取“领导者”大概会持续30-120s的时间，且选举的时候整个zookeeper是不可用的。导致在选举的时候注册服务瘫痪。 Eureka在设计的时候遵循AP可用性。Eureka各个接点是公平的，没有主从之分，down掉几个几点也没问题，其他接点依然可以支持注册，只要有一台Eureka在，注册就可以用，只不过查询到的数据可能不是最新的。Eureka有自我保护机制，如果15分钟之内超过85%接点都没有正常心跳，那么Eureka认为客户端与注册中心出现故障，此时情况可能是 Eureka不在从注册列表移除因为长时间没有瘦到心跳而过期的服务。 Eureka仍然能够接收注册和查询，但不会同步到其他接点。 当网络稳定后，当前的 实例注册信息会更新到其他接点。 Ｒibbon rebbon主要提供客户端的负载均衡，提供了一套完善的客户端的配置。Rebbin会自动帮助你基于某种规则（如：简单的轮询，随机链接等）。 服务端的负载均衡是一个url通过一个代理服务器，然后通过代理服务器（策略：轮询，随机 ，权重等等），反向代理到你的服务器。 客户端负载均衡是通过一个请求在客户端已经声明了要调用那个服务，然后通过具体算法来完成负载均衡。 Ｒibbon使用 引入依赖，Eureka以及把Ribbon集成在里面。 使用Ribbon只有在RestTemplate上面加入@LoadBalanced注解。 Feign负载均衡 feign是一个声明式的webService客户端，使用feign会让编写webService更简单，就是定义一个接口加上注解。 feign是为了编写java http客户端更加简单，在Ribbon+RestTemplate此基础上进一步封装，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。 Feign使用 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 在启动类上加@EnableFeignClients 然后在接口上加@FeignClient(&quot;SERVER-POWER&quot;)注解其中参数就是服务的名字。 Feign集成Ribbon 利用Ribbon维护服务列表信息，融合了Ribbon的负载均衡配置，与Ribbon不同的是Feign只需要定义服务绑定接口以声明的方式，实现简答的服务调用。 hystrix断路器 是一种用于处理分布式系统延迟和容错的开源库。在分布式系统中许多依赖不可避免的会调用失败，比如超时、异常等，断路器保证出错不会导致整体服务失败，避免级联故障。 断路器其实就是一种开关设置，类似保险丝，像调用方返回一个符合预期的、可处理的备选响应，而不是长时间等待或者抛出无法处理的异常，保证服务调用方线程不会被长时间 不必要占用，从而避免了在分布式系统中蔓延，乃至雪崩。 微服务中 client-&gt;微服务A-&gt;微服务B-&gt;微服务C-&gt;微服务D,其中微服务B异常了，所有请求微服务A的请求都会卡在B这里，就会导致线程一直累积在这里，那么其他微服务就没有可用线程，导致整个服务器雪崩。 针对这方案有 服务限流、超时监控、服务熔断、服务降级 降级 超时 降级就是服务响应过长 ，或者不可用了，就是服务调用不了了，我们不能把错误信息返回出来，或者长时间卡在哪里，所以要准备一个策略当发生这种问题我们直接调用这个方法快速返回这个请求，不让他一直卡在那。 要在调用方做降级（要不然那个微服务都down掉了在做降级就没有意义）。 引入hystrix依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 在启动类上加入@EnableHystrix 或者@EnableCircuitBreaker。 @RequestMapping(&quot;/feignPower.do&quot;) @HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;) public Object feignPower(String name){ return powerServiceClient.power(); } fallbackMethod： public Object fallbackMethod(String name){ System.out.println(name); return R.error(&quot;降级信息&quot;); } 这里的降级信息具体内容根据业务需求来，比如返回一个默认的查询信息等等。 hystrix有超时监听，当你请求超过1秒 就会超时，这个是可以配置的 这里的降级信息具体内容根据业务需求来，比如返回一个默认的查询信息等等。 hystrix有超时监听，当你请求超过1秒 就会超时，这个是可以配置的 降级什么用 第一他可以监听服务有没有超时。第二报错了他这里直接截断了没有让请求一直卡在这个。 其实降级，当你系统迎来高并发的时候，这时候发现系统马上承载不了这个大的并发 ，可以先关闭一些不重要 的微服务（就是在降级方法返回一个比较友好的信息）把资源让出来给主服务，其实就是整体资源不够用了，忍痛关闭某些服务，待过渡后再打开。 熔断限流 熔断就像生活中的跳闸，比如电路故障了，为了防止事故扩大，这里切断你的电源以免意外发生。当一个微服务调用多次，hystrix就会采取熔断 机制，不在继续调用你的方法，会默认短路，5秒后试探性的先关闭熔断机制，如果在这时候失败一次会直接调用降级方法，一定程度避免雪崩， 限流，限制某个微服务使用量，如果线程占用超过了，超过的就会直接降级该次调用。 Feign整合hystrix feign默认支持hystrix，需要在yml配置中打开。 feign: hystrix: enabled: true 降级方法 @FeignClient(value = &quot;SERVER-POWER&quot;, fallback = PowerServiceFallBack.class) public interface PowerServiceClient { @RequestMapping(&quot;/power.do&quot;) public Object power(@RequestParam(&quot;name&quot;) String name); } 在feign客户端的注解上 有个属性叫fallback 然后指向一个类 PowerServiceClient @Component public class PowerServiceFallBack implements PowerServiceClient { @Override public Object power(String name) { return R.error(&quot;测试降级&quot;); } } Zuul 网关 zuul包含了对请求的路由和过滤两个主要功能 路由是将外部请求转发到具体的微服务实例上。是实现统一入口基础而过滤器功能负责对请求的处理过程干预，是实现请求校验等功能。 Zuul与Eureka进行整合，将zuul注册在Eureka服务治理下，同时从Eureka获取其他服务信息。（zuul分服务最终还是注册在Eureka上） 路由 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; 最后要注册在Eureka上所以需要引入eureka依赖 YML server: port: 9000 eureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/ #eureka服务端提供的注册地址 参考服务端配置的这个路径 instance: instance-id: zuul-0 #此实例注册到eureka服务端的唯一的实例ID prefer-ip-address: true #是否显示IP地址 leaseRenewalIntervalInSeconds: 10 #eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着,默认为30 秒 (与下面配置的单位都是秒) leaseExpirationDurationInSeconds: 30 #Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒 spring: application: name: zuul #此实例注册到eureka服务端的name 启动类 @EnableZuulProxy 在实际开发当中我们肯定不会/server-power这样通过微服务调用， 可能只要一个/power就好了 zuul: routes: mypower: serviceId: server-power path: /power/** myorder: serviceId: server-order path: /order/** 注意/**代表是所有层级 /* 是代表一层。 一般我们会禁用服务名调用 ignored-services：server-order 这样就不能通过此服务名调用， 不过这个配置如果一个一个通微服务名字设置太复杂 一般禁用服务名 ignored-services：“*” 有时候要考虑到接口调用需要一定的规范，比如调用微服务URL需要前缀/api，可以加上一个prefix prefix：/api 在加上strip-prefix: false /api前缀是不会出现在路由中 zuul: prefix: /api ignored-services: &quot;*&quot; stripPrefix: false routes: product: serviceId: server-product path: /product/** order: serviceId: server-order path: /order/** 过滤器 过滤器(filter)是zuul的核心组件，zuul大部分功能是通过过滤器实现的，zuul中定义了4种标准过滤器类型，这些过滤器类型对应与请求的生命周期， PRE：这种过滤器在请求路由前被调用，可利用过滤器进行身份验证，记录请求微服务的调试信息等。 ROUTING：这种过滤器将请求路由到微服务，这种过滤器用于构建发送给微服务请求，并使用 Apache HttpClient或Netfix Ribbon请求微服务。 POST：这种过滤器在路由微服务后执行，可用来相应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端。 ERROR：在其他阶段发送错误时执行过滤器 继承ZuulFilter @Component public class LogFilter extends ZuulFilter { @Override public String filterType() { return FilterConstants.PRE_TYPE; } @Override public int filterOrder() { return FilterConstants.PRE_DECORATION_FILTER_ORDER+1; } @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); //被代理到的微服务 String proxy = (String)ctx.get(&quot;proxy&quot;); //请求的地址 String requestURI = (String)ctx.get(&quot;requestURI&quot;); //zuul路由后的url System.out.println(proxy+&quot;/&quot;+requestURI); HttpServletRequest request = ctx.getRequest(); String loginCookie = CookieUtil.getLoginCookie(request); ctx.addZuulRequestHeader(&quot;login_key&quot;,loginCookie); return null; } } 由此可知道自定义zuul Filter要实现以下几个方法。 filterType：返回过滤器类型，有pre、route、post、erro等几种取值 filterOrder：返回一个int值指定过滤器的顺序，不同过滤器允许返回相同数字。 shouldFilter：返回一个boolean判断过滤器是否执行，true执行，false不执行。 run：过滤器的具体实现。 Spting-Cloud默认为zuul编写并开启一些过滤器。如果要禁用部分过滤器，只需在application.yml里设置zuul…disable=true，例如zuul.LogFilter.pre.disable=true zuul也整合了了hystrix和ribbon的， 提供降级回退，继承FallbackProvider 类 然后重写里面的方法。 ","link":"https://kangjn.github.io/post/jie-xi-springcloud-fen-bu-shi-wei-fu-wu-de-shi-xian/"},{"title":"深入理解Java8","content":"Lambda的基本语法 (parm1,parm1,parm1) -&gt;{ }; lambda表达式结构 一个lambda表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断 所有参数需包含在圆括号内，参数之间用逗号相隔 空圆括号代表参数集为空 当只有一个参数，且其类型可推导时，圆括号()可省略 Lambda表达式的主体可包含零条或多条语句 如果Lambda表达式的主题只有一条语句，花括号{}可以省略。匿名函数的返回类型与该主体表达式一致 如果Lambda表达式的主题包含一条以上语句，则表达式必须包含再花括号{}中。匿名函数的返回类型与代码块的返回类型一致，若没有则返回为空 函数式接口 一个接口中只有一个抽象的方法 声明函数式接口时，在接口上添加@FunctionalInterface注解，这样编译器会按照函数式接口去验证 一个接口中只有一个抽象方法时，编译器会默认这个接口为函数式接口 接口中定义的方法为定级父类Object类中的方法时，接口可以拥有两个及以上的方法。因为接口的实现类也会继承Object,所以编译器会认为接口中只有一个方法 注意点 在Python、JavaScript等语言中lambda为函数，在java中lambda为对象 在java8中，接口中可以有具体方法的实现，必须是default meathod 在java中可以使用静态方法 函数式接口如何实例 函数式方法的声明 采用lambda表达式的方式进行声明一个接口实例 package funcationdemo; import java.util.Arrays; import java.util.List; /** 描述: lambda表达式练习 */ public class Test01 { public static void main(String[] args) { List list = Arrays.asList(1, 2, 3, 4, 5, 7); MyInterface myInterface = i -&gt; { return i; }; list.forEach(i -&gt; System.out.println(myInterface.printElement(i))); } } @FunctionalInterface interface MyInterface{ Integer printElement(Integer i); } 采用方法引用的方式进行声明 public class Test01 { public static void main(String[] args) { List list2 = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;hello world&quot;); list2.forEach(String::toUpperCase); } } 采用构造方法的方式进行声明 package funcationdemo; /** 描述: lambda表达式练习 */ public class Test01 { public static void main(String[] args) { MyInterface myInterface = Person::new; System.out.println(myInterface.getPerson(&quot;李华&quot;)); } } @FunctionalInterface interface MyInterface { Person getPerson(String name); } class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &quot;Person{&quot; + &quot;name='&quot; + name + '\\'' + '}'; } } 函数式接口四种类型 函数式接口 方法 参数类型 返回类型 作用 Consumer消费型接口 void accept(T t) T void 对T类型的参数进行操作 Supplier供给型接口 T get() 无 T 操作数据，返回T类型的结果 Function函数型接口 R apply(T t) T R 对T类型参数进行操作，并返回R类型的结果 Predicate 断定型接口 boolean test(T t) T boolean 确定T类型参数是否满足某约束，并返回boolean值 Lambda表达式的作用 传递行为，而不仅仅是值 提升抽象层次 API重用性更好 更加灵活 Function接口 函数式接口中，可以进行传值，也可以进行行为的传递，可以让方法的使用者传递方法所需要实现的行为，方法本身做更加抽象的逻辑实现 package funcationdemo; import java.util.function.Function; /** 描述: function 函数实现* */ public class FunctionTest { public static void main(String[] args) { FunctionTest functionTest = new FunctionTest(); System.out.println(functionTest.compute(3, value -&gt; value * value)); } public int compute(int a, Function&lt;Integer, Integer&gt; function) { return function.apply(a); } } BiFunction接口 package funcationdemo; import java.util.function.BiFunction; import java.util.function.Function; /**************************************** 描述: BiFunction函数接口练习 Interface BiFunction&lt;T,U,R&gt; T - 函数的第一个参数类型 U - 函数的第二个参数类型 R - 函数结果的类型 表示接受两个参数并产生结果的函数。 是Function函数有两个参数的展现方式 ****************************************/ public class BiFunctionTest { public static void main(String[] args) { BiFunctionTest test = new BiFunctionTest(); // 求两个数之和 System.out.println(test.compute(3, 4, Integer::sum)); // System.out.println(test.compute2(3, 4, Integer::sum, item -&gt; item * item)); // 等价于 System.out.println(test.compute2(3, 4, (num1, num2) -&gt; num1 * num2, value -&gt; value * value)); } /** * public interface BiFunction&lt;T, U, R&gt; { * &lt;p&gt; * R apply(T t, U u); * &lt;p&gt; * &lt;p&gt; * } */ public int compute(int num1, int num2, BiFunction&lt;Integer, Integer, Integer&gt; function) { return function.apply(num1, num2); } /**** * default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { * Objects.requireNonNull(after); * return (T t, U u) -&gt; after.apply(apply(t, u)); * } * @param num1 计算的值 * @param num2 计算的值 * @param function 需要求和函数参数（函数参数指的是需要函数执行的行为） * @param function2 需要返回函数参数 * @return 计算后返回的值 */ public int compute2(int num1, int num2, BiFunction&lt;Integer, Integer, Integer&gt; function, Function&lt;Integer, Integer&gt; function2) { return function.andThen(function2).apply(num1, num2); } } BinaryOperator接口 package funcationdemo; import java.util.Comparator; import java.util.function.BinaryOperator; /************************************************************** 描述: BinaryOperator 表示对同一类型的两个操作数的操作，产生与操作数相同的结果。 对于操作数和结果都是相同类型的情况 是BiFunction的专业化 **************************************************************/ public class BinaryOperatorTest { public static void main(String[] args) { BinaryOperatorTest test = new BinaryOperatorTest(); System.out.println(test.compute(3, 4, Integer::sum)); System.out.println(test.minByComparator(5, 6, Comparator.comparingInt(num -&gt; num))); } /**** * * 继承 BiFunction&lt;T,T,T&gt; ,也拥有 apply()方法 * 三个参数必须是同类型的 * * public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; { * * } * * * @param num1 * @param num2 * @param function * @return */ public int compute(int num1, int num2, BinaryOperator&lt;Integer&gt; function) { return function.apply(num1, num2); } /*** * * public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) { * Objects.requireNonNull(comparator); * return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b; * } * * @param num1 比较参数1 * @param num2 比较数字2 * @param comparator 比较器 * @return 返回比较的结果 */ public int minByComparator(int num1, int num2, Comparator&lt;Integer&gt; comparator) { return BinaryOperator.minBy(comparator).apply(num1, num2); } } Consumer接口 package funcationdemo; import java.util.Arrays; import java.util.List; import java.util.Optional; import java.util.function.Consumer; /********************************************************* 描述: Consumer函数 表示接受单个输入参数并且不返回结果的操作 ********************************************************/ public class ConsumerTest { public static void main(String[] args) { List list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;); list.forEach(str-&gt;{ String strParam = str; Optional optional = Optional.ofNullable(strParam); String rtn = optional.map(strParam1 -&gt; strParam1.toUpperCase()).orElse(&quot;&quot;); System.out.println(rtn); }); } } Predicate接口 结合Stream流使用 package funcationdemo; import java.util.Arrays; import java.util.List; import java.util.Optional; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Predicate; /************************************************************** 描述: Predicate 表示一个参数的谓词 **************************************************************/ public class PredicateTest { public static void main(String[] args) { PredicateTest test = new PredicateTest(); System.out.println(test.isTrueOfStr(&quot;hell0&quot;, str -&gt; str.length() &gt; 4)); List list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // Predicate 接口使用 Predicate predicate = i -&gt; i % 2 == 0; // Optional 使用的函数 Function&lt;Integer, Integer&gt; function = integer -&gt; { Optional integerOptional = Optional.of(integer); Integer rtn = integerOptional.map(ele -&gt; 2 * ele).get(); return rtn; }; // 输出参数 Consumer consumer = param -&gt; { Optional integer = Optional.ofNullable(param); Integer rtn = integer.map(function).get(); System.out.println(rtn); }; test.conditionFilter(list, predicate, consumer); } public boolean isTrueOfStr(String str, Predicate&lt;String&gt; funciton) { return funciton.test(str); } public void conditionFilter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate, Consumer&lt;Integer&gt; consumer) { list.stream().filter(predicate).forEach(consumer); } } Supplier接口 package funcationdemo; import java.util.function.Supplier; /************************************************************** 描述: Supplier 代表结果供应商，没有要求每次调用供应商时都会返回新的或不同的结果 不接受参数，返回一个结果。泛型就是需要返回结果的类型 **************************************************************/ public class SupplierTest { public static void main(String[] args) { Supplier supplier = String::new; String str = supplier.get(); str = &quot;hello world&quot;; System.out.println(str); } } MethodReference 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。 引用静态方法：ContainingClass::staticMethodName package methodreference; import java.util.Arrays; import java.util.List; /************************************************************** 描述: MethodReference 方法引用 **************************************************************/ public class MethodReferenceTest { static void toUpperCaseByStr(String str) { System.out.println(str.toUpperCase()); } public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;); // ContainingClass::staticMethodName 引用静态方法 list.forEach(MethodReferenceTest::toUpperCaseByStr); } } 引用某个对象的实例方法：containingObject::instanceMethodName package methodreference; import java.util.Arrays; import java.util.List; /************************************************************** 描述: MethodReference 方法引用 **************************************************************/ public class MethodReferenceTest { void toUpperCaseByStr(String str) { System.out.println(str.toUpperCase()); } public static void main(String[] args) { List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;); // 引用某个对象的实例方法 MethodReferenceTest test = new MethodReferenceTest(); list.forEach(test::toUpperCaseByStr); } } 引用某个类型的任意对象的实例方法：ContainingType::methodName package methodreference; import java.util.Arrays; import java.util.List; import java.util.function.Consumer; /************************************************************** 描述: MethodReference 方法引用 **************************************************************/ public class MethodReferenceTest{ public static void main(String[] args) { /*引用某个类型的任意对象的实例方法*/ List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;); list.sort(String::compareTo); list.forEach(System.out::println); } } 引用构造方法：ClassName::new package methodreference; import java.util.function.Supplier; /************************************************************** * 描述: * MethodReference * 方法引用 * **************************************************************/ public class MethodReferenceTest{ public MethodReferenceTest() { } public String getString(Supplier&lt;String&gt; supplier){ return supplier.get() +&quot;test&quot;; } public static void main(String[] args) { MethodReferenceTest test = new MethodReferenceTest(); System.out.println(test.getString(String::new)); } } 超类上的实例方法引用 **组成语法格式：super::methodName 方法的名称由methodName指定，通过使用super，可以引用方法的超类版本。 还可以捕获this 指针，this :: equals 等价于lambda表达式 x -&gt; this.equals(x); 数组构造方法引用 **组成语法格式：TypeName[]::new 例子： int[]::new 是一个含有一个参数的构造器引用，这个参数就是数组的长度。等价于lambda表达式 x -&gt; new int[x]。 假想存在一个接收int参数的数组构造方法 IntFunction arrayMaker =int[]::new;int[] array = arrayMaker.apply(10)// 创建数组 int[10] ","link":"https://kangjn.github.io/post/shen-ru-li-jie-java8/"},{"title":"Docker 教程（三）：Docker 命令","content":"我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。 请注意，根据在 Linux 系统上安装 Docker 的方式，可能需要在所有命令前面加上sudo，使用 root 权限运行他们。比如： sudo docker build . … 而不仅仅是： docker build . Docker 命令行工具 在 Linux 系统中安装 Docker 时，会安装一个名为docker的命令行工具，可以在 Linux 命令行执行。 docker有很多的参数，不同的参数作用不同，可以指挥 Docker 做出不同的行为，可以认为是给 Docker 的命令。以下是docker命令示例： docker build . 这个示例中包含三部分：docker命令、参数build、参数.。 参数build是一个 Docker 命令，换句话说，是一个给 docker 可执行命令行的命令。通常，docker 命令行的第一个参数都是 Docker 命令。 参数.是build命令的参数。 docker build docker build命令是调用 Docker 从 Dockerfile 文件构建 docker 镜像，要使用docker build命令，必须告诉它从哪个 Dockerfile 文件生成镜像。关于 Dockerfile 的内容，可以查看 这里。以下是docker build命令示例： docker build . 参数.表示从当前目录找到 Dockerfile 文件。 docker images docker images命令是列出本机的 Docker 镜像，以下是docker images命令示例： docker images 运行上述命令会输出类似下面的内容： REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest fce289e99eb9 9 months ago 1.84kB docker run docker run命令用来基于给定的 Docker 镜像运行 Docker 容器，docker run的参数，可以是 Docker 镜像的名称或 ID，以下是运行 Docker 容器的示例： docker run hello-world 这个例子会基于hello-world镜像运行 Docker 容器。 我们还可以通过 Docker 镜像 ID 运行 Docker 容器，命令如下： docker run fce289e99eb9 docker ps docker ps命令用于显示当前系统中正在运行的 Docker 容器，示例如下： docker ps 注意，一些 Docker 容器会在完成任务后立即关闭，在docker ps的结果列表中，这种 Docker 容器很有可能会很长时间都不可见。 ","link":"https://kangjn.github.io/post/docker-jiao-cheng-san-docker-ming-ling/"},{"title":"Docker 教程（二）：Dockerfile","content":"Dockerfile包含一组关于如何构建Docker镜像的说明，通过docker build命令执行Dockerfile文件，可以构建一个Docker镜像，本文介绍了如何编写Dockerfile文件以及构建一个Docker镜像。 Dockerfile的好处 Dockerfile文件以书面形式说明了如何构建一个Docker镜像，Docker镜像通常包含如下内容： 首先需要一个基本的Docker镜像，在这个基础Docker镜像上构建自己的Docker镜像。 一组需要安装在Docker镜像中的工具和应用。 一组需要复制到Docker镜像中的文件（比如配置文件）。 可能需要在防火墙中打开的网络（TPC/UDP）端口或其他。 等等。。。 首先，在Dockerfile文件中以书面形式说明这些，就意味着，我们不用特意记住应用程序如何安装，包括操作系统什么要求、需要安装的应用程序、需要赋值的文件、需要打开的网络端口等，这些内容都被记录在Dockerfile中。 另外，通过Dockerfile文件构建Docker镜像，我们不需要手动执行这些繁琐重复且容易出错的工作。Docker会自动做这些事情，简单、快速、且不容易出错。 第三，我们很容易和其他人分享Dockerfile文件，并且他们可以自己构建Docker镜像。 第四，Dockerfile很容易存储在Git这样的版本控制器中，这样就可以跟踪Dockerfile（服务器、应用配置）的变更记录。版本控制器也可以很容易的让人们协同合作，比如在Dockerfile上，以及分享Dockerfile。 Dockerfile的结构 Dockerfile包含一组指令，每个指令有一个命令和参数组成，类似于命令行可执行文件。下面是一个Dockerfile简单示例： # 基础镜像 FROM ubuntu:latest # 这里可以有更多安装软件和复制文件到镜像中的说明。 COPY /myapp/target/myapp.jar /myapp/myapp.jar # 在Docker容器中执行的命令。 CMD echo Starting Docker Container Docker基础镜像 Docker镜像是由层组成，每一层都会为最终的Docker镜像添加一些内容。每一个层实际上都是一个单独的Docker镜像，所以说，Docker镜像是由一个或多个层镜像组成，我们可以在其上添加自己的层。 当通过Dockerfile文件指定自己的Docker镜像时，通常是从一个Docker基础镜像开始。这是另一个Docker镜像，可以在其上构建自己的Docker镜像。这个Docker基础镜像本身可能也包含多个层，并且是基于另一个基础镜像构建的。 我们可以使用From命令在Dockerfile文件中指定Docker镜像作为基础镜像，如下节所述。 MAINTAINER MAINTAINER命令用于说明谁在维护这个Dockerfile文件。比如： MAINTAINER Joe Blocks &lt;joe@blocks.com&gt; MAINTAINER命令并不常用，因为这类信息在Git存储或其他地方有了。 FROM FROM命令用于指定Docker基础镜像，如果是从原始Linux镜像开始，可以使用如下命令： # 基础镜像 FROM ubuntu:latest CMD CMD命令用于指定启动Docker容器是需要执行的命令，该容器是基于此Dockerfile构建的Docker镜像，下面是一些Dockerfile的CMD示例： CMD echo Docker container started. 本例是打印“Docker container started”这行文本。 下一个CMD示例是启动一个java应用： CMD java -cp /myapp/myapp.jar com.jenkov.myapp.MainClass arg1 arg2 arg3 COPY COPY命令将一个或多个文件从主机（从Dockerfile文件构建Docker镜像的机器）复制到Docker镜像中，可以复制的内容包括文件或目录，下面是一个示例： COPY /myapp/target/myapp.jar /myapp/myapp.jar 这个例子是把主机的/myapp/target/myapp.jar文件复制到Docker进行中的/myapp/myapp.jar文件。第一个参数是主机路径（从哪里来），第二个参数是Docker镜像的路径（到哪里去）。 我们还可以复制一个目录到Docker镜像中，比如： COPY /myapp/config/prod /myapp/config 这个例子是把主机的/myapp/config/prod目录复制到Docker镜像中的/myapp/config目录。 我们还可以复制多个文件到Docker镜像中的一个目录中，比如： COPY /myapp/config/prod/conf1.cfg /myapp/config/prod/conf2.cfg /myapp/config/ 这个例子是将主机的/myapp/config/prod/conf1.cfg文件和/myapp/conig/prod/conf2.cfg文件复制到Docker镜像中的/myapp/config/目录中。注意，目标目录必须以/（斜杠）结束才能工作。 ADD ADD命令与COPY命令工作方式相同，只有一些细微的差别： ADD命令可以复制并提取TAR文件到Docker镜像中。 ADD命令可以通过HTTP下载文件，并复制到Docker镜像中。 下是一些示例： ADD myapp.tar /myapp/ 这个例子是将指定的TAR文件解压缩并提取到Docker镜像的/myapp/目录中。 下面是另一个例子： ADD http://jenkov.com/myapp.jar /myapp/ ENV ENV命令是在Docker镜像中设置环境变量，此环境变量可用于CMD命令在Docker镜像内部启动应用程序。举个例子： ENV MY_VAR 123 本例将环境变量MY_VAR设置为值123。 RUN RUN可以在Docker镜像中执行命令行指令，执行时机是Docker镜像构建过程中，所以RUN命令只会执行一次。RUN命令可用于在Docker镜像中安装应用程序、提取文件或其他命令行功能，这些操作只需要执行一次，以供Docker镜像后续使用。 RUN apt-get install some-needed-app ARG ARG命令允许定义一个参数，这个参数可以在通过Dockerfile文件构建Docker镜像时，通过命令参数传递给Docker。比如： ARG tcpPort 当执行docker build命令执行Dockerfile构建Docker镜像时，可以指定tcpPort参数，比如： docker build --build-arg tcpPort=8080 . 注意，--build-arg后面的tcpPort=8080，是将tcpPort参数的值设置为8080。 我们可以通过多个ARG命令定义多个参数，举个例子： ARG tcpPort ARG useTls 当构建Docker镜像时，必须为所有构建参数提供值。【译者注，1.13版本之前，不提供值会直接报错，1.13版本之后，不提供值不会报错，但是会弹出警告】。举个例子： docker build --build-arg tcpPort=8080 --build-arg useTls=true . 我们可以为ARG设置默认值，当构建Docker镜像时，如果没有指定参数值，将使用默认值。举个例子： ARG tcpPort=8080 ARG useTls=true 如果tcpPort和useTls在生成Docker镜像时，都没有设置参数，将使用默认值8080和true。 ARG声明的参数通常在Dockerfile的其他地方引用，比如： ARG tcpPort=8080 ARG useTls=true CMD start-my-server.sh -port ${tcpPort} -tls ${useTls} 注意：两个引用${tcpPort}和${useTls}，引用名是tcpPort和useTls这两个ARG声明的参数。 docker build --build-arg tcpPort=8080 WORKDIR WORKDIR命令指明了Docker镜像中的工作目录，工作目录将对WORKDIR指令之后的所有命令生效，举个例子： WORKDIR /java/jdk/bin EXPOSE EXPOSE命令将对外开放Docker容器中的网络端口，比如，如果Docker容器运行一个web服务器，那么，该web服务器可能需要打开端口80，以便客户端链接到它。举个例子： EXPOSE 8080 我们还可以指明打开端口的通信协议，比如：UDP和TCP。下面是设置允许通信协议的示例： EXPOSE 8080/tcp 9999/udp 如果没有指定协议，将默认认定为TCP协议。 VOLUME VOLUME命令会在Docker镜像中创建一个目录，这个目录可以挂载到Docker主机上。换句话说，可以在Docker镜像中创建目录，比如/data，这个目录可以在稍后挂载到Docker主机的/container-data/container1目录上。挂载成功后，容器会启动。下面是一个使用VOLUME命令在Dockerfile中定义装载目录的示例： VOLUME /data ENTRYPOINT ENTRYPOINT命令为从该Docker镜像启动Docker容器提供入口点，入口点是Docker容器启动时执行的应用程序或命令。这样，ENTRYPOINT和CMD工作方式类似，不同之处在于，使用ENTRYPOINT时，当ENTRYPOINT执行的应用程序完成时，Docker容器将关闭。因此，ENTRYPOINT使Docker镜像本身成为一个可执行命令，可以启动，完成后关闭。以下是ENTRYPOINT示例： ENTRYPOINT java -cp /apps/myapp/myapp.jar com.jenkov.myapp.Main 这个示例将在容器启动时执行Java应用程序的主类com.jenkov.myapp.Main，当应用程序关闭时，Docker容器也会关闭。 HEALTHCHECK HEALTHCHECK命令可以定期执行健康检查，以监视Docker容器中运行的应用程序的运行状况。如果命令返回0，Docker将认为应用程序和容器正常，如果命令返回1，Docker会认为应用程序和容器不正常。示例如下： HEALTHCHECK java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck 这个示例中使用了java应用程序的com.jenkov.myapp.HealthCheck作为健康检查的命令，我们可以使用任何有意义的健康检查命令。 健康检查间隔时间 默认情况下，Docker每30秒执行一次HEALTHCHECK命令。如果想修改时间间隔，我们可以自定义时间，通过--interval参数，可以指定健康检查的检查间隔时间。下面是一个将HEALTHCHECK间隔设置为60秒的示例： HEALTHCHECK --interval=60s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck 健康检查开始时间 默认情况下，Docker会立即检查Docker容器的监控状况。但是，有些应用程序可能需要一段时间启动，因此，只有经过某段时间后再进行健康检查才有意义。我们可以使用--start-period参数设置健康检查开始时间。下面是一个将健康检查设置为5分钟的示例，在Docker开始健康检查之前，为容器和应用程序提供300秒（5分钟）的启动时间： HEALTHCHECK --start-period=300s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck 健康检查超时时间 健康检查很有可能超时，如果HEALTCHECK命令需要超过给定时间限制才完成，Docker将认为健康检查超时。可以使用--timeout参数设置超时时间，如下是设置超时时间为5秒的示例： HEALTHCHECK --timeout=5s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck 注意，如果健康检查超时，Docker也会认为容器不健康。 健康检查重复次数 如果HEALTHCHECK命令执行失败，有可能是结果返回1，或者执行超时，Docker会在认定容器不健康前，重试3次HEALTHCHECK命令，用于检查Docker容器是否返回健康状态。可以通过--retries设置重试次数。下面是将重试次数设置为5的示例： HEALTHCHECK --retries=5 java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://local ","link":"https://kangjn.github.io/post/lesslessdocker-jiao-cheng-greatergreater-er-dockerfile/"},{"title":"Docker 教程（一）：Docker 是什么","content":"Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。 Docker 的优势 使用 Dockerfile 打包应用和服务器配置最大的好处是： 不会忘记服务器是如何配置的，这些配置信息都记录在 Dockerfile 中。 很容易在一个全新啊的 Docker 主机上运行应用程序，只需要将应用程序的 Docker 镜像部署到这台 Docker 主机上，然后启动它即可。 可以使用 Kubernetes 和 Swarm 轻松管理集群中的 Docker 容器。 目前许多云服务器平台可以很轻松的部署 Docker 容器，Docker 已经成为让云更加独立的部署方案。 Docker 容器可以很简单的实现在客户自己的服务器上按照你的应用程序。 什么是 Docker 容器 Linux 操作系统有几个特性：运行在操作系统上运行容器化的应用程序，这些容器化的特性，运行将文件系统和网络在各个容器化应用程序之间彼此分离。换句话说，一个容器化应用程序，不能访问另一个容器化应用程序的文件系统或网络，除非增加特殊配置，允许这种操作。Docker 使用 Linux 的容器化特性，并通过一组易于使用的工具公开这些特性。 Docker 容器 vs. 虚拟机 Docker 容器在本质上类似于虚拟机，两者的不同之处在于，虚拟机在总栈上有一个额外的操作系统。也就是说，虚拟机有完整的操作系统，然后这个虚拟机运行在一个有操作系统的主机上。 Docker 容器与虚拟机的实现不同，它没有自己单独的操作系统，直接运行在所在主机的操作系统中。所以，Docker 容器足够小，因为它不包含虚拟机操作系统。Docker 容器运行的也很好，因为它不需要虚拟机的虚拟化。 Dockerfile 如前所述，我们可以通过一个按规则定义的 Dockerfile 文件，指定要包含在 Docker 容器中的内容。Dockerfile 文件包含了一组有 Docker 命令行工具执行的 Docker 指令，按照 Dockerfile 执行的结果是 Docker 镜像。我们可以从 Dockerfile 教程 中得到更详细的解释。【译者注：后续翻译完成后，将替换此处链接。】 Docker 镜像 Docker 命令行工具按照 Dockerfile 中定义的结构执行指令时，会生产一个可移植、可运行的 Docker 镜像。这个 Docker 镜像中包含了所有 Docker 容器需要的文件和指令，同一个 Docker 镜像可以启动多个 Docker 容器。 Docker 仓库 Docker 镜像可以存储在 Docker 仓库中，一个可以将 Docker 镜像上传、下载的存储仓库。Docker 仓库可以是私有的，只能你或者你的组织或者你指定的人管理其中的镜像，也可以是公有的，任何人都可以管理其中的镜像，或者是从中下载 Docker 镜像。 一个公有的 Docker 仓库，是运行潜在用户下载、安装和运行软件的很好的方式，只需要将应用程序打包为 Docker 镜像，上传到公有的 Docker 仓库中，你的用户就可以访问并使用它。 Docker 公司已将 Docker 仓库作为一项托管服务，提供了私有和公有两种服务。一些云服务商，比如 AWS、AZure 和 Google，也提供了 Docker 仓库服务器，可以上传自己的 Docker 镜像。很容易的就能在云基础设施上的虚拟机或 Kubernetes 中使用这些镜像。 Docker 命令行工具 当在操作系统中安装 Docker 的时候，会同时安装 Docker 命令行工具。Docker 命令行工具可以通过 Dockerfile 构建 Docker 镜像，可以将 Docker 镜像上传到 Docker 仓库中，可以从 Docker 仓库中下载 Docker 镜像，可以操作 Docker 镜像启动或停止 Docker 容器。 Docker Compose Docker Compose 提供一种功能，可以将多个 Docker 容器链接成一个组合中，这个组合中的所有容器，可以一次性全部部署或停止。比如，一个 Docker 容器中运行应用，一个 Docker 容器中运行数据库，应用依赖于数据库，同时启动或停止，可以实现应用依赖的数据库没有正常运行。 ","link":"https://kangjn.github.io/post/docker-jiao-cheng-yi-docker-shi-shi-me/"},{"title":"CentOS7安装使用Docker","content":"安装 Docker 官方为了简化安装流程，提供了一套安装脚本，CentOS 系统上可以使用这套脚本安装： curl -sSL https://get.docker.com/ | sh 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系统中。 不过，由于伟大的墙的原因，在国内使用这个脚本可能会出现某些下载出现错误的情况。国内的一些云服务商提供了这个脚本的修改版本，使其使用国内的 Docker 软件源镜像安装，这样就避免了墙的干扰。 阿里云安装脚本 curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh 镜像 选择国内镜像 官方中国区加速器 sudo echo &quot;DOCKER_OPTS=\\&quot;--registry-mirror=https://registry.docker-cn.com\\&quot;&quot; &gt;&gt; /etc/default/docker 推荐使用官方加速器。 网易163 sudo echo &quot;DOCKER_OPTS=\\&quot;--registry-mirror=http://hub-mirror.c.163.com\\&quot;&quot; &gt;&gt; /etc/default/docker 目前网易镜像已经比较稳定。 修改完默认镜像仓库后需要重启docker才能生效： service docker restart 使用 启动Docker service docker start 开机自启动 sudo chkconfig docker on 停止Docker service docker stop 本地镜像列表 docker images 使用images命令查看发现当前本地没有任何镜像 搜索 docker search hello 以下结果是我们搜索到的与&quot;hello&quot;相关的所有镜像 拉取镜像 docker pull hello-world 我们尝试从仓库中拉取名为“hello-world”的镜像 拉取成功后使用docker images命令查看，发现该镜像已被拉取到本地。 运行镜像 docker run hello-world 运行后该镜像会输出如下信息： 查看运行中的镜像 docker ps 镜像重命名 docker tag hello-world hw 我们将之前下载的“hello_world”镜像重命名为“hw”，使用images命令查看会发现列表中已经多了一个名为“hw”的镜像。 删除镜像 docker rmi hello-world 我们删除了名为“hello_world”的镜像，rmi后面的参数也可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 卸载 列出安装包 yum list installed | grep docker 删除安装包 yum -y remove docker-engine.x86_64 yum -y remove docker-engine-selinux.noarch 删除镜像/容器等 rm -rf /var/lib/docker ","link":"https://kangjn.github.io/post/centos7-an-zhuang-shi-yong-docker/"},{"title":"Spring Boot与Docker部署","content":"开启Docker远程访问 首先需要开启docker远程访问功能，以便可以进行远程操作。 CentOS 6 修改/etc/default/docker文件，重启后生效（service docker restart）。 DOCKER_OPTS=&quot;-H=unix:///var/run/docker.sock -H=0.0.0.0:2375&quot; CentOS 7 打开/usr/lib/systemd/system/docker.service文件，修改ExecStart这行。 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 重启后生效 systemctl daemon-reload systemctl restart docker.service 测试是否生效 curl http://127.0.0.1:2375/info 新建Maven工程 pom.xml配置如下: &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;test.springboot.docker&lt;/groupId&gt; &lt;artifactId&gt;docker-springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.14&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;dockerHost&gt;http://192.168.1.200:2375&lt;/dockerHost&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; imageName：指定了镜像的名字 dockerDirectory：指定Dockerfile的位置 dockerHost：指定Docker远程API地址 resources：指那些需要和Dockerfile放在一起，在构建镜像时使用的文件，一般应用jar包需要纳入 创建Java类 package hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class Application { @RequestMapping(&quot;/&quot;) public String home() { return &quot;Hello Docker World&quot;; } public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 创建Dockerfile 在src/main/docker目录下创建一个名为Dockerfile的文件，配置如下： FROM java VOLUME /tmp ADD docker-springboot-0.0.1-SNAPSHOT.jar app.jar RUN bash -c 'touch /app.jar' ENV JAVA_OPTS=&quot;&quot; ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ] **FROM java：**指Docker Hub上官方提供的java镜像，有了这个基础镜像后，Dockerfile可以通过FROM指令直接获取它的状态——也就是在容器中java是已经安装的，接下来通过自定义的命令来运行Spring Boot应用。 **VOLUME /tmp：**创建/tmp目录并持久化到Docker数据文件夹，因为Spring Boot使用的内嵌Tomcat容器默认使用/tmp作为工作目录。 **ADD docker-springboot-0.0.1-SNAPSHOT.jar app.jar：**将应用jar包复制到/app.jar **ENTRYPOINT：**表示容器运行后默认执行的命令 完整目录结构如下所示： 运行以下命令创建Docker镜像： package docker:build Docker启动镜像 查看项目是否上传成功 启动镜像 docker run -p 8888:8080 springboot/docker-springboot 通过浏览器访问 ","link":"https://kangjn.github.io/post/spring-boot-yu-docker-bu-shu/"},{"title":"MQTT简介","content":"1 简述 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 2 设计规范 由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则： 精简，不添加可有可无的功能； 发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递； 允许用户动态创建主题，零运维成本； 把传输量降到最低以提高传输效率； 把低带宽、高延迟、不稳定的网络等因素考虑在内； 支持连续的会话控制； 理解客户端计算能力可能很低； 提供服务质量管理； 假设数据不可知，不强求传输数据的类型与格式，保持灵活性。 3 主要特性 MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性： 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，因为XMPP使用XML格式文本来传递数据。 对负载内容屏蔽的消息传输。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 有三种消息发布服务质量QoS (Quality of Service)： At Most Once 至多一次，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 At Least Once 至少一次，确保消息到达，但消息重复可能会发生。 Exactly Once 有且仅有一次，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。这就是为什么在介绍里说它非常适合&quot;在物联网领域，传感器与服务器的通信，信息的收集&quot;，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。 使用Last Will和Testament特性通知有关各方客户端异常中断的机制。 Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。 Testament：遗嘱机制，功能类似于Last Will。 4 MQTT协议原理 4.1 MQTT协议实现方式 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（Payload）两部分： Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（Payload）； Payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 4.2 网络传输与应用消息 MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。 当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。 4.3 MQTT客户端 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： 发布其他客户端可能会订阅的信息； 订阅其它客户端发布的消息； 退订或删除应用程序的消息； 断开与服务器连接。 4.4 MQTT服务器 MQTT服务器以称为&quot;消息代理&quot;（Broker），可以是一个应用程序或一台设备。它位于消息发布者和订阅者之间，它可以： 接受来自客户的网络连接； 接受客户发布的应用信息； 处理来自客户端的订阅和退订请求； 向订阅的客户转发应用程序消息。 4.5 MQTT协议中的订阅、主题、会话 4.5.1 订阅（Subscription） 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。 4.5.2 会话（Session） 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 4.5.3 主题名（Topic Name） 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。 4.5.4 主题筛选器（Topic Filter） 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 4.5.5 负载（Payload） 消息订阅者所具体接收的内容。 4.6 MQTT协议中的方法 MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有： Connect：等待与服务器建立连接。 Disconnect：等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。 Subscribe：等待完成订阅。 UnSubscribe：等待服务器取消客户端的一个或多个topics订阅。 Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程。 5 MQTT协议数据包结构 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。 固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。 可变头（Variable header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。 消息体（Payload）：存在于部分MQTT数据包中，表示客户端收到的具体内容。 5.1 MQTT固定头 固定头存在于所有MQTT数据包中，包含两部分内容：首字节(Byte 1) 和 剩余消息报文长度(1-4字节) Byte 1 首字节： Bit 7 6 5 4 高四位无符号值，用于表示MQTT消息的报文类型(MQTT Control Packet type)，总共可以表示2^4=16种协议类型。 Bit 3 2 1 0 低四位无符号值，用作某些报文的特殊标记(Flags specific to each MQTT Control Packet type)。 Byte 2… Remaining Length 剩余消息报文长度 5.1.1 MQTT数据包类型 MQTT Control Packet type 位于 首字节的高四位，即Byte 1中的 bits 7-4，相于一个4位的无符号值。用于确定报文类型。共有2^4=16种，其中0000和1111是保留字段。具体如下： 报文类型 字段值 数据方向 描述 保留 0 禁用 保留 CONNECT 1 Client -&gt; Server 客户端连接到服务器 CONNACK 2 Server -&gt; Client 连接确认 PUBLISH 3 Client &lt;-&gt; Server 发布消息 PUBACK 4 Client &lt;-&gt; Server 发布确认 PUBREC 5 Client &lt;-&gt; Server 消息已接收(QoS2第一阶段) PUBREL 6 Client &lt;-&gt; Server 消息释放(QoS2第二阶段) PUBCOMP 7 Client &lt;-&gt; Server 发布结束(QoS2第三阶段) SUBSCRIBE 8 Client -&gt; Server 客户端订阅请求 SUBACK 9 Server -&gt; Client 服务端订阅确认 UNSUBACRIBE 10 Client -&gt; Server 客户端取消订阅 UNSUBACK 11 Server -&gt; Client 服务端取消订阅确认 PINGREQ 12 Client -&gt; Server 客户端发送心跳 PINGRESP 13 Server -&gt; Client 服务端回复心跳 DISCONNECT 14 Client -&gt; Server 客户端断开连接请求 保留 15 禁用 保留 5.1.2 标识位 Flags specific to each MQTT Control Packet type 位于首字节的低四位，即Byte 1中bits 3-0。表示某些报文类型的控制字段，实际上只有少数报文类型有控制位。 在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接： DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。 QoS：发布消息的服务质量，即：保证消息传递的次数。 Ø00：最多一次，即：&lt;=1 Ø01：至少一次，即：&gt;=1 Ø10：一次，即：=1 Ø11：预留 RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 5.1.3 剩余长度（Remaining Length） 用来保存变长头部(Variable Header)和消息体(Payload)的总大小。从第二字节(Byte 2)开始，最长可达4字节，所以剩余长度范围是Byte[2-5]。那么怎样确定其长度到底是1字节还是4字节呢？它先用从低位Bit 0到Bit 6来存储，当发现不够时，则将 最高位Bit 7(默认都是高字节在前)置为 1，表示长度不足，需要使用下一个字节继续保存，就继续计算字节长度；如果是0，那么就不再计算字节长度。 消息长度可以简单理解为128进制的数据，4位长度最大可以表示128, 128*,* 128*128Byte=256MB。但是这个长度的计算有些特别，就是低位在前，高位在后(因为正常的表示方法是高位在前，低位在后)，字节最高位Bit7用于标记是否需要继续计算消息长度。以下是消息长度的长度范围： 字节数 长度最小值 长度最大值 1 0(0x00) 127(0x7F) 2 128 (0x80, 0x01) 16 383 (0xFF, 0x7F) 3 16 384 (0x80, 0x80, 0x01) 2 097 151 (0xFF, 0xFF, 0x7F) 4 2 097 152 (0x80, 0x80, 0x80, 0x01) 268 435 455 (0xFF, 0xFF, 0xFF, 0x7F) 5.2 MQTT可变头 MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识： 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。 5.3 Payload消息体 Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息： CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。 SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。 SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。 UNSUBSCRIBE，消息体内容是要订阅的主题。 ","link":"https://kangjn.github.io/post/mqtt-jian-jie/"},{"title":"Vue2.0 + TypeScript 项目搭建","content":"安装 cli Vue CLI 3 可以使用 TypeScript 生成新工程。创建方式： npm install --global @vue/cli 2. 创建一个新工程，并选择 &quot;Manually select features (手动选择特性)&quot; 选项 vue create my-project-name vue create my-project-name Vue CLI v4.5.12 ? Please pick a preset: Manually select features ? Check the features needed for your project: Choose Vue version, Babel, TS, PWA, Router, Vuex, CSS Pre-processors, Linter, Unit ? Choose a version of Vue.js that you want to start the project with 2.x ? Use class-style component syntax? Yes ? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes ? Use history mode for router? (Requires proper server setup for index fallback in production) Yes ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less ? Pick a linter / formatter config: Standard ? Pick additional lint features: Lint on save ? Pick a unit testing solution: Mocha ? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files ? Save this as a preset for future projects? No 配置 vue.config.js 根目录新建vue.config.js文件 1、publicPath 项目根路径 module.exports = { publicPath: '/',//根路径 cli3.0以上使用publicPath } 2、assetsDir 静态资源目录(js,css,img,fonts)这些文件都可以写里面 module.exports = { assetsDir: 'static',// 静态资源目录(js,css,img,fonts)这些文件都可以写里面 } 3、outputDir 打包输出目录 module.exports = { outputDir: 'dist',//打包的时候生成的一个文件名 } 4、lintOnSave 是否开启eslint保存检测 ,它的有效值为 true || false || 'error' module.exports = { lintOnSave: 'error',//是否开启eslint保存检测 ,它的有效值为 true || false || 'error' } 5、biyi-admin 指定对第三方依赖包进行babel-polyfill处理 module.exports = { transpileDependencies: [ 'biyi-admin', // 指定对第三方依赖包进行babel-polyfill处理 ], } 6、productionSourceMap 生产环境是否生成 sourceMap 文件 module.exports = { productionSourceMap: false, // 生产环境是否生成 sourceMap 文件 } 7、别名配置 '@' './src' ; '@a' './src/assets' ; '@c' './src/components' ; '@p' './src/pages' const path = require('path'); module.exports = { chainWebpack: config =&gt; { // 别名配置 config.resolve.alias .set('@', path.resolve(__dirname, './src')) .set('@a', path.resolve(__dirname, './src/assets')) .set('@c', path.resolve(__dirname, './src/components')) .set('@p', path.resolve(__dirname, './src/pages')) }, } 8、解决ie11兼容ES6 安装依赖 yarn add babel-polyfill module.exports = { chainWebpack: config =&gt; { // 解决ie11兼容ES6 config.entry('main').add('babel-polyfill'); }, } 9、symlinks 符号链接的资源将解析到其实际路径，而不是符号链接的位 module.exports = { chainWebpack: config =&gt; { // 修复HMR config.resolve.symlinks(true); }, } 10、gzip 压缩 yarn add terser-webpack-plugin --dev yarn add compression-webpack-plugin --dev package.json { &quot;openGzip&quot;: true, } let {version, openGzip} = require('./package.json'); module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = &quot;production&quot;; if (openGzip) { config.plugins.push( new CompressionWebpackPlugin({ filename: '[path].gz[query]', algorithm: 'gzip', test: /.js|\\.html|.\\css/, // 匹配文件名 threshold: 10240, // 只有大小大于该值的资源会被处理 10240 minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理 deleteOriginalAssets: false, // 删除原文件 }) ) } } else { // 为开发环境修改配置... config.mode = &quot;development&quot;; } }, } 11、打包文件大小配置 module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = &quot;production&quot;; // 打包文件大小配置 config[&quot;performance&quot;] = { hints: &quot;error&quot;, maxEntrypointSize: 400000, maxAssetSize: 30000000 }; } else { // 为开发环境修改配置... config.mode = &quot;development&quot;; } }, } 12、将每个依赖包打包成单独的js文件 let {version, openGzip} = require('./package.json'); module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = &quot;production&quot;; // 将每个依赖包打包成单独的js文件 Object.assign(config, { output: { ...config.output, filename: `static/js/[name].[chunkhash].${version}.js`, chunkFilename: `static/js/[name].[chunkhash].${version}.js` }, }) } else { // 为开发环境修改配置... config.mode = &quot;development&quot;; } }, } 13、去除线上的 console module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = &quot;production&quot;; Object.assign(config, { optimization: { minimizer: [ new TerserPlugin({ cache: true, // 是否缓存 // paraller: true, // 是否并行打包 sourceMap: true, terserOptions: { compress: { pure_funcs: [&quot;console.log&quot;] } } }) ], } }) } else { // 为开发环境修改配置... config.mode = &quot;development&quot;; } }, } 14、css相关配置 根目录创建 postcss.config.js module.exports = { plugins: [ // 兼容浏览器，添加前缀 require('autoprefixer')({ overrideBrowserslist: [ &quot;Android 4.1&quot;, &quot;iOS 7.1&quot;, &quot;Chrome &gt; 31&quot;, &quot;ff &gt; 31&quot;, &quot;ie &gt;= 8&quot; //'last 10 versions', // 所有主流浏览器最近10版本用 ], grid: true }) ] } module.exports = { // css相关配置 css: { extract: false, // 是否使用css分离插件 ExtractTextPlugin sourceMap: false, // 开启 CSS source maps? loaderOptions: { less: { javascriptEnabled: true }, css: {}, // 这里的选项会传递给 css-loader postcss: {} // 这里的选项会传递给 postcss-loader }, // css预设器配置项 详见https://cli.vuejs.org/zh/config/#css-loaderoptions requireModuleExtension: true // 启用 CSS requireModuleExtension for all css / pre-processor files. }, } 15、parallel 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 module.exports = { parallel: require('os').cpus().length &gt; 1, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 } 16、webpack-dev-server 相关配置 module.exports = { devServer: { open: true,// 打开谷歌 host: '0.0.0.0', // 允许外部ip访问 port: 8081, // 端口 https: false, // 启用https overlay: { warnings: true, errors: true }, // 错误、警告在页面弹出 proxy: { '/api': { target: ${process.env.VUE_APP_BASE_API}/api, changeOrigin: true, // 允许websockets跨域 // ws: true, pathRewrite: { '^/api': '' } } } // 代理转发配置，用于调试环境 }, } 17、环境变量和模式 根目录添加 .env 文件 【默认环境变量】 NODE_ENV = 'production' VUE_APP_MOCK = false VUE_APP_CDN = '' VUE_APP_BASE_API = '' 根目录添加 .env.development 文件 【开发环境变量】 NODE_ENV = 'development' VUE_APP_MOCK = true 根目录添加 .env.production 文件 【生产环境变量】 NODE_ENV = 'production' VUE_APP_MOCK = false VUE_APP_BASE_API = '' VUE_APP_CDN = '' 最终 vue.config.js /** @FileName vue.config.js @Author @Version V 0.0.1 @Date @Title Vue配置文件 @Desc **/ const path = require('path'); const TerserPlugin = require('terser-webpack-plugin'); const CompressionWebpackPlugin = require('compression-webpack-plugin'); const isProduction = process.env.NODE_ENV === 'production'; const {version, openGzip} = require('./package.json'); module.exports = { devServer: { open: false, host: '0.0.0.0', port: 8082, https: false, disableHostCheck: true, overlay: { warnings: true, errors: true }, proxy: { '/api': { target: ${process.env.VUE_APP_BASE_API}, changeOrigin: true, // ws: true, pathRewrite: { '^/api': '' } } } }, chainWebpack: config =&gt; { config.entry('main').add('babel-polyfill'); config.resolve.symlinks(true); config.resolve.alias .set('@', path.resolve(__dirname, './src')) .set('@a', path.resolve(__dirname, './src/assets')) .set('@c', path.resolve(__dirname, './src/components')) .set('@p', path.resolve(__dirname, './src/pages')) .set('@l', path.resolve(__dirname, './src/layout')); }, publicPath: '/', assetsDir: 'static', outputDir: 'dist', lintOnSave: 'error', transpileDependencies: ['biyi-admin'], productionSourceMap: false, configureWebpack: config =&gt; { console.log(isProduction); if (isProduction) { config.mode = 'production'; if (openGzip) { config.plugins.push( new CompressionWebpackPlugin({ filename: '[path].gz[query]', algorithm: 'gzip', test: /.js|\\.html|.\\css/, // 匹配文件名 threshold: 10240, // 只有大小大于该值的资源会被处理 10240 minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理 deleteOriginalAssets: false // 删除原文件 }) ); // 将每个依赖包打包成单独的js文件 Object.assign(config, { performance: { hints: 'error', maxEntrypointSize: 10000000, maxAssetSize: 30000000 }, output: { ...config.output, filename: `static/js/[name].[chunkhash].${version}.js`, chunkFilename: `static/js/[name].[chunkhash].${version}.js` }, optimization: { minimizer: [ new TerserPlugin({ cache: true, // 是否缓存 // paraller: true, // 是否并行打包 sourceMap: true, terserOptions: { compress: { pure_funcs: ['console.log'] } } }) ] } }); } } else { config.mode = 'development'; } }, css: { extract: false, sourceMap: false, loaderOptions: { less: { javascriptEnabled: true }, css: {}, postcss: {} }, requireModuleExtension: true }, parallel: require('os').cpus().length &gt; 1, pwa: {}, pluginOptions: {} }; package.json { &quot;name&quot;: &quot;big-data-platform&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;openGzip&quot;: true, &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; }, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.21.1&quot;, &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;, &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;localforage&quot;: &quot;^1.9.0&quot;, &quot;moment&quot;: &quot;^2.29.1&quot;, &quot;register-service-worker&quot;: &quot;^1.7.1&quot;, &quot;view-design&quot;: &quot;^4.5.0&quot;, &quot;vue&quot;: &quot;^2.6.11&quot;, &quot;vue-class-component&quot;: &quot;^7.2.3&quot;, &quot;vue-property-decorator&quot;: &quot;^9.1.2&quot;, &quot;vue-router&quot;: &quot;^3.2.0&quot;, &quot;vuex&quot;: &quot;^3.4.0&quot; }, &quot;devDependencies&quot;: { &quot;@types/chai&quot;: &quot;^4.2.11&quot;, &quot;@types/mocha&quot;: &quot;^5.2.4&quot;, &quot;@types/mockjs&quot;: &quot;^1.0.3&quot;, &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.18.0&quot;, &quot;@typescript-eslint/parser&quot;: &quot;^4.18.0&quot;, &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-pwa&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-router&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-typescript&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-unit-mocha&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-vuex&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;@vue/eslint-config-standard&quot;: &quot;^5.1.2&quot;, &quot;@vue/eslint-config-typescript&quot;: &quot;^7.0.0&quot;, &quot;@vue/test-utils&quot;: &quot;^1.0.3&quot;, &quot;chai&quot;: &quot;^4.1.2&quot;, &quot;compression-webpack-plugin&quot;: &quot;^7.1.2&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;, &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;, &quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;, &quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, &quot;less&quot;: &quot;^3.0.4&quot;, &quot;less-loader&quot;: &quot;^5.0.0&quot;, &quot;mockjs&quot;: &quot;^1.1.0&quot;, &quot;terser-webpack-plugin&quot;: &quot;^5.1.1&quot;, &quot;typescript&quot;: &quot;~4.1.5&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot; } } 配置eslint package.json 文件 { &quot;devDependencies&quot;: { &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.18.0&quot;, &quot;@typescript-eslint/parser&quot;: &quot;^4.18.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;, &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;, &quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;, &quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;, }, } 根目录添加 .eslintrc.js 配置文件 module.exports = { root: true, env: { node: true }, extends: [ 'plugin:vue/essential', '@vue/standard', '@vue/typescript/recommended' ], parserOptions: { ecmaVersion: 2020 }, rules: { 'no-console': 'off', 'indent': ['off', 2], 'semi': [2, 'always'], // 语句强制分号结尾 'quotes': [2, 'single'], // js必须使用单引号 'vue/no-parsing-error': 'off', 'no-irregular-whitespace': 'off', 'no-async-promise-executor': 'off', 'space-before-function-paren': 'off', 'object-curly-spacing': ['error', 'never'], 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', '@typescript-eslint/no-this-alias': 'off', '@typescript-eslint/ban-ts-ignore': 'off', '@typescript-eslint/no-unused-vars': 'off', '@typescript-eslint/ban-ts-comment': 'off', '@typescript-eslint/no-explicit-any': 'off', '@typescript-eslint/no-empty-function': 'off', '@typescript-eslint/explicit-module-boundary-types': 'off' }, overrides: [ { files: [ '/tests/*.{j,t}s?(x)', '/tests/unit/**/*.spec.{j,t}s?(x)' ], env: { mocha: true } } ] } 工具类封装 Cookie操作 /** @FileName cookie.ts @Author @Version V 0.0.1 @Date @Title Cookie操作 @Desc **/ /** 设置cookie @param name @param value @param hours @param path */ const setCookie = (name: string, value: any, hours: number, path: string) =&gt; { const expires = new Date(); expires.setTime(expires.getTime() + hours * 3600000); const expiresTxt = typeof hours === 'string' ? '' : ;expires=${expires.toUTCString()}; document.cookie = ${escape(name)}=${escape(value)}${expiresTxt}${path === '' ? '' :;path=${path}}; }; /** 获取cookie值 @param name */ const getCookieValue = (name: string) =&gt; { let nameTxt = escape(name); // 读cookie属性，这将返回文档的所有cookie const allCookies = document.cookie; // 查找名为name的cookie的开始位置 nameTxt += '='; const pos = allCookies.indexOf(nameTxt); // 如果找到了具有该名字的cookie，那么提取并使用它的值 if (pos !== -1) { // 如果pos值为-1则说明搜索'version='失败 const start = pos + nameTxt.length; // cookie值开始的位置 let end = allCookies.indexOf(';', start); // 从cookie值开始的位置起搜索第一个';'的位置,即cookie值结尾的位置 if (end === -1) end = allCookies.length; // 如果end值为-1说明cookie列表里只有一个cookie // 提取cookie的值 return allCookies.substring(start, end); // 对它解码 } return ''; // 搜索失败，返回空字符串 }; /** 删除cookie @param name @param path */ const deleteCookie = (name: string, path: string) =&gt; { const expires = new Date(0); document.cookie = ${escape(name)}=;expires=${expires.toUTCString()}${path === '' ? '' :;path=${path}}; }; export default { setCookie, getCookieValue, deleteCookie }; createRoutes yarn add view-design /** @FileName createRoutes.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import Vue from 'vue'; import VueRouter from 'vue-router'; import {LoadingBar} from 'view-design'; Vue.use(VueRouter); const VueRouterPush = VueRouter.prototype.push; VueRouter.prototype.push = function push(to: any): any { const a: any = VueRouterPush.call(this, to); a.catch((err: any) =&gt; err); return a; }; LoadingBar.config({ color: '#ff9900', failedColor: '#ed4014', height: 3, duration: 800 }); const createRouter = (baseRoutes: any = [], routes: any = [], base = '', homeName = 'home', mode: any = 'history', title = '', turnTo: any = () =&gt; { }) =&gt; { const router = new VueRouter({ mode: mode, base: base, routes: [ ...routes, ...baseRoutes ] }); // 全局守卫 router.beforeEach((to: any, from: any, next: any) =&gt; { LoadingBar.start(); turnTo(to, next, homeName); }); // 全局后置钩子 router.afterEach((to: any) =&gt; { if (to.meta.title) { document.title = title ? to.meta.title + '-' + title : to.meta.title; } LoadingBar.finish(); window.scrollTo(0, 0); }); return router; }; export default createRouter; gbk /** @FileName gbk.js @Author @Version V 0.0.1 @Date @Title 序列化 反序列化 @Desc */ / eslint-disable */ const util = function () { var data = function (zipData: any) { return zipData .replace(/#(\\d+)$/g, function (a: any, b: any) { return Array(+b + 3).join('#'); }) .replace(/#/g, '####') .replace(/(\\w\\w)😦[\\w#]+)(?:,|)/g, function (a: any, hd: any, dt: any) { return dt.replace(/../g, function (a: any) { if (a != &#039;##&#039;) { return hd + a; } else { return a; } }); }); }(&#039;4e:020405060f12171f20212326292e2f313335373c40414244464a5155575a5b6263646567686a6b6c6d6e6f727475767778797a7b7c7d7f808182838485878a#909697999c9d9ea3aaafb0b1b4b6b7b8b9bcbdbec8cccfd0d2dadbdce0e2e6e7e9edeeeff1f4f8f9fafcfe,4f:00020304050607080b0c12131415161c1d212328292c2d2e31333537393b3e3f40414244454748494a4b4c525456616266686a6b6d6e7172757778797a7d8081828586878a8c8e909293959698999a9c9e9fa1a2a4abadb0b1b2b3b4b6b7b8b9babbbcbdbec0c1c2c6c7c8c9cbcccdd2d3d4d5d6d9dbe0e2e4e5e7ebecf0f2f4f5f6f7f9fbfcfdff,50:000102030405060708090a#0b0e1011131516171b1d1e20222324272b2f303132333435363738393b3d3f404142444546494a4b4d5051525354565758595b5d5e5f6061626364666768696a6b6d6e6f70717273747578797a7c7d818283848687898a8b8c8e8f909192939495969798999a9b9c9d9e9fa0a1a2a4a6aaabadaeafb0b1b3b4b5b6b7b8b9bcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdced0d1d2d3d4d5d7d8d9dbdcdddedfe0e1e2e3e4e5e8e9eaebeff0f1f2f4f6f7f8f9fafcfdfeff,51:00010203040508#090a0c0d0e0f1011131415161718191a1b1c1d1e1f2022232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e42474a4c4e4f5052535758595b5d5e5f606163646667696a6f727a7e7f838486878a8b8e8f90919394989a9d9e9fa1a3a6a7a8a9aaadaeb4b8b9babebfc1c2c3c5c8cacdced0d2d3d4d5d6d7d8d9dadcdedfe2e3e5e6e7e8e9eaeceef1f2f4f7fe,52:0405090b0c0f101314151c1e1f2122232526272a2c2f313234353c3e4445464748494b4e4f5253555758#595a5b5d5f6062636466686b6c6d6e7071737475767778797a7b7c7e808384858687898a8b8c8d8e8f91929495969798999a9ca4a5a6a7aeafb0b4b5b6b7b8b9babbbcbdc0c1c2c4c5c6c8cacccdcecfd1d3d4d5d7d9dadbdcdddee0e1e2e3e5e6e7e8e9eaebecedeeeff1f2f3f4f5f6f7f8fbfcfd,53:0102030407090a0b0c0e11121314181b1c1e1f2224252728292b2c2d2f3031323334353637383c3d404244464b4c4d505458595b5d65686a6c6d7276797b7c7d7e80818387888a8e8f#90919293949697999b9c9ea0a1a4a7aaabacadafb0b1b2b3b4b5b7b8b9babcbdbec0c3c4c5c6c7cecfd0d2d3d5dadcdddee1e2e7f4fafeff,54:000205070b1418191a1c2224252a303336373a3d3f4142444547494c4d4e4f515a5d5e5f6061636567696a6b6c6d6e6f7074797a7e7f8183858788898a8d919397989c9e9fa0a1a2a5aeb0b2b5b6b7b9babcbec3c5cacbd6d8dbe0e1e2e3e4ebeceff0f1f4f5f6f7f8f9fbfe,55:0002030405080a0b0c0d0e121315161718191a1c1d1e1f212526#28292b2d3234353638393a3b3d40424547484b4c4d4e4f515253545758595a5b5d5e5f60626368696b6f7071727374797a7d7f85868c8d8e9092939596979a9b9ea0a1a2a3a4a5a6a8a9aaabacadaeafb0b2b4b6b8babcbfc0c1c2c3c6c7c8cacbcecfd0d5d7d8d9dadbdee0e2e7e9edeef0f1f4f6f8f9fafbfcff,56:0203040506070a0b0d1011121314151617191a1c1d202122252628292a2b2e2f30333537383a3c3d3e404142434445464748494a4b4f5051525355565a5b5d5e5f6061#636566676d6e6f70727374757778797a7d7e7f80818283848788898a8b8c8d9091929495969798999a9b9c9d9e9fa0a1a2a4a5a6a7a8a9aaabacadaeb0b1b2b3b4b5b6b8b9babbbdbebfc0c1c2c3c4c5c6c7c8c9cbcccdcecfd0d1d2d3d5d6d8d9dce3e5e6e7e8e9eaeceeeff2f3f6f7f8fbfc,57:00010205070b0c0d0e0f101112131415161718191a1b1d1e202122242526272b313234353637383c3d3f414344454648494b52535455565859626365676c6e707172747578797a7d7e7f80#818788898a8d8e8f90919495969798999a9c9d9e9fa5a8aaacafb0b1b3b5b6b7b9babbbcbdbebfc0c1c4c5c6c7c8c9cacccdd0d1d3d6d7dbdcdee1e2e3e5e6e7e8e9eaebeceef0f1f2f3f5f6f7fbfcfeff,58:0103040508090a0c0e0f101213141617181a1b1c1d1f222325262728292b2c2d2e2f31323334363738393a3b3c3d3e3f4041424345464748494a4b4e4f505253555657595a5b5c5d5f6061626364666768696a6d6e6f707172737475767778797a7b7c7d7f82848687888a8b8c#8d8e8f909194959697989b9c9da0a1a2a3a4a5a6a7aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbdbebfc0c2c3c4c6c7c8c9cacbcccdcecfd0d2d3d4d6d7d8d9dadbdcdddedfe0e1e2e3e5e6e7e8e9eaedeff1f2f4f5f7f8fafbfcfdfeff,59:000103050608090a0b0c0e1011121317181b1d1e2021222326282c30323335363b3d3e3f404345464a4c4d505253595b5c5d5e5f616364666768696a6b6c6d6e6f70717275777a7b7c7e7f8085898b8c8e8f90919495989a9b9c9d9fa0a1a2a6#a7acadb0b1b3b4b5b6b7b8babcbdbfc0c1c2c3c4c5c7c8c9cccdcecfd5d6d9dbdedfe0e1e2e4e6e7e9eaebedeeeff0f1f2f3f4f5f6f7f8fafcfdfe,5a:00020a0b0d0e0f101214151617191a1b1d1e2122242627282a2b2c2d2e2f3033353738393a3b3d3e3f414243444547484b4c4d4e4f5051525354565758595b5c5d5e5f60616364656668696b6c6d6e6f7071727378797b7c7d7e808182838485868788898a8b8c8d8e8f9091939495969798999c9d9e9fa0a1a2a3a4a5a6a7a8a9abac#adaeafb0b1b4b6b7b9babbbcbdbfc0c3c4c5c6c7c8cacbcdcecfd0d1d3d5d7d9dadbdddedfe2e4e5e7e8eaecedeeeff0f2f3f4f5f6f7f8f9fafbfcfdfeff,5b:0001020304050607080a0b0c0d0e0f10111213141518191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303133353638393a3b3c3d3e3f4142434445464748494a4b4c4d4e4f52565e606167686b6d6e6f7274767778797b7c7e7f82868a8d8e90919294969fa7a8a9acadaeafb1b2b7babbbcc0c1c3c8c9cacbcdcecf#d1d4d5d6d7d8d9dadbdce0e2e3e6e7e9eaebecedeff1f2f3f4f5f6f7fdfe,5c:0002030507080b0c0d0e10121317191b1e1f2021232628292a2b2d2e2f303233353637434446474c4d5253545657585a5b5c5d5f62646768696a6b6c6d70727374757677787b7c7d7e808384858687898a8b8e8f9293959d9e9fa0a1a4a5a6a7a8aaaeafb0b2b4b6b9babbbcbec0c2c3c5c6c7c8c9cacccdcecfd0d1d3d4d5d6d7d8dadbdcdddedfe0e2e3e7e9ebeceeeff1f2f3f4f5f6f7f8f9fafcfdfeff,5d:00#01040508090a0b0c0d0f10111213151718191a1c1d1f2021222325282a2b2c2f3031323335363738393a3b3c3f4041424344454648494d4e4f5051525354555657595a5c5e5f6061626364656667686a6d6e7071727375767778797a7b7c7d7e7f8081838485868788898a8b8c8d8e8f9091929394959697989a9b9c9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b8b9babbbcbdbebfc0c1c2c3c4c6c7c8c9cacbcccecfd0d1d2d3d4d5d6d7d8d9dadcdfe0e3e4eaeced#f0f5f6f8f9fafbfcff,5e:000407090a0b0d0e1213171e1f20212223242528292a2b2c2f303233343536393a3e3f404143464748494a4b4d4e4f50515253565758595a5c5d5f60636465666768696a6b6c6d6e6f70717577797e8182838588898c8d8e92989b9da1a2a3a4a8a9aaabacaeafb0b1b2b4babbbcbdbfc0c1c2c3c4c5c6c7c8cbcccdcecfd0d4d5d7d8d9dadcdddedfe0e1e2e3e4e5e6e7e9ebecedeeeff0f1f2f3f5f8f9fbfcfd,5f:050607090c0d0e10121416191a1c1d1e21222324#282b2c2e30323334353637383b3d3e3f4142434445464748494a4b4c4d4e4f5154595a5b5c5e5f60636567686b6e6f72747576787a7d7e7f83868d8e8f919394969a9b9d9e9fa0a2a3a4a5a6a7a9abacafb0b1b2b3b4b6b8b9babbbebfc0c1c2c7c8cacbced3d4d5dadbdcdedfe2e3e5e6e8e9eceff0f2f3f4f6f7f9fafc,60:0708090b0c10111317181a1e1f2223242c2d2e3031323334363738393a3d3e404445464748494a4c4e4f5153545657585b5c5e5f606165666e71727475777e80#8182858687888a8b8e8f909193959798999c9ea1a2a4a5a7a9aaaeb0b3b5b6b7b9babdbebfc0c1c2c3c4c7c8c9cccdcecfd0d2d3d4d6d7d9dbdee1e2e3e4e5eaf1f2f5f7f8fbfcfdfeff,61:02030405070a0b0c1011121314161718191b1c1d1e21222528292a2c2d2e2f303132333435363738393a3b3c3d3e4041424344454647494b4d4f50525354565758595a5b5c5e5f606163646566696a6b6c6d6e6f717273747678797a7b7c7d7e7f808182838485868788898a8c8d8f9091929395#969798999a9b9c9e9fa0a1a2a3a4a5a6aaabadaeafb0b1b2b3b4b5b6b8b9babbbcbdbfc0c1c3c4c5c6c7c9cccdcecfd0d3d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e7e8e9eaebecedeeeff0f1f2f3f4f6f7f8f9fafbfcfdfe,62:00010203040507091314191c1d1e2023262728292b2d2f303132353638393a3b3c424445464a4f50555657595a5c5d5e5f6061626465687172747577787a7b7d818283858687888b8c8d8e8f9094999c9d9ea3a6a7a9aaadaeafb0b2b3b4b6b7b8babec0c1#c3cbcfd1d5dddee0e1e4eaebf0f2f5f8f9fafb,63:00030405060a0b0c0d0f10121314151718191c2627292c2d2e30313334353637383b3c3e3f40414447484a51525354565758595a5b5c5d60646566686a6b6c6f707273747578797c7d7e7f81838485868b8d9193949597999a9b9c9d9e9fa1a4a6abafb1b2b5b6b9bbbdbfc0c1c2c3c5c7c8cacbccd1d3d4d5d7d8d9dadbdcdddfe2e4e5e6e7e8ebeceeeff0f1f3f5f7f9fafbfcfe,64:0304060708090a0d0e111215161718191a1d1f222324#252728292b2e2f3031323335363738393b3c3e404243494b4c4d4e4f505153555657595a5b5c5d5f60616263646566686a6b6c6e6f70717273747576777b7c7d7e7f8081838688898a8b8c8d8e8f90939497989a9b9c9d9fa0a1a2a3a5a6a7a8aaabafb1b2b3b4b6b9bbbdbebfc1c3c4c6c7c8c9cacbcccfd1d3d4d5d6d9dadbdcdddfe0e1e3e5e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,65:01020304050607080a0b0c0d0e0f10111314151617191a1b1c1d1e1f2021#222324262728292a2c2d30313233373a3c3d404142434446474a4b4d4e5052535457585a5c5f606164656768696a6d6e6f7173757678797a7b7c7d7e7f8081828384858688898a8d8e8f92949596989a9d9ea0a2a3a6a8aaacaeb1b2b3b4b5b6b7b8babbbebfc0c2c7c8c9cacdd0d1d3d4d5d8d9dadbdcdddedfe1e3e4eaebf2f3f4f5f8f9fbfcfdfeff,66:0104050708090b0d1011121617181a1b1c1e2122232426292a2b2c2e3032333738393a3b3d3f40424445464748494a4d4e505158#595b5c5d5e6062636567696a6b6c6d7172737578797b7c7d7f808183858688898a8b8d8e8f909293949598999a9b9c9e9fa0a1a2a3a4a5a6a9aaabacadafb0b1b2b3b5b6b7b8babbbcbdbfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8dadedfe0e1e2e3e4e5e7e8eaebecedeeeff1f5f6f8fafbfd,67:010203040506070c0e0f1112131618191a1c1e20212223242527292e303233363738393b3c3e3f414445474a4b4d5254555758595a5b5d62636466676b6c6e717476#78797a7b7d8082838586888a8c8d8e8f9192939496999b9fa0a1a4a6a9acaeb1b2b4b9babbbcbdbebfc0c2c5c6c7c8c9cacbcccdced5d6d7dbdfe1e3e4e6e7e8eaebedeef2f5f6f7f8f9fafbfcfe,68:01020304060d1012141518191a1b1c1e1f20222324252627282b2c2d2e2f30313435363a3b3f474b4d4f52565758595a5b5c5d5e5f6a6c6d6e6f707172737578797a7b7c7d7e7f8082848788898a8b8c8d8e90919294959698999a9b9c9d9e9fa0a1a3a4a5a9aaabacaeb1b2b4b6b7b8#b9babbbcbdbebfc1c3c4c5c6c7c8cacccecfd0d1d3d4d6d7d9dbdcdddedfe1e2e4e5e6e7e8e9eaebecedeff2f3f4f6f7f8fbfdfeff,69:00020304060708090a0c0f11131415161718191a1b1c1d1e21222325262728292a2b2c2e2f313233353637383a3b3c3e4041434445464748494a4b4c4d4e4f50515253555658595b5c5f616264656768696a6c6d6f7072737475767a7b7d7e7f8183858a8b8c8e8f909192939697999a9d9e9fa0a1a2a3a4a5a6a9aaacaeafb0b2b3b5b6b8b9babcbd#bebfc0c2c3c4c5c6c7c8c9cbcdcfd1d2d3d5d6d7d8d9dadcdddee1e2e3e4e5e6e7e8e9eaebeceeeff0f1f3f4f5f6f7f8f9fafbfcfe,6a:000102030405060708090b0c0d0e0f10111213141516191a1b1c1d1e20222324252627292b2c2d2e30323334363738393a3b3c3f40414243454648494a4b4c4d4e4f515253545556575a5c5d5e5f60626364666768696a6b6c6d6e6f70727374757677787a7b7d7e7f81828385868788898a8b8c8d8f929394959698999a9b9c9d9e9fa1a2a3a4a5a6#a7a8aaadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,6b:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f252628292a2b2c2d2e2f303133343536383b3c3d3f4041424445484a4b4d4e4f5051525354555657585a5b5c5d5e5f606168696b6c6d6e6f7071727374757677787a7d7e7f808588#8c8e8f909194959798999c9d9e9fa0a2a3a4a5a6a7a8a9abacadaeafb0b1b2b6b8b9babbbcbdbec0c3c4c6c7c8c9caccced0d1d8dadcdddedfe0e2e3e4e5e6e7e8e9ecedeef0f1f2f4f6f7f8fafbfcfeff,6c:000102030408090a0b0c0e12171c1d1e2023252b2c2d31333637393a3b3c3e3f434445484b4c4d4e4f5152535658595a62636566676b6c6d6e6f71737577787a7b7c7f8084878a8b8d8e9192959697989a9c9d9ea0a2a8acafb0b4b5b6b7bac0c1c2c3c6c7c8cbcdcecfd1d2d8#d9dadcdddfe4e6e7e9ecedf2f4f9ff,6d:000203050608090a0d0f101113141516181c1d1f20212223242628292c2d2f30343637383a3f404244494c50555657585b5d5f6162646567686b6c6d707172737576797a7b7d7e7f8081838486878a8b8d8f9092969798999a9ca2a5acadb0b1b3b4b6b7b9babbbcbdbec1c2c3c8c9cacdcecfd0d2d3d4d5d7dadbdcdfe2e3e5e7e8e9eaedeff0f2f4f5f6f8fafdfeff,6e:0001020304060708090b0f12131518191b1c1e1f222627282a2c2e30313335#3637393b3c3d3e3f40414245464748494a4b4c4f5051525557595a5c5d5e606162636465666768696a6c6d6f707172737475767778797a7b7c7d8081828487888a8b8c8d8e91929394959697999a9b9d9ea0a1a3a4a6a8a9abacadaeb0b3b5b8b9bcbebfc0c3c4c5c6c8c9cacccdced0d2d6d8d9dbdcdde3e7eaebecedeeeff0f1f2f3f5f6f7f8fafbfcfdfeff,6f:000103040507080a0b0c0d0e101112161718191a1b1c1d1e1f212223252627282c2e303234353738393a3b3c3d3f404142#43444548494a4c4e4f5051525354555657595a5b5d5f60616364656768696a6b6c6f707173757677797b7d7e7f808182838586878a8b8f909192939495969798999a9b9d9e9fa0a2a3a4a5a6a8a9aaabacadaeafb0b1b2b4b5b7b8babbbcbdbebfc1c3c4c5c6c7c8cacbcccdcecfd0d3d4d5d6d7d8d9dadbdcdddfe2e3e4e5e6e7e8e9eaebecedf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,70:000102030405060708090a0b0c0d0e0f1012131415161718191c1d1e1f2021222425262728292a#2b2c2d2e2f30313233343637383a3b3c3d3e3f404142434445464748494a4b4d4e505152535455565758595a5b5c5d5f606162636465666768696a6e7172737477797a7b7d818283848687888b8c8d8f90919397989a9b9e9fa0a1a2a3a4a5a6a7a8a9aab0b2b4b5b6babebfc4c5c6c7c9cbcccdcecfd0d1d2d3d4d5d6d7dadcdddee0e1e2e3e5eaeef0f1f2f3f4f5f6f8fafbfcfeff,71:0001020304050607080b0c0d0e0f111214171b1c1d1e1f2021222324252728292a2b2c2d2e323334#353738393a3b3c3d3e3f4041424344464748494b4d4f505152535455565758595a5b5d5f6061626365696a6b6c6d6f707174757677797b7c7e7f8081828385868788898b8c8d8e909192939596979a9b9c9d9ea1a2a3a4a5a6a7a9aaabadaeafb0b1b2b4b6b7b8babbbcbdbebfc0c1c2c4c5c6c7c8c9cacbcccdcfd0d1d2d3d6d7d8d9dadbdcdddedfe1e2e3e4e6e8e9eaebecedeff0f1f2f3f4f5f6f7f8fafbfcfdfeff,72:0001020304050708090a0b0c0d0e0f101112131415161718191a#1b1c1e1f2021222324252627292b2d2e2f3233343a3c3e40414243444546494a4b4e4f505153545557585a5c5e60636465686a6b6c6d707173747677787b7c7d828385868788898c8e9091939495969798999a9b9c9d9ea0a1a2a3a4a5a6a7a8a9aaabaeb1b2b3b5babbbcbdbebfc0c5c6c7c9cacbcccfd1d3d4d5d6d8dadb#95,30:000102,00b702:c9c7,00a830:0305,2014ff5e20:162618191c1d,30:141508090a0b0c0d0e0f16171011,00:b1d7f7,22:362728110f2a2908371aa52520,231222:992b2e614c483d1d606e6f64651e3534,26:4240,00b020:3233,2103ff0400a4ff:e0e1,203000a7211626:0605,25:cbcfcec7c6a1a0b3b2,203b21:92909193,30:13#95,21:70717273747576777879#4,24:88898a8b8c8d8e8f909192939495969798999a9b7475767778797a7b7c7d7e7f808182838485868760616263646566676869##,32:20212223242526272829##,21:606162636465666768696a6b#97,ff:010203e505060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5de3#95,30:4142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f90919293#106a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6#103,03:9192939495969798999a9b9c9d9e9fa0a1a3a4a5a6a7a8a9#6b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c3c4c5c6c7c8c9#5,fe:3536393a3f403d3e41424344##3b3c373831#3334#104$,04:10111213141501161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f#1330313233343551363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f#11,02:cacbd9,20:13152535,21:050996979899,22:151f23526667bf,25:505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f7071727381828384858687#88898a8b8c8d8e8f939495bcbde2e3e4e5,2609229530:121d1e#9,010100e101ce00e0011300e9011b00e8012b00ed01d000ec014d00f301d200f2016b00fa01d400f901:d6d8dadc,00:fcea,0251e7c701:4448,e7c802:61#2,31:05060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223242526272829#19,30:212223242526272829,32a333:8e8f9c9d9ea1c4ced1d2d5,fe30ff:e2e4#,212132:31#,20:10#1,30:fc9b9cfdfe069d9e,fe:494a4b4c4d4e4f50515254555657595a5b5c5d5e5f6061#626364656668696a6b,e7:e7e8e9eaebecedeeeff0f1f2f3,30:07#11,25:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b#13,72:dcdddfe2e3e4e5e6e7eaebf5f6f9fdfeff,73:00020405060708090b0c0d0f1011121418191a1f2023242627282d2f30323335363a3b3c3d404142434445464748#494a4b4c4e4f515354555658595a5b5c5d5e5f6162636465666768696a6b6e7071#9272737475767778797a7b7c7d7f808182838586888a8c8d8f90929394959798999a9c9d9ea0a1a3a4a5a6a7a8aaacadb1b4b5b6b8b9bcbdbebfc1c3c4c5c6c7#cbccced2d3d4d5d6d7d8dadbdcdddfe1e2e3e4e6e8eaebeceeeff0f1f3f4f5f6f7#92f8f9fafbfcfdfeff,74:0001020407080b0c0d0e1112131415161718191c1d1e1f2021232427292b2d2f31323738393a3b3d3e3f4042434445464748494a4b4c4d#4e4f505152535456585d606162636465666768696a6b6c6e6f717273747578797a#927b7c7d7f8284858688898a8c8d8f9192939495969798999a9b9d9fa0a1a2a3a4a5a6aaabacadaeafb0b1b2b3b4b5b6b7b8b9bbbcbdbebfc0c1c2c3c4c5c6c7#c8c9cacbcccdcecfd0d1d3d4d5d6d7d8d9dadbdddfe1e5e7e8e9eaebecedf0f1f2#92f3f5f8f9fafbfcfdfe,75:0001020305060708090a0b0c0e1012141516171b1d1e202122232426272a2e3436393c3d3f414243444647494a4d5051525355565758#5d5e5f60616263646768696b6c6d6e6f7071737576777a7b7c7d7e808182848587#92$88898a8c8d8e909395989b9c9ea2a6a7a8a9aaadb6b7babbbfc0c1c6cbcccecfd0d1d3d7d9dadcdddfe0e1e5e9ecedeeeff2f3f5f6f7f8fafbfdfe,76:02040607#08090b0d0e0f11121314161a1c1d1e212327282c2e2f31323637393a3b3d414244#9245464748494a4b4e4f50515253555758595a5b5d5f6061626465666768696a6c6d6e7071727374757677797a7c7f80818385898a8c8d8f9092949597989a9b#9c9d9e9fa0a1a2a3a5a6a7a8a9aaabacadafb0b3b5b6b7b8b9babbbcbdbec0c1c3,554a963f57c3632854ce550954c076:914c,853c77ee827e788d72319698978d6c285b894ffa630966975cb880fa684880ae660276ce51f9655671ac7ff1888450b2596561ca6fb382ad634c625253ed54277b06516b75a45df462d48dcb9776628a8019575d97387f627238767d67cf767e64464f708d2562dc7a17659173ed642c6273822c9881677f724862:6ecc,4f3474e3534a529e7eca90a65e2e6886699c81807ed168d278c5868c9551508d8c2482de80de53058912526576:c4c7c9cbccd3d5d9dadcdddee0e1e2e3e4e6e7e8e9eaebecedf0f3f5f6f7fafbfdff,77:00020305060a0c0e0f1011121314151617181b1c1d1e21232425272a2b#2c2e3031323334393b3d3e3f4244454648494a4b4c4d4e4f52535455565758595c,858496f94fdd582199715b9d62:b1a5,66b48c799c8d7206676f789160b253:5117,8f8880cc8d1d94a1500d72c8590760eb711988ab595482ef672c7b285d297ef7752d6cf58e668ff8903c9f3b6bd491197b145f7c78a784d6853d6b:d5d9d6,5e:0187,75f995ed655d5f:0ac5,8f9f58c181c2907f965b97ad8fb97f168d2c62414fbf53:d85e,8f:a8a9ab,904d68075f6a819888689cd6618b522b762a5f6c658c6fd26ee85bbe644851:75b0,67c44e1979c9997c70b377:5d5e5f606467696a6d6e6f7071727374757677787a7b7c818283868788898a8b8f90939495969798999a9b9c9d9ea1a3a4a6a8abadaeafb1b2b4b6b7b8b9ba#bcbec0c1c2c3c4c5c6c7c8c9cacbcccecfd0d1d2d3d4d5d6d8d9dadddedfe0e1e4,75c55e7673bb83e064ad62e894b56ce2535a52c3640f94c27b944f2f5e1b823681:168a,6e246cca9a736355535c54fa886557e04e0d5e036b657c3f90e8601664e6731c88c16750624d8d22776c8e2991c75f6983dc8521991053c286956b8b60:ede8,707f82:cd31,4ed36ca785cf64cd7cd969fd66f9834953957b564fa7518c6d4b5c428e6d63d253c983:2c36,67e578b4643d5bdf5c945dee8be762c667f48c7a640063ba8749998b8c177f2094f24ea7961098a4660c731677:e6e8eaeff0f1f2f4f5f7f9fafbfc,78:0304050607080a0b0e0f101315191b1e20212224282a2b2e2f31323335363d3f414243444648494a4b4d4f51535458595a#5b5c5e5f606162636465666768696f7071727374757678797a7b7d7e7f80818283,573a5c1d5e38957f507f80a05382655e7545553150218d856284949e671d56326f6e5de2543570928f66626f64a463a35f7b6f8890f481e38fb05c1866685ff16c8996488d81886c649179f057ce6a59621054484e587a0b60e96f848bda627f901e9a8b79e4540375f4630153196c608fdf5f1b9a70803b9f7f4f885c3a8d647fc565a570bd51:45b2,866b5d075ba062bd916c75748e0c7a2061017b794ec77ef877854e1181ed521d51fa6a7153a88e87950496cf6ec19664695a78:848586888a8b8f9092949596999d9ea0a2a4a6a8a9aaabacadaeafb5b6b7b8babbbcbdbfc0c2c3c4c6c7c8cccdcecfd1d2d3d6d7d8dadbdcdddedfe0e1e2e3#e4e5e6e7e9eaebedeeeff0f1f3f5f6f8f9fbfcfdfeff,79:00020304060708090a0b0c,784050a877d7641089e6590463e35ddd7a7f693d4f20823955984e3275ae7a975e:628a,95ef521b5439708a6376952457826625693f918755076df37eaf882262337ef075b5832878c196cc8f9e614874f78bcd6b64523a8d506b21806a847156f153064e:ce1b,51d17c97918b7c074fc38e7f7be17a9c64675d1450ac810676017cb96dec7fe067515b:58f8,78cb64:ae13,63:aa2b,9519642d8fbe7b5476296253592754466b7950a362345e266b864ee38d37888b5f85902e79:0d0e0f1011121415161718191a1b1c1d1f2021222325262728292a2b2c2d2e2f3031323335363738393d3f42434445474a4b4c4d4e4f505152545558596163#6466696a6b6c6e70717273747576797b7c7d7e7f8283868788898b8c8d8e909192,6020803d62c54e39535590f863b880c665e66c2e4f4660ee6de18bde5f3986cb5f536321515a83616863520063638e4850125c9b79775bfc52307a3b60bc905376d75f:b797,76848e6c706f767b7b4977aa51f3909358244f4e6ef48fea654c7b1b72c46da47fdf5ae162b55e95573084827b2c5e1d5f1f90127f1498a063826ec7789870b95178975b57ab75354f4375385e9760e659606dc06bbf788953fc96d551cb52016389540a94938c038dcc7239789f87768fed8c0d53e079:939495969798999b9c9d9e9fa0a1a2a3a4a5a6a8a9aaabacadaeafb0b1b2b4b5b6b7b8bcbfc2c4c5c7c8cacccecfd0d3d4d6d7d9dadbdcdddee0e1e2e5e8ea#eceef1f2f3f4f5f6f7f9fafcfeff,7a:0104050708090a0c0f10111213151618191b1c,4e0176ef53ee948998769f0e952d5b9a8ba24e:221c,51ac846361c252a8680b4f97606b51bb6d1e515c6296659796618c46901775d890fd77636bd272:8aec,8bfb583577798d4c675c9540809a5ea66e2159927aef77ed953b6bb565ad7f0e58065151961f5bf958a954288e726566987f56e4949d76fe9041638754c659:1a3a,579b8eb267358dfa8235524160f0581586fe5ce89e454fc4989d8bb95a2560765384627c904f9102997f6069800c513f80335c1499756d314e8c7a:1d1f21222425262728292a2b2c2d2e2f303132343536383a3e4041424344454748494a4b4c4d4e4f50525354555658595a5b5c5d5e5f606162636465666768#696a6b6c6d6e6f717273757b7c7d7e828587898a8b8c8e8f909394999a9b9ea1a2,8d3053d17f5a7b4f4f104e4f96006cd573d085e95e06756a7ffb6a0a77fe94927e4151e170e653cd8fd483038d2972af996d6cdb574a82b365b980aa623f963259a84eff8bbf7eba653e83f2975e556198de80a5532a8bfd542080ba5e9f6cb88d3982ac915a54296c1b52067eb7575f711a6c7e7c89594b4efd5fff61247caa4e305c0167ab87025cf0950b98ce75af70fd902251af7f1d8bbd594951e44f5b5426592b657780a45b7562:76c2,8f905e456c1f7b264f:0fd8,670d7a:a3a4a7a9aaabaeafb0b1b2b4b5b6b7b8b9babbbcbdbec0c1c2c3c4c5c6c7c8c9cacccdcecfd0d1d2d3d4d5d7d8dadbdcdde1e2e4e7e8e9eaebeceef0f1f2f3#f4f5f6f7f8fbfcfe,7b:0001020507090c0d0e1012131617181a1c1d1f21222327292d,6d:6eaa,798f88b15f17752b629a8f854fef91dc65a781:2f51,5e9c81508d74526f89868d4b590d50854ed8961c723681798d1f5bcc8ba3964459877f1a549056:760e,8be565396982949976d66e895e72751867:46d1,7aff809d8d76611f79c665628d635188521a94a27f38809b7eb25c976e2f67607bd9768b9ad8818f7f947cd5641e95507a3f54:4ae5,6b4c640162089e3d80f3759952729769845b683c86e496:0194,94ec4e2a54047ed968398ddf801566f45e9a7fb97b:2f303234353637393b3d3f404142434446484a4d4e535557595c5e5f61636465666768696a6b6c6d6f70737476787a7c7d7f81828384868788898a8b8c8e8f#9192939698999a9b9e9fa0a3a4a5aeafb0b2b3b5b6b7b9babbbcbdbebfc0c2c3c4,57c2803f68975de5653b529f606d9f9a4f9b8eac516c5bab5f135de96c5e62f18d21517194a952fe6c9f82df72d757a267848d2d591f8f9c83c754957b8d4f306cbd5b6459d19f1353e486ca9aa88c3780a16545987e56fa96c7522e74dc52505be1630289024e5662d0602a68fa51735b9851a089c27ba199867f5060ef704c8d2f51495e7f901b747089c4572d78455f529f9f95fa8f689b3c8be17678684267dc8d:ea35,523d8f8a6eda68cd950590ed56fd679c88f98fc754c87b:c5c8c9cacbcdcecfd0d2d4d5d6d7d8dbdcdedfe0e2e3e4e7e8e9ebecedeff0f2f3f4f5f6f8f9fafbfdff,7c:0001020304050608090a0d0e101112131415171819#1a1b1c1d1e20212223242528292b2c2d2e2f3031323334353637393a3b3c3d3e42,9ab85b696d776c264ea55bb39a87916361a890af97e9542b6db55bd251fd558a7f:55f0,64bc634d65f161be608d710a6c:5749,592f676d822a58d5568e8c6a6beb90dd597d801753f76d695475559d83:77cf,683879be548c4f55540876d28c8996026cb36db88d6b89109e648d3a563f9ed175d55f8872e0606854fc4ea86a2a886160528f7054c470d886799e3f6d2a5b8f5f187ea255894faf7334543c539a501954:0e7c,4e4e5ffd745a58f6846b80e1877472d07cca6e567c:434445464748494a4b4c4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f70717275767778797a7e7f8081828384858687#888a8b8c8d8e8f90939496999a9ba0a1a3a6a7a8a9abacadafb0b4b5b6b7b8babb,5f27864e552c62a44e926caa623782b154d7534e733e6ed1753b521253168bdd69d05f8a60006dee574f6b2273af68538fd87f13636260a3552475ea8c6271156da35ba65e7b8352614c9ec478fa87577c27768751f060f6714c66435e4c604d8c0e707063258f895fbd606286d456de6bc160946167534960e066668d3f79fd4f1a70e96c478b:b3f2,7ed88364660f5a5a9b426d:51f7,8c416d3b4f19706b83b7621660d1970d8d27797851fb57:3efa,673a75787a3d79ef7b957c:bfc0c2c3c4c6c9cbcecfd0d1d2d3d4d8dadbdddee1e2e3e4e5e6e7e9eaebecedeef0f1f2f3f4f5f6f7f9fafcfdfeff,7d:000102030405060708090b0c0d0e0f10#1112131415161718191a1b1c1d1e1f212324252628292a2c2d2e30313233343536,808c99658ff96fc08ba59e2159ec7ee97f095409678168d88f917c4d96c653ca602575be6c7253735ac97ea7632451e0810a5df184df628051805b634f0e796d524260b86d4e5b:c4c2,8b:a1b0,65e25fcc964559937e:e7aa,560967b759394f735bb652a0835a988a8d3e753294be50477a3c4ef767b69a7e5ac16b7c76d1575a5c167b3a95f4714e517c80a9827059787f04832768c067ec78:b177,62e363617b804fed526a51cf835069db92748d:f531,89c1952e7bad4ef67d:3738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6f70717273747576#78797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798,506582305251996f6e:1085,6da75efa50f559dc5c066d466c5f7586848b686859568bb253209171964d854969127901712680f64ea490ca6d479a845a0756bc640594f077eb4fa5811a72e189d2997a7f347ede527f655991758f:7f83,53eb7a9663:eda5,768679f888579636622a52ab8282685467706377776b7aed6d017ed389e359d0621285c982a5754c501f4ecb75a58beb5c4a5dfe7b4b65a491d14eca6d25895f7d2795264ec58c288fdb9773664b79818fd170ec6d787d:999a9b9c9d9e9fa0a1a2a3a4a5a7a8a9aaabacadafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9#dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fa,5c3d52b283465162830e775b66769cb84eac60ca7c:beb3,7ecf4e958b66666f988897595883656c955c5f8475c997567a:dfde,51c070af7a9863ea7a767ea0739697ed4e4570784e5d915253a965:51e7,81fc8205548e5c31759a97a062d872d975bd5c459a7983ca5c40548077e94e3e6cae805a62d2636e5de851778ddd8e1e952f4ff153e560e770ac526763509e435a1f5026773753777ee26485652b628963985014723589c951b38bc07edd574783cc94a7519b541b5cfb7d:fbfcfdfeff,7e:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233343536373839#3a3c3d3e3f40424344454648494a4b4c4d4e4f505152535455565758595a5b5c5d,4fca7ae36d5a90e19a8f55805496536154af5f0063e9697751ef6168520a582a52d8574e780d770b5eb761777ce062:5b97,4ea27095800362f770e49760577782db67ef68f578d5989779d158f354b353ef6e34514b523b5ba28bfe80af554357a660735751542d7a7a60505b5463a762a053e362635bc767af54ed7a9f82e691775e9388e4593857ae630e8de880ef57577b774fa95feb5bbd6b3e53217b5072c2684677:ff36,65f751b54e8f76d45cbf7aa58475594e9b4150807e:5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f8081838485868788898a8b8c8d8e8f909192939495969798999a9c9d9e#aeb4bbbcd6e4ecf9,7f:0a101e37393b3c3d3e3f404143464748494a4b4c4d4e4f5253,998861276e8357646606634656f062:ec69,5ed39614578362c955878721814a8fa3556683b167658d5684dd5a6a680f62e67bee961151706f9c8c3063fd89c861d27f0670c26ee57405699472fc5eca90ce67176d6a635e52b3726280014f6c59e5916a70d96d9d52d24e5096f7956d857e78ca7d2f5121579264c2808b7c7b6cea68f1695e51b7539868a872819ece7bf172f879bb6f137406674e91cc9ca4793c83:8954,540f68174e3d538952b1783e5386522950884f:8bd0,7f:56595b5c5d5e6063646566676b6c6d6f7073757677787a7b7c7d7f8082838485868788898b8d8f9091929395969798999b9ca0a2a3a5a6a8a9aaabacadaeb1#b3b4b5b6b7babbbec0c2c3c4c6c7c8c9cbcdcfd0d1d2d3d6d7d9dadbdcdddee2e3,75e27acb7c926ca596b6529b748354e94fe9805483b28fde95705ec9601c6d9f5e18655b813894fe604b70bc7ec37cae51c968817cb1826f4e248f8691cf667e4eae8c0564a9804a50da759771ce5be58fbd6f664e86648295635ed66599521788c270c852a3730e7433679778f797164e3490bb9cde6dcb51db8d41541d62ce73b283f196f69f8494c34f367f9a51cc707596755cad988653e64ee46e9c740969b4786b998f7559521876246d4167f3516d9f99804b54997b3c7abf7f:e4e7e8eaebecedeff2f4f5f6f7f8f9fafdfeff,80:020708090a0e0f11131a1b1d1e1f2123242b2c2d2e2f303234393a3c3e404144454748494e4f505153555657#595b5c5d5e5f6061626364656667686b6c6d6e6f7072737475767778797a7b7c7d,9686578462e29647697c5a0464027bd36f0f964b82a6536298855e90708963b35364864f9c819e93788c97328d:ef42,9e7f6f5e79845f559646622e9a74541594dd4fa365c55c:6561,7f1586516c2f5f8b73876ee47eff5ce6631b5b6a6ee653754e7163a0756562a18f6e4f264ed16ca67eb68bba841d87ba7f57903b95237ba99aa188f8843d6d1b9a867edc59889ebb739b780186829a:6c82,561b541757cb4e709ea653568fc881097792999286ee6ee1851366fc61626f2b80:7e818285888a8d8e8f909192949597999ea3a6a7a8acb0b3b5b6b8b9bbc5c7c8c9cacbcfd0d1d2d3d4d5d8dfe0e2e3e6eef5f7f9fbfeff,81:000103040507080b#0c1517191b1c1d1f202122232425262728292a2b2d2e3033343537393a3b3c3d3f,8c298292832b76f26c135fd983bd732b8305951a6bdb77db94c6536f830251925e3d8c8c8d384e4873ab679a68859176970971646ca177095a9295416bcf7f8e66275bd059b95a9a95:e8f7,4eec84:0c99,6aac76df9530731b68a65b5f772f919a97617cdc8ff78c1c5f257c7379d889c56ccc871c5bc65e4268c977207ef551:954d,52c95a297f05976282d763cf778485d079d26e3a5e9959998511706d6c1162bf76bf654f60af95fd660e879f9e2394ed54:0d7d,8c2c647881:40414243444547494d4e4f525657585b5c5d5e5f6162636466686a6b6c6f727375767778818384858687898b8c8d8e90929394959697999a9e9fa0a1a2a4a5#a7a9abacadaeafb0b1b2b4b5b6b7b8b9bcbdbebfc4c5c7c8c9cbcdcecfd0d1d2d3,647986116a21819c78e864699b5462b9672b83ab58a89ed86cab6f205bde964c8c0b725f67d062c772614ea959c66bcd589366ae5e5552df6155672876ee776672677a4662ff54:ea50,94a090a35a1c7eb36c164e435976801059485357753796be56ca63208111607c95f96dd65462998151855ae980fd59ae9713502a6ce55c3c62df4f60533f817b90066eba852b62c85e7478be64b5637b5ff55a18917f9e1f5c3f634f80425b7d556e95:4a4d,6d8560a867e072de51dd5b8181:d4d5d6d7d8d9dadbdcdddedfe0e1e2e4e5e6e8e9ebeeeff0f1f2f5f6f7f8f9fafdff,82:030708090a0b0e0f111315161718191a1d2024252627292e323a3c3d3f#404142434546484a4c4d4e5051525354555657595b5c5d5e606162636465666769,62e76cde725b626d94ae7ebd81136d53519c5f04597452aa6012597366968650759f632a61e67cef8bfa54e66b279e256bb485d5545550766ca4556a8db4722c5e156015743662cd6392724c5f986e436d3e65006f5876d878d076fc7554522453db4e535e9e65c180:2ad6,629b5486522870ae888d8dd16ce1547880da57f988f48d54966a914d4f696c9b55b776c6783062a870f96f8e5f6d84ec68da787c7bf781a8670b9e4f636778b0576f7812973962:79ab,528874356bd782:6a6b6c6d71757677787b7c808183858687898c90939495969a9b9ea0a2a3a7b2b5b6babbbcbfc0c2c3c5c6c9d0d6d9dadde2e7e8e9eaecedeef0f2f3f5f6f8#fafcfdfeff,83:000a0b0d1012131618191d1e1f20212223242526292a2e3032373b3d,5564813e75b276ae533975de50fb5c418b6c7bc7504f72479a9798d86f0274e27968648777a562fc98918d2b54c180584e52576a82f9840d5e7351ed74f68bc45c4f57616cfc98875a4678349b448feb7c955256625194fa4ec68386846183e984b257d467345703666e6d668c3166dd7011671f6b3a6816621a59bb4e0351c46f0667d26c8f517668cb59476b6775665d0e81109f5065d779:4841,9a918d775c824e5e4f01542f5951780c56686c148fc45f036c:7de3,8bab639083:3e3f41424445484a4b4c4d4e5355565758595d6270717273747576797a7e7f808182838487888a8b8c8d8f909194959697999a9d9fa1a2a3a4a5a6a7acadae#afb5bbbebfc2c3c4c6c8c9cbcdced0d1d2d3d5d7d9dadbdee2e3e4e6e7e8ebeced,60706d3d7275626694:8ec5,53438fc17b7e4edf8c264e7e9ed494:b1b3,524d6f5c90636d458c3458115d4c6b:2049,67aa545b81547f8c589985375f3a62a26a47953965726084686577a74e544fa85de7979864ac7fd85ced4fcf7a8d520783044e14602f7a8394a64fb54eb279e6743452e482b964d279bd5bdd6c8197528f7b6c22503e537f6e0564ce66746c3060c598778bf75e86743c7a7779cb4e1890b174036c4256da914b6cc58d8b533a86c666f28eaf5c489a716e2083:eeeff3f4f5f6f7fafbfcfeff,84:0002050708090a10121314151617191a1b1e1f20212223292a2b2c2d2e2f30323334353637393a3b3e3f404142434445474849#4a4b4c4d4e4f505253545556585d5e5f606264656667686a6e6f70727477797b7c,53d65a369f8b8da353bb570898a76743919b6cc9516875ca62f372ac52:389d,7f3a7094763853749e4a69b7786e96c088d97fa471:36c3,518967d374e458e4651856b78ba9997662707ed560f970ed58ec4e:c1ba,5fcd97e74efb8ba45203598a7eab62544ecd65e5620e833884c98363878d71946eb65bb97ed2519763c967d480898339881551125b7a59828fb14e736c5d516589258f6f962e854a745e95:10f0,6da682e55f3164926d128428816e9cc3585e8d5b4e0953c184:7d7e7f8081838485868a8d8f90919293949596989a9b9d9e9fa0a2a3a4a5a6a7a8a9aaabacadaeb0b1b3b5b6b7bbbcbec0c2c3c5c6c7c8cbcccecfd2d4d5d7#d8d9dadbdcdee1e2e4e7e8e9eaebedeeeff1f2f3f4f5f6f7f8f9fafbfdfe,85:000102,4f1e6563685155d34e2764149a9a626b5ac2745f82726da968ee50e7838e7802674052396c997eb150bb5565715e7b5b665273ca82eb67495c715220717d886b95ea965564c58d6181b355846c5562477f2e58924f2455468d4f664c4e0a5c1a88f368a2634e7a0d70e7828d52fa97f65c1154e890b57ecd59628d4a86c782:0c0d,8d6664445c0461516d89793e8bbe78377533547b4f388eab6df15a207ec5795e6c885ba15a76751a80be614e6e1758f075:1f25,727253477ef385:030405060708090a0b0d0e0f101214151618191b1c1d1e2022232425262728292a2d2e2f303132333435363e3f404142444546474b4c4d4e4f505152535455#57585a5b5c5d5f60616263656667696a6b6c6d6e6f707173757677787c7d7f8081,770176db526980dc57235e08593172ee65bd6e7f8bd75c388671534177f362fe65f64ec098df86805b9e8bc653f277e24f7f5c4e9a7659cb5f0f793a58eb4e1667ff4e8b62ed8a93901d52bf662f55dc566c90024ed54f8d91ca99706c0f5e0260435ba489c68bd56536624b99965b:88ff,6388552e53d77626517d852c67a268b36b8a62928f9353d482126dd1758f4e668d4e5b70719f85af66:91d9,7f7287009ecd9f205c5e672f8ff06811675f620d7ad658855eb665706f3185:82838688898a8b8c8d8e909192939495969798999a9d9e9fa0a1a2a3a5a6a7a9abacadb1b2b3b4b5b6b8babbbcbdbebfc0c2c3c4c5c6c7c8cacbcccdced1d2#d4d6d7d8d9dadbdddedfe0e1e2e3e5e6e7e8eaebecedeeeff0f1f2f3f4f5f6f7f8,60555237800d6454887075295e05681362f4971c53cc723d8c016c3477617a0e542e77ac987a821c8bf47855671470c165af64955636601d79c153f84e1d6b7b80865bfa55e356db4f:3a3c,99725df3677e80386002988290015b8b8b:bcf5,641c825864de55fd82cf91654fd77d20901f7c9f50f358516eaf5bbf8bc980839178849c7b97867d96:8b8f,7ee59ad3788e5c817a57904296a7795f5b59635f7b0b84d168ad55067f2974107d2295016240584c4ed65b835979585485:f9fafcfdfe,86:0001020304060708090a0b0c0d0e0f10121314151718191a1b1c1d1e1f20212223242526282a2b2c2d2e2f3031323334353637393a3b3d3e3f40#4142434445464748494a4b4c525355565758595b5c5d5f6061636465666768696a,736d631e8e:4b0f,80ce82d462ac53f06cf0915e592a60016c70574d644a8d2a762b6ee9575b6a8075f06f6d8c:2d08,57666bef889278b363a253f970ad6c645858642a580268e0819b55107cd650188eba6dcc8d9f70eb638f6d9b6ed47ee68404684390036dd896768ba85957727985e4817e75bc8a8a68af52548e22951163d098988e44557c4f5366ff568f60d56d9552435c4959296dfb586b75:301c,606c82148146631167618fe2773a8d:f334,94c15e165385542c70c386:6d6f7072737475767778838485868788898e8f90919294969798999a9b9e9fa0a1a2a5a6abadaeb2b3b7b8b9bbbcbdbebfc1c2c3c5c8cccdd2d3d5d6d7dadc#dde0e1e2e3e5e6e7e8eaebeceff5f6f7fafbfcfdff,87:010405060b0c0e0f10111416,6c405ef7505c4ead5ead633a8247901a6850916e77b3540c94dc5f647ae5687663457b527edf75db507762955934900f51f879c37a8156fe5f9290146d825c60571f541051546e4d56e263a89893817f8715892a9000541e5c6f81c062:d658,81319e3596409a:6e7c,692d59a562d3553e631654c786d96d3c5a0374e6889c6b6a59168c4c5f2f6e7e73a9987d4e3870f75b8c7897633d665a769660cb5b9b5a494e0781556c6a738b4ea167897f515f8065fa671b5fd859845a0187:191b1d1f20242627282a2b2c2d2f303233353638393a3c3d404142434445464a4b4d4f505152545556585a5b5c5d5e5f6162666768696a6b6c6d6f71727375#7778797a7f8081848687898a8c8e8f90919294959698999a9b9c9d9ea0a1a2a3a4,5dcd5fae537197e68fdd684556f4552f60df4e3a6f4d7ef482c7840e59d44f:1f2a,5c3e7eac672a851a5473754f80c355829b4f4f4d6e2d8c135c096170536b761f6e29868a658795fb7eb9543b7a337d0a95ee55e17fc174ee631d87176da17a9d621165a1536763e16c835deb545c94a84e4c6c618bec5c4b65e0829c68a754:3e34,6b:cb66,4e9463425348821e4f:0dae,575e620a96fe6664726952:ffa1,609f8bef661471996790897f785277fd6670563b54389521727a87:a5a6a7a9aaaeb0b1b2b4b6b7b8b9bbbcbebfc1c2c3c4c5c7c8c9cccdcecfd0d4d5d6d7d8d9dadcdddedfe1e2e3e4e6e7e8e9ebecedeff0f1f2f3f4f5f6f7f8#fafbfcfdff,88:0001020405060708090b0c0d0e0f101112141718191a1c1d1e1f2023,7a00606f5e0c6089819d591560dc718470ef6eaa6c5072806a8488ad5e2d4e605ab3559c94e36d177cfb9699620f7ec6778e867e5323971e8f9666875ce14fa072ed4e0b53a6590f54136380952851484ed99c9c7ea454b88d248854823795f26d8e5f265acc663e966973:b02e,53bf817a99857fa15baa96:7750,7ebf76f853a2957699997bb189446e584e617fd479658be660f354cd4eab98795df76a6150cf54118c618427785d9704524a54ee56a395006d885bb56dc6665388:2425262728292a2b2c2d2e2f30313334353637383a3b3d3e3f414243464748494a4b4e4f505152535556585a5b5c5d5e5f6066676a6d6f717374757678797a#7b7c80838687898a8c8e8f90919394959798999a9b9d9e9fa0a1a3a5a6a7a8a9aa,5c0f5b5d6821809655787b11654869544e9b6b47874e978b534f631f643a90aa659c80c18c10519968b0537887f961c86c:c4fb,8c225c5185aa82af950c6b238f9b65b05f:fbc3,4fe18845661f8165732960fa51745211578b5f6290a2884c91925e78674f602759d351:44f6,80f853086c7996c4718a4f:11ee,7f9e673d55c5950879c088967ee3589f620c9700865a5618987b5f908bb884c4915753d965ed5e8f755c60647d6e5a7f7e:eaed,8f6955a75ba360ac65cb738488:acaeafb0b2b3b4b5b6b8b9babbbdbebfc0c3c4c7c8cacbcccdcfd0d1d3d6d7dadbdcdddee0e1e6e7e9eaebecedeeeff2f5f6f7fafbfdff,89:0001030405060708#090b0c0d0e0f1114151617181c1d1e1f20222324262728292c2d2e2f3132333537,9009766377297eda9774859b5b667a7496ea884052cb718f5faa65ec8be25bfb9a6f5de16b896c5b8b:adaf,900a8fc5538b62bc9e:262d,54404e2b82bd7259869c5d1688596daf96c554d14e9a8bb6710954bd960970df6df976d04e25781487125ca95ef68a00989c960e708e6cbf594463a9773c884d6f148273583071d5538c781a96c155015f6671305bb48c1a9a8c6b83592e9e2f79e76768626c4f6f75a17f8a6d0b96336c274ef075d2517b68376f3e908081705996747689:38393a3b3c3d3e3f40424345464748494a4b4c4d4e4f505152535455565758595a5b5c5d6061626364656768696a6b6c6d6e6f707172737475767778797a7c#7d7e808284858788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1,64475c2790657a918c2359da54ac8200836f898180006930564e8036723791ce51b64e5f987563964e1a53f666f3814b591c6db24e0058f9533b63d694f14f:9d0a,886398905937905779fb4eea80f075916c825b9c59e85f5d69058681501a5df24e5977e34ee5827a6291661390915c794ebf5f7981c69038808475ab4ea688d4610f6bc55fc64e4976ca6ea28b:e3ae,8c0a8bd15f027f:fccc,7ece83:356b,56e06bb797f3963459fb541f94f66deb5bc5996e5c395f15969089:a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c3cdd3d4d5d7d8d9dbdddfe0e1e2e4e7e8e9eaecedeef0f1f2f4f5f6f7f8f9fa#fbfcfdfeff,8a:01020304050608090a0b0c0d0e0f101112131415161718191a1b1c1d,537082f16a315a749e705e947f2883b984:2425,836787478fce8d6276c85f719896786c662054df62e54f6381c375c85eb896cd8e0a86f9548f6cf36d8c6c38607f52c775285e7d4f1860a05fe75c24753190ae94c072b96cb96e389149670953:cbf3,4f5191c98bf153c85e7c8fc26de44e8e76c26986865e611a82064f:59de,903e9c7c61096e:1d14,96854e885a3196e84e0e5c7f79b95b878bed7fbd738957df828b90c15401904755bb5cea5fa161086b3272f180b28a:891e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3f4041424344454647494a4b4c4d4e4f505152535455565758595a5b5c5d5e#5f606162636465666768696a6b6c6d6e6f7071727374757677787a7b7c7d7e7f80,6d745bd388d598848c6b9a6d9e336e0a51:a443,57a38881539f63f48f9556ed54585706733f6e907f188fdc82d1613f6028966266f07ea68d:8ac3,94a55cb37ca4670860a6960580184e9190e75300966851418fd08574915d665597f55b55531d78386742683d54c9707e5bb08f7d518d572854b1651266828d:5e43,810f846c906d7cdf51ff85fb67a365e96fa186a48e81566a90207682707671e58d2362e952196cfd8d3c600e589e618e66fe8d60624e55b36e23672d8f678a:81828384858687888b8c8d8e8f9091929495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2#c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3,94e195f87728680569a8548b4e4d70b88bc86458658b5b857a84503a5be877bb6be18a797c986cbe76cf65a98f975d2d5c5586386808536062187ad96e5b7efd6a1f7ae05f706f335f20638c6da867564e085e108d264ed780c07634969c62db662d627e6cbc8d7571677f695146808753ec906e629854f286f08f998005951785178fd96d5973cd659f771f7504782781fb8d1e94884fa6679575b98bca9707632f9547963584b8632377415f8172f04e896014657462ef6b63653f8a:e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8b:0001020304050608090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223#24252728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445,5e2775c790d18bc1829d679d652f5431871877e580a281026c414e4b7ec7804c76f4690d6b966267503c4f84574063076b628dbe53ea65e87eb85fd763:1ab7,81:f3f4,7f6e5e1c5cd95236667a79e97a1a8d28709975d46ede6cbb7a924e2d76c55fe0949f88777ec879cd80bf91cd4ef24f17821f54685dde6d328bcc7ca58f7480985e1a549276b15b99663c9aa473e0682a86db6731732a8b:f8db,90107af970db716e62c477a956314e3b845767f152a986c08d2e94f87b518b:464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364656768696a6b6d6e6f707172737475767778797a7b7c7d7e7f80818283848586#8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9facb1bbc7d0ea,8c:091e,4f4f6ce8795d9a7b6293722a62fd4e1378168f6c64b08d5a7bc668695e8488c55986649e58ee72b6690e95258ffd8d5857607f008c0651c6634962d95353684c74228301914c55447740707c6d4a517954a88d4459ff6ecb6dc45b5c7d2b4ed47c7d6ed35b5081ea6e0d5b579b0368d58e2a5b977efc603b7eb590b98d70594f63cd79df8db3535265cf79568bc5963b7ec494bb7e825634918967007f6a5c0a907566285de64f5067de505a4f5c57505e:a7#3,8c:38393a3b3c3d3e3f4042434445484a4b4d4e4f5051525354565758595b5c5d5e5f60636465666768696c6d6e6f707172747576777b7c7d7e7f808183848687#888b8d8e8f90919293959697999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacad,4e:8d0c,51404e105eff53454e:15981e,9b325b6c56694e2879ba4e3f53154e47592d723b536e6c1056df80e499976bd3777e9f174e:369f,9f104e:5c6993,82885b5b556c560f4ec453:8d9da3a5ae,97658d5d53:1af5262e3e,8d5c53:6663,52:02080e2d333f404c5e615c,84af52:7d82819093,51827f544e:bbc3c9c2e8e1ebde,4f1b4ef34f:2264,4ef54f:2527092b5e67,65384f:5a5d,8c:aeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebec#edeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8d:000102030405060708090a0b0c0d,4f:5f57323d76749189838f7e7baa7cac94e6e8eac5dae3dcd1dff8,50:294c,4ff350:2c0f2e2d,4ffe50:1c0c25287e4355484e6c7ba5a7a9bad6,510650:edece6ee,51:070b,4edd6c3d4f:5865ce,9fa06c467c74516e5dfd9ec999985181591452f9530d8a07531051eb591951554ea051564eb388:6ea4,4eb5811488d279805b3488037fb851:abb1bdbc,8d:0e0f101112131415161718191a1b1c205152575f6568696a6c6e6f717278797a7b7c7d7e7f808283868788898c8d8e8f90929395969798999a9b9c9d9ea0a1#a2a4a5a6a7a8a9aaabacadaeafb0b2b6b7b9bbbdc0c1c2c5c7c8c9cacdd0d2d3d4,51:c796a2a5,8b:a0a6a7aab4b5b7c2c3cbcfced2d3d4d6d8d9dcdfe0e4e8e9eef0f3f6f9fcff,8c:000204070c0f1112141516191b181d1f202125272a2b2e2f32333536,53:697a,96:1d2221312a3d3c4249545f676c7274888d97b0,90:979b9d99aca1b4b3b6ba,8d:d5d8d9dce0e1e2e5e6e7e9edeef0f1f2f4f6fcfeff,8e:00010203040607080b0d0e1011121315161718191a1b1c202124252627282b2d303233343637383b3c3e#3f4345464c4d4e4f505354555657585a5b5c5d5e5f60616263646567686a6b6e71,90:b8b0cfc5bed0c4c7d3e6e2dcd7dbebeffe,91:04221e23312f394346,520d594252:a2acadbe,54ff52:d0d6f0,53df71ee77cd5ef451:f5fc,9b2f53b65f01755a5def57:4ca9a1,58:7ebcc5d1,57:292c2a33392e2f5c3b4269856b867c7b686d7673ada48cb2cfa7b493a0d5d8dad9d2b8f4eff8e4dd,8e:73757778797a7b7d7e808283848688898a8b8c8d8e91929395969798999a9b9d9fa0a1a2a3a4a5a6a7a8a9aaadaeb0b1b3b4b5b6b7b8b9bbbcbdbebfc0c1c2#c3c4c5c6c7c8c9cacbcccdcfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4,58:0b0d,57:fded,58:001e194420656c81899a80,99a89f1961ff82:797d7f8f8aa8848e919799abb8beb0c8cae398b7aecbccc1a9b4a1aa9fc4cea4e1,830982:f7e4,83:0f07,82:dcf4d2d8,830c82:fbd3,83:111a061415,82:e0d5,83:1c515b5c08923c34319b5e2f4f47435f4017602d3a336665,8e:e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,8f:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20212223#2425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f4041424344,83:681b696c6a6d6eb078b3b4a0aa939c857cb6a97db87b989ea8babcc1,840183:e5d8,580784:180b,83:ddfdd6,84:1c381106,83:d4df,84:0f03,83:f8f9eac5c0,842683:f0e1,84:5c515a597387887a89783c4669768c8e316dc1cdd0e6bdd3cabfbae0a1b9b497e5e3,850c750d853884f085:391f3a,8f:45464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364656a808c929da0a1a2a4a5a6a7aaacadaeafb2b3b4b5b7b8babbbcbfc0c3c6#c9cacbcccdcfd2d6d7dae0e1e3e7eceff1f2f4f5f6fafbfcfeff,90:07080c0e131518,85:563b,84:fffc,85:594868645e7a,77a285:43727ba4a8878f79ae9c85b9b7b0d3c1dcff,86:270529163c,5efe5f0859:3c41,803759:555a58,530f5c:22252c34,62:4c6a9fbbcadad7ee,632262f663:394b43adf6717a8eb46dac8a69aebcf2f8e0ffc4dece,645263:c6be,64:45410b1b200c26215e846d96,90:191c2324252728292a2b2c303132333437393a3d3f4043454648494a4b4c4e545556595a5c5d5e5f6061646667696a6b6c6f70717273767778797a7b7c7e81#84858687898a8c8d8e8f90929496989a9c9e9fa0a4a5a7a8a9abadb2b7bcbdbfc0,64:7ab7b899bac0d0d7e4e2,65:09252e,5f:0bd2,75195f1153:5ff1fde9e8fb,54:1216064b5253545643215759233282947771649a9b8476669dd0adc2b4d2a7a6d3d472a3d5bbbfccd9dadca9aaa4ddcfde,551b54e7552054fd551454f355:22230f11272a678fb5496d41553f503c,90:c2c3c6c8c9cbcccdd2d4d5d6d8d9dadedfe0e3e4e5e9eaeceef0f1f2f3f5f6f7f9fafbfcff,91:00010305060708090a0b0c0d0e0f1011121314151617181a1b1c#1d1f20212425262728292a2b2c2d2e30323334353637383a3b3c3d3e3f40414244,55:375675767733305c8bd283b1b988819f7ed6917bdfbdbe9499eaf7c9,561f55:d1ebecd4e6ddc4efe5f2f3cccde8f5e4,8f9456:1e080c012423,55fe56:00272d5839572c4d62595c4c548664716b7b7c8593afd4d7dde1f5ebf9ff,57:040a091c,5e:0f191411313b3c,91:454748515354555658595b5c5f606667686b6d737a7b7c808182838486888a8e8f939495969798999c9d9e9fa0a1a4a5a6a7a8a9abacb0b1b2b3b6b7b8b9bb#bcbdbebfc0c1c2c3c4c5c6c8cbd0d2d3d4d5d6d7d8d9dadbdddedfe0e1e2e3e4e5,5e:3744545b5e61,5c:8c7a8d9096889899919a9cb5a2bdacabb1a3c1b7c4d2e4cbe5,5d:020327262e241e061b583e343d6c5b6f5d6b4b4a697482999d,8c735d:b7c5,5f:73778287898c95999ca8adb5bc,88625f6172:adb0b4b7b8c3c1cecdd2e8efe9f2f4f7,730172f3730372fa91:e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,92:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021222324#25262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445,72fb73:1713210a1e1d152239252c3831504d57606c6f7e,821b592598e759:2402,99:636768696a6b6c74777d8084878a8d9091939495,5e:80918b96a5a0b9b5beb3,8d535e:d2d1dbe8ea,81ba5f:c4c9d6cf,60035fee60045f:e1e4fe,60:0506,5f:eaedf8,60:1935261b0f0d292b0a3f2178797b7a42,92:464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f7071727375767778797a7b7c7d7e7f808182838485#868788898a8b8c8d8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7,60:6a7d969aad9d83928c9becbbb1ddd8c6dab4,61:20261523,60f461:000e2b4a75ac94a7b7d4f5,5fdd96b395:e9ebf1f3f5f6fcfe,96:030406080a0b0c0d0f12151617191a,4e2c723f62156c:35545c4aa38590948c6869747686a9d0d4adf7f8f1d7b2e0d6faebeeb1d3effe,92:a8a9aaabacadafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8#e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,93:00010203040506070809,6d:39270c43480704190e2b4d2e351a4f525433916f9ea05e93945c607c63,6e1a6d:c7c5de,6e0e6d:bfe0,6e116d:e6ddd9,6e166dab6e0c6dae6e:2b6e4e6bb25f865354322544dfb198e0,6f2d6e:e2a5a7bdbbb7d7b4cf8fc29f,6f:6246472415,6ef96f:2f364b742a0929898d8c78727c7ad1,93:0a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3f40414243444546474849#4a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696b,6f:c9a7b9b6c2e1eedee0ef,70:1a231b39354f5e,5b:80849593a5b8,752f9a9e64345b:e4ee,89305bf08e478b078f:b6d3d5e5eee4e9e6f3e8,90:05040b26110d162135362d2f445152506858625b,66b990:747d8288838b,5f:50575658,5c3b54ab5c:5059,5b715c:6366,7fbc5f:2a292d,82745f3c9b3b5c6e59:81838da9aaa3,93:6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaab#acadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cbcccd,59:97caab9ea4d2b2afd7be,5a:0506,59dd5a0859:e3d8f9,5a:0c09323411231340674a553c6275,80ec5a:aa9b777abeebb2d2d4b8e0e3f1d6e6d8dc,5b:091716323740,5c:151c,5b:5a6573515362,9a:7577787a7f7d808185888a90929396989b9c9d9fa0a2a3a5a7,7e:9fa1a3a5a8a9,93:cecfd0d1d2d3d4d5d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,94:000102030405060708090a0b0c0d#0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e,7e:adb0bec0c1c2c9cbccd0d4d7dbe0e1e8ebeeeff1f2,7f0d7e:f6fafbfe,7f:01020307080b0c0f111217191c1b1f212223242526272a2b2c2d2f3031323335,5e7a757f5ddb753e909573:8e91aea29fcfc2d1b7b3c0c9c8e5d9,987c740a73:e9e7debaf2,74:0f2a5b262528302e2c,94:2f303132333435363738393a3b3c3d3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6c6d6e6f#707172737475767778797a7b7c7d7e7f8081828384919698c7cfd3d4dae6fb,95:1c20,74:1b1a415c575559776d7e9c8e8081878b9ea8a990a7d2ba,97:eaebec,67:4c535e4869a5876a7398a775a89ead8b777cf0,680967d8680a67:e9b0,680c67:d9b5dab3dd,680067:c3b8e2,680e67:c1fd,68:323360614e624464831d55664167403e4a4929b58f7477936bc2,696e68fc69:1f20,68f995:27333d43484b555a606e74757778797a7b7c7d7e808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aa#abacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacb,692468f069:0b0157,68e369:10713960425d846b80987834cc8788ce896663799ba7bbabadd4b1c1cadf95e08dff,6a2f69ed6a:171865,69f26a:443ea0505b358e793d28587c9190a997ab,73:3752,6b:8182878492938d9a9ba1aa,8f:6b6d71727375767877797a7c7e818284878b,95:cccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7ecff,96:0713181b1e20232425262728292b2c2d2f303738393a3e41434a4e4f5152535657#58595a5c5d5e606365666b6d6e6f70717378797a7b7c7d7e7f808182838487898a,8f:8d8e8f989a,8ece62:0b171b1f222125242c,81e774:eff4ff,75:0f1113,65:34eeeff0,66:0a19,677266:031500,708566:f71d34313635,800666:5f54414f56615777848ca79dbedbdce6e9,8d:3233363b3d4045464849474d5559,89:c7cacbcccecfd0d1,72:6e9f5d666f7e7f848b8d8f92,63:0832b0,96:8c8e91929395969a9b9d9e9fa0a1a2a3a4a5a6a8a9aaabacadaeafb1b2b4b5b7b8babbbfc2c3c8cacbd0d1d3d4d6d7d8d9dadbdcdddedfe1e2e3e4e5e6e7eb#ecedeef0f1f2f4f5f8fafbfcfdff,97:0203050a0b0c10111214151718191a1b1d1f20,64:3fd8,80046b:eaf3fdf5f9,6c:0507060d1518191a2129242a32,65:35556b,72:4d525630,8662521680:9f9c93bc,670a80:bdb1abadb4b7e7e8e9eadbc2c4d9cdd7,671080:ddebf1f4ed,81:0d0e,80:f2fc,671581128c5a81:361e2c1832484c5374595a7160697c7d6d67,584d5ab581:888291,6ed581:a3aacc,672681:cabb,97:2122232425262728292b2c2e2f3133343536373a3b3c3d3f404142434445464748494a4b4c4d4e4f5051545557585a5c5d5f63646667686a6b6c6d6e6f7071#72757778797a7b7d7e7f8081828384868788898a8c8e8f9093959697999a9b9c9d,81:c1a6,6b:243739434659,98:d1d2d3d5d9da,6bb35f406bc289f365909f5165:93bcc6c4c3ccced2d6,70:809c969dbbc0b7abb1e8ca,71:1013162f31735c6845724a787a98b3b5a8a0e0d4e7f9,72:1d28,706c71:1866b9,62:3e3d434849,79:3b4046495b5c535a6257606f677a858a9aa7b3,5f:d1d0,97:9e9fa1a2a4a5a6a7a8a9aaacaeb0b1b3b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3#e4e5e8eeeff0f1f2f4f7f8f9fafbfcfdfeff,98:000102030405060708090a0b0c0d0e,60:3c5d5a67415963ab,61:060d5da99dcbd1,620680:807f,6c:93f6,6dfc77:f6f8,78:0009171811,65ab78:2d1c1d393a3b1f3c252c23294e6d56572650474c6a9b939a879ca1a3b2b9a5d4d9c9ecf2,790578f479:13241e34,9f9b9e:f9fbfc,76f177:040d,76f977:07081a22192d263538505147435a68,98:0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d#4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e,77:62657f8d7d808c919fa0b0b5bd,75:3a404e4b485b727983,7f:58615f,8a487f:68747179817e,76:cde5,883294:8586878b8a8c8d8f909497959a9b9ca3a4abaaadacafb0b2b4b6b7b8b9babcbdbfc4c8c9cacbcccdced0d1d2d5d6d7d9d8dbdedfe0e2e4e5e7e8ea,98:6f70717273748b8e929599a3a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcfd0d4d6d7dbdcdde0e1e2e3e4#e5e6e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,99:0001020304050607,94:e9ebeeeff3f4f5f7f9fcfdff,95:03020607090a0d0e0f1213141516181b1d1e1f222a2b292c3132343637383c3e3f4235444546494c4e4f525354565758595b5e5f5d61626465666768696a6b6c6f7172733a,77:e7ec,96c979:d5ede3eb,7a065d477a:03021e14,99:08090a0b0c0e0f1112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2f303132333435363738393a3b3c3d3e3f40414243444546474849#4a4b4c4d4e4f50515253565758595a5b5c5d5e5f60616264667378797b7e828389,7a:393751,9ecf99a57a7076:888e9399a4,74:dee0,752c9e:202228292a2b2c3231363837393a3e414244464748494b4c4e5155575a5b5c5e63666768696a6b6c716d73,75:929496a09daca3b3b4b8c4b1b0c3c2d6cde3e8e6e4ebe7,760375:f1fcff,76:1000050c170a25181519,99:8c8e9a9b9c9d9e9fa0a1a2a3a4a6a7a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8#d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9,76:1b3c2220402d303f35433e334d5e545c566b6f,7fca7a:e6787980868895a6a0aca8adb3,88:6469727d7f82a2c6b7bcc9e2cee3e5f1,891a88:fce8fef0,89:2119131b0a342b3641667b,758b80e576:b2b4,77dc80:1214161c20222526272928310b3543464d526971,898398:788083,99:fafbfcfdfeff,9a:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738#393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f50515253545556575859,98:898c8d8f949a9b9e9fa1a2a5a6,86:4d546c6e7f7a7c7ba88d8bac9da7a3aa93a9b6c4b5ceb0bab1afc9cfb4e9f1f2edf3d0,871386:def4dfd8d1,87:0307,86f887:080a0d09233b1e252e1a3e48343129373f82227d7e7b60704c6e8b53637c64596593afa8d2,9a:5a5b5c5d5e5f606162636465666768696a6b7283898d8e949599a6a9aaabacadaeafb2b3b4b5b9bbbdbebfc3c4c6c7c8c9cacdcecfd0d2d4d5d6d7d9dadbdc#dddee0e2e3e4e5e7e8e9eaeceef0f1f2f3f4f5f6f7f8fafcfdfeff,9b:000102040506,87:c68885ad9783abe5acb5b3cbd3bdd1c0cadbeae0ee,88:1613,87fe88:0a1b21393c,7f:36424445,82107a:fafd,7b:080304150a2b0f47382a192e31202524333e1e585a45754c5d606e7b62727190a6a7b8ac9da885aa9ca2abb4d1c1ccdddae5e6ea,7c0c7b:fefc,7c:0f160b,9b:07090a0b0c0d0e1011121415161718191a1b1c1d1e2021222425262728292a2b2c2d2e3031333435363738393a3d3e3f40464a4b4c4e50525355565758595a#5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b,7c:1f2a26384140,81fe82:010204,81ec884482:2122232d2f282b383b33343e44494b4f5a5f68,88:7e8588d8df,895e7f:9d9fa7afb0b2,7c7c65497c:919d9c9ea2b2bcbdc1c7cccdc8c5d7e8,826e66a87f:bfced5e5e1e6e9eef3,7cf87d:77a6ae,7e:479b,9e:b8b4,8d:73849491b1676d,8c:4749,91:4a504e4f64,9b:7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9ba#bbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadb,91:626170696f7d7e7274798c85908d91a2a3aaadaeafb5b4ba,8c559e7e8d:b8eb,8e:055969,8d:b5bfbcbac4d6d7dadececfdbc6ecf7f8e3f9fbe4,8e098dfd8e:141d1f2c2e232f3a4039353d3149414251524a70767c6f74858f94909c9e,8c:78828a859894,659b89:d6dedadc,9b:dcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9c:000102030405060708090a0b0c0d0e0f101112131415161718191a#1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b,89:e5ebef,8a3e8b26975396:e9f3ef,97:0601080f0e2a2d303e,9f:808385868788898a8c,9efe9f:0b0d,96:b9bcbdced2,77bf96e092:8eaec8,93:3e6aca8f,94:3e6b,9c:7f8285868788,7a239c:8b8e90919294959a9b9e9fa0a1a2a3a5a6a7a8a9abadaeb0b1b2b3b4b5b6b7babbbcbdc4c5c6c7cacb3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a#7b7d7e808384898a8c8f93969798999daaacafb9bebfc0c1c2c8c9d1d2dadbe0e1cccdcecfd0d3d4d5d7d8d9dcdddfe2,97:7c85919294afaba3b2b4,9a:b1b0b7,9e589a:b6babcc1c0c5c2cbccd1,9b:45434749484d51,98e899:0d2e5554,9a:dfe1e6efebfbedf9,9b:080f131f23,9e:bdbe,7e3b9e:8287888b92,93d69e:9d9fdbdcdde0dfe2e9e7e5eaef,9f:222c2f39373d3e44,9c:e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9d:000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f2021#22232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142#92434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f8081#82838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2#92a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1#e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff,9e:000102#92030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e24272e30343b3c404d5052535456595d5f606162656e6f727475767778797a7b7c7d80#8183848586898a8c8d8e8f90919495969798999a9b9c9ea0a1a2a3a4a5a7a8a9aa#92abacadaeafb0b1b2b3b5b6b7b9babcbfc0c1c2c3c5c6c7c8cacbccd0d2d3d5d6d7d9dadee1e3e4e6e8ebecedeef0f1f2f3f4f5f6f7f8fafdff,9f:000102030405#060708090a0c0f1112141516181a1b1c1d1e1f21232425262728292a2b2d2e3031#923233343536383a3c3f4041424345464748494a4b4c4d4e4f52535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778#797a7b7c7d7e81828d8e8f9091929394959697989c9d9ea1a2a3a4a5,f9:2c7995e7f1#92,fa:0c0d0e0f111314181f20212324272829,e8:15161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40414243#4445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f6061626364'), U2Ghash: any = {}, G2Uhash: any = {}; // @ts-ignore !function (data: any) { let k = 0; data = data.match(/..../g); for (let i = 0x81; i &lt;= 0xfe; i += 1) { for (let j = 0x40; j &lt;= 0xFE; j += 1) { U2Ghash[data[k += 1]] = (%${i.toString(16)}%${j.toString(16)}) .toUpperCase(); } } for (const key in U2Ghash) { G2Uhash[U2Ghash[key]] = key; } }(data); function isAscii(unicode: any) { return ((unicode === 0x20AC) || (unicode &lt;= 0x007F &amp;&amp; unicode &gt;= 0x0000)); } return { encode: function (str: any) { return str.replace(/./g, (a: any) =&gt; { const code = a.charCodeAt(0); if (isAscii(code)) { return encodeURIComponent(a); } const key = code.toString(16); // @ts-ignore if (key.length !== 4) key = (000${key}).match(/..../)[0]; return U2Ghash[key] || a; }); }, decode: function (str: any) { return str.replace(/%[0-9A-F]{2}%[0-9A-F]{2}/g, (a: any) =&gt; { if (a in G2Uhash) { // @ts-ignore return String.fromCharCode(`0x{G2Uhash[a]}`); } return a; }).replace(/%[\\w]{2}/g, (a: any) =&gt; decodeURIComponent(a)); } }; }(); export default util; 存储localStorage /** @FileName lStorage.ts @Author @Version V 0.0.1 @Date @Title 存储localStorage @Desc **/ const isNull = (obj: any) =&gt; typeof obj === 'undefined' || obj === null; const trim = (str: any) =&gt; isNull(str) ? '' : (${str}).replace(/[1]+|[\\s\\uFEFF\\xA0]+$/g, ''); const getAll = () =&gt; { const len = localStorage.length; // 获取长度 // console.log(len); // 输出5 const arr: Array = []; // 定义数据集 for (let i = 0; i &lt; len; i += 1) { // 获取key 索引从0开始 const getKey = localStorage.key(i) || ''; // 获取key对应的值 const getVal = localStorage.getItem(getKey); // 放进数组 arr[i] = { key: getKey, val: getVal }; } return arr; }; const removeItem = (key: string) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return; window.localStorage.removeItem(key); }; const setItem = (key: string, content: any) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return; let contentTxt = content; if (typeof content !== 'string') { contentTxt = JSON.stringify(content); } window.localStorage.setItem(key, contentTxt); }; const getItem = (key: string) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return ''; return window.localStorage.getItem(key) || ''; }; const removeDataFromKey = (key = '') =&gt; { const all: any = getAll(); for (let i = 0, len = all.length; i &lt; len; i += 1) { if (trim(all[i].key).indexOf(key) !== -1) { removeItem(all[i].key); } } }; export default { // 存储localStorage setItem, // 获取localStorage getItem, // 删除localStorage removeItem, // 从localStorage删除所有保存的数据 clear: () =&gt; window.localStorage.clear(), // 获取所有的 缓存数据 getAll, // 删除指定 key匹配的数据 removeDataFromKey }; sessionStorage操作 /** @FileName sStorage.ts @Author @Version V 0.0.1 @Date @Title sessionStorage操作 @Desc **/ const setItem = (key: string, content: any) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return; sessionStorage.setItem(key, JSON.stringify(content)); }; const getItem = (key: string) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return; return JSON.parse(sessionStorage.getItem(key) || ''); }; const removeItem = (key: string) =&gt; { if (!key &amp;&amp; typeof window === 'undefined') return; sessionStorage.removeItem(key); }; const clear = () =&gt; { sessionStorage.clear(); }; export default { setItem, getItem, removeItem, clear }; mockjs 动态模拟数据 yarn add mockjs --dev /** @FileName mock.ts @Author @Version V 0.0.1 @Date @Title 动态模拟数据 @Desc **/ import Mock from 'mockjs'; class MockJs { private baseUrl: string; constructor(baseUrl = '') { this.baseUrl = baseUrl; } /** 基础方法 @param path 拦截的路径 @param params 返回的模拟数据 @param method 拦截的method */ action(path: string, params: any, method = 'post') { Mock.mock(new RegExp(^${this.baseUrl + path}), method, params); } get(path: string, params: any) { return this.action(path, params, 'get'); } post(path: string, params: any) { return this.action(path, params, 'post'); } put(path: string, params: any) { return this.action(path, params, 'put'); } patch(path: string, params: any) { return this.action(path, params, 'patch'); } delete(path: string, params: any) { return this.action(path, params, 'delete'); } head(path: string, params: any) { return this.action(path, params, 'head'); } options(path: string, params: any) { return this.action(path, params, 'options'); } tpl(data: any = '', msg = '成功', status = 200) { return {msg, data, status}; } } export default MockJs; Tools 通用工具类 /** @FileName tools.ts @Author @Version V 0.0.1 @Date @Title 通用工具类 @Desc **/ import ViewUI from 'view-design'; /* eslint-disable / const utils = { getUUID(len: number, radix: number) { const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); const uuid = []; let i; radix = radix || chars.length; if (len) { for (i = 0; i &lt; len; i += 1) uuid[i] = chars[0 | Math.random() * radix]; } else { let r; uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; uuid[14] = '4'; for (i = 0; i &lt; 36; i += 1) { if (!uuid[i]) { r = 0 | Math.random() * 16; uuid[i] = chars[(i === 19) ? (r &amp; 0x3) | 0x8 : r]; } } } return uuid.join(''); }, getResult(arr = [], id = '', find = 'id', result = 'value') { let value = ''; if (id === undefined || id === null || !find || !result) { return ''; } arr.map((e) =&gt; { if (e[find] === id) { value = e[result]; } return e; }); return value; }, object: { isObject(obj: any) { return typeof obj === 'object'; }, isFunction(obj: any) { return typeof obj === 'function'; }, isArray(obj: any) { return this.isNotNull(obj) &amp;&amp; obj.constructor === Array; }, isNull(obj: any) { return typeof obj === 'undefined' || obj === null || this.length(obj) === 0; }, isNotNull(obj: any) { return !this.isNull(obj); }, length(obj: any) { let count = 0; for (const i in obj) { // 如果包含除它的原型本身之外的属性 if (Object.prototype.hasOwnProperty.call(obj, i)) { count += 1; } } return count; }, getChildrenPath(obj: any, c: any, k: any): any { if (this.isNull(obj)) { return null; } if (obj === c) { return k; } if (this.isObject(obj)) { let v; for (const key in obj) { if (!Object.prototype.hasOwnProperty.call(obj, key)) continue; v = this.getChildrenPath(obj[key], c, key); if (utils.string.isNotBlank(v)) { return ${utils.string.isNotBlank(k) ?{k}.` : &#039;&#039;}{v}; } } } return null; }, merge(t: any, s: any, mergeArray = false) { for (const k in s) { if (!Object.prototype.hasOwnProperty.call(s, k) || typeof s[k] === 'undefined' || s[k] === null) continue; const item = s[k]; switch (item.constructor) { case Object: { if (t[k] &amp;&amp; t[k].constructor === Object) { this.merge(t[k], item); } else { t[k] = item; } break; } case Array: { if (item.length &lt; 1) { break; } if (mergeArray &amp;&amp; t[k] &amp;&amp; t[k].constructor === Array) { t[k] = [...t[k], ...item]; } else { t[k] = item; } break; } case String: { if (item.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '').length &gt; 0) { t[k] = item; } break; } default: { t[k] = item; } } } return t; } }, string: { trim(str: any) { return utils.object.isNull(str) ? '' : ({str}`).replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+/g, ''); }, isBlank(str: any) { return utils.object.isNull(str) || this.trim(str).length === 0; }, isNotBlank(str: any) { return !this.isBlank(str); }, isEmpty(str: any) { return utils.object.isNull(str) || (${str}).length === 0; }, isNotEmpty(str: any) { return !this.isEmpty(str); }, equalsIgnoreCase(a: any, b: any) { if (utils.object.isNull(a) || utils.object.isNull(b)) { return false; } return (${a}).toLowerCase() === (${b}).toLowerCase(); } }, list: { isEmpty(l: any) { return utils.object.isNull(l) || l.length &lt; 1; }, isNotEmpty(l: any) { return !utils.list.isEmpty(l); }, stringToList(s: any) { const txt = typeof s === 'string' ? s.split(',') : s; return s &amp;&amp; s.length &gt; 0 ? txt : []; }, find(l: any, k: any, v: any, j: any) { const n = []; if (utils.list.isNotEmpty(l)) { for (let i = 0, len = l.length, r = l[i]; i &lt; len; i += 1) { if (j ? r[k] === v : ${r[k]} === ${v}) n.push(r); } } return n; }, indexOf(l: any, k: any, v: any, b: any, j: any) { let n = -1; if (utils.list.isNotEmpty(l)) { for (let i = b || 0, len = l.length, r = l[i]; i &lt; len; i += 1) { if (j ? r[k] === v : ${r[k]} === ${v}) { n = i; break; } } } return n; } }, map: { mapsExtVal(maps: any, key: any) { const list = []; for (let i = 0, len = maps.length; i &lt; len; i += 1) { list.push(maps[i][key]); } return list; }, listToMap(list: any, key: any) { if (utils.object.isNull(list) || utils.string.isEmpty(key)) { return null; } const map: any = {}; for (let i = 0, len = list.length; i &lt; len; i += 1) { const row = list[i]; map[row[key]] = row; } return map; }, isEqualForString(a: any, b: any) { return utils.map.isEqual(a, b, null, true); }, isEmpty(m: any) { return utils.object.isNull(m) || this.keys(m).length &lt; 1; }, isNotEmpty(m: any) { return !this.isEmpty(m); }, isEqual(a: any, b: any, isWeak: any, isString: any) { if (utils.object.isNull(a) &amp;&amp; utils.object.isNull(b)) { return true; } if (utils.object.isNull(a) || utils.object.isNull(b)) { return false; } const aks: any = this.keys(a); const bks: any = this.keys(b); const aksl: number = aks.length; const bksl: number = bks.length; if (aksl !== bksl) { return false; } for (let i = 0; i &lt; aksl; i += 1) { if (isWeak || isString ? ${a[aks[i]]} !== ${b[aks[i]]} : a[aks[i]] !== b[aks[i]]) { return false; } } return true; }, keys(m: any): any[] { const keys: any[] = []; for (const key in m) { if (Object.prototype.hasOwnProperty.call(m, key)) { keys.push(key); } } return keys; }, vals(m: any) { const l = []; const keys = utils.map.keys(m); for (let i = 0, len = keys.length; i &lt; len; i += 1) { l.push(m[keys[i]]); } return l; } }, // 格式化手机号 隐藏中间数据 formatPhoneNumber(phone: string) { if (!phone) return ''; return ${String(phone).slice(0, 3)}****${String(phone).slice(-4)}; }, // 数组转 百分比 numberToPercentage(percentage: any) { if (percentage == null) return '--'; const num: any = (Math.round(percentage * 10000) / 100).toFixed(2); return Number(percentage) === 0 ? '0%' : ${Math.abs(num)}%; }, /* @param {Array} target 目标数组 @param {Array} arr 需要查询的数组 @description 判断要查询的数组是否至少有一个元素包含在目标数组中 / hasOneOf: (targetarr: any, arr: any) =&gt; { return targetarr.some((: any) =&gt; arr.indexOf() &gt; -1); }, onMsg: (callback: any) =&gt; { window.onmessage = (res: any) =&gt; { callback(res); }; }, /* 快捷键注册 @param kes @param fun */ compositeKey: (kes: string, fun: any) =&gt; { const k = kes || ''; const fn = fun || function () { }; const ks = k.split('+'); if (ks.length &lt; 2) { console.info('not composite key'); return; } document.addEventListener('keydown', function (e) { const ctrl = e.ctrlKey, shift = e.shiftKey, alt = e.altKey; // @ts-ignore let keyIdent = e.keyIdentifier; if (ctrl &amp;&amp; (ks.indexOf('ctrl') === -1)) { return; } if (shift &amp;&amp; (ks.indexOf('shift') === -1)) { return; } if (alt &amp;&amp; (ks.indexOf('alt') === -1)) { return; } if (e.keyCode &gt; 47 &amp;&amp; e.keyCode &lt; 91) { keyIdent = String.fromCharCode(e.keyCode); } if (keyIdent &amp;&amp; keyIdent.toLowerCase() === ks[ks.length - 1]) { fn(e); } }); }, /** 消息通用模板 @param type @param content @param duration / message: (type: string, content: string, duration = 6) =&gt; { // @ts-ignore ViewUI.Message[type]({ background: true, closable: true, content, duration }); }, /* 弹窗通用模板 @param type @param title @param content @param okCallBack @param cancelCallBack / modal: (type = 'info', title: string, content = '', okCallBack = () =&gt; { }, cancelCallBack = () =&gt; { }) =&gt; { // @ts-ignore ViewUI.Modal[type]({ title: title, content: content, onOk: () =&gt; { okCallBack(); }, onCancel: () =&gt; { cancelCallBack(); } }); }, /* 通知通用模板 @param type @param title @param desc @param duration / notice: (type: string, title: string, desc: string, duration = 6) =&gt; { // @ts-ignore ViewUI.Notice[type]({ title, desc, duration }); }, /* 遍历对象 返回 key value @param obj @param callback */ forIn: (obj: any, callback: any) =&gt; { Object.entries(obj).forEach(entry =&gt; { callback(...entry); }); } }; export default utils; vueTools /** @FileName vueTools.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import createRoutes from './createRoutes'; /** 路由权限判断处 @param to @param next @param homeName / const turnTo = (to: any, next: any, homeName = 'home') =&gt; { next(); }; /* 创建路由 @param title 模板通用标题 @param baseRoutes 基础路由 @param routes 模板路由 @param base 路由根地址，线上统一 / @param homeName 主界面路由名 @param mode 路由模式 默认 history */ const createRoute = (baseRoutes: any = [], routes: any = [], base = '', homeName = 'home', mode: any = 'history') =&gt; { if (process.env.NODE_ENV === 'production') base = ''; const title = ''; // @ts-ignore return createRoutes(baseRoutes, routes, base, homeName, mode, title, turnTo); }; export default {createRoute}; log /** @FileName log.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import moment from './moment'; import lStorage from './lStorage'; import fStorage from 'localforage'; const maxLog = 50; const setErrorLog = (key: string, info: any) =&gt; { if (typeof window !== 'undefined') { lStorage.setItem(key, info); } else { console.log('[ ERROR ]', info); } }; const setApiLog = (key: string, info: any) =&gt; { if (typeof window !== 'undefined') { // @ts-ignore info.time = moment.format(); const storage = fStorage.createInstance({name: key}); storage.keys().then((keys: any) =&gt; { if (keys.length &gt; maxLog) { const num = keys.length - maxLog; const newArr = keys.slice(0, num); newArr.forEach((item: any) =&gt; { storage.removeItem(item).then(() =&gt; { // 当值被移除后，此处代码运行 }).catch((err: any) =&gt; { console.log(err); }); }); } }).catch((err: any) =&gt; { console.error(err); }); // @ts-ignore if (info.status !== 200) { setErrorLog('errorMSG', info); } storage.setItem(moment.format(new Date(), 'x'), JSON.stringify(info)); } else { // @ts-ignore info.time = moment.format(); console.log('[ API ]', info); } }; const setConsoleLog = (key: string, info: any) =&gt; { if (typeof window !== 'undefined') { // @ts-ignore info.time = moment.format(); const storage = fStorage.createInstance({name: key}); storage.keys().then((keys: any) =&gt; { if (keys.length &gt; maxLog) { const num = keys.length - maxLog; const newArr = keys.slice(0, num); newArr.forEach((item: any) =&gt; { storage.removeItem(item).then(() =&gt; { // 当值被移除后，此处代码运行 }).catch((err: any) =&gt; { console.log(err); }); }); } }).catch((err: any) =&gt; { console.error(err); }); storage.setItem(moment.format(new Date(), 'x'), JSON.stringify(info)); } else { // @ts-ignore info.time = moment.format(); console.log('[ API ]', info); } }; const consoleMSG = (type: string, title: string, args: any) =&gt; { if (type === 'table') { // @ts-ignore console.log([ ${type} ] =&gt; ${title}); console.table([...args]); } // @ts-ignore console[type]([ ${type} ] =&gt; ${title}, args); const consoleInfo = { title: title, type, url: location.pathname + location.search, data: args }; setConsoleLog('logStorage', consoleInfo); }; export default { setConsoleLog, setErrorLog, setApiLog, info: (title: string, args: any) =&gt; consoleMSG('info', title, args), error: (title: string, args: any) =&gt; consoleMSG('error', title, args), debug: (title: string, args: any) =&gt; consoleMSG('debug', title, args), warn: (title: string, args: any) =&gt; consoleMSG('warn', title, args), table: (title: string, args: any) =&gt; consoleMSG('table', title, args) }; Axios /** @FileName axios.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import lStorage from './lStorage'; import ViewUI from 'view-design'; import tools from './tools'; import log from './log'; import axios from 'axios'; class HttpRequest { private baseUrl: string; private queue = {}; constructor(baseUrl = '') { this.baseUrl = baseUrl; this.queue = {}; } private static apiMsgTemplate(apiInfo: any) { return &lt;div style=&quot;font-size: 14px;&quot;&gt;&lt;p style=&quot;color: red;font-size: 14px;&quot;&gt;请截图给管理员，以便快捷修复错误！&lt;/p&gt;&lt;p&gt;错误: ${apiInfo.statusText}&lt;/p&gt;&lt;p&gt;method: ${apiInfo.request.method}&lt;/p&gt;&lt;p style=&quot;margin: 5px 0;&quot;&gt;URL:&lt;br&gt; ${apiInfo.request.url}&lt;/p&gt;&lt;p&gt;参数：&lt;br&gt;${apiInfo.request.data.toString()}&lt;/p&gt;&lt;/div&gt;; } private getInsideConfig() { return { baseURL: this.baseUrl, timeout: 10000, responseType: 'json', headers: { 'If-Modified-Since': 0, 'Cache-Control': 'no-cache' } }; } private destroy(url: string) { // @ts-ignore delete this.queue[url]; if (!Object.keys(this.queue).length) { // @ts-ignore ViewUI.LoadingBar.finish(); } } private unusualStatus(code: number, apiInfo: any) { switch (code) { case 0: tools.message('info', ${apiInfo.statusText}, 10); break; case 400: tools.notice('warning', 请求参数错误: ${apiInfo.status}, HttpRequest.apiMsgTemplate(apiInfo), 15); break; case 401: // this.notice('warning', '登录信息', '登录超时或未登录，请重新登录！'); tools.modal('warning', '登录信息', '登录超时或未登录，请重新登录！', () =&gt; { lStorage.setItem('userInfo', ''); lStorage.setItem('isLogin', false); lStorage.setItem('Authorization', ''); lStorage.setItem('errorMSG', ''); location.href = '/login?done=' + location.href; }); break; case 404: tools.notice('info', 资源未找到: ${apiInfo.status}, HttpRequest.apiMsgTemplate(apiInfo), 15); break; case 405: tools.notice('warning', 请求类型错误: ${apiInfo.status}, HttpRequest.apiMsgTemplate(apiInfo), 15); break; case 500: tools.notice('error', 服务器错误: ${apiInfo.status}, HttpRequest.apiMsgTemplate(apiInfo), 15); break; case 503: tools.notice('info', 服务器错误: ${apiInfo.status}, '服务器维护中，请稍后再试！', 15); break; default: tools.message('error', ${apiInfo.status} : ${apiInfo.statusText}); break; } } interceptors(instance: any, url: string) { // 请求拦截 instance.interceptors.request.use( (config: any) =&gt; { // 添加全局的loading... if (!Object.keys(this.queue).length) { // @ts-ignore ViewUI.LoadingBar.start(); } // @ts-ignore this.queue[url] = true; return config; }, (error: any) =&gt; Promise.reject(error) ); // axios 响应拦截 instance.interceptors.response.use( (res: any) =&gt; { this.destroy(url); const {data: {data}, config, request: {responseURL}} = res; const response = res.request; const apiInfo = { status: response.status, statusText: (data &amp;&amp; data.msg) || response.statusText, request: { url: responseURL, api: config.baseURL + config.url || '', method: config.method, data: config.data || '' }, response: { data: data || '' } }; log.setApiLog('apiLogStorage', apiInfo); return data || ''; }, (error: any) =&gt; { this.destroy(url); let apiInfo: any; if (error.response) { const {response: {status, statusText, data, config, request: {responseURL}}} = error; apiInfo = { status, statusText: (data &amp;&amp; data.msg) || statusText, request: { url: responseURL, api: config.baseURL + config.url || '', method: config.method, data: config.data || '' }, response: { data: data || '' } }; } else { const {config, message} = JSON.parse(JSON.stringify(error)); const {request} = error; apiInfo = { status: request.status, statusText: message || request.statusText || '', request: { url: '', api: config.baseURL + config.url || '', method: config.method, data: config.data || '' }, response: { data: '' } }; } log.setApiLog('apiLogStorage', apiInfo); this.unusualStatus(apiInfo.status, apiInfo); if (apiInfo.response &amp;&amp; apiInfo.response.data) { return Promise.reject(apiInfo.response.data); } return Promise.reject(error); } ); } request(options: any) { const instance = axios.create(); options = Object.assign(this.getInsideConfig(), options); this.interceptors(instance, options.url); return instance(options); } } export default HttpRequest; API request /** @FileName api.request.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import HttpRequest from './axios'; import lStorage from './lStorage'; const getTokenToLocalStorage = () =&gt; { return lStorage.getItem('Authorization') || ''; }; class API { private baseUrl: string; private axios: any; constructor(baseUrl = '') { this.baseUrl = baseUrl; this.axios = new HttpRequest(baseUrl); } /** post 请求 @param url 接口url @param data 参数 @param method */ post(url: string, data: any, method = 'post') { return this.axios.request({ url, // data: qs.stringify(data), from 标点传参 data, method, headers: { Authorization: getTokenToLocalStorage() } }); } /** put 请求 @param url 接口url @param data 参数 */ put(url: string, data: any) { return this.post(url, data, 'put'); } /** patch 请求 @param url 接口url @param data 参数 */ patch(url: string, data: any) { return this.post(url, data, 'patch'); } /** get 请求 @param url 接口url @param params 参数 @param method */ get(url: string, params: any, method = 'get') { return this.axios.request({ url, params, method, headers: { Authorization: getTokenToLocalStorage() } }); } /** delete 请求 @param url 接口url @param params 参数 */ delete(url: string, params: any) { return this.get(url, params, 'delete'); } /** head 请求 @param url 接口url @param params 参数 */ head(url: string, params: any) { return this.get(url, params, 'head'); } /** options 请求 @param url 接口url @param params 参数 */ options(url: string, params: any) { return this.get(url, params, 'options'); } /** axios本版本不支持jsonp 自己拓展一个 @param url */ jsonp(url: string) { if (!url) { console.error('Axios.JSONP 至少需要一个url参数!'); return; } return new Promise((resolve: any) =&gt; { // @ts-ignore window.jsonCallBack = (result: any) =&gt; { resolve(result); }; const JSONP = document.createElement('script'); JSONP.type = 'text/javascript'; JSONP.src = ${url}&amp;callback=jsonCallBack; document.getElementsByTagName('head')[0].appendChild(JSONP); setTimeout(() =&gt; { document.getElementsByTagName('head')[0].removeChild(JSONP); }, 500); }); } } export default API; 工具类统一导出 /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import moment from './moment'; import log from './log'; import API from './api.request'; import cookie from './cookie'; import gbk from './gbk'; import lStorage from './lStorage'; import sStorage from './sStorage'; import tools from './tools'; import MockJs from './mock'; import createRoutes from './createRoutes'; export default { ...tools, moment, cookie, log, API, gbk, lStorage, sStorage, MockJs, createRoutes }; API &amp; Mock 相关文件目录 ├─node_modules ├─public │ └─img │ └─icons ├─src │ ├─assets │ ├─components │ │ └─log │ ├─data │ │ ├─api │ │ │ └─test │ │ └─mock │ │ └─test │ ├─layout │ ├─libs │ ├─router │ ├─store │ └─views └─tests └─unit api 1、新建 /src/data/api 目录 2、新建 /src/data/api/test/index.ts 文件 接口调用配置 /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import tools from '@/libs/index'; const baseUrl = '/api'; const api = new tools.API(baseUrl); export default { // 获取用户信息 http://192.192.192.201:9001/app/mock/1/user/info getUserInfoData: () =&gt; api.get('/user/info', {}) }; 3、新建 /src/data/api/index.ts 文件 导出接口， /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import test from './test'; export default {test}; 4、新建 /src/index.ts 文件 所有通用引用配置，方便以后做多入口项目 /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import Vue from 'vue'; import ViewUI from 'view-design'; import tools from '@/libs/index'; import api from '@/data/api'; import 'view-design/dist/styles/iview.css'; Vue.use(ViewUI); declare module 'vue/types/vue' { interface Vue { api: any; log: any; CDN: any; tool: any; config: any; } } console.log(process.env); Vue.prototype.config = process.env; Vue.prototype.log = tools.log; Vue.prototype.tool = tools; Vue.prototype.api = api; Vue.prototype.CDN = (path: string) =&gt; ${process.env.VUE_APP_CDN || ''}${path}; Vue.config.productionTip = false; 5、 /src/main.ts 导入/src/index.ts import Vue from 'vue'; import App from './App.vue'; import router from './router'; import store from './store'; import '@/index'; new Vue({ router, store, render: h =&gt; h(App) }).$mount('#app'); 6、页面调用 api 接口 /src/views/Home.vue import {Component, Vue} from 'vue-property-decorator'; import HelloWorld from '@/components/HelloWorld.vue'; // @ is an alias to /src @Component({ components: { HelloWorld } }) export default class Home extends Vue { mounted() { this.getUserInfoAction(); } async getUserInfoAction() { try { const idCard = '33082219510203094X'; const data = await this.api.test.getUserInfoData(idCard); this.log.info('接口测试信息 - get', data); return data; } catch (e) { this.log.error('接口测试信息 - get', e); } } } Mock 1、新建 /src/data/mock 目录 2、新建 /src/data/mock/test/index.ts 文件 mock配置，目录结构和api保持一致，方便后期维护 /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import tools from '@/libs/index'; const baseUrl = '/api'; const mock = new tools.MockJs(baseUrl); mock.get('/user/info', mock.tpl({title: '@title'})); 3、根目录 .env 文件配置mock开关 NODE_ENV = 'development' VUE_APP_MOCK = true 4、/src/index.ts 导入mock /** @FileName index.ts @Author @Version V 0.0.1 @Date @Title @Desc **/ import Vue from 'vue'; import ViewUI from 'view-design'; import tools from '@/libs/index'; import api from '@/data/api'; import 'view-design/dist/styles/iview.css'; /* eslint-disable */ if (process.env.VUE_APP_MOCK === 'true') require('./data/mock'); Vue.use(ViewUI); declare module 'vue/types/vue' { interface Vue { api: any; log: any; CDN: any; tool: any; config: any; } } console.log(process.env); Vue.prototype.config = process.env; Vue.prototype.log = tools.log; Vue.prototype.tool = tools; Vue.prototype.api = api; Vue.prototype.CDN = (path: string) =&gt; ${process.env.VUE_APP_CDN || ''}${path}; Vue.config.productionTip = false; \\s\\uFEFF\\xA0 ↩︎ ","link":"https://kangjn.github.io/post/vue20-typescript-xiang-mu-da-jian/"},{"title":"理解高性能、高并发(七)：深入操作系统，一文读懂进程、线程、协程","content":"1、什么是进程？ 1.1 基本常识 我们需要明确一下几个常识： 1）计算机的核心是CPU，它承担了所有的计算任务； 2）操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件； 3）应用程序则是具有某种功能的程序，程序是运行于操作系统之上的。 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。 进程一般由程序、数据集合和进程控制块三部分组成： 1）程序用于描述进程要完成的功能，是控制进程执行的指令集； 2）数据集合是程序在执行时所需要的数据和工作区； 3）程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。 进程具有的特征： 1）动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的； 2）并发性：任何进程都可以同其他进程一起并发执行； 3）独立性：进程是系统进行资源分配和调度的一个独立单位； 4）结构性：进程由程序、数据和进程控制块三部分组成。 1.2 为什么要有多进程？ 多进程目的：提高cpu的使用率。 **一个例子：**一个用户现在既想使用打印机，又想玩游戏。 *假设只有一个进程（先不谈多线程）：* 从操作系统的层面看，我们使用打印机的步骤有如下： 1）使用CPU执行程序，去硬盘读取需要打印的文件，然后CPU会长时间的等待，直到硬盘读写完成； 2）使用CPU执行程序，让打印机打印这些内容，然后CPU会长时间的等待，等待打印结束。 **在这样的情况下：**其实CPU的使用率其实非常的低。 打印一个文件从头到尾需要的时间可能是1分钟，而cpu使用的时间总和可能加起来只有几秒钟。而后面如果单进程执行游戏的程序的时候，CPU也同样会有大量的空闲时间。 *使用多进程后：* 当CPU在等待硬盘读写文件，或者在等待打印机打印的时候，CPU可以去执行游戏的程序，这样CPU就能尽可能高的提高使用率。 再具体一点说，其实也提高了效率。因为在等待打印机的时候，这时候显卡也是闲置的，如果用多进程并行的话，游戏进程完全可以并行使用显卡，并且与打印机之间也不会互相影响。 1.3 小结一下 **进程，直观点说：**保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。 操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。 2、什么是线程？ 2.1 基本常识 早期：操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。 后来：随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程。 线程是程序执行中一个单一的顺序控制流程： 1）是程序执行流的最小单元； 2）是处理器调度和分派的基本单位。 一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针（PC）、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。 **如上图所示：**在任务管理器的进程一栏里，有道词典和有道云笔记就是进程，而在进程下又有着多个执行不同任务的线程。 2.2 任务调度 线程是什么？要理解这个概念，需要先了解一下操作系统的一些相关概念。 大部分操作系统（如Windows、Linux）的任务调度是采用时间片轮转的抢占式调度方式。 **在一个进程中：**当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。 **上述过程中：**任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。 这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发（别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行）。 多任务运行过程的示意图如下： ▲ 操作系统中的任务调度 2.3 进程与线程的区别 前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系。 下面就让我们一起来理一理： 1）线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位； 2）一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 3）进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其它进程不可见； 4）线程上下文切换比进程上下文切换要快得多。 以下线程与进程关系的示意图。 ▲ 进程与线程的资源共享关系 ▲ 单线程与多线程的关系 **总之：**线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。 在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程（Lightweight Process，LWP）。 ▲ 早期的操作系统只有进程，没有线程 后来：随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个（也可以是一个）线程。 ▲ 线程的出现，使得一个进程可以有多个线程 2.4 多线程与多核 上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。 那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？ 其实：“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。 ***多核(心)处理器是指：***在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。 内核线程（Kernel Thread，KLT）：就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。 一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。 现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器 -&gt; 性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。 ▲ 双核四线程在Windows8下查看的结果 超线程技术：就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术（如双核四线程）由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。 由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。 用户线程与内核线程的对应关系有三种模型： 1）一对一模型； 2）多对一模型； 3）多对多模型。 在下面的文字中，将以4个内核线程、3个用户线程为例对三种模型进行说明。 2.5 一对一模型 **对于一对一模型来说：**一个用户线程就唯一地对应一个内核线程（反过来不一定成立，一个内核线程不一定有对应的用户线程）。 **这样：**如果CPU没有采用超线程技术（如四核四线程的计算机），一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。 一对一模型使用户线程具有与内核线程一样的优点：一个线程因某种原因阻塞时其他线程的执行不受影响（此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现）。 但一对一模型也有两个缺点： 1）许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制； 2）许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。 ▲ 一对一模型 2.6 多对一模型 多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。 因此，相对一对一模型： 1）多对一模型的线程上下文切换速度要快许多； 2）多对一模型对用户线程的数量几乎无限制。 但多对一模型也有两个缺点： 1）如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了； 2）在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。 ▲ 多对一模型 2.7 多对多模型 多对多模型结合了一对一模型和多对一模型的优点：将多个用户线程映射到多个内核线程上，由线程库负责在可用的可调度实体上调度用户线程。 这使得线程的上下文切换非常快：因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。 多对多模型的优点有： 1）一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行； 2）多对多模型对用户线程的数量没有限制； 3）在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。 ▲ 多对多模型 在现在流行的操作系统中，大都采用多对多的模型。 2.8 查看进程与线程 一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？ 在Windows下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按“Ctrl+Alt+Del”或右键快捷工具栏打开任务管理器。 查看进程数和线程数： 在“进程”选项卡下，我们可以看到一个应用程序包含的线程数。 如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google的Chrome浏览器就有多个进程。 同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个cmd窗口，就有两个cmd进程。如果看不到线程数这一列，可以再点击“查看 -&gt; 选择列”菜单，增加监听的列。 查看CPU和内存的使用率：在性能选项卡中，我们可以查看CPU和内存的使用率，根据CPU使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。 ▲ 查看CPU和内存的使用率 2.9 线程的生命周期 当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。 但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。 在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及macOS等流行的操作系统。 我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。 ▲ 早期进程的生命周期 进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。 早期进程的生命周期详细说明如下： 创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。 ▲ 线程的生命周期 线程的生命周期跟进程很类似： 创建：一个新的线程被创建，等待该线程被调用执行； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。 3、什么是协程？ 3.1 基本常识 协程：英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做“用户空间线程”，具有对内核来说不可见的特性。 因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。 3.2 协程的目的 对于Java程序员来说，在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。 如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。 最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。 对于上述问题：现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是 [node.js]以及 Java 里的新秀 [Vert.x]。 而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。 3.3 协程的特点 协程的特点总结一下就是： 1）线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率； 2）线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程； 3）由于在同一个线程上，因此可以避免竞争关系而使用锁； 4）适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。 3.4 协程的原理 当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑。 这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如：Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。 由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。 **因此：**协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。 3.5 协程和线程的比较 4、总结一下 我们总结一下。 进程和线程的区别就是： 1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源； 4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 进程和线程之间的联系就是： 1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 2）资源分配给进程，同一进程的所有线程共享该进程的所有资源； 3）处理机分给线程，即真正在处理机上运行的是线程； 4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 *那么，既然有了线程，为啥还要有协程？* 考虑这一样一种场景： 开发者在每个线程中只做非常轻量的操作，比如访问一个极小的文件，下载一张极小的图片，加载一段极小的文本等。但是，这样”轻量的操作“的量却非常多。 在有大量这样的轻量操作的场景下，即使可以通过使用线程池来避免创建与销毁的开销，但是线程切换的开销也会非常大，甚至于接近操作本身的开销。 对于这些场景，就非常需要一种可以减少这些开销的方式。于是，协程就应景而出，非常适合这样的场景。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-qi-shen-ru-cao-zuo-xi-tong-yi-wen-du-dong-jin-cheng-xian-cheng-xie-cheng/"},{"title":"理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的","content":"1、多进程 历史上最早出现也是最简单的一种并行处理多个请求的方法就是利用[多进程]。 比如在Linux世界中，我们可以使用fork、exec等系统调用创建多个进程，我们可以在父进程中接收用户的连接请求，然后创建子进程去处理用户请求。 就像这样： 这种方法的优点就在于： 1）编程简单，非常容易理解； 2）由于各个进程的地址空间是相互隔离的，因此一个进程崩溃后并不会影响其它进程； 3）充分利用多核资源。 多进程并行处理的优点很明显，但是缺点同样明显： 1）各个进程地址空间相互隔离，这一优点也会变成缺点，那就是进程间要想通信就会变得比较困难，你需要借助进程间通信（IPC，interprocess communications）机制，想一想你现在知道哪些进程间通信机制，然后让你用代码实现呢？显然，进程间通信编程相对复杂，而且性能也是一大问题； 2）我们知道创建进程开销是比线程要大的，频繁的创建销毁进程无疑会加重系统负担。 2、多线程 不是创建进程开销大吗？不是进程间通信困难吗？这些对于线程来说统统不是问题。 由于线程共享进程地址空间，因此线程间通信天然不需要借助任何通信机制，直接读取内存就好了。 线程创建销毁的开销也变小了，要知道线程就像寄居蟹一样，房子（地址空间）都是进程的，自己只是一个租客，因此非常的轻量级，创建销毁的开销也非常小。 我们可以为每个请求创建一个线程，即使一个线程因执行I/O操作——比如读取数据库等——被阻塞暂停运行也不会影响到其它线程。 就像这样： 但线程就是完美的、包治百病的吗，显然，计算机世界从来没有那么简单。 由于线程共享进程地址空间，这在为线程间通信带来便利的同时也带来了无尽的麻烦。 正是由于线程间共享地址空间，因此一个线程崩溃会导致整个进程崩溃退出，同时线程间通信简直太简单了，简单到线程间通信只需要直接读取内存就可以了，也简单到出现问题也极其容易，死锁、线程间的同步互斥、等等，这些极容易产生bug，无数程序员宝贵的时间就有相当一部分用来解决多线程带来的无尽问题。 虽然线程也有缺点，但是相比多进程来说，线程更有优势，但想单纯的利用多线程就能解决高并发问题也是不切实际的。 因为虽然线程创建开销相比进程小，但依然也是有开销的，对于动辄数万数十万的链接的高并发服务器来说，创建数万个线程会有性能问题，这包括内存占用、线程间切换，也就是调度的开销。 3、事件驱动：Event Loop 到目前为止，我们提到“并行”二字就会想到进程、线程。 **但是：**并行编程只能依赖这两项技术吗？并不是这样的！ 还有另一项并行技术广泛应用在GUI编程以及服务器编程中，这就是近几年非常流行的事件驱动编程：event-based concurrency。实际上事件驱动编程原理上非常简单。 这一技术需要两种原料： 1）event； 2）处理event的函数，这一函数通常被称为event handler； 剩下的就简单了：你只需要安静的等待event到来就好，当event到来之后，检查一下event的类型，并根据该类型找到对应的event处理函数，也就是event handler，然后直接调用该event handler就好了。 **从上面可以看到：**我们需要不断的接收event然后处理event，因此我们需要一个循环（用while或者for循环都可以），这个循环被称为Event loop。 使用伪代码表示就是这样： while(true) { event = getEvent(); handler(event); } Event loop中要做的事情其实是非常简单的，只需要等待event的带来，然后调用相应的event处理函数即可。 **注意：**这段代码只需要运行在一个线程或者进程中，只需要这一个event loop就可以同时处理多个用户请求。 **有的可以依然不明白：**为什么这样一个event loop可以同时处理多个请求呢？ **原因很简单：**对于网络通信服务器来说，处理一个用户请求时大部分时间其实都用在了I/O操作上，像数据库读写、文件读写、网络读写等。当一个请求到来，简单处理之后可能就需要查询数据库等I/O操作，我们知道I/O是非常慢的，当发起I/O后我们大可以不用等待该I/O操作完成就可以继续处理接下来的用户请求。 **现在你应该明白了吧：**虽然上一个用户请求还没有处理完我们其实就可以处理下一个用户请求了，这也是并行，这种并行就可以用事件驱动编程来处理。 **这就好比餐厅服务员一样：**一个服务员不可能一直等上一个顾客下单、上菜、吃饭、买单之后才接待下一个顾客，服务员是怎么做的呢？当一个顾客下完单后直接处理下一个顾客，当顾客吃完饭后会自己回来买单结账的。 **看到了吧：**同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event loop只运行在一个线程(进程)中也可以同时处理多个用户请求。 相信你已经对事件驱动编程有一个清晰的认知了，那么接下来的问题就是，这个事件也就是event该怎么获取呢？ 4、事件来源：IO多路复用 在Linux/Unix世界中一切皆文件，而我们的程序都是通过文件描述符来进行I/O操作的，当然对于网络编程中的socket也不例外。 那我们该如何同时处理多个文件描述符呢？ **IO多路复用技术正是用来解决这一问题的：**通过IO多路复用技术，我们一次可以监控多个文件描述，当某个“文件”（实际可能是im网络通信中socket）可读或者可写的时候我们就能得到通知啦。 这样IO多路复用技术就成了event loop的原材料供应商，源源不断的给我们提供各种event，这样关于event来源的问题就解决了。 **至此：**关于利用事件驱动来实现并发编程的所有问题都解决了吗？event的来源问题解决了，当得到event后调用相应的handler，看上去大功告成了。 5、问题：阻塞式IO **现在：**我们可以使用一个线程（进程）就能基于事件驱动进行并行编程，再也没有了多线程中让人恼火的各种锁、同步互斥、死锁等问题了。 **但是：**计算机科学中从来没有出现过一种能解决所有问题的技术，现在没有，在可预期的将来也不会有。 那上述方法有什么问题吗？ 不要忘了，我们event loop是运行在一个线程（进程），这虽然解决了多线程问题，但是如果在处理某个event时需要进行IO操作会怎么样呢？ 我们讲解了最常用的文件读取在底层是如何实现的，程序员最常用的这种IO方式被称为阻塞式IO。 **也就是说：**当我们进行IO操作，比如读取文件时，如果文件没有读取完成，那么我们的程序（线程）会被阻塞而暂停执行，这在多线程中不是问题，因为操作系统还可以调度其它线程。 **但是：**在单线程的event loop中是有问题的，原因就在于当我们在event loop中执行阻塞式IO操作时整个线程（event loop）会被暂停运行，这时操作系统将没有其它线程可以调度，因为系统中只有一个event loop在处理用户请求，这样当event loop线程被阻塞暂停运行时所有用户请求都没有办法被处理。你能想象当服务器在处理其它用户请求读取数据库导致你的请求被暂停吗？ **因此：**在基于事件驱动编程时有一条注意事项，那就是不允许发起阻塞式IO。 有的可能会问，如果不能发起阻塞式IO的话，那么该怎样进行IO操作呢？ **PS：**有阻塞式IO，就有非阻塞式IO。 6、解决方法：非阻塞式IO 为克服阻塞式IO所带来的问题，现代操作系统开始提供一种新的发起IO请求的方法，这种方法就是异步IO。对应的，阻塞式IO就是同步IO。 异步IO时，假设调用aio_read函数（具体的异步IO API请参考具体的操作系统平台），也就是异步读取，当我们调用该函数后可以立即返回，并继续其它事情，虽然此时该文件可能还没有被读取，这样就不会阻塞调用线程了。此外，操作系统还会提供其它方法供调用线程来检测IO操作是否完成。 就这样，在操作系统的帮助下IO的阻塞调用问题也解决了。 7、基于事件驱动并行编程的难点 虽然有异步IO来解决event loop可能被阻塞的问题，但是基于事件编程依然是困难的。 **首先：**我们提到，event loop是运行在一个线程中的，显然一个线程是没有办法充分利用多核资源的，有的同学可能会说那就创建多个event loop实例不就可以了，这样就有多个event loop线程了，但是这样一来多线程问题又会出现。 另一点在于编程方面，异步编程需要结合回调函数（这种编程方式需要把处理逻辑分为两部分：一部分调用方自己处理，另一部分在回调函数中处理），这一编程方式的改变加重了程序员在理解上的负担，基于事件编程的项目后期会很难扩展以及维护。 8、更好的方法 为什么我们要使用异步这种难以理解的方式编程呢？ **是因为：**阻塞式编程虽然容易理解但会导致线程被阻塞而暂停运行。 **那么你一定会问了：**有没有一种方法既能结合同步IO的简单理解又不会因同步调用导致线程被阻塞呢？ **答案是肯定的：**这就是用户态线程（user level thread），也就是协程。 虽然基于事件编程有这样那样的缺点，但是在当今的高性能高并发服务器上基于事件编程方式依然非常流行，但已经不是纯粹的基于单一线程的事件驱动了，而是 event loop + multi thread + user level thread。 9、本文小结 高并发技术从最开始的多进程一路演进到当前的事件驱动，计算机技术就像生物一样也在不断演变进化，但不管怎样，了解历史才能更深刻的理解当下。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-liu-tong-su-yi-dong-gao-xing-neng-fu-wu-qi-dao-di-shi-ru-he-shi-xian-de/"},{"title":"理解高性能、高并发(五)：深入操作系统，理解高并发中的协程","content":"应该如何彻底理解协程。 1、普通的函数 我们先来看一个普通的函数，这个函数非常简单： def func(): print(&quot;a&quot;) print(&quot;b&quot;) print(&quot;c&quot;) 这是一个简单的普通函数，当我们调用这个函数时会发生什么？ 1）调用func； 2）func开始执行，直到return； 3）func执行完成，返回函数A。 是不是很简单，函数func执行直到返回，并打印出： a b c 注意这段代码是用python写的，但本篇关于协程的讨论适用于任何一门语言，因为协程并不是某种语言特有的。而我们只不过恰好使用了python来用作示例，因其足够简单。 那么协程是什么呢？ 2、从普通函数到协程 接下来，我们就要从普通函数过渡到协程了。和普通函数只有一个返回点不同，协程可以有多个返回点。 这是什么意思呢？ void func() { print(&quot;a&quot;) 暂停并返回 print(&quot;b&quot;) 暂停并返回 print(&quot;c&quot;) } 普通函数下，只有当执行完print(&quot;c&quot;)这句话后函数才会返回，但是在协程下当执行完print(&quot;a&quot;)后func就会因“暂停并返回”这段代码返回到调用函数。 有的可能会一脸懵，这有什么神奇的吗？ 我写一个return也能返回，就像这样： void func() { print(&quot;a&quot;) return print(&quot;b&quot;) 暂停并返回 print(&quot;c&quot;) } 直接写一个return语句确实也能返回，但这样写的话return后面的代码都不会被执行到了。 协程之所以神奇就神奇在当我们从协程返回后还能继续调用该协程，并且是从该协程的上一个返回点后继续执行。 就好比孙悟空说一声“定”，函数就被暂停了： void func() { print(&quot;a&quot;) 定 print(&quot;b&quot;) 定 print(&quot;c&quot;) } 这时我们就可以返回到调用函数，当调用函数什么时候想起该协程后可以再次调用该协程，该协程会从上一个返回点继续执行。在编程语言中一般叫做yield（其它语言中可能会有不同的实现，但本质都是一样的）。 需要注意的是：当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的。 接下来，我们就用实际的代码看一看协程。 3、“Talk is cheap，show me the code” 下面我们使用一个真实的例子来讲解，语言采用python. 在python语言中，这个“定”字同样使用关键词yield。 这样我们的func函数就变成了： void func() { print(&quot;a&quot;) yield print(&quot;b&quot;) yield print(&quot;c&quot;) } **注意：**这时我们的func就不再是简简单单的函数了，而是升级成为了协程，那么我们该怎么使用呢？ 很简单： def A(): co =func() # 得到该协程 next(co) # 调用协程 print(&quot;in function A&quot;) # do something next(co) # 再次调用该协程 我们看到虽然func函数没有return语句，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了。 接下来我们调用该协程，使用next(co)，运行函数A看看执行到第3行的结果是什么： a 显然，和我们的预期一样，协程func在print(&quot;a&quot;)后因执行yield而暂停并返回函数A。 接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印： a in function A 接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢？ 如果func是普通函数，那么会执行func的第一行代码，也就是打印a。 但func不是普通函数，而是协程，我们之前说过，协程会在上一个返回点继续运行，因此这里应该执行的是func函数第一个yield之后的代码，也就是 print(&quot;b&quot;)。 a in function A b 看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行。 4、图形化解释 为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍。 首先是普通的函数调用： **在该图中：**方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向。 **从上图中我们可以看到：**我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行。这是普通的函数调用。 接下来是协程： **在这里：**我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程。 **注意：**协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是从上一次的挂起点开始执行，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束。 5、函数只是协程的一种特例 和普通函数不同的是，协程能知道自己上一次执行到了哪里。 现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。 很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。 只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。 这就是为什么有的人说可以把协程理解为用户态线程的原因。 也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。 在协程这件事儿上，调度你说了算。 当你在协程中写下 yield 的时候就是想要暂停该协程，当使用 next() 时就是要再次运行该协程。 现在你应该理解为什么说函数只是协程的一种特例了吧，函数其实只是没有挂起点的协程而已。 6、协程的历史 有的可能认为协程是一种比较新的技术，然而其实协程这种概念早在1958年就已经提出来了，要知道这时线程的概念都还没有提出来。 到了1972年，终于有编程语言实现了这个概念，这两门编程语言就是Simula 67 以及Scheme。 但协程这个概念始终没有流行起来，甚至在1993年还有人考古一样专门写论文挖出协程这种古老的技术。 因为这一时期还没有线程，如果你想在操作系统写出并发程序那么你将不得不使用类似协程这样的技术，后来线程开始出现，操作系统终于开始原生支持程序的并发执行，就这样，协程逐渐淡出了程序员的视线。 直到近些年，随着互联网的发展，尤其是移动互联网时代的到来，服务端对高并发的要求越来越高，协程再一次重回技术主流，各大编程语言都已经支持或计划开始支持协程。 那么协程到底是如何实现的呢？ 7、协程到底是如何实现的？ **让我们从问题的本质出发来思考这个问题：**协程的本质是什么呢？ 其实就是可以被暂停以及可以被恢复运行的函数。那么可以被暂停以及可以被恢复意味着什么呢？ 看过篮球比赛的同学想必都知道（没看过的也能知道），篮球比赛也是可以被随时暂停的，暂停时大家需要记住球在哪一方，各自的站位是什么，等到比赛继续的时候大家回到各自的位置，裁判哨子一响比赛继续，就像比赛没有被暂停过一样。 **看到问题的关键了吗：**比赛之所以可以被暂停也可以继续是因为比赛状态被记录下来了（站位、球在哪一方），这里的状态就是计算机科学中常说的上下文（context）。 回到协程。 协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文（状态）另外：函数运行时所有的状态信息都位于函数运行时栈中。 函数运行时栈就是我们需要保存的状态，也就是所谓的上下文。 如图所示： **从上图中我们可以看出：**该进程中只有一个线程，栈区中有四个栈帧，main函数调用A函数，A函数调用B函数，B函数调用C函数，当C函数在运行时整个进程的状态就如图所示。 **现在：**我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦。 既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？ **想一想这个问题：**整个进程的内存区中哪一块是专门用来长时间(进程生命周期)存储数据的？ **很显然：**这就是堆区啊（heap），我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new。 **我们需要做的就是：**在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态。 再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？ **实际上：**我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如下图所示。 **从上图中我们可以看到：**该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了。 有的可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？ **答案是：**这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的。 现在你应该看到了吧，在上图中实际上共有3个执行流： 1）一个普通线程； 2）两个协程。 虽然有3个执行流但我们创建了几个线程呢？ **答案是：**一个线程。 **现在你应该明白为什么要使用协程了吧：**使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在。 因此：即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的。 这也许是为什么协程这个概念比线程提出的要早的原因，可能是写普通应用的程序员比写操作系统的程序员最先遇到需要多个并行流的需求，那时可能都还没有操作系统的概念，或者操作系统没有并行这种需求，所以非操作系统程序员只能自己动手实现执行流，也就是协程。 8、协程技术概念小结 到底什么是协程呢？ 8.1 协程是比线程更小的执行单元 协程是比线程更小的一种执行单元，你可以认为是轻量级的线程。 **之所以说轻：**其中一方面的原因是协程所持有的栈比线程要小很多，java当中会为每个线程分配1M左右的栈空间，而协程可能只有几十或者几百K，栈主要用来保存函数参数、局部变量和返回地址等信息。 **我们知道：**而线程的调度是在操作系统中进行的，而协程调度则是在用户空间进行的，是开发人员通过调用系统底层的执行上下文相关api来完成的。有些语言，比如nodejs、go在语言层面支持了协程，而有些语言，比如C，需要使用第三方库才可以拥有协程的能力（比如微信开源的Libco库就是这样的）。 由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的。 使用协程是因为线程的切换成本比较高，而协程在这方面很有优势。 8.2 协程的切换到底为什么很廉价？ 关于这个问题，我们回顾一下线程切换的过程： 1）线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读入另外一个线程的数据，这个会花费一些时间； 2）CPU的高速缓存中的数据，也可能失效，需要重新加载； 3）线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都需要执行上千条指令，很耗时。 实际上协程的切换之所以快的原因我认为主要是： 1）在切换的时候，寄存器需要保存和加载的数据量比较小； 2）高速缓存可以有效利用； 3）没有用户模式到内核模式的切换操作； 4）更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的切换（为了尽量让用户感知不到某个线程卡）。 9、写在最后 写到这里，相信你已经理解协程到底是怎么一回事了，关于协程更系统的知识可以自行查阅相关资料。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-wu-shen-ru-cao-zuo-xi-tong-li-jie-gao-bing-fa-zhong-de-xie-cheng/"},{"title":"理解高性能、高并发(四)：深入操作系统，理解同步与异步","content":"1、编程中的同步调用 我们先说同步调用，这是程序员最熟悉的场景。 一般的函数调用都是同步的，就像这样： funcA() { // 等待函数funcB执行完成 funcB(); // 继续接下来的流程 } funcA调用funcB，那么在funcB执行完前，funcA中的后续代码都不会被执行，也就是说funcA必须等待funcB执行完成。 就像下图这样： ​ 从上图中我们可以看到，在funcB运行期间funcA什么都做不了，这就是典型的同步。 注意：一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的，这是最为常见的情况。 **但值得注意的是：**即使运行在两个不能线程中的函数也可以进行同步调用，像我们进行IO操作时实际上底层是通过系统调用的方式向操作系统发出请求的，比如磁盘文件读取： read(file, buf); 这就是我们在《深入操作系统，理解I/O与零拷贝技术》中描述的阻塞式I/O，在read函数返回前程序是无法继续向前推进的： read(file, buf); // 程序暂停运行， // 等待文件读取完成后继续运行 如下图所示： ​ 只有当read函数返回后程序才可以被继续执行。 **注意：**和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。 **因此：**我们可以得出结论，同步调用和函数与被调函数是否运行在同一个线程是没有关系的。 在这里我们还要再次强调：同步方式下函数和被调函数无法同时进行。 同步编程对程序员来说是最自然最容易理解的。 但容易理解的代价就是在一些场景下，同步并不是高效的，原因很简单，因为任务没有办法同时进行。 接下来我们看异步调用。 2、编程中的异步调用 有同步调用就有异步调用。 如果你真的理解了本节到目前为止的内容的话，那么异步调用对你来说不是问题。 **一般来说：**异步调用总是和I/O操作等耗时较高的任务如影随形，像磁盘文件读写、网络数据的收发、数据库操作等。 我们还是以磁盘文件读取为例。 在read函数的同步调用方式下，文件读取完之前调用方是无法继续向前推进的，但如果read函数可以异步调用情况就不一样了。 假如read函数可以异步调用的话，即使文件还没有读取完成，read函数也可以立即返回。 read(file, buff); // read函数立即返回 // 不会阻塞当前程序 就像下图这样： ​ **可以看到：**在异步这种调用方式下，调用方不会被阻塞，函数调用完成后可以立即执行接下来的程序。 这时异步的重点就在于：调用方接下来的程序执行可以和文件读取同时进行，从上图中我们也能看出这一点，这就是异步的高效之处。 **但是：**请注意，异步调用对于程序员来说在理解上是一种负担，代码编写上更是一种负担，总的来说，上帝在为你打开一扇门的时候会适当的关上一扇窗户。 有的可能会问，在同步调用下，调用方不再继续执行而是暂停等待，被调函数执行完后很自然的就是调用方继续执行，那么异步调用下调用方怎知道被调函数是否执行完成呢？ 这就分为了两种情况： 1）调用方根本就不关心执行结果； 2）调用方需要知道执行结果。 第一种情况比较简单，无需讨论。 第二种情况下就比较有趣了，通常有两种实现方式： 1）一种是通知机制：当任务执行完成后发送信号来通知调用方任务完成（这里的信号有很多实现方式：Linux中的signal，或使用信号量等机制都可实现）； 2）一种是回调机制：也就是我们常说的callback（关于回调我们将在下一篇文章中重点讲解，本篇会有简短的讨论）。 接下来我们用一个具体的例子讲解一下同步调用与异步调用。 3、具体的编程例子中理解同步和异步 3.1 一个具体的示例 我们以常见的Web服务来举例说明这一问题。 一般来说Web Server接收到用户请求后会有一些典型的处理逻辑，最常见的就是数据库查询（当然，你也可以把这里的数据库查询换成其它I/O操作，比如磁盘读取、网络通信等），在这里我们假定处理一次用户请求需要经过步骤A、B、C，然后读取数据库，数据库读取完成后需要经过步骤D、E、F。 就像这样： # 处理一次用户请求需要经过的步骤： A; B; C; 数据库读取; D； E； F； **其中：**步骤A、B、C和D、E、F不需要任何I/O，也就是说这六个步骤不需要读取文件、网络通信等，涉及到I/O操作的只有数据库查询这一步。 **一般来说：**这样的Web Server有两个典型的线程：主线程和数据库处理线程（注意：这讨论的只是典型的场景，具体业务实际上可会有差别，但这并不影响我们用两个线程来说明问题）。 首先我们来看下最简单的实现方式，也就是同步。 这种方式最为自然也最为容易理解： // 主线程 main_thread() { A; B; C; 发送数据库查询请求; D; E; F; } // 数据库线程 DataBase_thread() { while(1) { ​ 处理数据库读取请求; ​ 返回结果; } } 这就是最为典型的同步方法：主线程在发出数据库查询请求后就会被阻塞而暂停运行，直到数据库查询完毕后面的D、E、F才可以继续运行。 就像下图这样： ​ **从上图中我们可以看到：**主线程中会有“空隙”，这个空隙就是主线程的“休闲时光”，主线程在这段休闲时光中需要等待数据库查询完成才能继续后续处理流程。 在这里主线程就好比监工的老板，数据库线程就好比苦逼搬砖的程序员，在搬完砖前老板什么都不做只是紧紧的盯着你，等你搬完砖后才去忙其它事情。 **显然：**高效的程序员是不能容忍主线程偷懒的。 是时候祭出大杀器了，这就是异步： 在异步这种实现方案下主线程根本不去等待数据库是否查询完成，而是发送完数据库读写请求后直接处理下一个请求。 **有的同学可能会有疑问：**一个请求需要经过A、B、C、数据库查询、D、E、F这七个步骤，如果主线程在完成A、B、C、数据库查询后直接进行处理接下来的请求，那么上一个请求中剩下的D、E、F几个步骤怎么办呢？ 如果大家还没有忘记上一小节内容的话应该知道，这有两种情况，我们来分别讨论。 3.2 异步情况1：主线程不关心数据库操作结果 在这种情况下，主线程根本就不关心数据库是否查询完毕，数据库查询完毕后自行处理接下来的D、E、F三个步骤。 就像下图这样： ​ 我们说过一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？ 这时，我们的另一个主角回调函数就开始登场啦。 没错，回调函数就是用来解决这一问题的。 我们可以将处理D、E、F这几个步骤封装到一个函数中，假定将该函数命名为handle_DEF_after_DB_query。 伪码如下： void handle_DEF_after_DB_query () { D; E; F; } 这样主线程在发送数据库查询请求的同时将该函数一并当做参数传递过去： DB_query(request, handle_DEF_after_DB_query); 数据库线程处理完后直接调用handle_DEF_after_DB_query就可以了，这就是回调函数的作用。 也有的同学可能会有疑问，为什么这个函数要传递给数据库线程而不是数据库线程自己定义自己调用呢？ 因为从软件组织结构上讲，这不是数据库线程该做的工作。 数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心。 **你可以传入各种各样的回调函数：**也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。 **而从软件开发的角度看：**假设数据库线程逻辑封装为了库提供给其它团队，当数据库团队在研发时怎么可能知道数据库查询后该做什么呢？ 显**然：**只有使用方才知道查询完数据库后该做些什么，因此使用方在使用时简单的传入这个回调函数就可以了。 这样复杂数据库的团队就和使用方团队实现了所谓的解耦。 现在你应该明白回调函数的作用了吧。 **另外：**仔细观察上面两张图，你能看出为什么异步比同步高效吗？ 原因很简单，这也是我们在本篇提到过的，异步天然就无需等待，无依赖。 主线程处理请求和数据库处理查询请求可以同时进行，因此从系统性能上看，这样的设计能更加充分的利用系统资源，更加快速的处理请求；从用户的角度看，系统的响应也会更加迅速。 这就是异步的高效之处。 **但我们应该也可以看出：**异步编程并不如同步来的容易理解，系统可维护性上也不如同步模式。 那么有没有一种方法既能结合同步模式的容易理解又能结合异步模式的高效呢？答案是肯定的。 接下来我们看第二种情况，那就是主线程需要关心数据库查询结果。 3.3 异步情况2：主线程关心数据库操作结果 在这种情况下，数据库线程需要将查询结果利用通知机制发送给主线程，主线程在接收到消息后继续处理上一个请求的后半部分。 就像下图这样： ​ **从这里我们可以看到：**ABCDEF几个步骤全部在主线中处理，同时主线程同样也没有了“休闲时光”，只不过在这种情况下数据库线程是比较清闲的，从这里并没有上一种方法高效，但是依然要比同步模式下要高效。 **最后需要注意的是：**并不是所有的情况下异步都一定比同步高效，还需要结合具体业务以及IO的复杂度具体情况具体分析。 4、本文小结 在这篇文章中我们从各种场景分析了同步与异步这两个概念，但是不管在什么场景下，同步往往意味着双方要相互等待、相互依赖，而异步意味着双方相互独立、各行其是。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-si-shen-ru-cao-zuo-xi-tong-li-jie-tong-bu-yu-yi-bu/"},{"title":"理解高性能、高并发(三)：深入操作系统，彻底理解I/O多路复用","content":"1、什么是文件？ 在正式展开本文的内容之前，我们需要先预习一下文件以及文件描述符的概念。 程序员使用I/O最终都逃不过文件这个概念。 在Linux世界中文件是一个很简单的概念，作为程序员我们只需要将其理解为一个N byte的序列就可以了： b1, b2, b3, b4, ....... bN 实际上所有的I/O设备都被抽象为了文件这个概念，一切皆文件（Everything is File），磁盘、网络数据、终端，甚至进程间通信工具管道pipe等都被当做文件对待。 ​ 所有的I/O操作也都可以通过文件读写来实现，这一非常优雅的抽象可以让程序员使用一套接口就能对所有外设I/O操作。 常用的I/O操作接口一般有以下几类： 1）打开文件，open； 2）改变读写位置，seek； 3）文件读写，read、write； 4）关闭文件，close。 程序员通过这几个接口几乎可以实现所有I/O操作，这就是文件这个概念的强大之处。 2、什么是文件描述符？ 在上一篇《深入操作系统，理解I/O与零拷贝技术》中我们讲到：要想进行I/O读操作，像磁盘数据，我们需要指定一个buff用来装入数据。 一般都是这样写的： read(buff); 但是这里我们忽略了一个关键问题：那就是，虽然我们指定了往哪里写数据，但是我们该从哪里读数据呢？ 从上一节中我们知道，通过文件这个概念我们能实现几乎所有I/O操作，因此这里少的一个主角就是文件。 那么我们一般都怎样使用文件呢？ **举个例子：**如果周末你去比较火的餐厅吃饭应该会有体会，一般周末人气高的餐厅都会排队，然后服务员会给你一个排队序号，通过这个序号服务员就能找到你，这里的好处就是服务员无需记住你是谁、你的名字是什么、来自哪里、喜好是什么、是不是保护环境爱护小动物等等，这里的关键点就是：服务员对你一无所知，但依然可以通过一个号码就能找到你。 **同样的：**在Linux世界要想使用文件，我们也需要借助一个号码，根据“弄不懂原则”，这个号码就被称为了文件描述符（file descriptors），在Linux世界中鼎鼎大名，其道理和上面那个排队号码一样。 **因此：**文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。 ​ 有了文件描述符，进程可以对文件一无所知，比如文件在磁盘的什么位置、加载到内存中又是怎样管理的等等，这些信息统统交由操作系统打理，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。 因此我们来完善上述程序： int fd = open(file_name); // 获取文件描述符 read(fd, buff); 怎么样，是不是非常简单。 3、文件描述符太多了怎么办？ 经过了这么多的铺垫，终于要到高性能、高并发这一主题了。 从前几节我们知道，所有I/O操作都可以通过文件样的概念来进行，这当然包括网络通信。 如果你有一个IM服务器，当三次握手建议长连接成功以后，我们会调用accept来获取一个链接，调用该函数我们同样会得到一个文件描述符，通过这个文件描述符就可以处理客户端发送的聊天消息并且把消息转发给接收者。 也就是说，通过这个描述符我们就可以和客户端进行通信了： // 通过accept获取客户端的文件描述符 int conn_fd = accept(...); Server端的处理逻辑通常是接收客户端消息数据，然后执行转发（给接收者）逻辑： if(read(conn_fd, msg_buff) &gt; 0) { do_transfer(msg_buff); } 是不是非常简单，然而世界终归是复杂的，当然也不是这么简单的。 接下来就是比较复杂的了。 既然我们的主题是高并发，那么Server端就不可能只和一个客户端通信，而是可能会同时和成千上万个客户端进行通信。这时你需要处理不再是一个描述符这么简单，而是有可能要处理成千上万个描述符。 为了不让问题一上来就过于复杂，我们先简单化，假设只同时处理两个客户端的请求。 有的同学可能会说，这还不简单，这样写不就行了： if(read(socket_fd1, buff) &gt; 0) { // 处理第一个 do_transfer(); } if(read(socket_fd2, buff) &gt; 0) { // 处理第二个 do_transfer(); 在《[深入操作系统，理解I/O与零拷贝技术]》中我们讨论过，这是非常典型的阻塞式I/O，如果此时没有数据可读那么进程会被阻塞而暂停运行。这时我们就无法处理第二个请求了，即使第二个请求的数据已经就位，这也就意味着处理某一个客户端时由于进程被阻塞导致剩下的所有其它客户端必须等待，在同时处理几万客户端的server上。这显然是不能容忍的。 聪明的你一定会想到使用多线程：为每个客户端请求开启一个线程，这样一个客户端被阻塞就不会影响到处理其它客户端的线程了。注意：既然是高并发，那么我们要为成千上万个请求开启成千上万个线程吗，大量创建销毁线程会严重影响系统性能。 那么这个问题该怎么解决呢？ **这里的关键点在于：**我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。 因此要优雅的解决这个问题，就要从其它角度来思考这个问题了。 4、“不要打电话给我，有需要我会打给你” 大家生活中肯定会接到过推销电话，而且不止一个，一天下来接上十个八个推销电话你的身体会被掏空的。 这个场景的关键点在于：打电话的人并不知道你是不是要买东西，只能来一遍遍问你。因此一种更好的策略是不要让他们打电话给你，记下他们的电话，有需要的话打给他们，这样推销员就不会一遍一遍的来烦你了（虽然现实生活中这并不可能）。 **在这个例子中：**你，就好比内核，推销者就好比应用程序，电话号码就好比文件描述符，和你用电话沟通就好比I/O。 现在你应该明白了吧，处理多个文件描述符的更好方法其实就存在于推销电话中。 因此相比上一节中：我们通过I/O接口主动问内核这些文件描述符对应的外设是不是已经就绪了，一种更好的方法是，我们把这些感兴趣的文件描述符一股脑扔给内核，并霸气的告诉内核：“我这里有1万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？。。。” **这样：**应用程序就从“繁忙”的主动变为了清闲的被动，反正文件描述可读可写了内核会通知我，能偷懒我才不要那么勤奋。 这是一种更加高效的I/O处理机制，现在我们可以一次处理多路I/O了，为这种机制起一个名字吧，就叫I/O多路复用吧，这就是 I/O multiplexing。 5、I/O多路复用（I/O multiplexing） multiplexing一词其实多用于通信领域，为了充分利用通信线路，希望在一个信道中传输多路信号，要想在一个信道中传输多路信号就需要把这多路信号结合为一路，将多路信号组合成一个信号的设备被称为Multiplexer（多路复用器），显然接收方接收到这一路组合后的信号后要恢复原先的多路信号，这个设备被称为Demultiplexer（多路分用器）。 如下图所示： ​ 回到我们的主题。 所谓I/O多路复用指的是这样一个过程： 1）我们拿到了一堆文件描述符（不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以）； 2）通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回”； 3）当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。 也就是说通过I/O多路复用我们可以同时处理多路I/O。那么有哪些函数可以用来进行I/O多路复用呢？ 以Linux为例，有这样三种机制可以用来进行I/O多路复用： 1）select； 2）poll； 3）epoll。 接下来我们就来介绍一下I/O多路复用三剑客。 6、I/O多路复用三剑客 **本质上：**Linux上的select、poll、epoll都是阻塞式I/O，也就是我们常说的同步I/O。 原因在于：调用这些I/O多路复用函数时如果任何一个需要监视的文件描述符都不可读或者可写那么进程会被阻塞暂停执行，直到有文件描述符可读或者可写才继续运行。 6.1 select：初出茅庐 在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中。 我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个。因此程序员必须再遍历一边找到具体是哪个文件描述符可以读写了。 因此，总结下来select有这样几个特点： 1）我能照看的文件描述符数量有限，不能超过1024个； 2）用户给我的文件描述符需要拷贝的内核中； 3）我只能告诉你有文件描述符满足要求了，但是我不知道是哪个，你自己一个一个去找吧（遍历）。 因此我们可以看到，select机制的这些特性在高并发网络服务器动辄几万几十万并发链接的场景下无疑是低效的。 6.2 poll：小有所成 poll和select是非常相似的。 poll相对于select的优化仅仅在于解决了文件描述符不能超过1024个的限制，select和poll都会随着监控的文件描述数量增加而性能下降，因此不适合高并发场景。 6.3 epoll：独步天下 在select面临的三个问题中，文件描述数量限制已经在poll中解决了，剩下的两个问题呢？ 针对拷贝问题：epoll使用的策略是各个击破与共享内存。 **实际上：**文件描述符集合的变化频率比较低，select和poll频繁的拷贝整个集合，内核都快被烦死了，epoll通过引入epoll_ctl很体贴的做到了只操作那些有变化的文件描述符。同时epoll和内核还成为了好朋友，共享了同一块内存，这块内存中保存的就是那些已经可读或者可写的的文件描述符集合，这样就减少了内核和程序的拷贝开销。 针对需要遍历文件描述符才能知道哪个可读可写这一问题，epoll使用的策略是“当小弟”。 在select和poll机制下：进程要亲自下场去各个文件描述符上等待，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。 但epoll就懂事多了，主动找到进程。 **在这种机制下：**进程不需要亲自下场了，进程只要等待在epoll上，epoll代替进程去各个文件描述符上等待，当哪个文件描述符可读或者可写的时候就告诉epoll，epoll用小本本认真记录下来然后唤醒大哥：“进程大哥，快醒醒，你要处理的文件描述符我都记下来了”，这样进程被唤醒后就无需自己从头到尾检查一遍，因为epoll小弟都已经记下来了。 因此我们可以看到：在epoll这种机制下，实际上利用的就是“不要打电话给我，有需要我会打给你”这种策略，进程不需要一遍一遍麻烦的问各个文件描述符，而是翻身做主人了——“你们这些文件描述符有哪个可读或者可写了主动报上来”。 这种机制实际上就是大名鼎鼎的事件驱动——Event-driven，这也是我们下一篇的主题。 **实际上：**在Linux平台，epoll基本上就是高并发的代名词。 7、本文小结 基于一切皆文件的设计哲学，I/O也可以通过文件的形式实现，高并发场景下要与多个文件交互，这就离不开高效的I/O多路复用技术。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-san-shen-ru-cao-zuo-xi-tong-che-di-li-jie-io-duo-lu-fu-yong/"},{"title":"理解高性能、高并发(二)：深入操作系统，理解I/O与零拷贝技术","content":"1、不能执行I/O的计算机是什么？ 相信对于程序员来说I/O操作是最为熟悉不过的了，比如： 1）当我们使用C语言中的printf、C++中的&quot;&lt;&lt;&quot;，Python中的print，Java中的System.out.println等时； 2）当我们使用各种语言读写文件时； 3）当我们通过TCP/IP进行网络通信时； 4）当我们使用鼠标龙飞凤舞时； 5）当我们拿起键盘在评论区指点江山亦或是埋头苦干努力制造bug时； 6）当我们能看到屏幕上的漂亮的图形界面时等等。 以上这一切，都是I/O！ **想一想：**如果没有I/O计算机该是一种多么枯燥的设备，不能看电影、不能玩游戏，也不能上网，这样的计算机最多就是一个大号的计算器。 既然I/O这么重要，那么到底什么才是I/O呢？ 2、什么是I/O？ I/O就是简单的数据Copy，仅此而已！ 这一点很重要！ 既然是copy数据，那么又是从哪里copy到哪里呢？ 如果数据是从外部设备copy到内存中，这就是Input。 如果数据是从内存copy到外部设备，这就是Output。 内存与外部设备之间不嫌麻烦的来回copy数据就是Input and Output，简称I/O（Input/Output），仅此而已。 3、I/O与CPU 现在我们知道了什么是I/O，接下来就是重点部分了。 我们知道现在的CPU其主频都是数GHz起步，这是什么意思呢？ **简单说就是：**CPU执行机器指令的速度是纳秒级别的，而通常的I/O比如磁盘操作，一次磁盘seek大概在毫秒级别，因此如果我们把CPU的速度比作战斗机的话，那么I/O操作的速度就是肯德鸡。 也就是说当我们的程序跑起来时（CPU执行机器指令），其速度是要远远快于I/O速度的。那么接下来的问题就是二者速度相差这么大，那么我们该如何设计、该如何更加合理的高效利用系统资源呢？ 既然有速度差异，而且进程在执行完I/O操作前不能继续向前推进，那么显然只有一个办法，那就是等待（wait）。 同样是等待，有聪明的等待，也有傻傻的等待，简称傻等，那么是选择聪明的等待呢还是选择傻等呢？ 假设你是一个急性子（CPU），需要等待一个重要的文件，不巧的是这个文件只能快递过来（I/O），那么这时你是选择什么事情都不干了，深情的注视着门口就像盼望着你的哈尼一样专心等待这个快递呢？还是暂时先不要管快递了，玩个游戏看个电影刷会儿短视频等快递来了再说呢？ 很显然，更好的方法就是先去干其它事情，快递来了再说。 **因此：**这里的关键点就是快递没到前手头上的事情可以先暂停，切换到其它任务，等快递过来了再切换回来。 理解了这一点你就能明白执行I/O操作时底层都发生了什么。 接下来让我们以读取磁盘文件为例来讲解这一过程。 4、执行I/O时底层都发生了什么 在支持线程的操作系统中，实际上被调度的是线程而不是进程，为了更加清晰的理解I/O过程，我们暂时假设操作系统只有进程这样的概念，先不去考虑线程，这并不会影响我们的讨论。 现在内存中有两个进程，进程A和进程B，当前进程A正在运行。 如下图所示： 进程A中有一段读取文件的代码，不管在什么语言中通常我们定义一个用来装数据的buff，然后调用read之类的函数。 就像这样： read(buff); 这就是一种典型的I/O操作，当CPU执行到这段代码的时候会向磁盘发送读取请求。 **注意：**与CPU执行指令的速度相比，I/O操作操作是非常慢的，因此操作系统是不可能把宝贵的CPU计算资源浪费在无谓的等待上的，这时重点来了，注意接下来是重点哦。 由于外部设备执行I/O操作是相当慢的，因此在I/O操作完成之前进程是无法继续向前推进的，这就是所谓的阻塞，即通常所说的block。 操作系统检测到进程向I/O设备发起请求后就暂停进程的运行，怎么暂停运行呢？**很简单：**只需要记录下当前进程的运行状态并把CPU的PC寄存器指向其它进程的指令就可以了。 进程有暂停就会有继续执行，因此操作系统必须保存被暂停的进程以备后续继续执行，显然我们可以用队列来保存被暂停执行的进程。 如下图所示，进程A被暂停执行并被放到阻塞队列中（**注意：**不同的操作系统会有不同的实现，可能每个I/O设备都有一个对应的阻塞队列，但这种实现细节上的差异不影响我们的讨论）。 这时操作系统已经向磁盘发送了I/O请求，因此磁盘driver开始将磁盘中的数据copy到进程A的buff中。虽然这时进程A已经被暂停执行了，但这并不妨碍磁盘向内存中copy数据。 **注意：**现代磁盘向内存copy数据时无需借助CPU的帮助，这就是所谓的DMA（Direct Memory Access）。 这个过程如下图所示： 让磁盘先copy着数据，我们接着聊。 **实际上：**操作系统中除了有阻塞队列之外也有就绪队列，所谓就绪队列是指队列里的进程准备就绪可以被CPU执行了。 你可能会问为什么不直接执行非要有个就绪队列呢？**答案很简单：**那就是僧多粥少，在即使只有1个核的机器上也可以创建出成千上万个进程，CPU不可能同时执行这么多的进程，因此必然存在这样的进程，即使其一切准备就绪也不能被分配到计算资源，这样的进程就被放到了就绪队列。 现在进程B就位于就绪队列，万事俱备只欠CPU。 如下图所示： 当进程A被暂停执行后CPU是不可以闲下来的，因为就绪队列中还有嗷嗷待哺的进程B，这时操作系统开始在就绪队列中找下一个可以执行的进程，也就是这里的进程B。 此时操作系统将进程B从就绪队列中取出，找出进程B被暂停时执行到的机器指令的位置，然后将CPU的PC寄存器指向该位置，这样进程B就开始运行啦。 如下图所示： **注意：**接下来的这段是重点中的重点！ **注意观察上图：**此时进程B在被CPU执行，磁盘在向进程A的内存空间中copy数据，看出来了吗——大家都在忙，谁都没有闲着，数据copy和指令执行在同时进行，在操作系统的调度下，CPU、磁盘都得到了充分的利用，这就是程序员的智慧所在。 现在你应该理解为什么操作系统这么重要了吧。 此后磁盘终于将全部数据都copy到了进程A的内存中，这时磁盘通知操作系统任务完成啦，你可能会问怎么通知呢？这就是中断。 操作系统接收到磁盘中断后发现数据copy完毕，进程A重新获得继续运行的资格，这时操作系统小心翼翼的把进程A从阻塞队列放到了就绪队列当中。 如下图所示： **注意：**从前面关于就绪状态的讨论中我们知道，操作系统是不会直接运行进程A的，进程A必须被放到就绪队列中等待，这样对大家都公平。 此后进程B继续执行，进程A继续等待，进程B执行了一会儿后操作系统认为进程B执行的时间够长了，因此把进程B放到就绪队列，把进程A取出并继续执行。 **注意：**操作系统把进程B放到的是就绪队列，因此进程B被暂停运行仅仅是因为时间片到了而不是因为发起I/O请求被阻塞。 如下图所示： 进程A继续执行，此时buff中已经装满了想要的数据，进程A就这样愉快的运行下去了，就好像从来没有被暂停过一样，进程对于自己被暂停一事一无所知，这就是操作系统的魔法。 现在你应该明白了I/O是一个怎样的过程了吧。 这种进程执行I/O操作被阻塞暂停执行的方式被称为阻塞式I/O，blocking I/O，这也是最常见最容易理解的I/O方式，有阻塞式I/O就有非阻塞式I/O，在这里我们暂时先不考虑这种方式。 在本节开头我们说过暂时只考虑进程而不考虑线程，现在我们放宽这个条件，实际上也非常简单，只需要把前图中调度的进程改为线程就可以了，这里的讨论对于线程一样成立。 5、零拷贝（Zero-copy） **最后需要注意的一点就是：**上面的讲解中我们直接把磁盘数据copy到了进程空间中，但实际上一般情况下I/O数据是要首先copy到操作系统内部，然后操作系统再copy到进程空间中。 因此我们可以看到这里其实还有一层经过操作系统的copy，对于性能要求很高的场景其实也是可以绕过操作系统直接进行数据copy的，这也是本文描述的场景，这种绕过操作系统直接进行数据copy的技术被称为Zero-copy，也就零拷贝，高并发、高性能场景下常用的一种技术，原理上很简单吧。 6、本文小结 本文讲解的是程序员常用的I/O（包括所谓的网络I/O），一般来说作为程序员我们无需关心，但是理解I/O背后的底层原理对于设计比如IM这种高性能、高并发系统是极为有益的。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-er-shen-ru-cao-zuo-xi-tong-li-jie-io-yu-ling-kao-bei-ji-zhu/"},{"title":"理解高性能、高并发(一)：深入计算机底层，理解线程与线程池","content":"1、一切要从CPU说起 你可能会有疑问，讲多线程为什么要从CPU说起呢？原因很简单，在这里没有那些时髦的概念，你可以更加清晰的看清问题的本质。 实际情况是：CPU并不知道线程、进程之类的概念。 CPU只知道两件事： 1）从内存中取出指令； 2）执行指令，然后回到 1）。 你看，在这里CPU确实是不知道什么进程、线程之类的概念。 接下来的问题就是CPU从哪里取出指令呢？答案是来自一个被称为Program Counter（简称PC）的寄存器，也就是我们熟知的程序计数器，在这里大家不要把寄存器想的太神秘，你可以简单的把寄存器理解为内存，只不过存取速度更快而已。 PC寄存器中存放的是什么呢？这里存放的是指令在内存中的地址，什么指令呢？是CPU将要执行的下一条指令。 ​ 那么是谁来设置PC寄存器中的指令地址呢？ 原来PC寄存器中的地址默认是自动加1的，这当然是有道理的，因为大部分情况下CPU都是一条接一条顺序执行，当遇到if、else时，这种顺序执行就被打破了，CPU在执行这类指令时会根据计算结果来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。 聪明的你一定会问，那么PC中的初始值是怎么被设置的呢？ 在回答这个问题之前我们需要知道CPU执行的指令来自哪里？是来自内存，废话，内存中的指令是从磁盘中保存的可执行程序加载过来的，磁盘中可执行程序是编译器生成的，编译器又是从哪里生成的机器指令呢？答案就是我们定义的函数。 ​ 注意是函数，函数被编译后才会形成CPU执行的指令，那么很自然的，我们该如何让CPU执行一个函数呢？显然我们只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。 现在你应该知道了吧，我们想要CPU执行一个函数，那么只需要把该函数对应的第一条机器指令的地址写入PC寄存器就可以了，这样我们写的函数就开始被CPU执行起来啦。 你可能会有疑问，这和线程有什么关系呢？ 2、从CPU到操作系统 上一小节中我们明白了CPU的工作原理，我们想让CPU执行某个函数，那么只需要把函数对应的第一条机器执行装入PC寄存器就可以了，这样即使没有操作系统我们也可以让CPU执行程序，虽然可行但这是一个非常繁琐的过程。 我们需要： 1）在内存中找到一块大小合适的区域装入程序； 2）找到函数入口，设置好PC寄存器让CPU开始执行程序。 这两个步骤绝不是那么容易的事情，如果每次在执行程序时程序员自己手动实现上述两个过程会疯掉的，因此聪明的程序员就会想干脆直接写个程序来自动完成上面两个步骤吧。 机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地址并写到PC寄存器中，想一想这是不是需要一个数据结构来记录下这些信息。 数据结构大致如下： struct *** { void* start_addr; intlen; void* start_point; ... }; 接下来就是起名字时刻。 这个数据结构总要有个名字吧，这个结构体用来记录什么信息呢？记录的是程序在被加载到内存中的运行状态，程序从磁盘加载到内存跑起来叫什么好呢？干脆就叫进程（Process）好了，我们的指导原则就是一定要听上去比较神秘，总之大家都不容易弄懂就对了，我将其称为“弄不懂原则”。 就这样进程诞生了。 CPU执行的第一个函数也起个名字，第一个要被执行的函数听起来比较重要，干脆就叫main函数吧。 完成上述两个步骤的程序也要起个名字，根据“弄不懂原则”这个“简单”的程序就叫操作系统（Operating System）好啦。 就这样操作系统诞生了，程序员要想运行程序再也不用自己手动加载一遍了。 现在进程和操作系统都有了，一切看上去都很完美。 3、从单核到多核，如何充分利用多核 人类的一大特点就是生命不息折腾不止，从单核折腾到了多核。 ​ 这时，假设我们想写一个程序并且要分利用多核该怎么办呢？ 有的同学可能会说不是有进程吗，多开几个进程不就可以了？ 听上去似乎很有道理，但是主要存在这样几个问题： 1）进程是需要占用内存空间的(从上一节能看到这一点)，如果多个进程基于同一个可执行程序，那么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费； 2）计算机处理的任务可能是比较复杂的，这就涉及到了进程间通信，由于各个进程处于不同的内存地址空间，进程间通信天然需要借助操作系统，这就在增大编程难度的同时也增加了系统开销。 该怎么办呢？ 4、从进程到线程 让我再来仔细的想一想这个问题，所谓进程无非就是内存中的一段区域，这段区域中保存了CPU执行的机器指令以及函数运行时的堆栈信息，要想让进程运行，就把main函数的第一条机器指令地址写入PC寄存器，这样进程就运行起来了。 ​ 进程的缺点在于只有一个入口函数，也就是main函数，因此进程中的机器指令只能被一个CPU执行，那么有没有办法让多个CPU来执行同一个进程中的机器指令呢？ 聪明的你应该能想到，既然我们可以把main函数的第一条指令地址写入PC寄存器，那么其它函数和main函数又有什么区别呢？ 答案是没什么区别，main函数的特殊之处无非就在于是CPU执行的第一个函数，除此之外再无特别之处，我们可以把PC寄存器指向main函数，就可以把PC寄存器指向任何一个函数。 当我们把PC寄存器指向非main函数时，线程就诞生了。 ​ 至此我们解放了思想，一个进程内可以有多个入口函数，也就是说属于同一个进程中的机器指令可以被多个CPU同时执行。 **注意：**这是一个和进程不同的概念，创建进程时我们需要在内存中找到一块合适的区域以装入进程，然后把CPU的PC寄存器指向main函数，也就是说进程中只有一个执行流。 ​ 但是现在不一样了，多个CPU可以在同一个屋檐下(进程占用的内存区域)同时执行属于该进程的多个入口函数，也就是说现在一个进程内可以有多个执行流了。 ​ 总是叫执行流好像有点太容易理解了，再次祭出”弄不懂原则“，起个不容易懂的名字，就叫线程吧。 这就是线程的由来。 操作系统为每个进程维护了一堆信息，用来记录进程所处的内存空间等，这堆信息记为数据集A。 同样的，操作系统也需要为线程维护一堆信息，用来记录线程的入口函数或者栈信息等，这堆数据记为数据集B。 显然数据集B要比数据A的量要少，同时不像进程，创建一个线程时无需去内存中找一段内存空间，因为线程是运行在所处进程的地址空间的，这块地址空间在程序启动时已经创建完毕，同时线程是程序在运行期间创建的（进程启动后），因此当线程开始运行的时候这块地址空间就已经存在了，线程可以直接使用。这就是为什么各种教材上提的创建线程要比创建进程快的原因（当然还有其它原因）。 值得注意的是，有了线程这个概念后，我们只需要进程开启后创建多个线程就可以让所有CPU都忙起来，这就是所谓高性能、高并发的根本所在。 ​ 很简单，只需要创建出数量合适的线程就可以了。 另外值得注意的一点是：由于各个线程共享进程的内存地址空间，因此线程之间的通信无需借助操作系统，这给程序员带来极大方便的同时也带来了无尽的麻烦，多线程遇到的多数问题都出自于线程间通信简直太方便了以至于非常容易出错。出错的根源在于CPU执行指令时根本没有线程的概念，多线程编程面临的互斥与同步问题需要程序员自己解决，关于互斥与同步问题限于篇幅就不详细展开了，大部分的操作系统资料都有详细讲解。 最后需要提醒的是：虽然前面关于线程讲解使用的图中用了多个CPU，但不是说一定要有多核才能使用多线程，在单核的情况下一样可以创建出多个线程，原因在于线程是操作系统层面的实现，和有多少个核心是没有关系的，CPU在执行机器指令时也意识不到执行的机器指令属于哪个线程。即使在只有一个CPU的情况下，操作系统也可以通过线程调度让各个线程“同时”向前推进，方法就是将CPU的时间片在各个线程之间来回分配，这样多个线程看起来就是“同时”运行了，但实际上任意时刻还是只有一个线程在运行。 5、线程与内存 在前面的讨论中我们知道了线程和CPU的关系，也就是把CPU的PC寄存器指向线程的入口函数，这样线程就可以运行起来了，这就是为什么我们创建线程时必须指定一个入口函数的原因。 无论使用任何编程语言，创建一个线程大体相同： // 设置线程入口函数DoSomething thread = CreateThread(DoSomething); // 让线程运行起来 thread.Run(); 那么线程和内存又有什么关联呢？ 我们知道函数在被执行的时产生的数据包括：函数参数、局部变量、返回地址等信息。这些信息是保存在栈中的，线程这个概念还没有出现时进程中只有一个执行流，因此只有一个栈，这个栈的栈底就是进程的入口函数，也就是main函数。 假设main函数调用了funA，funcA又调用了funcB，如图所示： ​ 那么有了线程以后了呢？ 有了线程以后一个进程中就存在多个执行入口，即同时存在多个执行流，那么只有一个执行流的进程需要一个栈来保存运行时信息，那么很显然有多个执行流时就需要有多个栈来保存各个执行流的信息，也就是说操作系统要为每个线程在进程的地址空间中分配一个栈，即每个线程都有独属于自己的栈，能意识到这一点是极其关键的。 ​ 同时我们也可以看到，创建线程是要消耗进程内存空间的，这一点也值得注意。 6、线程的使用 现在有了线程的概念，那么接下来作为程序员我们该如何使用线程呢？ 从生命周期的角度讲，线程要处理的任务有两类：长任务和短任务。 *1）长任务（long-lived tasks）：* 顾名思义，就是任务存活的时间很长，比如以我们常用的word为例，我们在word中编辑的文字需要保存在磁盘上，往磁盘上写数据就是一个任务，那么这时一个比较好的方法就是专门创建一个写磁盘的线程，该写线程的生命周期和word进程是一样的，只要打开word就要创建出该写线程，当用户关闭word时该线程才会被销毁，这就是长任务。 ​ 这种场景非常适合创建专用的线程来处理某些特定任务，这种情况比较简单。 有长任务，相应的就有短任务。 *2）短任务（short-lived tasks）：* 这个概念也很简单，那就是任务的处理时间很短，比如一次网络请求、一次数据库查询等，这种任务可以在短时间内快速处理完成。因此短任务多见于各种Server，像web server、database server、file server、mail server等，这也是互联网行业的同学最常见的场景，这种场景是我们要重点讨论的。 **这种场景有两个特点：**一个是任务处理所需时间短；另一个是任务数量巨大。 如果让你来处理这种类型的任务该怎么办呢？ 你可能会想，这很简单啊，当server接收到一个请求后就创建一个线程来处理任务，处理完成后销毁该线程即可，So easy。 这种方法通常被称为thread-per-request，也就是说来一个请求就创建一个线程： ​ 如果是长任务，那么这种方法可以工作的很好，但是对于大量的短任务这种方法虽然实现简单但是有缺点。 具体是以下这样的缺点： 1）从前几节我们能看到，线程是操作系统中的概念(这里不讨论用户态线程实现、协程之类)，因此创建线程天然需要借助操作系统来完成，操作系统创建和销毁线程是需要消耗时间的； 2）每个线程需要有自己独立的栈，因此当创建大量线程时会消耗过多的内存等系统资源。 这就好比你是一个工厂老板（想想都很开心有没有），手里有很多订单，每来一批订单就要招一批工人，生产的产品非常简单，工人们很快就能处理完，处理完这批订单后就把这些千辛万苦招过来的工人辞退掉，当有新的订单时你再千辛万苦的招一遍工人，干活儿5分钟招人10小时，如果你不是励志要让企业倒闭的话大概是不会这么做到的。 因此一个更好的策略就是招一批人后就地养着，有订单时处理订单，没有订单时大家可以闲呆着。 这就是线程池的由来。 7、从多线程到线程池 线程池的概念是非常简单的，无非就是创建一批线程，之后就不再释放了，有任务就提交给这些线程处理，因此无需频繁的创建、销毁线程，同时由于线程池中的线程个数通常是固定的，也不会消耗过多的内存，因此这里的思想就是复用、可控。 8、线程池是如何工作的 可能有的同学会问，该怎么给线程池提交任务呢？这些任务又是怎么给到线程池中线程呢？ 很显然，数据结构中的队列天然适合这种场景，提交任务的就是生产者，消费任务的线程就是消费者，实际上这就是经典的生产者-消费者问题。 ​ 现在你应该知道为什么操作系统课程要讲、面试要问这个问题了吧，因为如果你对生产者-消费者问题不理解的话，本质上你是无法正确的写出线程池的。 限于篇幅在这里不打算详细的讲解生产者消费者问题，参考操作系统相关资料就能获取答案。这里我打算讲一讲一般提交给线程池的任务是什么样子的。 一般来说提交给线程池的任务包含两部分： 需要被处理的数据； 处理数据的函数。 伪码描述一下： struct task { void* data; // 任务所携带的数据 handler handle; // 处理数据的方法 } （注意：你也可以把代码中的struct理解成class，也就是对象) 线程池中的线程会阻塞在队列上，当生产者向队列中写入数据后，线程池中的某个线程会被唤醒，该线程从队列中取出上述结构体(或者对象)，以结构体(或者对象)中的数据为参数并调用处理函数。 伪码如下： while(true) { struct task = GetFromQueue(); // 从队列中取出数据 task-&gt;handle(task-&gt;data); // 处理数据 } 以上就是线程池最核心的部分。 理解这些你就能明白线程池是如何工作的了。 9、线程池中线程的数量 现在线程池有了，那么线程池中线程的数量该是多少呢？ 在接着往下看前先自己想一想这个问题。如果你能看到这里说明还没有睡着。 要知道线程池的线程过少就不能充分利用CPU，线程创建的过多反而会造成系统性能下降，内存占用过多，线程切换造成的消耗等等。因此线程的数量既不能太多也不能太少，那到底该是多少呢？ 回答这个问题，你需要知道线程池处理的任务有哪几类，有的同学可能会说你不是说有两类吗？长任务和短任务，这个是从生命周期的角度来看的，那么从处理任务所需要的资源角度看也有两种类型，这就是没事儿找抽型。。。啊不，是CPU密集型和I/O密集型。 *1）CPU密集型：* 所谓CPU密集型就是说处理任务不需要依赖外部I/O，比如科学计算、矩阵运算等等。在这种情况下只要线程的数量和核数基本相同就可以充分利用CPU资源。 ​ *2）I/O密集型：* 这一类任务可能计算部分所占用时间不多，大部分时间都用在了比如磁盘I/O、网络I/O等。 ​ 这种情况下就稍微复杂一些了，你需要利用性能测试工具评估出用在I/O等待上的时间，这里记为WT(wait time)，以及CPU计算所需要的时间，这里记为CT（computing time），那么对于一个N核的系统，合适的线程数大概是 N * (1 + WT/CT) ，假设I/O等待时间和计算时间相同，那么你大概需要2N个线程才能充分利用CPU资源，注意这只是一个理论值，具体设置多少需要根据真实的业务场景进行测试。 当然充分利用CPU不是唯一需要考虑的点，随着线程数量的增多，内存占用、系统调度、打开的文件数量、打开的socker数量以及打开的数据库链接等等是都需要考虑的。 因此这里没有万能公式，要具体情况具体分析。 10、线程池不是万能的 线程池仅仅是多线程的一种使用形式，因此多线程面临的问题线程池同样不能避免，像死锁问题、race condition问题等等，关于这一部分同样可以参考操作系统相关资料就能得到答案。 11、线程池使用的最佳实践 线程池是程序员手中强大的武器，互联网公司的各个server上几乎都能见到线程池的身影。 但使用线程池前你需要考虑： 1）充分理解你的任务，是长任务还是短任务、是CPU密集型还是I/O密集型，如果两种都有，那么一种可能更好的办法是把这两类任务放到不同的线程池中，这样也许可以更好的确定线程数量； 2）如果线程池中的任务有I/O操作，那么务必对此任务设置超时，否则处理该任务的线程可能会一直阻塞下去； 3）线程池中的任务最好不要同步等待其它任务的结果。 12、本文小结 本文我们从CPU开始一路来到常用的线程池，从底层到上层、从硬件到软件。 注意：这里通篇没有出现任何特定的编程语言，线程不是语言层面的概念（依然不考虑用户态线程），但是当你真正理解了线程后，相信你可以在任何一门语言下用好多线程，你需要理解的是道，此后才是术。 ","link":"https://kangjn.github.io/post/cong-gen-shang-li-jie-gao-xing-neng-gao-bing-fa-yi-shen-ru-ji-suan-ji-di-ceng-li-jie-xian-cheng-yu-xian-cheng-chi/"},{"title":"Node–异步I/O解析","content":"“异步”这个名词其实在Node之前就已经诞生了。但是在绝大多数高级编程语言中，异步并不多见。在众多高级语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。 异步I/O、事件驱动和单线程构成了Node的基调，而Nginx与Node的事件驱动、异步I/O设计理念比较相近。Nginx采用纯C编写，性能表现非常优异，具备面向客户端管理连接的强大能力，但是它的背后依然受限于各种同步方式的编程语言。但Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。 为什么要异步I/O 为什么异步I/O在Node中如此重要，这是因为Node面向网络设计，在跨网络的结构下，并发已经是现代编程中的标准配备了。 用户体验 《高性能JavaScript》中提到过，如果脚本的执行时间超过100毫秒，用户就会感到页面卡顿，以为页面停止响应。而在B/S模型中，网络速度的限制给网页的实时体验造成很大的麻烦。 如果网页临时需要获取一个资源，通过同步的方式获取，那么JavaScript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI停顿，不响应用户的交互行为。这样用户体验将会极差。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。 同理，前端通过异步可以消除掉UI阻塞现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源消耗M毫秒，第二个资源消耗N毫秒。如果采用同步的方式，获取两个资源消耗的的时间为M+N毫秒。而采用异步的方式，第一个资源的获取并不会阻塞第二个资源的获取，消耗的时间为max(M,N)。 随着网站或应用不断膨胀，M与N的值会线性增长，那么异步的性能将比同步更加优越。 资源分配 假设业务场景中有一组互不相关的任务需要完成，有以下两种主流的方法： 单线程串行一次执行 多线程并行完成 如果创建多线程的开销小于并行执行，那么多线程是首选的，但是多线程在创建线程和执行期线程上下文切换的开销较大，而且多线程编程经常面临锁、状态同步等问题。 单线程顺序执行任务的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞。在计算机资源中，通常I/O与CPU计算之间是可以并行执行的，但是同步的编程模型导致I/O的进行会让后续任务等待，造成资源不能被更好的利用。 Node利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，更好的利用CPU。 异步I/O实现 异步I/O在Node中应用最为广泛，但是它并不是Node的原创。 异步I/O与非阻塞I/O 对于计算机内核I/O而言，异步/同步和阻塞/非阻塞是两码事。 操作系统对于I/O只有两种方式：阻塞和非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。 阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作之后，调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。 为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回，非阻塞I/O返回之后，CPU的时间片可以用来处理其他事物，此时提升性能是明显的，但是由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前的调用状态。 为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询。 现存的轮询技术主要有read、select、poll、epoll和kqueue。这里只讲一下epoll的轮询原理。 epoll是Linux下效率最高的I/O事件通知机制，在进入轮询的时候，如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件的通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。 轮询技术满足了非阻塞I/O确保获取完整数据的需求，但是对于程序而言，它仍然算是一种同步，因为应用程序仍然需要等待I/O完全返回，依旧花费了很多时间等待。等待期间，CPU要么用于遍历文件描述符，要么用于休眠等待时间发生。 现实的异步I/O 通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O（虽然这是模拟的） 但是最初，Node在*nix 平台下采用了libeio配合libev实现I/O部分，实现了异步I/O。在Node v0.9.3中，自行实现了线程池来完成异步I/O。 而Windows下的IOCP在某种程度上提供了理想的异步I/O：调用异步方法，等待I/O完成之后的通知，执行回调，用户无需考虑轮询。但是它的内部其实依然是线程池原理，不同之处在于这些线程池有系统内核接手管理。 由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的Node与下层的自定义线程池及IOCP之间个字独立。 我们时常提到Node是单线程的，这里的单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。 Node的异步I/O 完成整个异步I/O环节的有事件循环、观察者和请求对象等。 事件循环 事件循环是Node自身的执行模型，正式它使得回调函数十分普遍。 在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行他们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者 每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。 在Node中，事件主要来源于网络请求、文件I/O等，这些时间对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。 事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。 请求对象 对于Node的异步I/O调用而言，回调函数不由开发者来调用。从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种产物，叫做请求对象 下面用fs.open()方法作为一个小小的例子。 fs.open = function(path,flags,mode,callback){ //... binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback); } fs.open()的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初试操作。JavaScript层面的代码通过调用C++核心模块进行下层的操作。 从事JavaScript调用Node的核心模块，核心模块调用C++模块，内建模块通过libuv进行系统调用，这里是Node里经典的调用方式。这里libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uv_fs_open()的调用过程中，将从JavaScript层传入的参数和当前方法都封装在一个请求对象中，回调函数则被设置在这个对象的属性上。对象包装完毕后，将对象推入线程池等待执行。 至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。 请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。 执行回调 组装好请求对象、送入I/O线程池等待执行，只是完成一部I/O的第一部分，回调通知是第二部分。 线程池中的I/O操作调用完毕之后，会将获取的结果存储在req-&gt;result属性上，然后调用PostQueueCompletionStatus()通知IOCP，告知当前对象操作已经完成。 至此，整个异步I/O的流程完全结束。 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 小结 整理下来，我们可以提取异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。单线程和线程池看起来有些悖论的样子。因为JavaScript是单线程的，所以很容易理解为它不能充分利用多核CPU。实际上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。还有就是除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）都是可以并行起来的。 ","link":"https://kangjn.github.io/post/node-yi-bu-io-jie-xi/"},{"title":"计算机网络 — TCP的三次握手、四次挥手","content":"TCP 头部标识符意义解读 SYN：建立连接 SYN=1，ACK=0 表示一个连接请求 SYN=1，ACK=1 表示同意建立一个连接 FIN：关闭连接 FIN=1 表示发端完成发送任务 注意：表明发送方已经没有数据发送 但不代表之前的数据发送完毕 ACK：置1时表示确认 seq：发送序列号 ack (number)：确认码 更多关于TCP 和 UDP 的详细内容见 计算机网络系列 -- TCP和UDP TCP 三次握手 过程通俗理解 A—&gt;B B收到，B—&gt;A A收到 过程的详细解读 （1） 第一次握手：客户端发送【SYN = 1，随机序列号seq = x】的数据包到服务器,服务器由【SYN = 1】知道客户端要建立连接；此时客户端进入已发送状态，等待服务器确认 （2） 第二次握手：服务器向客户端发送标【SYN = 1，ACK = 1】和【随机序列号seq = y, 确认码ack number = x+1】的数据包；此时服务器进入已收到状态 （3） 第三次握手：客户端收到后判断【ACK=1】和【收的ack number =发的seq+1】； 若正确，客户端发送标识位【ACK = 1、seq = x + 1】和【确认码ack number = y + 1】（服务器发送的seq+1）到服务器； 服务器收到后判断【ACK=1】和【收的ack number =发的seq+1】是否正确； 若正确则完成建立连接，此包发送完毕。此时客户端和服务器进入已连接状态，完成三次握手，客户端与服务器开始传送数据 TCP 三次握手的目的 建立客户端和服务器之间的连接，确认各自的收发能力是否正常 对准好 TCP 包的序号问题，为保证可靠传送 如果是 https 协议，还会进行解密加密 HTTPS解密解密过程见 计算机网络系列 -- HTTPS加密解密过程 为什么要三次握手而不是两次？ 这句话可以转化为第三次握手的意义是什么？ 第三次握手的意义在于：`让服务器知道客户端也收到了自己的同步信号` 通俗理解 两次握手只能保证`单向`：只知道A能向B发送数据 三次握手能保证`双向`：保证A也能收到B发送的数据 第三次握手失败了怎么办？ server端发送了SYN+ACK报文后就会启动一个定时器，等待client返回的ACK报文。如果第三次握手失败的话client给server返回了ACK报文，server并不能收到这个ACK报文。那么server端就会启动超时重传机制，超过规定时间后重新发送SYN+ACK，重传次数默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，server自动关闭这个连接。但是client认为这个连接已经建立，如果client端向server写数据，server端将发送RTS报文段，以防止syn洪泛攻击。 syn洪泛攻击 通俗的理解是：当第三次握手没有发送确认信息时，等待一段时间后，主机就会断开之前的半开连接并回收资源，这为dos（deny of service）攻击埋下隐患，当主动方主动发送大量的syn数据包，但并不做出第三次握手响应，server就会为这些syn包分配资源（但并未使用），就会使server占用大量内存，使server连接环境耗尽，这就是syn洪泛攻击 为什么要三次握手而不是四次？ 四次握手的过程： 第一次：客户端发送【SYN = 1，随机序列号seq = u】到服务器，用来请求开启客户A到服务器B的数据传送； 第二次：服务器B收到这个SYN，它发回【ACK = 1、确认序号ack=u+1】表示同意； 第三次：服务器开启与客户端的连接，发回标识位【SYN = 1，ACK = 1,，确认码ack =u+1】给客户端； 第四次：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。 很明显，第二次和第三次没有分开的必要，可以合并，而且还能提高建立连接时的效率 TCP 四次挥手 过程通俗理解 A：B 啊，我不想玩了 B：好，知道了，等一下哈，我这边还没好 【注意】这时，只是A不想玩了，即不再发送数据。但是B可能还有未发送完的数据，所以需要等待B也主动关闭 B：好的，我弄完了，我也不玩了，拜拜 A：好的，拜拜 [ 过程的详细解读 （1）第一次挥手：客户端发送【FIN = 1，随机序列号seq = u】到服务器，用来主动关闭客户A到服务器B的数据传送；客户机A进入FIN-WAIT-1状态，等待服务器B发送FIN （2）第二次挥手：服务器B收到这个FIN，它发回【ACK = 1、确认序号ack number=u+1】表示同意；客户端进入FIN-WAIT-2状态，稍后关闭连接，服务器B进入CLOSE_WAIT，等待关闭连接; （3）第三次挥手：服务器关闭与客户端的连接，发回标识位【FIN = 1，ACK = 1,，确认码ack number=u+1】给客户端；服务器进入LAST_ACK，等待最后一次ACK确认 （4）第四次挥手：客户端发送【ACK = 1，确认码ack number=w+1】到服务器。客户端进入TIME-WAIT等待2MAL后进入CLOSE可用状态，服务器B进入CLOSE可用状态 TCP 四次挥手的目的 保证客户端、服务器真正断开连接 为什么挥手要四次？而握手只要三次？ B表示收到A的报文之后，可能有未发送完的数据，所以需要把数据全部发送完毕后再来告诉A说可以断开了，所以多了一次 2MSL是什么？目的是什么？ MSL是时间单位 —— 任何报文在网络上存在的最长时间 2MSL目的：保证第四次挥手正常进行 若第4次挥手的报文段丢失了 服务器就会超时重传第3次挥手的报文段 客户端就会重新给服务器发送第4次挥手的报文 最后，客户端、服务器才真正断开连接 为什么客户端关闭后不能再发一下就行？ 不能保证新、老连接端口号一致 ","link":"https://kangjn.github.io/post/ji-suan-ji-wang-luo-tcp-de-san-ci-wo-shou-si-ci-hui-shou/"},{"title":"算法小记","content":"数组去重 第一种 new Set let ary = [1,2,3,4,2,1,3,4,5,6,4,3,5,6,3] let arr = Array.from(new Set(ary)) 第二种 第二种 拿出当前项和后面内容比较 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary.splice(i,1); // 这个性能不如 新建一个数组好 i--; // 会因为splice造成数组塌陷 } } 第三种 判断是否包含，包含的话 那最后一项把当前项覆盖 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary[i] = ary[ary.length - 1]; ary.length--; i-- } } 第四种 循环遍历是否包含，不包含push let arr = [] for(let i = 0;i &lt; ary.length; i++){ if(arr.indexOf(item) === -1){ arr.push(ary[i]) } } 等等还有很多，比如对象键值对，比如包含置为null 在过滤 数组扁平化 第一种 flat let arr = [ [1,2,3], [3,4,5,6], [6,7,8,9,0,[1],[2,3]],10 ] flat()写 几 就扁平化 几级 Infinity 无限 arr.flat(Infinity) 第二种 reduce function ab(arr){ return arr.reduce((pre,cur) =&gt; { return pre.concat(Array.isArray(cur) ? ab(cur) : cur) },[]) } 第三种 toString arr.toString().split(',').map(itm =&gt; parserFloat(itm)) 第四种 while + reduce + concat while(arr.some(itm =&gt; Array.isArray(itm))){ arr = [].concat(...arr) } 第五种 正则 JSON.stringify(arr).replace(/(\\[|\\])/g,'').split(',').map(itm =&gt;parseFloat(itm)) 斐波那契数列 let arr = [1,1,2,3,5,8,13,21] 当前项 = 当前项的 前面两位相加 可以 实现 传入 number 就能计算出对应斐波那契下标的值 第一种： while循环 function fibonacci(n){ if(n&lt;=1) return 1; let arr = [1,1]; let i = n + 1 -2; // why?因为传入的n是数组下标，所以要+1 减2的话就是因为一开始就有两个所以只需要创建剩下的位数 while(i &gt; 0){ let a = arr[arr.length - 2]; let b = arr[arr.length - 1]; arr.push(a+b); i-- } return arr[arr.length - 1]; } 第二种 递归 count：传进来的number cur：放的最终值 next：每次递归的时候作为下一次 cur 的值，需要每次 cur + next ](https://www.pipipi.net/wp-content/uploads/front-end-baike/01fcb9a1a61742a29a3c276a25a83e5d~tplv-k3u1fbpfcp-watermark.png) || || 搭配食用 || fibonacci(count){ function fn(count,cur = 1,next = 1){ if(count == 0){ return cur }else { return fn(count - 1,next,cur+next) } } return fn(count) } 冒泡排序 相邻两元素之间两两比较，比较出大值进行赋值互换，再依次与相邻的元素比较 必须要明白总共比较几回，一回比较几次！！！ let arr = [1,2,3,5,8,0,10] // 外层控制比较几回 for(let i = 0; i &lt; arr.length - 1; i++){ // 内层控制一回比较几次，并且比较大小 for(let j = 0; j &lt; arr.length -1 -i; j++){ if(arr[j] &gt; arr[j + 1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } 快速排序 分三步 取出数组的中间值 遍历数组，大于的放在右数组，小于的放在左边数组 递归并且用 concat 连接 let arr = [1,5,2,7,9,10,90,29,25,11,45,34]; function fast(arr){ if(arr.length &lt; 1) return arr; let num = Math.floor(arr.length / 2) let idx = arr.splice(num,1)[0]; let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; idx){ left.push(arr[i]) }else { right.push(arr[i]) } } return fast(left).concat(idx,fast(right)) } 插入排序 拿出一个值，作为初始数组的值， 通过循环想要排序的数组 并和新数组的值从后向前比 大于就splice到该项后面 function insert(arr){ let handle = []; // 这是最终成型的数组 handle.push(arr[0]); // 先拿一个值 for(let i = 1; i&lt; arr.length; i++){ let news = arr[i]; for(let j = handle.length - 1; j &gt;= 0; j--){ //从后向前比较 if(news &gt; handle[j]){ handle.splice(j+1,0,news); break; } if(j === 0){ // 比到为0的话直接放到数组头部 handle.unshift(news); } } } return handle } 单链表反转 看到这的话，要明白它反转后是什么样 { a:4, next:{ a:3, next:{ a:2, next:{ a:1, next: null } } } } 看到这，肯定是有个大概的思路，就是节点替换 ](https://www.pipipi.net/wp-content/uploads/front-end-baike/e9030c138fbf4e0e8ba87222f3b66dff~tplv-k3u1fbpfcp-watermark.png) let obj = { a:1, next:{ a:2, next: { a:3, next:{ a:4, next:null } } } } function reverseObj(obj){ let pre = null; // pre 最终的值(包含每一步) let cur = obj while(cur.next !== null){ let context = cur.next; // 首先拿到下一个next的值保存 cur.next = pre === null ? null : pre; // pre是上一项保存的值 pre = cur; // 将 当前项的值赋值给最终的值 cur = context // 拿到下一项next继续重复以商操作 } } ","link":"https://kangjn.github.io/post/suan-fa-xiao-ji/"},{"title":"学习笔记：promise","content":" then接收两个参数, onFulfilled 和 onRejected 检查并处理参数, 如果参数不是function就忽略(原样返回value或者reason) class MyPromise { constructor(fn) { // 初始状态为pending this.status = PENDING;//状态 this.value = null;//成功的值 this.reason = null;//失败的值 try { fn(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 3. 根据当前promise的状态, 调用不同的函数 class MyPromise { ..... //这时候then函数被调用会瞬间就会执行switch判断，那这时候如果status可能还没变成fulfilled或者rejected，很有可能还是pending then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 4、首先要拿到所有的回调, 然后在某个时机去执行他. 需要新建两个数组, 分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组. class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 5、在status状态发生变化的时候调用数组里所有的函数 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; //执行存储的函数 this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.value); }); } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; //执行存储的函数 this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.reason); }); } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 7、then的返回值 情况1：如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则新promise必须reject e class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况2：如果onFulfilled不是函数且promise成功执行，那么新的promise必须返回同样的状态和val 情况3：如果onRejected不是函数且promise拒绝执行，那么新的promise必须返回同样的状态和reason class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); resolve(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); if (this.isFunction(onRejected)) { resolve(); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况4:如果onFulfilled或者onRejected 返回一个值 x ，则运行resolvePromise方法 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { const newPromise = new MyPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MyPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } //检验是否为function isFunction(param) { return typeof param === 'function'; } resolvePromise(newPromise, x, resolve, reject){} } 8、resolvePromise resolvePromise(newPromise, x, resolve, reject) { // 防止死循环 if (newPromise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MPromise) { x.then((y) =&gt; { resolvePromise(newPromise, y, resolve, reject); }, reject); } else if (typeof x === 'object' || this.isFunction(x)) { if (x === null) { return resolve(x); } let then = null; try { then = x.then; } catch (error) { return reject(error); } // 如果 then 是函数 if (this.isFunction(then)) { let called = false; try { then.call( x, (y) =&gt; { if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, (r) =&gt; { if (called) return; called = true; reject(r); }); } catch (error) { if (called) return; reject(error); } } else { resolve(x); } } else { resolve(x); } } 9、onFulfilled 和 onRejected 是微任务 then(onFulfilled, onRejected) { ... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }) }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } }) } switch (this.status) { case FULFILLED: { const newPromise = new MPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } } 10. catch方法 catch (onRejected) { return this.then(null, onRejected); } 11. promise.resolve(静态方法) 将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。 static resolve(param) { if (param instanceof MyPromise) { return param; } return new MyPromise(function (resolve) { resolve(param); }); } 12. promise.reject(静态方法) 返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 static reject(reason) { return new MPromise((resolve, reject) =&gt; { reject(reason); }); } ","link":"https://kangjn.github.io/post/xue-xi-bi-ji-promise/"},{"title":"前端学习-Vue","content":"核心特性 数据驱动视图 数据变化会自动更新到对应元素中，无需手动操作 DOM，这种行为称作单向数据绑定。 对于输入框等可输入元素，可设置双向数据绑定。 双向数据绑定是在数据绑定基础上，可自动将元素输入内容更新给数据， 实现数据与元素内容的双向绑定。 Vue.js 的数据驱动视图是基于 MVVM 模型实现的。 MVVM (Model – View – ViewModel )是一种软件开发思想 Model 层，代表数据 View 层， 代表视图模板 ViewModel 层，代表业务逻辑处理代码 基于MVVM 模型实现的数据驱动视图解放了DOM操作 View 与 Model 处理分离，降低代码耦合度 但双向绑定时的 Bug 调试难度增大 大型项目的 View 与 Model 过多，维护成本高 组件化开发 组件化开发，允许我们将网页功能封装为自定义 HTML 标签，复用时书写自定义标签名即可。 组件不仅可以封装结构，还可以封装样式与逻辑代码，大大提交 了开发效率与可维护性。 基础语法 Vue 实例 通过 Vue 函数创建的对象，是使用 Vue 功能的基础。 new Vue({ //选项对象 }); el 选项 用于选取一个 DOM 元素作为 Vue 实例的挂载目标。 只有挂载元素内部才会被 Vue 进行处理，外部为普通 HTML 元素。 代表 MVVM 中的 View 层(视图)。 可以为 CSS 选择器格式的字符串 或 HTMLElement 实例，但不能为 html 或 body。 var vm = new Vue({ el: '#app' }); var app = document.querySelector('#app'); var vm = new Vue({ el: app }); 挂载完毕后，可以通过 vm.$el 进行访问。 var vm = new Vue({ el: '#app' }); console.log(vm.$el); 未设置 el 的 vue 实例，也可以通过 vm.$mount() 进行挂载，参数形式与 el 规则相同。 var app = document.getElementById('app'); var vm = new Vue({}); vm.$mount(app); 插值表达式 挂载元素可以使用 Vue.js 的模板语法，模板中可以通过插值表达式为元素进行动态内容设置，写法为 {{ }}。 &lt;li&gt;第一段示例内容：{{ 10 + 20 + 30 }}&lt;/li&gt; &lt;li&gt;第二段示例内容：{{ 22 &gt; 3 ? '22比3大' : '3比22大' }}&lt;/li&gt; &lt;!-- 错误写法 --&gt; &lt;!-- &lt;li id=&quot;{{ 1 + 2 }}&quot;&gt;&lt;/li&gt; --&gt; &lt;!-- &lt;li&gt;{{ var num = 100; }}&lt;/li&gt; --&gt; 注意点: 插值表达式只能书写在标签内容区域，可以与其它内容混合。 内部只能书写 JavaScript 表达式，不能书写语句。 data 选项 用于存储 Vue 实例需要使用的数据，值为对象类型。 data 中的数据可以通过 vm.$data.数据 或 vm.数据 访问。 var vm = new Vue({ el: '#app', data: { title: '标题文本' } }); console.log(vm.$data.title); console.log(vm.title); data 中的数据可以直接在视图中通过插值表达式访问。 data 中的数据为响应式数据，在发生改变时，视图会自动更新。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ title }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '标题文本', } }); vm.title = '新的标题内容'; &lt;/script&gt; data 中存在数组时，索引操作与 length 操作无法自动更新视图， 这时可以借助 Vue.set() 方法替代操作。 var vm = new Vue({ el: '#app', data: { arr: ['内容1', '内容2', '内容3'] } }); Vue.set(vm.arr, 0, '新内容'); methods 选项 用于存储需要在 Vue 实例中使用的函数。 methods 中的方法可以通过 vm.方法名 访问。 方法中的 this 为 vm 实例，可以便捷的访问 vm 数据等功能。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ fn(title1) }}&lt;/p&gt; &lt;p&gt;{{ fn(title2) }}&lt;/p&gt; &lt;p&gt;{{ title1.split('-').join('') }}&lt;/p&gt; &lt;p&gt;{{ title2.split('-').join('') }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { prefix: '处理的结果为：', title1: 'a-b-c-d-e', title2: 'x-y-z' }, methods: { fn (value) { // console.log(this); this.fn1(); this.fn2(); return this.prefix + value.split('-').join(''); }, fn1 () { console.log('执行了 fn1 的代码'); }, fn2 () { console.log('执行了 fn2 的代码'); } } }); // console.log(vm) &lt;/script&gt; ","link":"https://kangjn.github.io/post/qian-duan-xue-xi-vue/"},{"title":"springboot-文件上传/下载","content":"springboot-文件上传/下载 代码 application.yml spring: servlet: multipart: max-file-size: 50MB #上传文件最大大小 max-request-size: 50MB #单次请求最大大小 # 自定义文件上传路径 web: upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/ ps : 路径中不能包含中文，不然无法读取 FileUtils (文件上传工具类) package cn.justcoding.util; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; /** * 文件上传工具包 */ public class FileUtils { /** * * @param file 文件 * @param path 文件存放路径 * @param fileName 源文件名 * @return */ public static boolean upload(MultipartFile file, String path, String fileName){ //使用原文件名 String realPath = path + &quot;/&quot; +fileName; File dest = new File(realPath); //判断文件父目录是否存在 if(!dest.getParentFile().exists()){ dest.getParentFile().mkdir(); } try { //保存文件 file.transferTo(dest); return true; } catch (IllegalStateException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } } } TestController(进行测试) @Controller public class TestController { private final ResourceLoader resourceLoader; @Value(&quot;${web.upload-path}&quot;) private String path; @Autowired public TestController(ResourceLoader resourceLoader) { this.resourceLoader = resourceLoader; } /** * 跳转到文件上传页面 * @return */ @RequestMapping(&quot;test&quot;) public String toUpload(){ return &quot;freemarker/test&quot;; } /** * * @param file 要上传的文件 * @return */ @RequestMapping(&quot;fileUpload&quot;) public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){ // 要上传的目标文件存放路径 // String localPath = &quot;/src/main/resources/static/photos&quot;; // 上传成功或者失败的提示 String msg = &quot;&quot;; if (FileUtils.upload(file, path, file.getOriginalFilename())){ // 上传成功，给出页面提示 msg = &quot;上传成功！&quot;; }else { msg = &quot;上传失败！&quot;; } // 显示图片 map.put(&quot;msg&quot;, msg); map.put(&quot;fileName&quot;, file.getOriginalFilename()); return &quot;forward:/test&quot;; } /** * 显示单张图片 * @return */ @RequestMapping(&quot;show&quot;) public ResponseEntity showPhotos(String fileName){ try { // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径 // System.out.println(fileName); return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName)); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @RequestMapping(&quot;batch&quot;) public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) { List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;); MultipartFile file = null; BufferedOutputStream stream = null; String msg = &quot;&quot;; for (int i = 0; i &lt; files.size(); ++i) { file = files.get(i); if (!file.isEmpty()) { try { byte[] bytes = file.getBytes(); stream = new BufferedOutputStream(new FileOutputStream( new File(path + file.getOriginalFilename())));//设置文件路径及名字 stream.write(bytes);// 写入 stream.close(); } catch (Exception e) { stream = null; msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot; + e.getMessage(); } } else { msg= &quot;第 &quot; + i + &quot; 个文件上传失败因为文件为空&quot;; } } msg= &quot;上传成功&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } @RequestMapping(&quot;/download&quot;) public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) { String msg = &quot;&quot;; if (fileName != null) { //设置文件路径 File file = new File(path+fileName); //File file = new File(realPath , fileName); if (file.exists()) { response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开 response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名 byte[] buffer = new byte[1024]; FileInputStream fis = null; BufferedInputStream bis = null; try { fis = new FileInputStream(file); bis = new BufferedInputStream(fis); OutputStream os = response.getOutputStream(); int i = bis.read(buffer); while (i != -1) { os.write(buffer, 0, i); i = bis.read(buffer); } msg = &quot;下载成功&quot;; } catch (Exception e) { e.printStackTrace(); } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } msg = &quot;下载失败&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } } test.ytl (简易freemarker测试模板) &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;图片上传Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 &gt;图片上传Demo&lt;/h1&gt; &lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;#--判断是否上传文件--&gt; &lt;#if msg??&gt; &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt; &lt;#else &gt; &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt; &lt;/#if&gt; &lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt; &lt;#if fileName??&gt; &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt; &lt;#else&gt; &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt; &lt;/#if&gt; &lt;hr/&gt; &lt;p&gt;多文件上传&lt;/p&gt; &lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt; &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;hr/&gt; &lt;p&gt;文件下载&lt;/p&gt; &lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/"},{"title":"springboot-7.快速上手redis","content":"springboot-7.快速上手redis 前言 为什么需要Redis? 在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。 为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。 Redis在java web中的应用场景 存储 缓存用的数据； 需要高速读/写的场合使用它快速读/写； Redis作为缓存的读取逻辑 下载安装redis 下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads 选择最新版下载一个即可，下载完后解压便可使用。 为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件： redis-server redis.windows.conf 这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动： 下载安装redis可视化工具 RedisDesktopManager springboot配置使用redis （1）在pom文件中添加依赖项 &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; (2) 编写application.yml spring: # redis redis: host: 127.0.0.1 port: 6379 timeout: 3000 #连接超时 password: minIdle: 1 #连接池中的最小空闲连接 maxIdle: 10 maxWait: 3 #连接池中的最大阻塞等待时间 maxActive: 8 #连接池最大连接数 (3)新建文件夹和文件，如下所示： (4)Reidis配置文件-RedisConfig.java import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.cache.annotation.CachingConfigurerSupport; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.*; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration @EnableCaching //开启注解 public class RedisConfig extends CachingConfigurerSupport { /** * retemplate相关配置 * @param factory * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 配置连接工厂 template.setConnectionFactory(factory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式） Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常 om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 值采用json序列化 template.setValueSerializer(jacksonSeial); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); // 设置hash key 和value序列化模式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jacksonSeial); template.afterPropertiesSet(); return template; } /** * 对hash类型的数据操作 * * @param redisTemplate * @return */ @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForHash(); } /** * 对redis字符串类型数据操作 * * @param redisTemplate * @return */ @Bean public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForValue(); } /** * 对链表类型的数据操作 * * @param redisTemplate * @return */ @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForList(); } /** * 对无序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForSet(); } /** * 对有序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForZSet(); } } (5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java） 为了测试方便，只放入了get和set方法。 @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } } (6)在controller文件中进行测试 @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Resource private RedisUtil redisUtil; @RequestMapping(&quot;/setRedis&quot;) public boolean redisSet() { return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;); } @RequestMapping(&quot;/getRedis&quot;) public String redisGet() { return redisUtil.get(&quot;username&quot;).toString(); } } (7)预览 ps:记得开启redis（通过startup.cmd） 访问 http://localhost:8080/user/setRedis 返回true说明缓存存储成功，使用工具查看 获取缓存存取的值 访问 http://localhost:8080/user/getRedis 以上便是redis的基本使用 redisUtil.java工具类 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * redisTemplate封装 * * @author yinxp@dist.com.cn */ @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key,long time){ try { if(time&gt;0){ redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key){ return redisTemplate.getExpire(key,TimeUnit.SECONDS); } /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key){ try { return redisTemplate.hasKey(key); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String ... key){ if(key!=null&amp;&amp;key.length&gt;0){ if(key.length==1){ redisTemplate.delete(key[0]); }else{ redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key,Object value,long time){ try { if(time&gt;0){ redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); }else{ set(key, value); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递增因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, delta); } /** * 递减 * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递减因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, -delta); } //================================Map================================= /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key,String item){ return redisTemplate.opsForHash().get(key, item); } /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object,Object&gt; hmget(String key){ return redisTemplate.opsForHash().entries(key); } /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map){ try { redisTemplate.opsForHash().putAll(key, map); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){ try { redisTemplate.opsForHash().putAll(key, map); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value) { try { redisTemplate.opsForHash().put(key, item, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value,long time) { try { redisTemplate.opsForHash().put(key, item, value); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item){ redisTemplate.opsForHash().delete(key,item); } /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item){ return redisTemplate.opsForHash().hasKey(key, item); } /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item, by); } /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item,-by); } //============================set============================= /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key){ try { return redisTemplate.opsForSet().members(key); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key,Object value){ try { return redisTemplate.opsForSet().isMember(key, value); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object...values) { try { return redisTemplate.opsForSet().add(key, values); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key,long time,Object...values) { try { Long count = redisTemplate.opsForSet().add(key, values); if(time&gt;0) { expire(key, time); } return count; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key){ try { return redisTemplate.opsForSet().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object ...values) { try { Long count = redisTemplate.opsForSet().remove(key, values); return count; } catch (Exception e) { e.printStackTrace(); return 0; } } //===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end){ try { return redisTemplate.opsForList().range(key, start, end); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key){ try { return redisTemplate.opsForList().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key,long index){ try { return redisTemplate.opsForList().index(key, index); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) { try { redisTemplate.opsForList().rightPush(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) { try { redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) { try { redisTemplate.opsForList().rightPushAll(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) { try { redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index,Object value) { try { redisTemplate.opsForList().set(key, index, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key,long count,Object value) { try { Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 模糊查询获取key值 * @param pattern * @return */ public Set keys(String pattern){ return redisTemplate.keys(pattern); } /** * 使用Redis的消息队列 * @param channel * @param message 消息内容 */ public void convertAndSend(String channel, Object message){ redisTemplate.convertAndSend(channel,message); } } ","link":"https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/"},{"title":"springboot-6.整合Mybatis","content":"springboot-6.整合Mybatis 一 .解析Java框架中entity层，mapper层，service层各层作用 （1）entity层 别名： model层 ，domain层。 用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应 简单例子：user表的实体User public class User { private int id;//id private String username;//用户名 //……省略set,get方法 } （2）mapper层 别名： dao层 用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作 简单例子： @Mapper public interface UserMapper { public User selectUserById(int id); } (3) service层 业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。 作用：为controller层的类提供接口进行调用。 简单例子： public interface UserService extends Service&lt;User&gt; { } 二.快速使用 （1）添加依赖项 &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; （2）配置application.yml spring: #数据源配置 datasource: url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: ****** driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource connectionProperties: druid.stat.mergeSql=true #为mybatis配置，生产环境可删除 restart: include: mapper: /mapper-[\\\\w-\\\\.]+jar pagehelper: /pagehelper-[\\\\w-\\\\.]+jar pagehelper: auto-dialect: msyql reasonable: true support-methods-arguments: true params: count=countSql (3)编写User.java【entity层】 public class User { private String id; private String username; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } (4)编写UserMapper.java(dao层) @Mapper public interface UserMapper { @Select(&quot;select * from user where id = #{id}&quot;) public User selectUserById(int id); @Select(&quot;select * from user where username = #{username}&quot;) public List&lt;User&gt; selectUserByName(String userName); @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;) public void addUser(User user); @Update(&quot;update user set username=#{username} where id=#{id}&quot;) public void updateUser(User user); @Delete(&quot;delete from user where id=#{id}&quot;) public void deleteUser(int id); } (5)编写userController.java @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Autowired UserMapper userMapper; @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET) public User selectUserById(String id){ User user = userMapper.selectUserById(Integer.parseInt(id)); return user; } @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET) public List&lt;User&gt; selectUserByName(String userName){ return userMapper.selectUserByName(userName); } @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST) public void addUser(User user){ userMapper.addUser(user); } @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST) public void updateUser(User user){ userMapper.updateUser(user); } @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST) public void deleteUser(String id){ userMapper.deleteUser(Integer.parseInt(id)); } } 此时便已经全部配置结束 为了方便测试，忽略了service层，直接调用了mapper层 （6）测试 1. ","link":"https://kangjn.github.io/post/springboot-6zheng-he-mybatis/"},{"title":"springboot-5.全局异常捕获","content":"springboot-5.全局异常捕获 在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。 1 浏览器访问异常时： 2.postman访问异常时： 显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。 正文 1.自定义基础接口类+自定义枚举类 public interface BaseErrorInfoInterface { /** 错误码*/ String getResultCode(); /** 错误描述*/ String getResultMsg(); public enum CommonEnum implements BaseErrorInfoInterface { // 数据操作错误定义 SUCCESS(&quot;200&quot;, &quot;成功!&quot;), BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;), SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;), NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;), INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;), SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;) ; /** 错误码 */ private String resultCode; /** 错误描述 */ private String resultMsg; CommonEnum(String resultCode, String resultMsg) { this.resultCode = resultCode; this.resultMsg = resultMsg; } @Override public String getResultCode() { return resultCode; } @Override public String getResultMsg() { return resultMsg; } } } 2.自定义异常类 public class BizException extends RuntimeException { private static final long serialVersionUID = 1L; /** * 错误码 */ protected String errorCode; /** * 错误信息 */ protected String errorMsg; public BizException() { super(); } public BizException(BaseErrorInfoInterface errorInfoInterface) { super(errorInfoInterface.getResultCode()); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) { super(errorInfoInterface.getResultCode(), cause); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(String errorMsg) { super(errorMsg); this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg) { super(errorCode); this.errorCode = errorCode; this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg, Throwable cause) { super(errorCode, cause); this.errorCode = errorCode; this.errorMsg = errorMsg; } public String getErrorCode() { return errorCode; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public String getErrorMsg() { return errorMsg; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public String getMessage() { return errorMsg; } @Override public Throwable fillInStackTrace() { return this; } } 3.自定义数据格式 public class ResultBody { /** * 响应代码 */ private String code; /** * 响应消息 */ private String message; /** * 响应结果 */ private Object result; public ResultBody() { } public ResultBody(BaseErrorInfoInterface errorInfo) { this.code = errorInfo.getResultCode(); this.message = errorInfo.getResultMsg(); } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Object getResult() { return result; } public void setResult(Object result) { this.result = result; } /** * 成功 * * @return */ public static ResultBody success() { return success(null); } /** * 成功 * @param data * @return */ public static ResultBody success(Object data) { ResultBody rb = new ResultBody(); rb.setCode(CommonEnum.SUCCESS.getResultCode()); rb.setMessage(CommonEnum.SUCCESS.getResultMsg()); rb.setResult(data); return rb; } /** * 失败 */ public static ResultBody error(BaseErrorInfoInterface errorInfo) { ResultBody rb = new ResultBody(); rb.setCode(errorInfo.getResultCode()); rb.setMessage(errorInfo.getResultMsg()); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error(String code, String message) { ResultBody rb = new ResultBody(); rb.setCode(code); rb.setMessage(message); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error( String message) { ResultBody rb = new ResultBody(); rb.setCode(&quot;-1&quot;); rb.setMessage(message); rb.setResult(null); return rb; } @Override public String toString() { return JSONObject.toJSONString(this); } } 4.自定义全局异常处理类 @RestControllerAdvice public class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); public static final String Demo_View = &quot;error&quot;; /** * 处理自定义的业务异常 * @param req * @param e * @return */ @ExceptionHandler(value = BizException.class) public Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,e.getErrorCode()); mav.setViewName(Demo_View); return mav; } } /** * 处理空指针的异常 * @param req * @param e * @return */ @ExceptionHandler(value =NullPointerException.class) @ResponseBody public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){ logger.error(&quot;发生空指针异常！原因是:&quot;,e); return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH); } /** * 处理其他异常 * @param req * @param e * @return */ @ExceptionHandler(value =Exception.class) public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR); mav.setViewName(Demo_View); return mav; } } //判断是否是ajax请求 public static boolean isAjax(HttpServletRequest httpRequest) { return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString())); } } 5.编写前端异常显示页面 ps:名称对应步骤4里的String Demo_View 为了测试，快速建立一个html &lt;!doctype html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 此时全局异常捕获已经建立完毕，接下来进行测试 测试 1.web页面跳转 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;/error&quot;) public String error() { int a = 1 / 0; //除以0，产生异常 return &quot;error&quot;; } } 此时访问web页面： 2.ajax形式跳转 更改controller文件 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;&quot;) public String err() { return &quot;thymeleaf/ajaxerror&quot;; } @RequestMapping(&quot;getAjaxError&quot;) public jsonResult ajaxError() { int a = 1/0; return jsonResult.ok(200); } } 新建一个ajaxerror.html文件于thymeleaf文件夹下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ajax测试&lt;/title&gt; &lt;/head&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt; &lt;/body&gt; &lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt; &lt;/html&gt; 新建一个ajax.js文件编写ajax请求 $(&quot;#test&quot;).click(function() { $.ajax({ url: &quot;/err/getAjaxError&quot;, type: &quot;POST&quot;, async: false, success: function (data) { if (data.status == 200 &amp;&amp; data.msg == 'OK') { alert(&quot;success&quot;); } else { alert(&quot;发生异常&quot; + data.msg); } }, error: function (response, ajaxOption, thrownError) { alert(&quot;error&quot;); } }); }); 记得在application文件夹添加静态文件路径配置 mvc: static-path-pattern: /static/** 此时访问 3.测试自定义异常 新建一个controller文件 @Controller @RequestMapping(value = &quot;/api&quot;) public class UserRestController { @RequestMapping(&quot;&quot;) public String api(ModelMap map) { User u = new User(); map.addAttribute(&quot;user&quot;,u); return &quot;thymeleaf/api&quot;; } @PostMapping(&quot;/user&quot;) public boolean insert(User user) { System.out.println(&quot;开始新增...&quot;); //如果姓名为空就手动抛出一个自定义的异常！ if (user.getUsername() == null) { throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;); } return true; } } 新建一个api.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 访问 3.测试自定义异常 @RequestMapping(&quot;/error&quot;) public String error() { throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;); } 尾言 按照步骤添加即可完成操作~ User类自行添加或者浏览前文即可。 其他 1.SpringBoot异常处理-自定义错误页面 (1) 在Spring Boot中一共提供了几种处理异常的方式？ SpringBoot 中对于异常处理提供了五种处理方式： 自定义错误页面； @ExceptionHandle 注解处理异常； @ControllerAdvice+@ExceptionHandler 注解处理异常； 配置 SimpleMappingExceptionResolver 处理异常； 自定义 HandlerExceptionResolver 类处理异常 (2) 什么是自定义错误页面方式？ SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫 BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。 (3) 自义定错误页面应该放到项目的什么位置？ 放在一般网页资源存放的位置 即src/main/resources/templates 2.SpringBoot异常处理-@ControlleAdvice (1) @ControllerAdvice注解的作用是什么？ 需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。 (2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？ 是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。 ","link":"https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/"},{"title":"springboot-4.模板引擎","content":"springboot-4.模板引擎 前言 关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。 freemarker (1)在pom文件中添加依赖项 &lt;!-- freemarker 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加freemarker相关配置 spring: http: encoding: force: true charset: UTF-8 freemarker: allow-request-override: false cache: false check-template-location: true charset: UTF-8 content-type: text/html; charset=utf-8 expose-request-attributes: false expose-session-attributes: false expose-spring-macro-helpers: false suffix: .ftl template-loader-path: classpath:/templates (3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl 文件树结构： 快速创建一个网页模板进行测试，内容如下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;${host}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ps：其中host的值通过后台读取。 （4）在controller文件夹下新建一个freemarkerController.java文件 @Controller public class freemarkerController { @RequestMapping(&quot;/&quot;) public String index(ModelMap map) { map.addAttribute(&quot;host&quot;,&quot;ericam&quot;); return &quot;freemarker/center&quot;; } } ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl） (5)预览 此时打开浏览器可以看到如下内容： 接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf） Thymeleaf 一. 快速入门使用 （1）在pom文件夹添加项目依赖 &lt;!-- ThymeLeaf 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加themeleaf相关配置 spring: thymeleaf: cache: false # 开发时关闭缓存,不然没法看到实时页面 mode: HTML # 用非严格的 HTML encoding: UTF-8 servlet: content-type: text/html (3) 在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html 文件树： 新建一个User.java文件 文件树： (4)编写User.java文件 为了方便测试，用户具备如下属性： id 用户名 年龄 创建时间 用户简介 public class User { private String id; private int age; private String username; private Date createTime; private String desc; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } //请读者自行补充 构造器和 get/set方法.. public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } (5)新建一个themeleafController.java进行测试 @Controller public class themeleafController { @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); //这里的user对应html里的user return &quot;thymeleaf/test&quot;; } } (6)最后我们进行编写test.html文件 &lt;div&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt; &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt; &lt;/div&gt; ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。 (7)预览 二.Thymeleaf常用标签-方法 （1）上述test.html的等同写法 &lt;div th:object=&quot;${user}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt; &lt;/div&gt; 这样可以简化内容，使用更加广泛。 （2）表单的提交 我们在test.html里添加如下内容 &lt;div&gt; &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/div&gt; ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username 接着在themeleafController添加如下内容 @PostMapping(&quot;/postform&quot;) public String postform(User u) //前端传入了一个User对象 { System.out.println(u.getUsername()); return &quot;redirect:/test&quot;; //重定向（等于转向/test地址 } （3）th:if标签 &lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt; 利用if判断变量是否为空，非空时显示 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; if / else 的实现 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt; (4)th:selected标签 &lt;select&gt; &lt;option &gt;选择框&lt;/option&gt; &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt; &lt;/select&gt; (5)table表单 &lt;table&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;person:${userlist}&quot;&gt; &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在这里我们需要修改下themeleafController文件，为其添加一个userlist。 @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); List&lt;User&gt; userlist = new ArrayList&lt;&gt;(); //添加一个userlist userlist.add(u); u = new User(); u.setId(&quot;234&quot;); u.setUsername(&quot;ericam&quot;); u.setCreateTime(new Date(2020-1900,5-1,12)); u.setAge(3); userlist.add(u); map.addAttribute(&quot;userlist&quot;,userlist); return &quot;thymeleaf/test&quot;; } (6)th:switch &lt;div th:switch=&quot;${user.username}&quot;&gt; &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 备注：常用标签的效果可以自行去测试 ","link":"https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/"},{"title":"springboot-3.资源文件属性配置","content":"springboot-3.资源文件属性配置 前言 为什么要进行资源文件属性配置呢？可以想象成就是一个设置文件。比如设置好数据库密码.port端口后，在其他地方只需要用名字引用即可。 举个例子： 我们设置以下项目的持有者名称为ericam demo: name: &quot;ericam&quot; 那么在其他地方只需要引用name名称即可，然后如果整个项目需要多次引用，后期我们只需要在一个配置文件里更改下名称即可，不必多次操作。 Spring Boot可使用注解的方式将自定义的properties文件映射到实体bean中，比如application.properties文件 或者application.yml 正文 （1）首先，在pom文件中添加依赖项 &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; （2）修改application.yml文件，添加如下内容 demo: name: &quot;ericam&quot; （3）新建一个Resource.java文件 package cn.ericam.nndemo; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; @Configuration //使用配置注解 ，表示这个类是配置文件 @ConfigurationProperties(prefix = &quot;demo&quot;) //prefix 指定配置文件里的前缀 @PropertySource(value = &quot;classpath:application.yml&quot;) public class Resource { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } ps：ConfigurationProperties是一个注解，可以标注在一个Class上，这样Spring Boot会从Environment中获取其属性对应的属性值给其进行注入。 （4）接下来，我们开始引用一波尝试，打开helloController.java文件 @RestController public class helloController { @Autowired private Resource resource; //构建一个Resource类对象，通过autowired自动赋值 @RequestMapping(&quot;/getR&quot;) public jsonResult gr() { Resource b = new Resource(); BeanUtils.copyProperties(resource,b); //将resource的值拷贝复制给b return jsonResult.ok(b); } } ps:@Autowired 注释可以对类成员变量、方法及构造函数进行标注，完成自动装配。 通过 @Autowired的使用来消除 set、get方法。 打开浏览器 application.yml文件中重要属性 server: port: 8080 #端口 servlet: context-path: /demo #配置路径，此后访问http://localhost:****/demo/**** ","link":"https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/"},{"title":"springboot-2.利用接口返回数据（json）","content":"springboot-2.利用接口返回数据（json） 前言 项目前后台交互存在两种方式 一种普通整体页面提交，比如form提交； 还有一种局部刷新，或者叫做异步刷新，ajax提交； @Controller就是整体页面刷新提交的处理注解 @RestController就是ajax提交，一般返回json格式，相当于我们经常使用的@ResponseBody+@Controller组合 正文 新建文件夹controller 然后在该文件夹下新建 控制类.java文件 [![cWWn9x.png]((https://gitee.com/kangjun/MyBlogImage/raw/master/cWWn9x.png) 1.最简单的数据返回 @RestController public class helloController { @RequestMapping(&quot;/&quot;) public String hello() { return &quot;hello&quot;; } } 【@RequestMapping作用】 处理请求地址的映射 用于类和方法上，类上的 “请求地址” 是方法上的 “请求地址” 的父地址 [ 2.返回类对象信息 为了演示，我们新建一个文件夹User，然后在该文件夹下新建一个文件User.java [ 内容如下： public class User { private String name; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 然后在controller文件夹下新建一个userController.java文件 (记得自行import需要的文件) [ @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public User getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return u; } } 3.返回封装的类对象信息 解释一下该处和2处的区别： @Description: 自定义响应数据结构这个类是提供给门户，ios，安卓，微信商城用的门户接受此类数据后需要使用本类的方法转换成对于的数据类型格式（类，或者list）其他自行处理 200：表示成功 500：表示错误，错误信息在msg字段中 501：bean验证错误，不管多少个错误都以map形式返回 502：拦截器拦截到用户token出错 555：异常抛出信息 简单来说，就是当前台提交用户信息给后台时，后台会返回一个json数据，其中包含状态码（200等），message（“ok”或者“failure”），然后再包含一个用户信息列表。 首先，在pom文件中添加依赖项 jackson-databind jackson-core 新建一个jsonResult.java文件 package cn.ericam.nndemo.Json; public class jsonResult { // 响应业务状态 private Integer status; // 响应消息 private String msg; // 响应中的数据 private Object data; public static jsonResult ok(Object data) { return new jsonResult(data); } //类含参初始化1 public jsonResult(Integer status, String msg, Object data) { this.status = status; this.msg = msg; this.data = data; } //类含参初始化2 public jsonResult(Object data) { this.status = 200; this.msg = &quot;OK&quot;; this.data = data; } //get和set方法 public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } 然后在userController.java下修改为如下代码： @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public jsonResult getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return jsonResult.ok(u); } } [ 【ps：IDEA利用ctrl+insert可以快速生成get和set方法】 ","link":"https://kangjn.github.io/post/springboot-2li-yong-jie-kou-fan-hui-shu-ju-json/"},{"title":"springboot-1.简约版创建第一个应用","content":"springboot-1.简约版创建第一个应用 勾选依赖项 由于只是体验搭建一个springboot项目，因此依赖项只需要勾选一个spring web 创建成功后项目列表如下图所示 其中 DemoApplication.java:关键的启动类（程序的入口） pom.xml:Maven构建说明文件 DemoApplicationTests.java:一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文 application.properties:一个空的properties文件，根据需要添加配置属性 为了演示简单，不再新建控制类，而是直接在这个入口类(DemoApplication.java)中编写，添加@RestController以及index方法，如下： 红色框内 内容需要添加 ps:@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 运行项目 浏览器访问http://localhost:8080/ 至此第一个springboot项目已经创建完毕 端口被占用 由于项目需要运行在端口8080，当端口被占用时，需要杀死该端口上运行的进程 进入命令行 netstat -o -n -a | findstr :8080 # TCP 0.0.0.0:3000 0.0.0.0:0 LISTENING 3116 taskkill /F /PID 3116 实现热启动 热启动：修改代码保存时会自动重新启动项目 1.修改pom.xml文件(添加spring-boot-devtools包) &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 修改spring-boot-maven-plugin插件 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork:设置True，否则可能devtools不会起作用--&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2.修改IDEA配置 打开 File -&gt; Settings -&gt;Build,Executions,Deployment -&gt; Compiler ，勾选 然后，Ctrl + Shift + Alt + / 打开 勾选该选项 热更新完成！ ","link":"https://kangjn.github.io/post/springboot-1jian-yue-ban-chuang-jian-di-yi-ge-ying-yong/"},{"title":"git命令行常用指令","content":"git命令行日常指令 首先，需要在Github/Coding平台新建一个仓库。 本地新建一个文件夹，打开该文件夹，右键选择“git bash here”进入命令行。 1.将项目初次拉取到本地（clone） git clone 项目地址 2. 将本地文件push到远程仓库 git init #初始化 git add . #将文件夹内所有文件添加至本地仓库 git commit -m &quot;描述&quot; #添加本次提交描述 git remote add origin https://github.com/用户名/项目名.git git push -u origin master ps: git remote add origin...为建立本地与远程依赖，某些情况下需要重置。 清空依赖命令 git remote rm origin 3.删除文件夹 git pull origin master git rm -r --cached idea #删除idea文件夹 git commit -m '删除.idea' git push -u origin master 4. git push 命令使用 场景1 场景：当本地的当前分支不是local_branch； 作用：将远程分支拉取到指定本地分支； 例如：当前分支是dev，但是你想把远程master “同步”到本地master，但又不想使checkout切换到master分支； git pull origin master：master #将远程master分支拉取到本地master分支 场景2 场景：在当前分支上进行同步操作； 作用：将指定远程分支同步到当前本地分支； git pull origin master 场景3 场景：本地分支已经和想要拉取的分支建立了“关联”关系； 作用：拉取所有远程分支的新版本&quot;坐标&quot;，并同步当前分支的本地代码(具体根据关联分支而定) git push 5.强制拉取 git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull git fetch&amp;&amp;git pull git pull : 拉取代码并合并 git fetch :拉取代码 (如果需要合并，执行git merge) git fetch使用方法 git fetch origin master:tmp // 拉取远程master分支，并放到本地tmp分支上 git diff tmp //查看当前分支和tmp分支的区别 git merge tmp // 把tmp分支合并到当前分支 git branch -d tmp // 删除tmp分支 ","link":"https://kangjn.github.io/post/git-ming-ling-xing-chang-yong-zhi-ling/"},{"title":"设计模式-六大设计原则","content":"单一职责原则 简介 单一职责原则（SRP，Single Responsesibility Principle）：There should never be more than one reason for a class to change.(应该有且仅有一个原因引起类的变更) 优势 类的复杂性降低。实现什么职责都有清晰明确的定义 可读性提高，复杂性降低 可维护性提高，可读性提高 变更引起的风险降低 注意 单一职责是一个标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是这两者都是不可度量的，因项目和环境而定。 里氏替换原则 简介 里氏替换原则（LSP，Liskov Substitution Principle）： If for each object o1 of type S there is an object o2 of type T suchthat for all programs P defined in terms of T, the behavior of P is unchangedwhen o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。） functions that use pointers or references to base classes must beable to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 理解：只要父类能出现的地方子类就可以出现，即将父类对象调用的行为切换成子类对象调用行为也不会产生任何错误或异常，但是反过来却不行。 含义 子类必须完全实现父类的方法 里氏替换原则可以正着用，不能反过来用：子类出现的地方，父类未必可以胜任 覆盖或实现父类的方法时，输入参数可以被放大：如果反过来会引起业务逻辑的错乱。子类中方法的前置条件（参数）必须与超类中被覆写的方法的前置条件相同或更宽松。（如：父类是HashMap，子类是HashMap或Map） 覆写或实现父类的方法时输出结果可以被缩小：里氏替换原则要求S小于等于T，则S和T要么是同一类型，要么S是T的子类。 注意 在类中调用其他类时必须要使用父类或接口，如果不能使用父类或接口，说明类的设计已经违背了LSP原则 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生了&quot;畸变&quot;，建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 依赖倒置原则 简介 依赖倒置原则（DIP，Dependence Inversion Principle）：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions 理解：高层模块不应该依赖底层模块，两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象 含义 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象实现的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 注意 Java变量有两种类型：表面类型（定义时候赋予的类型），实际类型（对象的类型） 依赖的三种写法：构造函数传递依赖对象、setter方法传递依赖对象、接口声明依赖对象 依赖倒置原则是实现开闭原则的重要途径。 使用 要想使用这个规则只需要做到一下几点： 每个类尽量都有接口或抽象类，或两者皆有 变量的表面类型尽量是接口或抽象类 任何类都不应该从具体类派生 尽量不要覆写基类方法 结合里氏替换原则使用：接口负责定义Public属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化 接口隔离原则 简介 接口隔离原则（ISP：Interface Segregation Principle）： Clients should not be forced to depend upon interfaces that they don't use（客户端不应该依赖于它不需要的接口） The dependency of one class to another one should depend on the smallest possible interface（类间的依赖关系应该建立在最小的接口上） 理解：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化同时接口方法尽量少 含义 接口尽可能的小：前提是不能违背单一职责原则，优先考虑单一职责原则 接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互 定制服务：单独为一个个体提供优良的服务 接口设计是有限度的 注意 接口隔离原则和单一职责并不冲突，两者针对的角度不同。单一职责注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少 设计是有限度的，不要无限的考虑未来可能出现的情况 使用 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑尽量压缩接口中的public方法，并经常回顾接口 如果接口已经被污染，尽量去修改。如果不行，则使用适配器模式进行转换处理 了解环境，根据业务来设计 迪米特法则 简介 迪米特法则（LoD：Law of Demeter）：一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道的最少 含义 只和朋友交流：不要出现getA().getB().getC().getD()的奇葩写法 朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类 朋友间也是有距离的：公开的public属性或方法越多，修改时涉及的面也就越大。在设计时候要反复考虑是否可以减少public的方法和属性，将其修改成private等，并且是否可以加上final关键字 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系也不对本类产生负面影响，就放在本类中 谨慎使用Serializable：由于很容易被发现，所以不必太过在意。 注意 一个类只和朋友交流不和陌生人交流 ，不要出现getA().getB().getC().getD()的奇葩写法 类与类之间的关系是建立在类间的，而不是方法间的，一个方法尽量不引入一个类中不存在的对象，JDK API提供的除外 尽量不要对外公布太多的public方法和非静态的public变量 如果一个类跳转两次以上才能访问到另外一个类，就需要进行重构了。 开闭原则 简介 开闭原则：Software entities like classes,modules and functions should be open for extension but closed for modifications（一个软件实体，如类、模块和函数应该对扩展开发对修改关闭） 理解：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。 优势 使用开闭原则能有效的减少重构时的测试 可以提高复用性 可以提高可维护性 面向对象开发的要求 使用 抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法 参数类型、引用对象尽量使用接口或抽象类，而不是实现类 抽象层尽量保持稳定，一旦确认就不允许修改 元数据控制模块行为：尽量使用元数据来控制程序的行为（描述缓解和数据的数据，通俗的说就是配置） 制定项目章程 封装变化 将相同的变化封装到一个接口或抽象类中 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中 注意 开闭原则对扩展开放对修改关闭，并不意味着不做任何修改，底层模块的变更，必然有高层模块进行耦合，否则就是无意义的代码 ","link":"https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/"},{"title":"《论语》50经典名句","content":"1．朝闻道，夕死可矣。 早上明白知晓了真理，即便晚上死去，也是值得的。 2．见贤思齐焉，见不贤而内自省也。 见到贤人便应考虑怎样才能向他看齐，见到不贤的人便应在内心反省，看自己有没有同样的缺点。 3．己所不欲，勿施于人。 如果不希望他人这样对待自己，自己也不要这样对待他人。 4．不怨天，不尤人。 遇到挫折与失败，绝不抱怨天，不责怪人。 5．不迁怒，不贰过。 不会迁怒于人，不会犯两次同样的错误。 6．过而不改，是谓过矣。 有了过错而不改正，这就是真的过错了。 7．人而无信，不知其可也。 一个人不讲信用，不知他怎样立身处世。 8．有则改之，无则加勉。 别人给自己指出缺点错误，如果有，就改正，如果没有，就用来提醒自己不犯同样的错误。 9．如切如磋，如琢如磨。 完善自身的修养，既像雕琢玉器，又像雕刻石头，都是需要下功夫的。 10．人无远虑，必有近忧。 一个人没有长远的考虑，一定会有眼前的忧患。指智者能不为眼前得失所羁绊，目光长远，判断敏锐。 11．君子求诸己，小人求诸人。 君子哪儿做得不对，会从自己内心去查找原因，要求自己做好，从而修正自己；小人则是向外去查找原因，要求别人做好。 12．君子坦荡荡，小人长戚戚。 君子光明磊落，胸怀坦荡，小人则斤斤计较，患得患失。 13．君子喻于义，小人喻于利。 君子能够领悟的是道义，小人能够领悟的是利益。 14．君子和而不同，小人同而不和。 君子和谐而不同流合污，小人同流合污而不和谐。 15．君子泰而不骄，小人骄而不泰。 君子坦荡舒畅而不骄傲自大，小人骄傲自大而不坦荡舒畅。 16．君子成人之美，不成人之恶。小人反是。 君子成全别人的好事，而不促成别人的坏事。小人则与此相反。 17．君子欲讷于言，而敏于行。 君子说话要谨慎，而行动要敏捷。君子说话要谨慎，是因为“覆水难收”，随心所欲说出口的话，可能对于别人有失尊重。但是一旦君子对于决定的事情，绝不犹豫推托而耽误了时光。这一缓一急之间，正是体现君子有为有守的处世原则。 18．君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。 君子食不追求饱足，居住不追求安逸，对工作勤奋敏捷，说话却谨慎，接近有道德有学问的人并向他学习，纠正自己的缺点，就可以称得上是好学了。 **19．与善人居，如入芝兰之室，久而不闻其香，即与之化矣；与不善人居，如入鲍鱼之肆，久而不闻其臭；亦与之化矣。 ** 常与善人相处，就像生活在种满兰芝仙草的花房，时间长了便察觉不到香味，那是因为已经习惯了善行的芬芳；常与不善的人相处，就像住进了满是臭鱼烂虾的海鲜市场，时间长了便察觉不到腥味，也是因为闻惯了恶行的腐臭。 圣人此言是在告诫我们：与人相处，先看人品。 常跟善良的人在一起，便会耳濡目染地跟着行善事、说善言，久而久之，心胸也会变得更加宽广。 常跟邪恶的人在一起，则会不知不觉地跟做错事、说恶话，久而久之，难免会折损自身的品行。 20．君子有三畏：畏天命，畏大人，畏圣人之言。小人不知天命而不畏也，狎大人，侮圣人之言”。 君子有三件敬畏的事情：敬畏天命，敬畏居高位的人，敬畏圣人的话，小人不知道天所赋予的正理而不敬畏，怠慢轻视高位的人，戏侮圣人的话。 21．学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？ 学过的知识，在适当的时候去复习它，这不是令人感到快乐的事吗？ 有朋友从远方来，这不是件令人感到快乐的事吗？ 别人不了解我，我也不生气，这不也是一种君子风度的表现吗？ 22．三人行，必有我师焉。择其善者而从之，其不善者而改之。 几个人同行，其中必有值得我学习的人，选取他的优点向他学习，对他的缺点引以为戒，有则改之。 23．学而不厌，诲人不倦。 努力学习却不感到满足，教导别人不感到厌倦。 24．学而不思则罔，思而不学则殆。 只学习却不思考就会感到迷茫，只空想却不学习就会疲倦而没有收获。 25．敏而好学，不耻下问，是以谓之文也。 聪明而且好学，不认为向地位比自己低、学识比自己浅的人请教是可耻的事，任何一个能如此作为的人，怎会不能成才？ 26．知之为知之，不知为不知，是知也。 知道就是知道，不知道应当说不知道，这才是明智的行为。 27．温故而知新，可以为师矣。 温习旧知识从而得到新的理解与体会，凭借这一点就可以成为老师了。 28．子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。” 孔子说：“我十五岁时，便立定志向学习；三十岁时，能立身处世；四十岁时，可以免于迷惑；五十岁时，已经能够领悟天命；六十岁时，就可以顺从天命；七十岁时，终于能做到做事随心所欲，却都能合于规矩的境界了。” 29．欲速则不达；见小利则大事不成。 不要求快，不要贪求小利。求快反而达不到目的，贪求小利就做不成大事。 30．小不忍，则乱大谋。 小事不忍耐，就会坏了大事情。 31．知者不惑，仁者不忧，勇者不惧。 有智慧的人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。 32．见义不为，无勇也。 见到应该挺身而出的事情，却袖手旁观，就是怯懦。 33．志士仁人，无求生以害仁，有杀身以成仁。 一位怀有大志和仁德的人，不会贪生怕死而损害仁德，只会不惜牺牲生命而成全仁德。 34．三军可夺帅也，匹夫不可夺志也。 三军可以丧失主帅，一个人的志气与主张却是不能被强迫改变的。 35．士不可以不弘毅，任重而道远。 有志者不可以不心胸开阔，意志坚强，因为担子沉重而且道路遥远。 36．名不正，则言不顺，言不顺，则事不成。 名分不正，所说的话就不合道理。说话不合理，事情就办不成。 37．自古皆有死，民无信不立。 子贡问怎么治理国家。孔子说：“粮食充足，军备充足，人民信任当政者。”子贡说：“如果不得不去掉一项，那么这三项应先去掉哪一项？”孔子说：“去掉军备。”子贡说：“如果不得不再去掉一项，那么这两项应去掉哪一项？”孔子说：“去掉粮食。自古以来人终究是要死的，老百姓如果不信任当政者，那么国家就不能成立了。” 38．其身正，不令而行；其身不正，虽令不从。 自身品行端正，即使不下达命令，百姓也会自觉去做；自身品行不端正，即使下达了命令，百姓也不会服从。 39．不在其位，不谋其政。 不在那个职位上，就不去考虑那个职位上的事。不是事不关己的冷漠，而是行事恪守本分。 40．听其言而观其行。 指听了他的话，还要看他的行动。 指不要只听言论，还要看实际行动。 41．四海之内，皆兄弟也。 司马牛见到师兄子夏后忧愁地说他人皆有兄弟相亲，而唯独我没有兄弟相亲。子夏安慰他说君子和人交往态度恭谨而合乎礼节，那么普天之下到处都是兄弟。 42．与朋友交，言而有信。 与朋友们交往，应该诚实守信，说到做到。 43．礼之用，和为贵。 礼的作用，在于使人的关系变得更加和谐。 44．益者三友，损者三友。友直，友谅，友多闻，益矣；友便辟，友善柔，友便佞，损矣。 有益的朋友有三种，有害的朋友也有三种。与正直的人交朋友，与守信的人交朋友，与见多识广的人交朋友，是有益的。与谄媚逢迎的人交朋友，与两面三刀的人交朋友，与花言巧语的人交朋友，是有害的。 45．道不同，不相为谋。 立场不同、观点不同，也就不要相互商议谋划了。 46．父母在，不远游，游必有方。 父母年迈在世，尽量不长期在外地。不得已，必须告诉父母去哪里，为什么去，什么时候回来，并安排好父母的赡养。 47．是可忍也，孰不可忍也。 孔子谈到季氏说：“他用天子的舞蹈阵容在自己的庭院中舞蹈，如果这样僭礼的事情都可以容忍的话，还有什么事情是不可以容忍的呢？” 48．毋意，毋必，毋因，毋我。 不凭空猜测，不死板，不固执，不自以为是。 49．士志于道，而耻恶衣恶食者，未足与议也。 有志之士，既然存心在道，就不应该贪求享受，如果还以粗糙的衣服和简陋的饮食为耻辱，那就不值得和他说什么了。 50．往者不可谏，来者犹可追。 过去的不可挽回，未来的还可以赶上。 ","link":"https://kangjn.github.io/post/lesslesslun-yu-greatergreater-50-jing-dian-ming-ju/"},{"title":"RabbitMQ使用教程(五)","content":"4.7.主题模式（通配符模式） 4.7.1.图示 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 4.7.2.生产者 package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.zpc.rabbitmq.util.ConnectionUtil; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); // 消息内容 String message = &quot;Hello World!!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 4.7.3.消费者1（前台系统） package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.7.4.消费者2（搜索系统） package com.zpc.rabbitmq.topic; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 5.Springboot集成RabbitMQ springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。 5.1.简单队列 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持 org.springframework.boot spring-boot-starter-amqp 2、配置application.properties文件 配置rabbitmq的安装地址、端口以及账户信息 spring.application.name=spirng-boot-rabbitmq spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin 3、配置队列 package com.zpc.rabbitmq; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitConfig { @Bean public Queue queue() { return new Queue(&quot;q_hello&quot;); } } 4、发送者 package com.zpc.rabbitmq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.text.SimpleDateFormat; import java.util.Date; @Component public class HelloSender { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } } 5、接收者 package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver : &quot; + hello); } } 6、测试 package com.zpc.rabbitmq; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMqHelloTest { @Autowired private HelloSender helloSender; @Test public void hello() throws Exception { helloSender.send(); } } 5.2.多对多使用（Work模式） 注册两个Receiver: package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } @Test public void oneToMany() throws Exception { for (int i=0;i&lt;100;i++){ helloSender.send(i); Thread.sleep(300); } } public void send(int i) { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + i + &quot; &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } 5.3.Topic Exchange（主题模式） topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 首先对topic规则配置，这里使用两个队列(消费者)来演示。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig { final static String message = &quot;q_topic_message&quot;; final static String messages = &quot;q_topic_messages&quot;; @Bean public Queue queueMessage() { return new Queue(TopicRabbitConfig.message); } @Bean public Queue queueMessages() { return new Queue(TopicRabbitConfig.messages); } /** * 声明一个Topic类型的交换机 * @return */ @Bean TopicExchange exchange() { return new TopicExchange(&quot;mybootexchange&quot;); } /** * 绑定Q到交换机,并且指定routingKey * @param queueMessage * @param exchange * @return */ @Bean Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;); } @Bean Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;); } } 2)创建2个消费者 q_topic_message 和q_topic_messages package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_message&quot;) public class Receiver1 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver1 : &quot; + hello); } } package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_messages&quot;) public class Receiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } 3)消息发送者（生产者） package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSender { @Autowired private AmqpTemplate rabbitTemplate; public void send1() { String context = &quot;hi, i am message 1&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context); } public void send2() { String context = &quot;hi, i am messages 2&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context); } } send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。 4)测试 package com.zpc.rabbitmq.topic; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitTopicTest { @Autowired private MsgSender msgSender; @Test public void send1() throws Exception { msgSender.send1(); } @Test public void send2() throws Exception { msgSender.send2(); } } 5.4.Fanout Exchange（订阅模式） Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanoutRabbitConfig { @Bean public Queue aMessage() { return new Queue(&quot;q_fanout_A&quot;); } @Bean public Queue bMessage() { return new Queue(&quot;q_fanout_B&quot;); } @Bean public Queue cMessage() { return new Queue(&quot;q_fanout_C&quot;); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(&quot;mybootfanoutExchange&quot;); } @Bean Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(aMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(bMessage).to(fanoutExchange); } @Bean Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(cMessage).to(fanoutExchange); } } 2）创建3个消费者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_A&quot;) public class ReceiverA { @RabbitHandler public void process(String hello) { System.out.println(&quot;AReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_B&quot;) public class ReceiverB { @RabbitHandler public void process(String hello) { System.out.println(&quot;BReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_C&quot;) public class ReceiverC { @RabbitHandler public void process(String hello) { System.out.println(&quot;CReceiver : &quot; + hello + &quot;/n&quot;); } } 3）生产者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSenderFanout { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String context = &quot;hi, fanout msg &quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context); } } 4）测试 package com.zpc.rabbitmq.fanout; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitFanoutTest { @Autowired private MsgSenderFanout msgSender; @Test public void send1() throws Exception { msgSender.send(); } } 结果如下，三个消费者都收到消息： AReceiver : hi, fanout msg CReceiver : hi, fanout msg BReceiver : hi, fanout msg 6.总结 使用MQ实现商品数据的同步优势： 1、降低系统间耦合度 2、便于管理数据的同步（数据一致性） 推荐阅读 《RabbitMQ详解》 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/"},{"title":"RabbitMQ使用教程(四)","content":"4.4.消息的确认模式 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？ 模式1：自动确认 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。 模式2：手动确认 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。 手动模式： 自动模式： 4.5.订阅模式 4.5.1.图示 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费 4.5.2.消息的生产者（看作是后台系统） 向交换机中发送消息。 package com.zpc.rabbitmq.subscribe; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。 4.5.3.消费者1（看作是前台系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.4.消费者2（看作是搜索系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.5.测试 测试结果： 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 在管理工具中查看队列和交换机的绑定关系： 4.6.路由模式 4.6.1.图示 4.6.2.生产者 4.6.3.消费者1(假设是前台系统) 4.6.4.消费2（假设是搜索系统） ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/"},{"title":"RabbitMQ使用教程(三)","content":"4、学习五种队列 4.1 简单队列 4.1.1.图示 P：消息的生产者 C：消息的消费者 红色：队列 生产者将消息发送到队列，消费者从队列中获取消息。 4.1.2.导入RabbitMQ的客户端依赖 com.rabbitmq amqp-client 3.4.1 4.1.3.获取MQ的连接 package com.zpc.rabbitmq.util; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; public class ConnectionUtil { public static Connection getConnection() throws Exception { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost(&quot;localhost&quot;); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost(&quot;testhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 4.1.4.生产者发送消息到队列 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明（创建）队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); //关闭通道和连接 channel.close(); connection.close(); } } 4.1.5.管理工具中查看消息 点击上面的队列名称，查询具体的队列中的信息： 4.1.6.消费者从队列中获取消息 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); } } } 4.2.Work模式 4.2.1.图示 一个生产者、2个消费者。 一个消息只能被一个消费者获取。 4.2.2.消费者1 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;); //休眠 Thread.sleep(10); // 返回确认状态，注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)； } } } 4.2.3.消费者2 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); // 休眠1秒 Thread.sleep(1000); //下面这行注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.2.4.生产者 向队列中发送100条消息。 package com.zpc.rabbitmq.work; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 100; i++) { // 消息内容 String message = &quot;&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); Thread.sleep(i * 10); } channel.close(); connection.close(); } } 4.2.5.测试 测试结果： 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。 RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。 basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。 2个概念 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 4.3.Work模式的“能者多劳” 打开上述代码的注释： // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); //开启这行 表示使用手动确认模式 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 同时改为手动确认： // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, false, consumer); 测试： 消费者1比消费者2获取的消息更多。 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/"},{"title":"RabbitMQ使用教程(二)","content":"2.4.学习5种队列 2.5.安装文档 3.搭建RabbitMQ环境 3.1.下载 下载地址：http://www.rabbitmq.com/download.html 3.2.windows下安装 3.2.1.安装Erlang 下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装 3.2.2.安装RabbitMQ 3.2.3.启用管理工具 1、双击 2、进入C:\\Program Files (x86)\\RabbitMQ Server\\rabbitmq_server-3.4.1\\sbin输入命令： rabbitmq-plugins enable rabbitmq_management 这样就启动了管理工具，可以试一下命令： 停止：net stop RabbitMQ 启动：net start RabbitMQ 3、在浏览器中输入地址查看：http://127.0.0.1:15672/ 4、使用默认账号登录：guest/ guest 3.3.Linux下安装 3.3.1.安装Erlang 3.3.2.添加yum支持 cd /usr/local/src/ mkdir rabbitmq cd rabbitmq wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc 使用yum安装： sudo yum install erlang 3.3.3.安装RabbitMQ 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/ 安装： rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 3.3.4.启动、停止 service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 3.3.5.设置开机启动 chkconfig rabbitmq-server on 3.3.6.设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 3.3.7.开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 注意要去掉后面的逗号。 3.3.8.开启web界面管理工具 rabbitmq-plugins enable rabbitmq_management service rabbitmq-server restart 3.3.9.防火墙开放15672端口 /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT /etc/rc.d/init.d/iptables save 3.4.安装的注意事项 1、推荐使用默认的安装路径 2、系统用户名必须是英文 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/"},{"title":"RabbitMQ使用教程(一)","content":"1.什么是MQ 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。 其主要用途：不同进程Process/线程Thread之间通信。 为什么会产生消息队列？有几个原因： 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列； 关于消息队列的详细介绍请参阅： 《Java帝国之消息队列》 《一个故事告诉你什么是消息队列》 《到底什么时候该使用MQ》 MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。 2.RabbitMQ 2.1.RabbitMQ的简介 开发语言：Erlang – 面向并发的编程语言。 2.1.1.AMQP AMQP是消息队列的一个协议。 2.2.官网 2.3.MQ的其他产品 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/"},{"title":"前端面试题目（二）","content":"解决HTML5新标签的兼容性： &lt;![if lt IE 9]&gt; //解决IE6-8支持HTML5新元素 //解决IE6-8对css Media Query//媒体查询 &lt;![endif]&gt; a:hover，a:active失效的问题？(lvha) 现象： a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。 解决方式： a:link {color:black} a:visited{color:pink} a:hover {color: blue} a:active {color: green} 将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。 如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。 选择器优先级？ 内联样式&gt;内部样式&gt;外部样式 ！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式 注意： 1、!important声明的样式优先级最高，如果冲突再进行计算。 2、如果优先级相同，则选择最后出现的样式。 3、继承得到的样式的优先级最低。 文本怎么自动换行？ word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。 word-wrap:normal word-wrap:break-word box-sizing模型？ content-box:默认 padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding border-box: padding和border包含在元素的宽度内，元素的实际宽度为：width js中创建自定义对象 ? var f=function(){} new Object() function f() this? 指向调用它的对象，如果没有，就指window HTML5表单新元素？ date time color number range email url search 5种常见的HTTP状态码及意义？ 200:请求成功 301、302：永久重定向/暂时重定向 400：请求格式错误 404：找不到资源 500：服务器内部错误 怎么让一个图片在一个DIV中垂直居中对齐？ 父元素使用相对定位 子元素使用绝对定位 怎么让文字垂直居中对齐？ 一行文字父元素不固定：padding:20px 父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell 如何让图片跟文字在居中显示： 父元素设置为vertical-align:middle 浏览器兼容？ 1、不同的浏览器默认样式不一样：padding margin 2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden 3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距 页面优化/站点优化？ 1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度 2、代码压缩/css/js yui compressor 数组的方法： join concat push pop unshift shift slice splice 正则表达式： \\d数字 \\s空白字符 \\w数字、字母、下划线 ？ 0-1 或 改为懒惰模式 0-n 1-n ^ 开关 $ 结尾 \\b 边界 new 一个对象具体干了什么？ 第一步是建立一个新对象； 第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象； 第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。 如何判断一个对象是否为数组？ typeof &quot;sflkj&quot; typeof无法判断数组跟对象 [] instanceof Array Array.prototype.isPrototypeOf([]) Array.isArray([]) 获取一个选项卡的值？ aa bb function showinfo(){ var sel=document.getElementById(\"s1\"); var i=sel.selectedIndex; var result=sel.options[i].value; } 浏览器对象有哪些？ navigator history window location screen event document window对象的常用方法？ alert confirm prompt close js绑定事件： btnObj.addEventListener(&quot;click&quot;,function(){}) jquery 把变量$的控制权交给其他JS库 jQuery.noConflict(); jQuery(function($){}) jQuery 遍历？（$.each()方法） asdf luili 234 var m=$(\"ul li\"); m.each(function(i){ if(i==0){ $(this).css(\"font-size\",\"18px\") } }) 怎么把一个JSON字符串转换成一个js对象？ var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} 把一个js对象转换成一个josn字符吕？ var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' 表单序列化成字符串：serialize（） 序列化成json对象：serializeArray() 手机端头部怎么写？ 不通过插件实现自响应布局？ CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局 CSS的媒体查询？ @media screen and(min-width:990px){//(一个css文件内) #id{ float:left } } @media screen and(min-width:700px) and (max-width:989px){ #id{ float:left } @media screen and(max-width:699px){ } angularjs？ 采用MVC模式 数据绑定 依赖注入 模块化设计 初始化一个模型数据 ng-bind=&quot;name&quot; ng-repeat=&quot;data in array&quot; angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){ .controller(&quot;myCtrl&quot;,function($scope){ $scope.newsTitle=&quot;hello&quot; }) } 什么是高内聚，低耦合？ 高内聚：一个模块内的元素的关系赵紧密越好 低耦合：不同模块间的关系尽量不要有关联 ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/"},{"title":"前端面试题目（一）","content":"什么是闭包？ 指有权访问另一个函数作用域中变量的函数 null 和undefined的区别？ 共同点：都是原始类型，保存在栈中变量本地 不同点： undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用 null:表示一个变量不再指向任何对象地址 表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用 常见行内元素和块级元素有哪些，他们有什么区别？ 行内元素：span img a u s i input select 块级元素：div ul ol li dt dd h1-h6 块级元素会单独占一行，行内元素会在一行显示。 什么是ajax？ ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。 实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新： 如何创建XMLHttpRequest请求步骤： 1、获取ajax对象 var xhr=new XMLHttpRequest(); 2、创建请求:调用XMLHttpRequest对象的open方法 xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步]) 3、回调函数的处理 xhr.onreadystatechange=function(){ if(xhr.readyState4){ if(xhr.status200){ var txt=xhr.responseText/responseXML } } } 4、发送请求 xhr.send(&quot;name=value$pwd=value&quot;); readyState属性： 0=未初始化 1=正在加载 2=以加载 3=交互中 4=加载完成 Ajax异步请求？ .ajax( { url:&quot;destination.php&quot;, type:&quot;post&quot;, data:(&quot;#id&quot;).val(), dataType:&quot;json&quot;, success:function(data){ console.log(data) } error:function(){ window.alert(&quot;error&quot;) } } ) AJAX的优缺点？ 优点： 页面局部刷新，提高用户体验 减轻服务器负担 具有更迅速的响应能力 能被广泛支持 缺点： 不支持浏览器后退按钮 安全问题 对搜索引擎支持比较弱 html中有哪些定位？ static:默认规则定位。 absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间 relative:相对定位，相对于初始位置定位/占页面空间 fixed:固定定位，相对于浏览器窗口 http 建立TCP连接 发送请求命令 发送请求头部 服务器应答 服务器发送应答头部 服务器发送应答具体信息 关闭连接 如何居中DIV？ 给DIV设置一个宽度，再设置margin为:0 auto; 如何居中一个浮动元素？ 使用一个居中显示的DIV包含些浮动元素。 position:fixed;//固定定位 width: 200px; height: 200px; background: red; margin-left:-100px; margin-top: -100px; left: 50%; top: 50%; 纯CSS实现一个三角形？ width: 0; height: 0; border:25px solid transparent; border-top-color: red; 重写trim()方法 if(String.prototype.trim===undefined){ String.prototype.trim=function () { return this.replace(/^\\s+|\\s+$/g) } } var str=&quot; helloworld &quot;; document.write(&quot;|&quot;+str+&quot;| &quot;); str=str.trim(); document.write(&quot;|&quot;+str+&quot;|&quot;); function trim(str){//同时去掉开头和结尾的空字符 var reg=/^\\s+|\\s+$/g; return str.replace(reg,&quot;&quot;); } var str=&quot; zhang dong &quot;; console.log(ltrim(str));//&quot;zhang dong &quot; console.log(rtrim(str));//&quot; zhang dong&quot; console.log(trim(str));//&quot;zhang dong&quot; 水仙花数 var a,b,c for(var i=100;i&lt;1000;i++){ a=parseInt(i%10); b=parseInt((i/10)%10); c=parseInt(i/100); if(iaaa+bbb+ccc){ console.log(i); } } 判断某一年是不是闰年 function isLeap(year){ console.log(year%40&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;); } isLeap(prompt(&quot;主输入年份&quot;)); 在单词后面加上数字 var str=&quot;one two three four&quot;; var i=4; var reg=/\\b[a-z]+\\b/g; str=str.replace(reg,function(kw){ return kw+i++; }) console.log(str); 判断是不是数组 var str=[] Array.prototype.isPrototypeOf(str);//true Object.prototype.toString.call(str);//[Object Array]; str instanceof Array; Array.isArray([]) 什么是继承？ 父对象已有的成员，子对象不用重复定义，就可以直接使用 什么是原型？ 每个函数都有一个prototype属性，该属性引用的就是原型对象， 原型对象就是保存共有属性和方法的对象 window窗口的全局对象？ history navigator screen location event 动态加载Dom? var frg=document.createDocumentFragment(); var m=document.createElement(&quot;div&quot;); m.innerHTML=&quot;this is first page&quot;; frg.appendChild(m); document.body.appendChild(frg); 数组去重？ var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] function unique(arr){ for(var i=0,arr2={};i&lt;arr.length;i++){ arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1); } var arr=[]; for(var key in arr2){ arr.push(key) } return arr; } console.log(unique(arr)); var arr1=[2,5,9,1,7] function sort(arr){ for(var i=0;iarr[j+1]]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } sort(arr1); console.log(arr1) 数组降维 var arr=[[1,2,3],[1,3,2]]; var res=Array.prototype.concat.apply([],arr) console.log(res); 如何理解HTML语义化？ 可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性 常用的语义化标签： 哪些属性可以继承？ font-size font-family color display:none和visibility:hidden的区别？ display不占据页面空间 visibility仍然占据空间 css3伪类选择器 :enabled :disabled :checked :firtt-child :last-child 为什么建议在设置背景图像的同时还设置背景颜色？ 如果因为各种原因图片无法加载的时候，页面会显示背景颜色。 CSS sprite的优缺点？ 把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位 优点： 减少网页的http请求，提高性能 减少图片的大小 维护更方便，只需要在一张图片上修改就可以。 缺点： 图片合成比较麻烦 背景设置时需要得到每一个图片的精确位置 CSS3新特性 box-shadow border-radius text-shadow ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/"}]}