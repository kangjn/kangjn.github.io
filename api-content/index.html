{"posts":[{"title":"算法小记","content":"数组去重 第一种 new Set let ary = [1,2,3,4,2,1,3,4,5,6,4,3,5,6,3] let arr = Array.from(new Set(ary)) 第二种 第二种 拿出当前项和后面内容比较 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary.splice(i,1); // 这个性能不如 新建一个数组好 i--; // 会因为splice造成数组塌陷 } } 第三种 判断是否包含，包含的话 那最后一项把当前项覆盖 for(let i = 0;i &lt; ary.length - 1; i++){ let item = ary[i] let arg = ary.slice(i + 1); if(arg.indexOf(item) &gt; -1){ ary[i] = ary[ary.length - 1]; ary.length--; i-- } } 第四种 循环遍历是否包含，不包含push let arr = [] for(let i = 0;i &lt; ary.length; i++){ if(arr.indexOf(item) === -1){ arr.push(ary[i]) } } 等等还有很多，比如对象键值对，比如包含置为null 在过滤 数组扁平化 第一种 flat let arr = [ [1,2,3], [3,4,5,6], [6,7,8,9,0,[1],[2,3]],10 ] flat()写 几 就扁平化 几级 Infinity 无限 arr.flat(Infinity) 第二种 reduce function ab(arr){ return arr.reduce((pre,cur) =&gt; { return pre.concat(Array.isArray(cur) ? ab(cur) : cur) },[]) } 第三种 toString arr.toString().split(',').map(itm =&gt; parserFloat(itm)) 第四种 while + reduce + concat while(arr.some(itm =&gt; Array.isArray(itm))){ arr = [].concat(...arr) } 第五种 正则 JSON.stringify(arr).replace(/(\\[|\\])/g,'').split(',').map(itm =&gt;parseFloat(itm)) 斐波那契数列 let arr = [1,1,2,3,5,8,13,21] 当前项 = 当前项的 前面两位相加 可以 实现 传入 number 就能计算出对应斐波那契下标的值 第一种： while循环 function fibonacci(n){ if(n&lt;=1) return 1; let arr = [1,1]; let i = n + 1 -2; // why?因为传入的n是数组下标，所以要+1 减2的话就是因为一开始就有两个所以只需要创建剩下的位数 while(i &gt; 0){ let a = arr[arr.length - 2]; let b = arr[arr.length - 1]; arr.push(a+b); i-- } return arr[arr.length - 1]; } 第二种 递归 count：传进来的number cur：放的最终值 next：每次递归的时候作为下一次 cur 的值，需要每次 cur + next ](https://www.pipipi.net/wp-content/uploads/front-end-baike/01fcb9a1a61742a29a3c276a25a83e5d~tplv-k3u1fbpfcp-watermark.png) || || 搭配食用 || fibonacci(count){ function fn(count,cur = 1,next = 1){ if(count == 0){ return cur }else { return fn(count - 1,next,cur+next) } } return fn(count) } 冒泡排序 相邻两元素之间两两比较，比较出大值进行赋值互换，再依次与相邻的元素比较 必须要明白总共比较几回，一回比较几次！！！ let arr = [1,2,3,5,8,0,10] // 外层控制比较几回 for(let i = 0; i &lt; arr.length - 1; i++){ // 内层控制一回比较几次，并且比较大小 for(let j = 0; j &lt; arr.length -1 -i; j++){ if(arr[j] &gt; arr[j + 1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } 快速排序 分三步 取出数组的中间值 遍历数组，大于的放在右数组，小于的放在左边数组 递归并且用 concat 连接 let arr = [1,5,2,7,9,10,90,29,25,11,45,34]; function fast(arr){ if(arr.length &lt; 1) return arr; let num = Math.floor(arr.length / 2) let idx = arr.splice(num,1)[0]; let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; idx){ left.push(arr[i]) }else { right.push(arr[i]) } } return fast(left).concat(idx,fast(right)) } 插入排序 拿出一个值，作为初始数组的值， 通过循环想要排序的数组 并和新数组的值从后向前比 大于就splice到该项后面 function insert(arr){ let handle = []; // 这是最终成型的数组 handle.push(arr[0]); // 先拿一个值 for(let i = 1; i&lt; arr.length; i++){ let news = arr[i]; for(let j = handle.length - 1; j &gt;= 0; j--){ //从后向前比较 if(news &gt; handle[j]){ handle.splice(j+1,0,news); break; } if(j === 0){ // 比到为0的话直接放到数组头部 handle.unshift(news); } } } return handle } 单链表反转 看到这的话，要明白它反转后是什么样 { a:4, next:{ a:3, next:{ a:2, next:{ a:1, next: null } } } } 看到这，肯定是有个大概的思路，就是节点替换 ](https://www.pipipi.net/wp-content/uploads/front-end-baike/e9030c138fbf4e0e8ba87222f3b66dff~tplv-k3u1fbpfcp-watermark.png) let obj = { a:1, next:{ a:2, next: { a:3, next:{ a:4, next:null } } } } function reverseObj(obj){ let pre = null; // pre 最终的值(包含每一步) let cur = obj while(cur.next !== null){ let context = cur.next; // 首先拿到下一个next的值保存 cur.next = pre === null ? null : pre; // pre是上一项保存的值 pre = cur; // 将 当前项的值赋值给最终的值 cur = context // 拿到下一项next继续重复以商操作 } } ","link":"https://kangjn.github.io/post/suan-fa-xiao-ji/"},{"title":"学习笔记：promise","content":" then接收两个参数, onFulfilled 和 onRejected 检查并处理参数, 如果参数不是function就忽略(原样返回value或者reason) class MyPromise { constructor(fn) { // 初始状态为pending this.status = PENDING;//状态 this.value = null;//成功的值 this.reason = null;//失败的值 try { fn(this.resolve.bind(this), this.reject.bind(this)); } catch (e) { this.reject(e); } } resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 3. 根据当前promise的状态, 调用不同的函数 class MyPromise { ..... //这时候then函数被调用会瞬间就会执行switch判断，那这时候如果status可能还没变成fulfilled或者rejected，很有可能还是pending then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 4、首先要拿到所有的回调, 然后在某个时机去执行他. 需要新建两个数组, 分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组. class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 5、在status状态发生变化的时候调用数组里所有的函数 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... resolve(value) { if (this.status === PENDING) { //这层判断是因为fulfilled状态只可以由pending状态改变而来 this.status = FULFILLED; this.value = value; //执行存储的函数 this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.value); }); } } reject(reason) { if (this.status === PENDING) { //同理这层判断是因为rejected状态只可以由pending状态改变而来 this.status = REJECTED; this.reason = reason; //执行存储的函数 this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; { callback(this.reason); }); } } then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; switch (this.status) { case FULFILLED: { fulFilledFn(this.value); break; } case REJECTED: { rejectedFn(this.reason); break; } case PENDING: { this.FULFILLED_CALLBACK_LIST.push(fulFilledFn); this.REJECTED_CALLBACK_LIST.push(rejectedFn); break; } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 7、then的返回值 情况1：如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则新promise必须reject e class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况2：如果onFulfilled不是函数且promise成功执行，那么新的promise必须返回同样的状态和val 情况3：如果onRejected不是函数且promise拒绝执行，那么新的promise必须返回同样的状态和reason class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... then(onFulfilled, onRejected) { const fulFilledFn = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; value const rejectedFn = this.isFunction(onRejected) ? onRejected : (reason) =&gt; { throw reason }; const fulFilledFnWithCatch = (resolve, reject) =&gt; { try { fulFilledFn(this.value); resolve(this.value); } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject) =&gt; { try { rejectedFn(this.reason); if (this.isFunction(onRejected)) { resolve(); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { return new MyPromise(fulFilledFnWithCatch); } case REJECTED: { return new MyPromise(rejectedFnWithCatch); } case PENDING: { return new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject)); }); } } } //检验是否为function isFunction(param) { return typeof param === 'function'; } } 情况4:如果onFulfilled或者onRejected 返回一个值 x ，则运行resolvePromise方法 class MyPromise { FULFILLED_CALLBACK_LIST = [] //存储成功回调 REJECTED_CALLBACK_LIST = [] //存储失败回调 ..... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } } switch (this.status) { case FULFILLED: { const newPromise = new MyPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MyPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MyPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } //检验是否为function isFunction(param) { return typeof param === 'function'; } resolvePromise(newPromise, x, resolve, reject){} } 8、resolvePromise resolvePromise(newPromise, x, resolve, reject) { // 防止死循环 if (newPromise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MPromise) { x.then((y) =&gt; { resolvePromise(newPromise, y, resolve, reject); }, reject); } else if (typeof x === 'object' || this.isFunction(x)) { if (x === null) { return resolve(x); } let then = null; try { then = x.then; } catch (error) { return reject(error); } // 如果 then 是函数 if (this.isFunction(then)) { let called = false; try { then.call( x, (y) =&gt; { if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, (r) =&gt; { if (called) return; called = true; reject(r); }); } catch (error) { if (called) return; reject(error); } } else { resolve(x); } } else { resolve(x); } } 9、onFulfilled 和 onRejected 是微任务 then(onFulfilled, onRejected) { ... const fulFilledFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onFulfilled)) { resolve(this.value); } else { const x = fulFilledFn(this.value); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e) } }) }; const rejectedFnWithCatch = (resolve, reject, newPromise) =&gt; { queueMicrotask(() =&gt; { try { if (!this.isFunction(onRejected)) { reject(this.reason); } else { const x = rejectedFn(this.reason); this.resolvePromise(newPromise, x, resolve, reject); } } catch (e) { reject(e); } }) } switch (this.status) { case FULFILLED: { const newPromise = new MPromise((resolve, reject) =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); return newPromise; } case REJECTED: { const newPromise = new MPromise((resolve, reject) =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); return newPromise; } case PENDING: { const newPromise = new MPromise((resolve, reject) =&gt; { this.FULFILLED_CALLBACK_LIST.push(() =&gt; fulFilledFnWithCatch(resolve, reject, newPromise)); this.REJECTED_CALLBACK_LIST.push(() =&gt; rejectedFnWithCatch(resolve, reject, newPromise)); }); return newPromise; } } } 10. catch方法 catch (onRejected) { return this.then(null, onRejected); } 11. promise.resolve(静态方法) 将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。 static resolve(param) { if (param instanceof MyPromise) { return param; } return new MyPromise(function (resolve) { resolve(param); }); } 12. promise.reject(静态方法) 返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 static reject(reason) { return new MPromise((resolve, reject) =&gt; { reject(reason); }); } ","link":"https://kangjn.github.io/post/xue-xi-bi-ji-promise/"},{"title":"前端学习-Vue","content":"核心特性 数据驱动视图 数据变化会自动更新到对应元素中，无需手动操作 DOM，这种行为称作单向数据绑定。 对于输入框等可输入元素，可设置双向数据绑定。 双向数据绑定是在数据绑定基础上，可自动将元素输入内容更新给数据， 实现数据与元素内容的双向绑定。 Vue.js 的数据驱动视图是基于 MVVM 模型实现的。 MVVM (Model – View – ViewModel )是一种软件开发思想 Model 层，代表数据 View 层， 代表视图模板 ViewModel 层，代表业务逻辑处理代码 基于MVVM 模型实现的数据驱动视图解放了DOM操作 View 与 Model 处理分离，降低代码耦合度 但双向绑定时的 Bug 调试难度增大 大型项目的 View 与 Model 过多，维护成本高 组件化开发 组件化开发，允许我们将网页功能封装为自定义 HTML 标签，复用时书写自定义标签名即可。 组件不仅可以封装结构，还可以封装样式与逻辑代码，大大提交 了开发效率与可维护性。 基础语法 Vue 实例 通过 Vue 函数创建的对象，是使用 Vue 功能的基础。 new Vue({ //选项对象 }); el 选项 用于选取一个 DOM 元素作为 Vue 实例的挂载目标。 只有挂载元素内部才会被 Vue 进行处理，外部为普通 HTML 元素。 代表 MVVM 中的 View 层(视图)。 可以为 CSS 选择器格式的字符串 或 HTMLElement 实例，但不能为 html 或 body。 var vm = new Vue({ el: '#app' }); var app = document.querySelector('#app'); var vm = new Vue({ el: app }); 挂载完毕后，可以通过 vm.$el 进行访问。 var vm = new Vue({ el: '#app' }); console.log(vm.$el); 未设置 el 的 vue 实例，也可以通过 vm.$mount() 进行挂载，参数形式与 el 规则相同。 var app = document.getElementById('app'); var vm = new Vue({}); vm.$mount(app); 插值表达式 挂载元素可以使用 Vue.js 的模板语法，模板中可以通过插值表达式为元素进行动态内容设置，写法为 {{ }}。 &lt;li&gt;第一段示例内容：{{ 10 + 20 + 30 }}&lt;/li&gt; &lt;li&gt;第二段示例内容：{{ 22 &gt; 3 ? '22比3大' : '3比22大' }}&lt;/li&gt; &lt;!-- 错误写法 --&gt; &lt;!-- &lt;li id=&quot;{{ 1 + 2 }}&quot;&gt;&lt;/li&gt; --&gt; &lt;!-- &lt;li&gt;{{ var num = 100; }}&lt;/li&gt; --&gt; 注意点: 插值表达式只能书写在标签内容区域，可以与其它内容混合。 内部只能书写 JavaScript 表达式，不能书写语句。 data 选项 用于存储 Vue 实例需要使用的数据，值为对象类型。 data 中的数据可以通过 vm.$data.数据 或 vm.数据 访问。 var vm = new Vue({ el: '#app', data: { title: '标题文本' } }); console.log(vm.$data.title); console.log(vm.title); data 中的数据可以直接在视图中通过插值表达式访问。 data 中的数据为响应式数据，在发生改变时，视图会自动更新。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ title }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '标题文本', } }); vm.title = '新的标题内容'; &lt;/script&gt; data 中存在数组时，索引操作与 length 操作无法自动更新视图， 这时可以借助 Vue.set() 方法替代操作。 var vm = new Vue({ el: '#app', data: { arr: ['内容1', '内容2', '内容3'] } }); Vue.set(vm.arr, 0, '新内容'); methods 选项 用于存储需要在 Vue 实例中使用的函数。 methods 中的方法可以通过 vm.方法名 访问。 方法中的 this 为 vm 实例，可以便捷的访问 vm 数据等功能。 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ fn(title1) }}&lt;/p&gt; &lt;p&gt;{{ fn(title2) }}&lt;/p&gt; &lt;p&gt;{{ title1.split('-').join('') }}&lt;/p&gt; &lt;p&gt;{{ title2.split('-').join('') }}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { prefix: '处理的结果为：', title1: 'a-b-c-d-e', title2: 'x-y-z' }, methods: { fn (value) { // console.log(this); this.fn1(); this.fn2(); return this.prefix + value.split('-').join(''); }, fn1 () { console.log('执行了 fn1 的代码'); }, fn2 () { console.log('执行了 fn2 的代码'); } } }); // console.log(vm) &lt;/script&gt; ","link":"https://kangjn.github.io/post/qian-duan-xue-xi-vue/"},{"title":"springboot-文件上传/下载","content":"springboot-文件上传/下载 代码 application.yml spring: servlet: multipart: max-file-size: 50MB #上传文件最大大小 max-request-size: 50MB #单次请求最大大小 # 自定义文件上传路径 web: upload-path: C:/Users/Ericam/Desktop/JustCoding/src/main/resources/static/photos/ ps : 路径中不能包含中文，不然无法读取 FileUtils (文件上传工具类) package cn.justcoding.util; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.io.IOException; /** * 文件上传工具包 */ public class FileUtils { /** * * @param file 文件 * @param path 文件存放路径 * @param fileName 源文件名 * @return */ public static boolean upload(MultipartFile file, String path, String fileName){ //使用原文件名 String realPath = path + &quot;/&quot; +fileName; File dest = new File(realPath); //判断文件父目录是否存在 if(!dest.getParentFile().exists()){ dest.getParentFile().mkdir(); } try { //保存文件 file.transferTo(dest); return true; } catch (IllegalStateException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); return false; } } } TestController(进行测试) @Controller public class TestController { private final ResourceLoader resourceLoader; @Value(&quot;${web.upload-path}&quot;) private String path; @Autowired public TestController(ResourceLoader resourceLoader) { this.resourceLoader = resourceLoader; } /** * 跳转到文件上传页面 * @return */ @RequestMapping(&quot;test&quot;) public String toUpload(){ return &quot;freemarker/test&quot;; } /** * * @param file 要上传的文件 * @return */ @RequestMapping(&quot;fileUpload&quot;) public String upload(@RequestParam(&quot;fileName&quot;) MultipartFile file, Map&lt;String, Object&gt; map){ // 要上传的目标文件存放路径 // String localPath = &quot;/src/main/resources/static/photos&quot;; // 上传成功或者失败的提示 String msg = &quot;&quot;; if (FileUtils.upload(file, path, file.getOriginalFilename())){ // 上传成功，给出页面提示 msg = &quot;上传成功！&quot;; }else { msg = &quot;上传失败！&quot;; } // 显示图片 map.put(&quot;msg&quot;, msg); map.put(&quot;fileName&quot;, file.getOriginalFilename()); return &quot;forward:/test&quot;; } /** * 显示单张图片 * @return */ @RequestMapping(&quot;show&quot;) public ResponseEntity showPhotos(String fileName){ try { // 由于是读取本机的文件，file是一定要加上的， path是在application配置文件中的路径 // System.out.println(fileName); return ResponseEntity.ok(resourceLoader.getResource(&quot;file:&quot; + path + fileName)); } catch (Exception e) { return ResponseEntity.notFound().build(); } } @RequestMapping(&quot;batch&quot;) public String handleFileUpload(HttpServletRequest request, Map&lt;String, Object&gt; map) { List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;); MultipartFile file = null; BufferedOutputStream stream = null; String msg = &quot;&quot;; for (int i = 0; i &lt; files.size(); ++i) { file = files.get(i); if (!file.isEmpty()) { try { byte[] bytes = file.getBytes(); stream = new BufferedOutputStream(new FileOutputStream( new File(path + file.getOriginalFilename())));//设置文件路径及名字 stream.write(bytes);// 写入 stream.close(); } catch (Exception e) { stream = null; msg= &quot;第 &quot; + i + &quot; 个文件上传失败 ==&gt; &quot; + e.getMessage(); } } else { msg= &quot;第 &quot; + i + &quot; 个文件上传失败因为文件为空&quot;; } } msg= &quot;上传成功&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } @RequestMapping(&quot;/download&quot;) public String downloadFile(HttpServletRequest request, String fileName,HttpServletResponse response,Map&lt;String, Object&gt; map) { String msg = &quot;&quot;; if (fileName != null) { //设置文件路径 File file = new File(path+fileName); //File file = new File(realPath , fileName); if (file.exists()) { response.setContentType(&quot;application/force-download&quot;);// 设置强制下载不打开 response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);// 设置文件名 byte[] buffer = new byte[1024]; FileInputStream fis = null; BufferedInputStream bis = null; try { fis = new FileInputStream(file); bis = new BufferedInputStream(fis); OutputStream os = response.getOutputStream(); int i = bis.read(buffer); while (i != -1) { os.write(buffer, 0, i); i = bis.read(buffer); } msg = &quot;下载成功&quot;; } catch (Exception e) { e.printStackTrace(); } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } msg = &quot;下载失败&quot;; map.put(&quot;msg&quot;, msg); return &quot;forward:/test&quot;; } } test.ytl (简易freemarker测试模板) &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;图片上传Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 &gt;图片上传Demo&lt;/h1&gt; &lt;form action=&quot;fileUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;选择文件: &lt;input type=&quot;file&quot; name=&quot;fileName&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;#--判断是否上传文件--&gt; &lt;#if msg??&gt; &lt;span&gt;${msg}&lt;/span&gt;&lt;br&gt; &lt;#else &gt; &lt;span&gt;${msg!(&quot;文件未上传&quot;)}&lt;/span&gt;&lt;br&gt; &lt;/#if&gt; &lt;#--显示图片，一定要在img中的src发请求给controller，否则直接跳转是乱码--&gt; &lt;#if fileName??&gt; &lt;img src=&quot;/show?fileName=${fileName}&quot; style=&quot;width: 200px&quot;/&gt; &lt;#else&gt; &lt;img src=&quot;/show&quot; style=&quot;width: 100px&quot;/&gt; &lt;/#if&gt; &lt;hr/&gt; &lt;p&gt;多文件上传&lt;/p&gt; &lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;batch&quot;&gt; &lt;p&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;hr/&gt; &lt;p&gt;文件下载&lt;/p&gt; &lt;a href=&quot;download?fileName=${fileName}&quot;&gt;下载文件&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://kangjn.github.io/post/springboot-wen-jian-shang-chuan-xia-zai/"},{"title":"springboot-7.快速上手redis","content":"springboot-7.快速上手redis 前言 为什么需要Redis? 在涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。 为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。 Redis在java web中的应用场景 存储 缓存用的数据； 需要高速读/写的场合使用它快速读/写； Redis作为缓存的读取逻辑 下载安装redis 下载地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads 选择最新版下载一个即可，下载完后解压便可使用。 为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件： redis-server redis.windows.conf 这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动： 下载安装redis可视化工具 RedisDesktopManager springboot配置使用redis （1）在pom文件中添加依赖项 &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; (2) 编写application.yml spring: # redis redis: host: 127.0.0.1 port: 6379 timeout: 3000 #连接超时 password: minIdle: 1 #连接池中的最小空闲连接 maxIdle: 10 maxWait: 3 #连接池中的最大阻塞等待时间 maxActive: 8 #连接池最大连接数 (3)新建文件夹和文件，如下所示： (4)Reidis配置文件-RedisConfig.java import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.cache.annotation.CachingConfigurerSupport; import org.springframework.cache.annotation.EnableCaching; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.*; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration @EnableCaching //开启注解 public class RedisConfig extends CachingConfigurerSupport { /** * retemplate相关配置 * @param factory * @return */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 配置连接工厂 template.setConnectionFactory(factory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式） Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常 om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 值采用json序列化 template.setValueSerializer(jacksonSeial); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); // 设置hash key 和value序列化模式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(jacksonSeial); template.afterPropertiesSet(); return template; } /** * 对hash类型的数据操作 * * @param redisTemplate * @return */ @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForHash(); } /** * 对redis字符串类型数据操作 * * @param redisTemplate * @return */ @Bean public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForValue(); } /** * 对链表类型的数据操作 * * @param redisTemplate * @return */ @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForList(); } /** * 对无序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForSet(); } /** * 对有序集合类型的数据操作 * * @param redisTemplate * @return */ @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) { return redisTemplate.opsForZSet(); } } (5)为了方便使用，我们对于Redis进行进一步封装--&gt;Redis工具类（RedisUtil.java） 为了测试方便，只放入了get和set方法。 @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } } (6)在controller文件中进行测试 @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Resource private RedisUtil redisUtil; @RequestMapping(&quot;/setRedis&quot;) public boolean redisSet() { return redisUtil.set(&quot;username&quot;,&quot;ericam&quot;); } @RequestMapping(&quot;/getRedis&quot;) public String redisGet() { return redisUtil.get(&quot;username&quot;).toString(); } } (7)预览 ps:记得开启redis（通过startup.cmd） 访问 http://localhost:8080/user/setRedis 返回true说明缓存存储成功，使用工具查看 获取缓存存取的值 访问 http://localhost:8080/user/getRedis 以上便是redis的基本使用 redisUtil.java工具类 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * redisTemplate封装 * * @author yinxp@dist.com.cn */ @Component public class RedisUtil { @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) { this.redisTemplate = redisTemplate; } /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key,long time){ try { if(time&gt;0){ redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key){ return redisTemplate.getExpire(key,TimeUnit.SECONDS); } /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key){ try { return redisTemplate.hasKey(key); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String ... key){ if(key!=null&amp;&amp;key.length&gt;0){ if(key.length==1){ redisTemplate.delete(key[0]); }else{ redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key){ return key==null?null:redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key,Object value,long time){ try { if(time&gt;0){ redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); }else{ set(key, value); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递增因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, delta); } /** * 递减 * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta){ if(delta&lt;0){ throw new RuntimeException(&quot;递减因子必须大于0&quot;); } return redisTemplate.opsForValue().increment(key, -delta); } //================================Map================================= /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key,String item){ return redisTemplate.opsForHash().get(key, item); } /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object,Object&gt; hmget(String key){ return redisTemplate.opsForHash().entries(key); } /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map){ try { redisTemplate.opsForHash().putAll(key, map); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map, long time){ try { redisTemplate.opsForHash().putAll(key, map); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value) { try { redisTemplate.opsForHash().put(key, item, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value,long time) { try { redisTemplate.opsForHash().put(key, item, value); if(time&gt;0){ expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item){ redisTemplate.opsForHash().delete(key,item); } /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item){ return redisTemplate.opsForHash().hasKey(key, item); } /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item, by); } /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item,double by){ return redisTemplate.opsForHash().increment(key, item,-by); } //============================set============================= /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key){ try { return redisTemplate.opsForSet().members(key); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key,Object value){ try { return redisTemplate.opsForSet().isMember(key, value); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object...values) { try { return redisTemplate.opsForSet().add(key, values); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key,long time,Object...values) { try { Long count = redisTemplate.opsForSet().add(key, values); if(time&gt;0) { expire(key, time); } return count; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key){ try { return redisTemplate.opsForSet().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object ...values) { try { Long count = redisTemplate.opsForSet().remove(key, values); return count; } catch (Exception e) { e.printStackTrace(); return 0; } } //===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end){ try { return redisTemplate.opsForList().range(key, start, end); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key){ try { return redisTemplate.opsForList().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key,long index){ try { return redisTemplate.opsForList().index(key, index); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) { try { redisTemplate.opsForList().rightPush(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) { try { redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) { try { redisTemplate.opsForList().rightPushAll(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) { try { redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index,Object value) { try { redisTemplate.opsForList().set(key, index, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key,long count,Object value) { try { Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 模糊查询获取key值 * @param pattern * @return */ public Set keys(String pattern){ return redisTemplate.keys(pattern); } /** * 使用Redis的消息队列 * @param channel * @param message 消息内容 */ public void convertAndSend(String channel, Object message){ redisTemplate.convertAndSend(channel,message); } } ","link":"https://kangjn.github.io/post/springboot-7kuai-su-shang-shou-redis/"},{"title":"springboot-6.整合Mybatis","content":"springboot-6.整合Mybatis 一 .解析Java框架中entity层，mapper层，service层各层作用 （1）entity层 别名： model层 ，domain层。 用途： 实体层，用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。一般数据库一张表对应一个实体类，类属性同表字段一一对应 简单例子：user表的实体User public class User { private int id;//id private String username;//用户名 //……省略set,get方法 } （2）mapper层 别名： dao层 用途： 对数据库进行数据持久化操作，针对数据库操作的，主要实现增删改查操作 简单例子： @Mapper public interface UserMapper { public User selectUserById(int id); } (3) service层 业务逻辑层，调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。 作用：为controller层的类提供接口进行调用。 简单例子： public interface UserService extends Service&lt;User&gt; { } 二.快速使用 （1）添加依赖项 &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10 &lt;/version&gt; &lt;/dependency&gt; （2）配置application.yml spring: #数据源配置 datasource: url: jdbc:mysql://localhost:3306/customer_db?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: ****** driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource connectionProperties: druid.stat.mergeSql=true #为mybatis配置，生产环境可删除 restart: include: mapper: /mapper-[\\\\w-\\\\.]+jar pagehelper: /pagehelper-[\\\\w-\\\\.]+jar pagehelper: auto-dialect: msyql reasonable: true support-methods-arguments: true params: count=countSql (3)编写User.java【entity层】 public class User { private String id; private String username; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } (4)编写UserMapper.java(dao层) @Mapper public interface UserMapper { @Select(&quot;select * from user where id = #{id}&quot;) public User selectUserById(int id); @Select(&quot;select * from user where username = #{username}&quot;) public List&lt;User&gt; selectUserByName(String userName); @Insert(&quot;insert into user(id,username) values (#{id},#{username})&quot;) public void addUser(User user); @Update(&quot;update user set username=#{username} where id=#{id}&quot;) public void updateUser(User user); @Delete(&quot;delete from user where id=#{id}&quot;) public void deleteUser(int id); } (5)编写userController.java @RestController @RequestMapping(&quot;/user&quot;) public class userController { @Autowired UserMapper userMapper; @RequestMapping(value={&quot;/selectUserById&quot;}, method=RequestMethod.GET) public User selectUserById(String id){ User user = userMapper.selectUserById(Integer.parseInt(id)); return user; } @RequestMapping(value={&quot;/selectUserByName&quot;}, method=RequestMethod.GET) public List&lt;User&gt; selectUserByName(String userName){ return userMapper.selectUserByName(userName); } @RequestMapping(value={&quot;/addUser&quot;}, method=RequestMethod.POST) public void addUser(User user){ userMapper.addUser(user); } @RequestMapping(value={&quot;/updateUser&quot;}, method=RequestMethod.POST) public void updateUser(User user){ userMapper.updateUser(user); } @RequestMapping(value={&quot;/deleteUser&quot;}, method=RequestMethod.POST) public void deleteUser(String id){ userMapper.deleteUser(Integer.parseInt(id)); } } 此时便已经全部配置结束 为了方便测试，忽略了service层，直接调用了mapper层 （6）测试 1. ","link":"https://kangjn.github.io/post/springboot-6zheng-he-mybatis/"},{"title":"springboot-5.全局异常捕获","content":"springboot-5.全局异常捕获 在web应用中，请求处理时，出现异常是非常常见的。所以当应用出现各类异常时，进行异常的捕获或者二次处理(比如sql异常正常是不能外抛)是非常必要的，比如在开发对外api服务时，约定了响应的参数格式，如respCode、respMsg，调用方根据错误码进行自己的业务逻辑。 1 浏览器访问异常时： 2.postman访问异常时： 显然，默认的异常页是对用户或者调用者而言都是不友好的，所以一般上我们都会进行实现自己业务的异常提示信息。 正文 1.自定义基础接口类+自定义枚举类 public interface BaseErrorInfoInterface { /** 错误码*/ String getResultCode(); /** 错误描述*/ String getResultMsg(); public enum CommonEnum implements BaseErrorInfoInterface { // 数据操作错误定义 SUCCESS(&quot;200&quot;, &quot;成功!&quot;), BODY_NOT_MATCH(&quot;400&quot;,&quot;请求的数据格式不符!&quot;), SIGNATURE_NOT_MATCH(&quot;401&quot;,&quot;请求的数字签名不匹配!&quot;), NOT_FOUND(&quot;404&quot;, &quot;未找到该资源!&quot;), INTERNAL_SERVER_ERROR(&quot;500&quot;, &quot;服务器内部错误!&quot;), SERVER_BUSY(&quot;503&quot;,&quot;服务器正忙，请稍后再试!&quot;) ; /** 错误码 */ private String resultCode; /** 错误描述 */ private String resultMsg; CommonEnum(String resultCode, String resultMsg) { this.resultCode = resultCode; this.resultMsg = resultMsg; } @Override public String getResultCode() { return resultCode; } @Override public String getResultMsg() { return resultMsg; } } } 2.自定义异常类 public class BizException extends RuntimeException { private static final long serialVersionUID = 1L; /** * 错误码 */ protected String errorCode; /** * 错误信息 */ protected String errorMsg; public BizException() { super(); } public BizException(BaseErrorInfoInterface errorInfoInterface) { super(errorInfoInterface.getResultCode()); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(BaseErrorInfoInterface errorInfoInterface, Throwable cause) { super(errorInfoInterface.getResultCode(), cause); this.errorCode = errorInfoInterface.getResultCode(); this.errorMsg = errorInfoInterface.getResultMsg(); } public BizException(String errorMsg) { super(errorMsg); this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg) { super(errorCode); this.errorCode = errorCode; this.errorMsg = errorMsg; } public BizException(String errorCode, String errorMsg, Throwable cause) { super(errorCode, cause); this.errorCode = errorCode; this.errorMsg = errorMsg; } public String getErrorCode() { return errorCode; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public String getErrorMsg() { return errorMsg; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public String getMessage() { return errorMsg; } @Override public Throwable fillInStackTrace() { return this; } } 3.自定义数据格式 public class ResultBody { /** * 响应代码 */ private String code; /** * 响应消息 */ private String message; /** * 响应结果 */ private Object result; public ResultBody() { } public ResultBody(BaseErrorInfoInterface errorInfo) { this.code = errorInfo.getResultCode(); this.message = errorInfo.getResultMsg(); } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Object getResult() { return result; } public void setResult(Object result) { this.result = result; } /** * 成功 * * @return */ public static ResultBody success() { return success(null); } /** * 成功 * @param data * @return */ public static ResultBody success(Object data) { ResultBody rb = new ResultBody(); rb.setCode(CommonEnum.SUCCESS.getResultCode()); rb.setMessage(CommonEnum.SUCCESS.getResultMsg()); rb.setResult(data); return rb; } /** * 失败 */ public static ResultBody error(BaseErrorInfoInterface errorInfo) { ResultBody rb = new ResultBody(); rb.setCode(errorInfo.getResultCode()); rb.setMessage(errorInfo.getResultMsg()); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error(String code, String message) { ResultBody rb = new ResultBody(); rb.setCode(code); rb.setMessage(message); rb.setResult(null); return rb; } /** * 失败 */ public static ResultBody error( String message) { ResultBody rb = new ResultBody(); rb.setCode(&quot;-1&quot;); rb.setMessage(message); rb.setResult(null); return rb; } @Override public String toString() { return JSONObject.toJSONString(this); } } 4.自定义全局异常处理类 @RestControllerAdvice public class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); public static final String Demo_View = &quot;error&quot;; /** * 处理自定义的业务异常 * @param req * @param e * @return */ @ExceptionHandler(value = BizException.class) public Object bizExceptionHandler(HttpServletRequest request,HttpServletRequest req, BizException e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,e.getErrorCode()); mav.setViewName(Demo_View); return mav; } } /** * 处理空指针的异常 * @param req * @param e * @return */ @ExceptionHandler(value =NullPointerException.class) @ResponseBody public ResultBody exceptionHandler(HttpServletRequest req, NullPointerException e){ logger.error(&quot;发生空指针异常！原因是:&quot;,e); return ResultBody.error(BaseErrorInfoInterface.CommonEnum.BODY_NOT_MATCH); } /** * 处理其他异常 * @param req * @param e * @return */ @ExceptionHandler(value =Exception.class) public Object exceptionHandler(HttpServletRequest request,HttpServletRequest req, Exception e){ if(isAjax(request)) { return ResultBody.error(e.getMessage()); } else { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;,e); mav.addObject(&quot;status&quot;,INTERNAL_SERVER_ERROR); mav.setViewName(Demo_View); return mav; } } //判断是否是ajax请求 public static boolean isAjax(HttpServletRequest httpRequest) { return(httpRequest.getHeader(&quot;X-Requested-With&quot;)!=null &amp;&amp;&quot;XMLHttpRequest&quot;.equals(httpRequest.getHeader(&quot;X-Requested-With&quot;).toString())); } } 5.编写前端异常显示页面 ps:名称对应步骤4里的String Demo_View 为了测试，快速建立一个html &lt;!doctype html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:text=&quot;${url}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${exception.message}&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;${status}&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 此时全局异常捕获已经建立完毕，接下来进行测试 测试 1.web页面跳转 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;/error&quot;) public String error() { int a = 1 / 0; //除以0，产生异常 return &quot;error&quot;; } } 此时访问web页面： 2.ajax形式跳转 更改controller文件 @Controller @RequestMapping(&quot;/err&quot;) public class errorController { @RequestMapping(&quot;&quot;) public String err() { return &quot;thymeleaf/ajaxerror&quot;; } @RequestMapping(&quot;getAjaxError&quot;) public jsonResult ajaxError() { int a = 1/0; return jsonResult.ok(200); } } 新建一个ajaxerror.html文件于thymeleaf文件夹下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ajax测试&lt;/title&gt; &lt;/head&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;input id=&quot;test&quot; value=&quot;测试&quot; type=&quot;submit&quot;&gt; &lt;/body&gt; &lt;script th:src=&quot;@{/static/js/ajaxjs.js}&quot;&gt;&lt;/script&gt; &lt;/html&gt; 新建一个ajax.js文件编写ajax请求 $(&quot;#test&quot;).click(function() { $.ajax({ url: &quot;/err/getAjaxError&quot;, type: &quot;POST&quot;, async: false, success: function (data) { if (data.status == 200 &amp;&amp; data.msg == 'OK') { alert(&quot;success&quot;); } else { alert(&quot;发生异常&quot; + data.msg); } }, error: function (response, ajaxOption, thrownError) { alert(&quot;error&quot;); } }); }); 记得在application文件夹添加静态文件路径配置 mvc: static-path-pattern: /static/** 此时访问 3.测试自定义异常 新建一个controller文件 @Controller @RequestMapping(value = &quot;/api&quot;) public class UserRestController { @RequestMapping(&quot;&quot;) public String api(ModelMap map) { User u = new User(); map.addAttribute(&quot;user&quot;,u); return &quot;thymeleaf/api&quot;; } @PostMapping(&quot;/user&quot;) public boolean insert(User user) { System.out.println(&quot;开始新增...&quot;); //如果姓名为空就手动抛出一个自定义的异常！ if (user.getUsername() == null) { throw new BizException(&quot;-1&quot;, &quot;用户姓名不能为空！&quot;); } return true; } } 新建一个api.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/api/user&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 访问 3.测试自定义异常 @RequestMapping(&quot;/error&quot;) public String error() { throw new BizException(&quot;400&quot;, &quot;这是400错误&quot;); } 尾言 按照步骤添加即可完成操作~ User类自行添加或者浏览前文即可。 其他 1.SpringBoot异常处理-自定义错误页面 (1) 在Spring Boot中一共提供了几种处理异常的方式？ SpringBoot 中对于异常处理提供了五种处理方式： 自定义错误页面； @ExceptionHandle 注解处理异常； @ControllerAdvice+@ExceptionHandler 注解处理异常； 配置 SimpleMappingExceptionResolver 处理异常； 自定义 HandlerExceptionResolver 类处理异常 (2) 什么是自定义错误页面方式？ SpringBoot 默认的处理异常的机制：SpringBoot 默认的已经提供了一套处理异常的机制。一旦程序中出现了异常 SpringBoot 会像/error 的 url 发送请求。在 springBoot 中提供了一个叫 BasicExceptionController 来处理/error 请求，然后跳转到默认显示异常的页面来展示异常信息。 (3) 自义定错误页面应该放到项目的什么位置？ 放在一般网页资源存放的位置 即src/main/resources/templates 2.SpringBoot异常处理-@ControlleAdvice (1) @ControllerAdvice注解的作用是什么？ 需要创建一个能够处理异常的全局异常类。 在该类上需要添加@ControllerAdvice 注解。 (2) @ControllerAdvice+@ExceptionHandler注解处理异常有什么特点？ 是一个处理异常的全局异常类，整个项目只要产生了该类方法捕获的异常都会被捕获处理。缺点是要根据异常类型不同规定很多的异常处理方法，也就是@ExceptionHandler方法，代码冗余而且没有规定的异常类型无法捕获还是会走SpringBoot默认的异常处理方法。 ","link":"https://kangjn.github.io/post/springboot-5quan-ju-yi-chang-bu-huo/"},{"title":"springboot-4.模板引擎","content":"springboot-4.模板引擎 前言 关于freemarker和thymeleaf的介绍自行查阅，本文只讲快速入门使用。 freemarker (1)在pom文件中添加依赖项 &lt;!-- freemarker 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加freemarker相关配置 spring: http: encoding: force: true charset: UTF-8 freemarker: allow-request-override: false cache: false check-template-location: true charset: UTF-8 content-type: text/html; charset=utf-8 expose-request-attributes: false expose-session-attributes: false expose-spring-macro-helpers: false suffix: .ftl template-loader-path: classpath:/templates (3)在templates文件夹下新建一个freemarker文件夹，然后再在该文件夹下新建文件center.ftl 文件树结构： 快速创建一个网页模板进行测试，内容如下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;${host}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ps：其中host的值通过后台读取。 （4）在controller文件夹下新建一个freemarkerController.java文件 @Controller public class freemarkerController { @RequestMapping(&quot;/&quot;) public String index(ModelMap map) { map.addAttribute(&quot;host&quot;,&quot;ericam&quot;); return &quot;freemarker/center&quot;; } } ps: 通过map将字符串ericam赋值给host，然后返回前端页面（可以不用写后缀ftl） (5)预览 此时打开浏览器可以看到如下内容： 接下来着重介绍thymeleaf，它在日常项目中使用更加广泛。（ps:项目中可以同时使用freemarker和thymeleaf） Thymeleaf 一. 快速入门使用 （1）在pom文件夹添加项目依赖 &lt;!-- ThymeLeaf 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; (2)在application.yml文件中添加themeleaf相关配置 spring: thymeleaf: cache: false # 开发时关闭缓存,不然没法看到实时页面 mode: HTML # 用非严格的 HTML encoding: UTF-8 servlet: content-type: text/html (3) 在templates文件夹下新建一个themeleaf文件夹，然后再新建一个test.html 文件树： 新建一个User.java文件 文件树： (4)编写User.java文件 为了方便测试，用户具备如下属性： id 用户名 年龄 创建时间 用户简介 public class User { private String id; private int age; private String username; private Date createTime; private String desc; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } //请读者自行补充 构造器和 get/set方法.. public String getId() { return id; } public void setId(String id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } (5)新建一个themeleafController.java进行测试 @Controller public class themeleafController { @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); //这里的user对应html里的user return &quot;thymeleaf/test&quot;; } } (6)最后我们进行编写test.html文件 &lt;div&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.id}&quot; th:name=&quot;${user.id}&quot;th:value=&quot;${user.id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.username}&quot; th:name=&quot;${user.username}&quot; th:value=&quot;${user.username}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.age}&quot; th:name=&quot;${user.age}&quot; th:value=&quot;${user.age}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;${user.createTime}&quot; th:name=&quot;${user.createTime}&quot; th:value=&quot;${#dates.format(user.createTime,'dd/MM/yyyy')}&quot;&gt; &lt;span th:utext=&quot;${user.desc}&quot;&gt;&lt;/span&gt; &lt;/div&gt; ps: th:utext可以将内容作为html格式输出，而th:text则是直接输出文本。 (7)预览 二.Thymeleaf常用标签-方法 （1）上述test.html的等同写法 &lt;div th:object=&quot;${user}&quot;&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{id}&quot; th:name=&quot;*{id}&quot;th:value=&quot;*{id}&quot;/&gt; &lt;input type=&quot;text&quot; th:id=&quot;*{username}&quot; th:name=&quot;*{username}&quot; th:value=&quot;*{username}&quot;&gt; &lt;/div&gt; 这样可以简化内容，使用更加广泛。 （2）表单的提交 我们在test.html里添加如下内容 &lt;div&gt; &lt;form th:action=&quot;@{/postform}&quot; th:object=&quot;${user}&quot; method=&quot;post&quot; th:method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; th:field=&quot;*{username}&quot;/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/div&gt; ps:提交地址为 url/postform ,提交方法为post，提交的内容为user.username 接着在themeleafController添加如下内容 @PostMapping(&quot;/postform&quot;) public String postform(User u) //前端传入了一个User对象 { System.out.println(u.getUsername()); return &quot;redirect:/test&quot;; //重定向（等于转向/test地址 } （3）th:if标签 &lt;div th:if=&quot;${user.age}==18&quot;&gt;1&lt;/div&gt; &lt;!--等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} gt 18&quot;&gt;2&lt;/div&gt;&lt;!--大于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} lt 18&quot;&gt;3&lt;/div&gt;&lt;!--小于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} ge 18&quot;&gt;4&lt;/div&gt;&lt;!--大于等于18，显示该标签--&gt; &lt;div th:if=&quot;${user.age} le 18&quot;&gt;5&lt;/div&gt;&lt;!--小于等于18，显示该标签--&gt; 利用if判断变量是否为空，非空时显示 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; if / else 的实现 &lt;span th:if=&quot;${msg}&quot; th:text=&quot;${msg}&quot;&gt;&lt;/span&gt;&lt;br&gt; &lt;span th:unless=&quot;${msg}&quot; th:text=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt; (4)th:selected标签 &lt;select&gt; &lt;option &gt;选择框&lt;/option&gt; &lt;option th:selected=&quot;${user.username eq 'fwf'}&quot;&gt;fwf&lt;/option&gt; &lt;/select&gt; (5)table表单 &lt;table&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;person:${userlist}&quot;&gt; &lt;td th:text=&quot;${person.id}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.username}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${person.age gt 18}?大:小&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${#dates.format(person.createTime,'yyyy-MM-dd')}&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在这里我们需要修改下themeleafController文件，为其添加一个userlist。 @RequestMapping(&quot;/test&quot;) public String test(ModelMap map) { User u = new User(); u.setId(&quot;123&quot;); u.setUsername(&quot;fwf&quot;); u.setCreateTime(new Date(2020-1900,6-1,12)); u.setDesc(&quot;&lt;p&gt;ssssssssssss&lt;/p&gt;&quot;); u.setAge(18); map.addAttribute(&quot;user&quot;,u); List&lt;User&gt; userlist = new ArrayList&lt;&gt;(); //添加一个userlist userlist.add(u); u = new User(); u.setId(&quot;234&quot;); u.setUsername(&quot;ericam&quot;); u.setCreateTime(new Date(2020-1900,5-1,12)); u.setAge(3); userlist.add(u); map.addAttribute(&quot;userlist&quot;,userlist); return &quot;thymeleaf/test&quot;; } (6)th:switch &lt;div th:switch=&quot;${user.username}&quot;&gt; &lt;p th:case=&quot;'fwf'&quot;&gt;111&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 备注：常用标签的效果可以自行去测试 ","link":"https://kangjn.github.io/post/springboot-4mo-ban-yin-qing/"},{"title":"springboot-3.资源文件属性配置","content":"springboot-3.资源文件属性配置 前言 为什么要进行资源文件属性配置呢？可以想象成就是一个设置文件。比如设置好数据库密码.port端口后，在其他地方只需要用名字引用即可。 举个例子： 我们设置以下项目的持有者名称为ericam demo: name: &quot;ericam&quot; 那么在其他地方只需要引用name名称即可，然后如果整个项目需要多次引用，后期我们只需要在一个配置文件里更改下名称即可，不必多次操作。 Spring Boot可使用注解的方式将自定义的properties文件映射到实体bean中，比如application.properties文件 或者application.yml 正文 （1）首先，在pom文件中添加依赖项 &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; （2）修改application.yml文件，添加如下内容 demo: name: &quot;ericam&quot; （3）新建一个Resource.java文件 package cn.ericam.nndemo; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; @Configuration //使用配置注解 ，表示这个类是配置文件 @ConfigurationProperties(prefix = &quot;demo&quot;) //prefix 指定配置文件里的前缀 @PropertySource(value = &quot;classpath:application.yml&quot;) public class Resource { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } ps：ConfigurationProperties是一个注解，可以标注在一个Class上，这样Spring Boot会从Environment中获取其属性对应的属性值给其进行注入。 （4）接下来，我们开始引用一波尝试，打开helloController.java文件 @RestController public class helloController { @Autowired private Resource resource; //构建一个Resource类对象，通过autowired自动赋值 @RequestMapping(&quot;/getR&quot;) public jsonResult gr() { Resource b = new Resource(); BeanUtils.copyProperties(resource,b); //将resource的值拷贝复制给b return jsonResult.ok(b); } } ps:@Autowired 注释可以对类成员变量、方法及构造函数进行标注，完成自动装配。 通过 @Autowired的使用来消除 set、get方法。 打开浏览器 application.yml文件中重要属性 server: port: 8080 #端口 servlet: context-path: /demo #配置路径，此后访问http://localhost:****/demo/**** ","link":"https://kangjn.github.io/post/springboot-3zi-yuan-wen-jian-shu-xing-pei-zhi/"},{"title":"springboot-2.利用接口返回数据（json）","content":"springboot-2.利用接口返回数据（json） 前言 项目前后台交互存在两种方式 一种普通整体页面提交，比如form提交； 还有一种局部刷新，或者叫做异步刷新，ajax提交； @Controller就是整体页面刷新提交的处理注解 @RestController就是ajax提交，一般返回json格式，相当于我们经常使用的@ResponseBody+@Controller组合 正文 新建文件夹controller 然后在该文件夹下新建 控制类.java文件 1.最简单的数据返回 @RestController public class helloController { @RequestMapping(&quot;/&quot;) public String hello() { return &quot;hello&quot;; } } 【@RequestMapping作用】 处理请求地址的映射 用于类和方法上，类上的 “请求地址” 是方法上的 “请求地址” 的父地址 2.返回类对象信息 为了演示，我们新建一个文件夹User，然后在该文件夹下新建一个文件User.java 内容如下： public class User { private String name; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 然后在controller文件夹下新建一个userController.java文件 (记得自行import需要的文件) @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public User getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return u; } } 3.返回封装的类对象信息 解释一下该处和2处的区别： @Description: 自定义响应数据结构这个类是提供给门户，ios，安卓，微信商城用的门户接受此类数据后需要使用本类的方法转换成对于的数据类型格式（类，或者list）其他自行处理 200：表示成功 500：表示错误，错误信息在msg字段中 501：bean验证错误，不管多少个错误都以map形式返回 502：拦截器拦截到用户token出错 555：异常抛出信息 简单来说，就是当前台提交用户信息给后台时，后台会返回一个json数据，其中包含状态码（200等），message（“ok”或者“failure”），然后再包含一个用户信息列表。 首先，在pom文件中添加依赖项 jackson-databind jackson-core 新建一个jsonResult.java文件 package cn.ericam.nndemo.Json; public class jsonResult { // 响应业务状态 private Integer status; // 响应消息 private String msg; // 响应中的数据 private Object data; public static jsonResult ok(Object data) { return new jsonResult(data); } //类含参初始化1 public jsonResult(Integer status, String msg, Object data) { this.status = status; this.msg = msg; this.data = data; } //类含参初始化2 public jsonResult(Object data) { this.status = 200; this.msg = &quot;OK&quot;; this.data = data; } //get和set方法 public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } 然后在userController.java下修改为如下代码： @RestController public class userController { @RequestMapping(&quot;/getUser&quot;) public jsonResult getUser() { User u = new User(); u.setName(&quot;x&quot;); u.setSex(&quot;nan&quot;); return jsonResult.ok(u); } } 【ps：IDEA利用ctrl+insert可以快速生成get和set方法】 ","link":"https://kangjn.github.io/post/springboot-2li-yong-jie-kou-fan-hui-shu-ju-json/"},{"title":"springboot-1.简约版创建第一个应用","content":"springboot-1.简约版创建第一个应用 勾选依赖项 由于只是体验搭建一个springboot项目，因此依赖项只需要勾选一个spring web 创建成功后项目列表如下图所示 其中 DemoApplication.java:关键的启动类（程序的入口） pom.xml:Maven构建说明文件 DemoApplicationTests.java:一个空的Junit测试类，它加载了一个使用Spring Boot字典配置功能的Spring应用程序上下文 application.properties:一个空的properties文件，根据需要添加配置属性 为了演示简单，不再新建控制类，而是直接在这个入口类(DemoApplication.java)中编写，添加@RestController以及index方法，如下： 红色框内 内容需要添加 ps:@RestController注解等价于@Controller+@ResponseBody的结合，使用这个注解的类里面的方法都以json格式输出。 运行项目 浏览器访问http://localhost:8080/ 至此第一个springboot项目已经创建完毕 端口被占用 由于项目需要运行在端口8080，当端口被占用时，需要杀死该端口上运行的进程 进入命令行 netstat -o -n -a | findstr :8080 # TCP 0.0.0.0:3000 0.0.0.0:0 LISTENING 3116 taskkill /F /PID 3116 实现热启动 热启动：修改代码保存时会自动重新启动项目 1.修改pom.xml文件(添加spring-boot-devtools包) &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 修改spring-boot-maven-plugin插件 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork:设置True，否则可能devtools不会起作用--&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2.修改IDEA配置 打开 File -&gt; Settings -&gt;Build,Executions,Deployment -&gt; Compiler ，勾选 然后，Ctrl + Shift + Alt + / 打开 勾选该选项 热更新完成！ ","link":"https://kangjn.github.io/post/springboot-1jian-yue-ban-chuang-jian-di-yi-ge-ying-yong/"},{"title":"git命令行常用指令","content":"git命令行日常指令 首先，需要在Github/Coding平台新建一个仓库。 本地新建一个文件夹，打开该文件夹，右键选择“git bash here”进入命令行。 1.将项目初次拉取到本地（clone） git clone 项目地址 2. 将本地文件push到远程仓库 git init #初始化 git add . #将文件夹内所有文件添加至本地仓库 git commit -m &quot;描述&quot; #添加本次提交描述 git remote add origin https://github.com/用户名/项目名.git git push -u origin master ps: git remote add origin...为建立本地与远程依赖，某些情况下需要重置。 清空依赖命令 git remote rm origin 3.删除文件夹 git pull origin master git rm -r --cached idea #删除idea文件夹 git commit -m '删除.idea' git push -u origin master 4. git push 命令使用 场景1 场景：当本地的当前分支不是local_branch； 作用：将远程分支拉取到指定本地分支； 例如：当前分支是dev，但是你想把远程master “同步”到本地master，但又不想使checkout切换到master分支； git pull origin master：master #将远程master分支拉取到本地master分支 场景2 场景：在当前分支上进行同步操作； 作用：将指定远程分支同步到当前本地分支； git pull origin master 场景3 场景：本地分支已经和想要拉取的分支建立了“关联”关系； 作用：拉取所有远程分支的新版本&quot;坐标&quot;，并同步当前分支的本地代码(具体根据关联分支而定) git push 5.强制拉取 git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull git fetch&amp;&amp;git pull git pull : 拉取代码并合并 git fetch :拉取代码 (如果需要合并，执行git merge) git fetch使用方法 git fetch origin master:tmp // 拉取远程master分支，并放到本地tmp分支上 git diff tmp //查看当前分支和tmp分支的区别 git merge tmp // 把tmp分支合并到当前分支 git branch -d tmp // 删除tmp分支 ","link":"https://kangjn.github.io/post/git-ming-ling-xing-chang-yong-zhi-ling/"},{"title":"设计模式-六大设计原则","content":"单一职责原则 简介 单一职责原则（SRP，Single Responsesibility Principle）：There should never be more than one reason for a class to change.(应该有且仅有一个原因引起类的变更) 优势 类的复杂性降低。实现什么职责都有清晰明确的定义 可读性提高，复杂性降低 可维护性提高，可读性提高 变更引起的风险降低 注意 单一职责是一个标准，用“职责”或“变化原因”来衡量接口或类设计的是否优良，但是这两者都是不可度量的，因项目和环境而定。 里氏替换原则 简介 里氏替换原则（LSP，Liskov Substitution Principle）： If for each object o1 of type S there is an object o2 of type T suchthat for all programs P defined in terms of T, the behavior of P is unchangedwhen o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。） functions that use pointers or references to base classes must beable to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。） 理解：只要父类能出现的地方子类就可以出现，即将父类对象调用的行为切换成子类对象调用行为也不会产生任何错误或异常，但是反过来却不行。 含义 子类必须完全实现父类的方法 里氏替换原则可以正着用，不能反过来用：子类出现的地方，父类未必可以胜任 覆盖或实现父类的方法时，输入参数可以被放大：如果反过来会引起业务逻辑的错乱。子类中方法的前置条件（参数）必须与超类中被覆写的方法的前置条件相同或更宽松。（如：父类是HashMap，子类是HashMap或Map） 覆写或实现父类的方法时输出结果可以被缩小：里氏替换原则要求S小于等于T，则S和T要么是同一类型，要么S是T的子类。 注意 在类中调用其他类时必须要使用父类或接口，如果不能使用父类或接口，说明类的设计已经违背了LSP原则 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生了&quot;畸变&quot;，建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 依赖倒置原则 简介 依赖倒置原则（DIP，Dependence Inversion Principle）：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions 理解：高层模块不应该依赖底层模块，两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象 含义 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象实现的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 注意 Java变量有两种类型：表面类型（定义时候赋予的类型），实际类型（对象的类型） 依赖的三种写法：构造函数传递依赖对象、setter方法传递依赖对象、接口声明依赖对象 依赖倒置原则是实现开闭原则的重要途径。 使用 要想使用这个规则只需要做到一下几点： 每个类尽量都有接口或抽象类，或两者皆有 变量的表面类型尽量是接口或抽象类 任何类都不应该从具体类派生 尽量不要覆写基类方法 结合里氏替换原则使用：接口负责定义Public属性和方法，并声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化 接口隔离原则 简介 接口隔离原则（ISP：Interface Segregation Principle）： Clients should not be forced to depend upon interfaces that they don't use（客户端不应该依赖于它不需要的接口） The dependency of one class to another one should depend on the smallest possible interface（类间的依赖关系应该建立在最小的接口上） 理解：建立单一接口，不要建立臃肿庞大的接口，接口尽量细化同时接口方法尽量少 含义 接口尽可能的小：前提是不能违背单一职责原则，优先考虑单一职责原则 接口要高内聚：提高接口、类、模块的处理能力，减少对外的交互 定制服务：单独为一个个体提供优良的服务 接口设计是有限度的 注意 接口隔离原则和单一职责并不冲突，两者针对的角度不同。单一职责注重的是职责，是业务逻辑上的划分。而接口隔离原则要求接口的方法尽量少 设计是有限度的，不要无限的考虑未来可能出现的情况 使用 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑尽量压缩接口中的public方法，并经常回顾接口 如果接口已经被污染，尽量去修改。如果不行，则使用适配器模式进行转换处理 了解环境，根据业务来设计 迪米特法则 简介 迪米特法则（LoD：Law of Demeter）：一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道的最少 含义 只和朋友交流：不要出现getA().getB().getC().getD()的奇葩写法 朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，出现在方法体内部的类不属于朋友类 朋友间也是有距离的：公开的public属性或方法越多，修改时涉及的面也就越大。在设计时候要反复考虑是否可以减少public的方法和属性，将其修改成private等，并且是否可以加上final关键字 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系也不对本类产生负面影响，就放在本类中 谨慎使用Serializable：由于很容易被发现，所以不必太过在意。 注意 一个类只和朋友交流不和陌生人交流 ，不要出现getA().getB().getC().getD()的奇葩写法 类与类之间的关系是建立在类间的，而不是方法间的，一个方法尽量不引入一个类中不存在的对象，JDK API提供的除外 尽量不要对外公布太多的public方法和非静态的public变量 如果一个类跳转两次以上才能访问到另外一个类，就需要进行重构了。 开闭原则 简介 开闭原则：Software entities like classes,modules and functions should be open for extension but closed for modifications（一个软件实体，如类、模块和函数应该对扩展开发对修改关闭） 理解：一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。 优势 使用开闭原则能有效的减少重构时的测试 可以提高复用性 可以提高可维护性 面向对象开发的要求 使用 抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法 参数类型、引用对象尽量使用接口或抽象类，而不是实现类 抽象层尽量保持稳定，一旦确认就不允许修改 元数据控制模块行为：尽量使用元数据来控制程序的行为（描述缓解和数据的数据，通俗的说就是配置） 制定项目章程 封装变化 将相同的变化封装到一个接口或抽象类中 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中 注意 开闭原则对扩展开放对修改关闭，并不意味着不做任何修改，底层模块的变更，必然有高层模块进行耦合，否则就是无意义的代码 ","link":"https://kangjn.github.io/post/she-ji-mo-shi-liu-da-she-ji-yuan-ze/"},{"title":"《论语》50经典名句","content":"1．朝闻道，夕死可矣。 早上明白知晓了真理，即便晚上死去，也是值得的。 2．见贤思齐焉，见不贤而内自省也。 见到贤人便应考虑怎样才能向他看齐，见到不贤的人便应在内心反省，看自己有没有同样的缺点。 3．己所不欲，勿施于人。 如果不希望他人这样对待自己，自己也不要这样对待他人。 4．不怨天，不尤人。 遇到挫折与失败，绝不抱怨天，不责怪人。 5．不迁怒，不贰过。 不会迁怒于人，不会犯两次同样的错误。 6．过而不改，是谓过矣。 有了过错而不改正，这就是真的过错了。 7．人而无信，不知其可也。 一个人不讲信用，不知他怎样立身处世。 8．有则改之，无则加勉。 别人给自己指出缺点错误，如果有，就改正，如果没有，就用来提醒自己不犯同样的错误。 9．如切如磋，如琢如磨。 完善自身的修养，既像雕琢玉器，又像雕刻石头，都是需要下功夫的。 10．人无远虑，必有近忧。 一个人没有长远的考虑，一定会有眼前的忧患。指智者能不为眼前得失所羁绊，目光长远，判断敏锐。 11．君子求诸己，小人求诸人。 君子哪儿做得不对，会从自己内心去查找原因，要求自己做好，从而修正自己；小人则是向外去查找原因，要求别人做好。 12．君子坦荡荡，小人长戚戚。 君子光明磊落，胸怀坦荡，小人则斤斤计较，患得患失。 13．君子喻于义，小人喻于利。 君子能够领悟的是道义，小人能够领悟的是利益。 14．君子和而不同，小人同而不和。 君子和谐而不同流合污，小人同流合污而不和谐。 15．君子泰而不骄，小人骄而不泰。 君子坦荡舒畅而不骄傲自大，小人骄傲自大而不坦荡舒畅。 16．君子成人之美，不成人之恶。小人反是。 君子成全别人的好事，而不促成别人的坏事。小人则与此相反。 17．君子欲讷于言，而敏于行。 君子说话要谨慎，而行动要敏捷。君子说话要谨慎，是因为“覆水难收”，随心所欲说出口的话，可能对于别人有失尊重。但是一旦君子对于决定的事情，绝不犹豫推托而耽误了时光。这一缓一急之间，正是体现君子有为有守的处世原则。 18．君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。 君子食不追求饱足，居住不追求安逸，对工作勤奋敏捷，说话却谨慎，接近有道德有学问的人并向他学习，纠正自己的缺点，就可以称得上是好学了。 **19．与善人居，如入芝兰之室，久而不闻其香，即与之化矣；与不善人居，如入鲍鱼之肆，久而不闻其臭；亦与之化矣。 ** 常与善人相处，就像生活在种满兰芝仙草的花房，时间长了便察觉不到香味，那是因为已经习惯了善行的芬芳；常与不善的人相处，就像住进了满是臭鱼烂虾的海鲜市场，时间长了便察觉不到腥味，也是因为闻惯了恶行的腐臭。 圣人此言是在告诫我们：与人相处，先看人品。 常跟善良的人在一起，便会耳濡目染地跟着行善事、说善言，久而久之，心胸也会变得更加宽广。 常跟邪恶的人在一起，则会不知不觉地跟做错事、说恶话，久而久之，难免会折损自身的品行。 20．君子有三畏：畏天命，畏大人，畏圣人之言。小人不知天命而不畏也，狎大人，侮圣人之言”。 君子有三件敬畏的事情：敬畏天命，敬畏居高位的人，敬畏圣人的话，小人不知道天所赋予的正理而不敬畏，怠慢轻视高位的人，戏侮圣人的话。 21．学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？ 学过的知识，在适当的时候去复习它，这不是令人感到快乐的事吗？ 有朋友从远方来，这不是件令人感到快乐的事吗？ 别人不了解我，我也不生气，这不也是一种君子风度的表现吗？ 22．三人行，必有我师焉。择其善者而从之，其不善者而改之。 几个人同行，其中必有值得我学习的人，选取他的优点向他学习，对他的缺点引以为戒，有则改之。 23．学而不厌，诲人不倦。 努力学习却不感到满足，教导别人不感到厌倦。 24．学而不思则罔，思而不学则殆。 只学习却不思考就会感到迷茫，只空想却不学习就会疲倦而没有收获。 25．敏而好学，不耻下问，是以谓之文也。 聪明而且好学，不认为向地位比自己低、学识比自己浅的人请教是可耻的事，任何一个能如此作为的人，怎会不能成才？ 26．知之为知之，不知为不知，是知也。 知道就是知道，不知道应当说不知道，这才是明智的行为。 27．温故而知新，可以为师矣。 温习旧知识从而得到新的理解与体会，凭借这一点就可以成为老师了。 28．子曰：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。” 孔子说：“我十五岁时，便立定志向学习；三十岁时，能立身处世；四十岁时，可以免于迷惑；五十岁时，已经能够领悟天命；六十岁时，就可以顺从天命；七十岁时，终于能做到做事随心所欲，却都能合于规矩的境界了。” 29．欲速则不达；见小利则大事不成。 不要求快，不要贪求小利。求快反而达不到目的，贪求小利就做不成大事。 30．小不忍，则乱大谋。 小事不忍耐，就会坏了大事情。 31．知者不惑，仁者不忧，勇者不惧。 有智慧的人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。 32．见义不为，无勇也。 见到应该挺身而出的事情，却袖手旁观，就是怯懦。 33．志士仁人，无求生以害仁，有杀身以成仁。 一位怀有大志和仁德的人，不会贪生怕死而损害仁德，只会不惜牺牲生命而成全仁德。 34．三军可夺帅也，匹夫不可夺志也。 三军可以丧失主帅，一个人的志气与主张却是不能被强迫改变的。 35．士不可以不弘毅，任重而道远。 有志者不可以不心胸开阔，意志坚强，因为担子沉重而且道路遥远。 36．名不正，则言不顺，言不顺，则事不成。 名分不正，所说的话就不合道理。说话不合理，事情就办不成。 37．自古皆有死，民无信不立。 子贡问怎么治理国家。孔子说：“粮食充足，军备充足，人民信任当政者。”子贡说：“如果不得不去掉一项，那么这三项应先去掉哪一项？”孔子说：“去掉军备。”子贡说：“如果不得不再去掉一项，那么这两项应去掉哪一项？”孔子说：“去掉粮食。自古以来人终究是要死的，老百姓如果不信任当政者，那么国家就不能成立了。” 38．其身正，不令而行；其身不正，虽令不从。 自身品行端正，即使不下达命令，百姓也会自觉去做；自身品行不端正，即使下达了命令，百姓也不会服从。 39．不在其位，不谋其政。 不在那个职位上，就不去考虑那个职位上的事。不是事不关己的冷漠，而是行事恪守本分。 40．听其言而观其行。 指听了他的话，还要看他的行动。 指不要只听言论，还要看实际行动。 41．四海之内，皆兄弟也。 司马牛见到师兄子夏后忧愁地说他人皆有兄弟相亲，而唯独我没有兄弟相亲。子夏安慰他说君子和人交往态度恭谨而合乎礼节，那么普天之下到处都是兄弟。 42．与朋友交，言而有信。 与朋友们交往，应该诚实守信，说到做到。 43．礼之用，和为贵。 礼的作用，在于使人的关系变得更加和谐。 44．益者三友，损者三友。友直，友谅，友多闻，益矣；友便辟，友善柔，友便佞，损矣。 有益的朋友有三种，有害的朋友也有三种。与正直的人交朋友，与守信的人交朋友，与见多识广的人交朋友，是有益的。与谄媚逢迎的人交朋友，与两面三刀的人交朋友，与花言巧语的人交朋友，是有害的。 45．道不同，不相为谋。 立场不同、观点不同，也就不要相互商议谋划了。 46．父母在，不远游，游必有方。 父母年迈在世，尽量不长期在外地。不得已，必须告诉父母去哪里，为什么去，什么时候回来，并安排好父母的赡养。 47．是可忍也，孰不可忍也。 孔子谈到季氏说：“他用天子的舞蹈阵容在自己的庭院中舞蹈，如果这样僭礼的事情都可以容忍的话，还有什么事情是不可以容忍的呢？” 48．毋意，毋必，毋因，毋我。 不凭空猜测，不死板，不固执，不自以为是。 49．士志于道，而耻恶衣恶食者，未足与议也。 有志之士，既然存心在道，就不应该贪求享受，如果还以粗糙的衣服和简陋的饮食为耻辱，那就不值得和他说什么了。 50．往者不可谏，来者犹可追。 过去的不可挽回，未来的还可以赶上。 ","link":"https://kangjn.github.io/post/lesslesslun-yu-greatergreater-50-jing-dian-ming-ju/"},{"title":"RabbitMQ使用教程(五)","content":"4.7.主题模式（通配符模式） 4.7.1.图示 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 4.7.2.生产者 package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.zpc.rabbitmq.util.ConnectionUtil; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); // 消息内容 String message = &quot;Hello World!!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 4.7.3.消费者1（前台系统） package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.7.4.消费者2（搜索系统） package com.zpc.rabbitmq.topic; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 5.Springboot集成RabbitMQ springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。 5.1.简单队列 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持 org.springframework.boot spring-boot-starter-amqp 2、配置application.properties文件 配置rabbitmq的安装地址、端口以及账户信息 spring.application.name=spirng-boot-rabbitmq spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin 3、配置队列 package com.zpc.rabbitmq; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitConfig { @Bean public Queue queue() { return new Queue(&quot;q_hello&quot;); } } 4、发送者 package com.zpc.rabbitmq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.text.SimpleDateFormat; import java.util.Date; @Component public class HelloSender { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } } 5、接收者 package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver : &quot; + hello); } } 6、测试 package com.zpc.rabbitmq; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMqHelloTest { @Autowired private HelloSender helloSender; @Test public void hello() throws Exception { helloSender.send(); } } 5.2.多对多使用（Work模式） 注册两个Receiver: package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } @Test public void oneToMany() throws Exception { for (int i=0;i&lt;100;i++){ helloSender.send(i); Thread.sleep(300); } } public void send(int i) { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + i + &quot; &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } 5.3.Topic Exchange（主题模式） topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 首先对topic规则配置，这里使用两个队列(消费者)来演示。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig { final static String message = &quot;q_topic_message&quot;; final static String messages = &quot;q_topic_messages&quot;; @Bean public Queue queueMessage() { return new Queue(TopicRabbitConfig.message); } @Bean public Queue queueMessages() { return new Queue(TopicRabbitConfig.messages); } /** * 声明一个Topic类型的交换机 * @return */ @Bean TopicExchange exchange() { return new TopicExchange(&quot;mybootexchange&quot;); } /** * 绑定Q到交换机,并且指定routingKey * @param queueMessage * @param exchange * @return */ @Bean Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;); } @Bean Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;); } } 2)创建2个消费者 q_topic_message 和q_topic_messages package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_message&quot;) public class Receiver1 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver1 : &quot; + hello); } } package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_messages&quot;) public class Receiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } 3)消息发送者（生产者） package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSender { @Autowired private AmqpTemplate rabbitTemplate; public void send1() { String context = &quot;hi, i am message 1&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context); } public void send2() { String context = &quot;hi, i am messages 2&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context); } } send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。 4)测试 package com.zpc.rabbitmq.topic; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitTopicTest { @Autowired private MsgSender msgSender; @Test public void send1() throws Exception { msgSender.send1(); } @Test public void send2() throws Exception { msgSender.send2(); } } 5.4.Fanout Exchange（订阅模式） Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanoutRabbitConfig { @Bean public Queue aMessage() { return new Queue(&quot;q_fanout_A&quot;); } @Bean public Queue bMessage() { return new Queue(&quot;q_fanout_B&quot;); } @Bean public Queue cMessage() { return new Queue(&quot;q_fanout_C&quot;); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(&quot;mybootfanoutExchange&quot;); } @Bean Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(aMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(bMessage).to(fanoutExchange); } @Bean Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(cMessage).to(fanoutExchange); } } 2）创建3个消费者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_A&quot;) public class ReceiverA { @RabbitHandler public void process(String hello) { System.out.println(&quot;AReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_B&quot;) public class ReceiverB { @RabbitHandler public void process(String hello) { System.out.println(&quot;BReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_C&quot;) public class ReceiverC { @RabbitHandler public void process(String hello) { System.out.println(&quot;CReceiver : &quot; + hello + &quot;/n&quot;); } } 3）生产者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSenderFanout { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String context = &quot;hi, fanout msg &quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context); } } 4）测试 package com.zpc.rabbitmq.fanout; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitFanoutTest { @Autowired private MsgSenderFanout msgSender; @Test public void send1() throws Exception { msgSender.send(); } } 结果如下，三个消费者都收到消息： AReceiver : hi, fanout msg CReceiver : hi, fanout msg BReceiver : hi, fanout msg 6.总结 使用MQ实现商品数据的同步优势： 1、降低系统间耦合度 2、便于管理数据的同步（数据一致性） 推荐阅读 《RabbitMQ详解》 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/"},{"title":"RabbitMQ使用教程(四)","content":"4.4.消息的确认模式 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？ 模式1：自动确认 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。 模式2：手动确认 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。 手动模式： 自动模式： 4.5.订阅模式 4.5.1.图示 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费 4.5.2.消息的生产者（看作是后台系统） 向交换机中发送消息。 package com.zpc.rabbitmq.subscribe; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。 4.5.3.消费者1（看作是前台系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.4.消费者2（看作是搜索系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.5.测试 测试结果： 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 在管理工具中查看队列和交换机的绑定关系： 4.6.路由模式 4.6.1.图示 4.6.2.生产者 4.6.3.消费者1(假设是前台系统) 4.6.4.消费2（假设是搜索系统） ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/"},{"title":"RabbitMQ使用教程(三)","content":"4、学习五种队列 4.1 简单队列 4.1.1.图示 P：消息的生产者 C：消息的消费者 红色：队列 生产者将消息发送到队列，消费者从队列中获取消息。 4.1.2.导入RabbitMQ的客户端依赖 com.rabbitmq amqp-client 3.4.1 4.1.3.获取MQ的连接 package com.zpc.rabbitmq.util; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; public class ConnectionUtil { public static Connection getConnection() throws Exception { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost(&quot;localhost&quot;); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost(&quot;testhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 4.1.4.生产者发送消息到队列 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明（创建）队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); //关闭通道和连接 channel.close(); connection.close(); } } 4.1.5.管理工具中查看消息 点击上面的队列名称，查询具体的队列中的信息： 4.1.6.消费者从队列中获取消息 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); } } } 4.2.Work模式 4.2.1.图示 一个生产者、2个消费者。 一个消息只能被一个消费者获取。 4.2.2.消费者1 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;); //休眠 Thread.sleep(10); // 返回确认状态，注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)； } } } 4.2.3.消费者2 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); // 休眠1秒 Thread.sleep(1000); //下面这行注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.2.4.生产者 向队列中发送100条消息。 package com.zpc.rabbitmq.work; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 100; i++) { // 消息内容 String message = &quot;&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); Thread.sleep(i * 10); } channel.close(); connection.close(); } } 4.2.5.测试 测试结果： 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。 RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。 basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。 2个概念 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 4.3.Work模式的“能者多劳” 打开上述代码的注释： // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); //开启这行 表示使用手动确认模式 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 同时改为手动确认： // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, false, consumer); 测试： 消费者1比消费者2获取的消息更多。 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/"},{"title":"RabbitMQ使用教程(二)","content":"2.4.学习5种队列 2.5.安装文档 3.搭建RabbitMQ环境 3.1.下载 下载地址：http://www.rabbitmq.com/download.html 3.2.windows下安装 3.2.1.安装Erlang 下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装 3.2.2.安装RabbitMQ 3.2.3.启用管理工具 1、双击 2、进入C:\\Program Files (x86)\\RabbitMQ Server\\rabbitmq_server-3.4.1\\sbin输入命令： rabbitmq-plugins enable rabbitmq_management 这样就启动了管理工具，可以试一下命令： 停止：net stop RabbitMQ 启动：net start RabbitMQ 3、在浏览器中输入地址查看：http://127.0.0.1:15672/ 4、使用默认账号登录：guest/ guest 3.3.Linux下安装 3.3.1.安装Erlang 3.3.2.添加yum支持 cd /usr/local/src/ mkdir rabbitmq cd rabbitmq wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc 使用yum安装： sudo yum install erlang 3.3.3.安装RabbitMQ 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/ 安装： rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 3.3.4.启动、停止 service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 3.3.5.设置开机启动 chkconfig rabbitmq-server on 3.3.6.设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 3.3.7.开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 注意要去掉后面的逗号。 3.3.8.开启web界面管理工具 rabbitmq-plugins enable rabbitmq_management service rabbitmq-server restart 3.3.9.防火墙开放15672端口 /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT /etc/rc.d/init.d/iptables save 3.4.安装的注意事项 1、推荐使用默认的安装路径 2、系统用户名必须是英文 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/"},{"title":"RabbitMQ使用教程(一)","content":"1.什么是MQ 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。 其主要用途：不同进程Process/线程Thread之间通信。 为什么会产生消息队列？有几个原因： 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列； 关于消息队列的详细介绍请参阅： 《Java帝国之消息队列》 《一个故事告诉你什么是消息队列》 《到底什么时候该使用MQ》 MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。 2.RabbitMQ 2.1.RabbitMQ的简介 开发语言：Erlang – 面向并发的编程语言。 2.1.1.AMQP AMQP是消息队列的一个协议。 2.2.官网 2.3.MQ的其他产品 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/"},{"title":"前端面试题目（二）","content":"解决HTML5新标签的兼容性： &lt;![if lt IE 9]&gt; //解决IE6-8支持HTML5新元素 //解决IE6-8对css Media Query//媒体查询 &lt;![endif]&gt; a:hover，a:active失效的问题？(lvha) 现象： a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。 解决方式： a:link {color:black} a:visited{color:pink} a:hover {color: blue} a:active {color: green} 将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。 如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。 选择器优先级？ 内联样式&gt;内部样式&gt;外部样式 ！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式 注意： 1、!important声明的样式优先级最高，如果冲突再进行计算。 2、如果优先级相同，则选择最后出现的样式。 3、继承得到的样式的优先级最低。 文本怎么自动换行？ word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。 word-wrap:normal word-wrap:break-word box-sizing模型？ content-box:默认 padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding border-box: padding和border包含在元素的宽度内，元素的实际宽度为：width js中创建自定义对象 ? var f=function(){} new Object() function f() this? 指向调用它的对象，如果没有，就指window HTML5表单新元素？ date time color number range email url search 5种常见的HTTP状态码及意义？ 200:请求成功 301、302：永久重定向/暂时重定向 400：请求格式错误 404：找不到资源 500：服务器内部错误 怎么让一个图片在一个DIV中垂直居中对齐？ 父元素使用相对定位 子元素使用绝对定位 怎么让文字垂直居中对齐？ 一行文字父元素不固定：padding:20px 父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell 如何让图片跟文字在居中显示： 父元素设置为vertical-align:middle 浏览器兼容？ 1、不同的浏览器默认样式不一样：padding margin 2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden 3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距 页面优化/站点优化？ 1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度 2、代码压缩/css/js yui compressor 数组的方法： join concat push pop unshift shift slice splice 正则表达式： \\d数字 \\s空白字符 \\w数字、字母、下划线 ？ 0-1 或 改为懒惰模式 0-n 1-n ^ 开关 $ 结尾 \\b 边界 new 一个对象具体干了什么？ 第一步是建立一个新对象； 第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象； 第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。 如何判断一个对象是否为数组？ typeof &quot;sflkj&quot; typeof无法判断数组跟对象 [] instanceof Array Array.prototype.isPrototypeOf([]) Array.isArray([]) 获取一个选项卡的值？ aa bb function showinfo(){ var sel=document.getElementById(\"s1\"); var i=sel.selectedIndex; var result=sel.options[i].value; } 浏览器对象有哪些？ navigator history window location screen event document window对象的常用方法？ alert confirm prompt close js绑定事件： btnObj.addEventListener(&quot;click&quot;,function(){}) jquery 把变量$的控制权交给其他JS库 jQuery.noConflict(); jQuery(function($){}) jQuery 遍历？（$.each()方法） asdf luili 234 var m=$(\"ul li\"); m.each(function(i){ if(i==0){ $(this).css(\"font-size\",\"18px\") } }) 怎么把一个JSON字符串转换成一个js对象？ var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} 把一个js对象转换成一个josn字符吕？ var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' 表单序列化成字符串：serialize（） 序列化成json对象：serializeArray() 手机端头部怎么写？ 不通过插件实现自响应布局？ CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局 CSS的媒体查询？ @media screen and(min-width:990px){//(一个css文件内) #id{ float:left } } @media screen and(min-width:700px) and (max-width:989px){ #id{ float:left } @media screen and(max-width:699px){ } angularjs？ 采用MVC模式 数据绑定 依赖注入 模块化设计 初始化一个模型数据 ng-bind=&quot;name&quot; ng-repeat=&quot;data in array&quot; angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){ .controller(&quot;myCtrl&quot;,function($scope){ $scope.newsTitle=&quot;hello&quot; }) } 什么是高内聚，低耦合？ 高内聚：一个模块内的元素的关系赵紧密越好 低耦合：不同模块间的关系尽量不要有关联 ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/"},{"title":"前端面试题目（一）","content":"什么是闭包？ 指有权访问另一个函数作用域中变量的函数 null 和undefined的区别？ 共同点：都是原始类型，保存在栈中变量本地 不同点： undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用 null:表示一个变量不再指向任何对象地址 表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用 常见行内元素和块级元素有哪些，他们有什么区别？ 行内元素：span img a u s i input select 块级元素：div ul ol li dt dd h1-h6 块级元素会单独占一行，行内元素会在一行显示。 什么是ajax？ ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。 实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新： 如何创建XMLHttpRequest请求步骤： 1、获取ajax对象 var xhr=new XMLHttpRequest(); 2、创建请求:调用XMLHttpRequest对象的open方法 xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步]) 3、回调函数的处理 xhr.onreadystatechange=function(){ if(xhr.readyState4){ if(xhr.status200){ var txt=xhr.responseText/responseXML } } } 4、发送请求 xhr.send(&quot;name=value$pwd=value&quot;); readyState属性： 0=未初始化 1=正在加载 2=以加载 3=交互中 4=加载完成 Ajax异步请求？ .ajax( { url:&quot;destination.php&quot;, type:&quot;post&quot;, data:(&quot;#id&quot;).val(), dataType:&quot;json&quot;, success:function(data){ console.log(data) } error:function(){ window.alert(&quot;error&quot;) } } ) AJAX的优缺点？ 优点： 页面局部刷新，提高用户体验 减轻服务器负担 具有更迅速的响应能力 能被广泛支持 缺点： 不支持浏览器后退按钮 安全问题 对搜索引擎支持比较弱 html中有哪些定位？ static:默认规则定位。 absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间 relative:相对定位，相对于初始位置定位/占页面空间 fixed:固定定位，相对于浏览器窗口 http 建立TCP连接 发送请求命令 发送请求头部 服务器应答 服务器发送应答头部 服务器发送应答具体信息 关闭连接 如何居中DIV？ 给DIV设置一个宽度，再设置margin为:0 auto; 如何居中一个浮动元素？ 使用一个居中显示的DIV包含些浮动元素。 position:fixed;//固定定位 width: 200px; height: 200px; background: red; margin-left:-100px; margin-top: -100px; left: 50%; top: 50%; 纯CSS实现一个三角形？ width: 0; height: 0; border:25px solid transparent; border-top-color: red; 重写trim()方法 if(String.prototype.trim===undefined){ String.prototype.trim=function () { return this.replace(/^\\s+|\\s+$/g) } } var str=&quot; helloworld &quot;; document.write(&quot;|&quot;+str+&quot;| &quot;); str=str.trim(); document.write(&quot;|&quot;+str+&quot;|&quot;); function trim(str){//同时去掉开头和结尾的空字符 var reg=/^\\s+|\\s+$/g; return str.replace(reg,&quot;&quot;); } var str=&quot; zhang dong &quot;; console.log(ltrim(str));//&quot;zhang dong &quot; console.log(rtrim(str));//&quot; zhang dong&quot; console.log(trim(str));//&quot;zhang dong&quot; 水仙花数 var a,b,c for(var i=100;i&lt;1000;i++){ a=parseInt(i%10); b=parseInt((i/10)%10); c=parseInt(i/100); if(iaaa+bbb+ccc){ console.log(i); } } 判断某一年是不是闰年 function isLeap(year){ console.log(year%40&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;); } isLeap(prompt(&quot;主输入年份&quot;)); 在单词后面加上数字 var str=&quot;one two three four&quot;; var i=4; var reg=/\\b[a-z]+\\b/g; str=str.replace(reg,function(kw){ return kw+i++; }) console.log(str); 判断是不是数组 var str=[] Array.prototype.isPrototypeOf(str);//true Object.prototype.toString.call(str);//[Object Array]; str instanceof Array; Array.isArray([]) 什么是继承？ 父对象已有的成员，子对象不用重复定义，就可以直接使用 什么是原型？ 每个函数都有一个prototype属性，该属性引用的就是原型对象， 原型对象就是保存共有属性和方法的对象 window窗口的全局对象？ history navigator screen location event 动态加载Dom? var frg=document.createDocumentFragment(); var m=document.createElement(&quot;div&quot;); m.innerHTML=&quot;this is first page&quot;; frg.appendChild(m); document.body.appendChild(frg); 数组去重？ var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] function unique(arr){ for(var i=0,arr2={};i&lt;arr.length;i++){ arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1); } var arr=[]; for(var key in arr2){ arr.push(key) } return arr; } console.log(unique(arr)); var arr1=[2,5,9,1,7] function sort(arr){ for(var i=0;iarr[j+1]]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } sort(arr1); console.log(arr1) 数组降维 var arr=[[1,2,3],[1,3,2]]; var res=Array.prototype.concat.apply([],arr) console.log(res); 如何理解HTML语义化？ 可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性 常用的语义化标签： 哪些属性可以继承？ font-size font-family color display:none和visibility:hidden的区别？ display不占据页面空间 visibility仍然占据空间 css3伪类选择器 :enabled :disabled :checked :firtt-child :last-child 为什么建议在设置背景图像的同时还设置背景颜色？ 如果因为各种原因图片无法加载的时候，页面会显示背景颜色。 CSS sprite的优缺点？ 把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位 优点： 减少网页的http请求，提高性能 减少图片的大小 维护更方便，只需要在一张图片上修改就可以。 缺点： 图片合成比较麻烦 背景设置时需要得到每一个图片的精确位置 CSS3新特性 box-shadow border-radius text-shadow ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/"}]}