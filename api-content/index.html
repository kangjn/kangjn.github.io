{"posts":[{"title":"RabbitMQ使用教程(五)","content":"4.7.主题模式（通配符模式） 4.7.1.图示 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 4.7.2.生产者 package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.zpc.rabbitmq.util.ConnectionUtil; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;); // 消息内容 String message = &quot;Hello World!!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 4.7.3.消费者1（前台系统） package com.zpc.rabbitmq.topic; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.7.4.消费者2（搜索系统） package com.zpc.rabbitmq.topic; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2_x] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 5.Springboot集成RabbitMQ springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。 5.1.简单队列 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持 org.springframework.boot spring-boot-starter-amqp 2、配置application.properties文件 配置rabbitmq的安装地址、端口以及账户信息 spring.application.name=spirng-boot-rabbitmq spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=admin spring.rabbitmq.password=admin 3、配置队列 package com.zpc.rabbitmq; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitConfig { @Bean public Queue queue() { return new Queue(&quot;q_hello&quot;); } } 4、发送者 package com.zpc.rabbitmq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.text.SimpleDateFormat; import java.util.Date; @Component public class HelloSender { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } } 5、接收者 package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver : &quot; + hello); } } 6、测试 package com.zpc.rabbitmq; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMqHelloTest { @Autowired private HelloSender helloSender; @Test public void hello() throws Exception { helloSender.send(); } } 5.2.多对多使用（Work模式） 注册两个Receiver: package com.zpc.rabbitmq; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_hello&quot;) public class HelloReceiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } @Test public void oneToMany() throws Exception { for (int i=0;i&lt;100;i++){ helloSender.send(i); Thread.sleep(300); } } public void send(int i) { String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());//24小时制 String context = &quot;hello &quot; + i + &quot; &quot; + date; System.out.println(&quot;Sender : &quot; + context); //简单对列的情况下routingKey即为Q名 this.rabbitTemplate.convertAndSend(&quot;q_hello&quot;, context); } 5.3.Topic Exchange（主题模式） topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 首先对topic规则配置，这里使用两个队列(消费者)来演示。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig { final static String message = &quot;q_topic_message&quot;; final static String messages = &quot;q_topic_messages&quot;; @Bean public Queue queueMessage() { return new Queue(TopicRabbitConfig.message); } @Bean public Queue queueMessages() { return new Queue(TopicRabbitConfig.messages); } /** * 声明一个Topic类型的交换机 * @return */ @Bean TopicExchange exchange() { return new TopicExchange(&quot;mybootexchange&quot;); } /** * 绑定Q到交换机,并且指定routingKey * @param queueMessage * @param exchange * @return */ @Bean Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) { return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;); } @Bean Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) { return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;); } } 2)创建2个消费者 q_topic_message 和q_topic_messages package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_message&quot;) public class Receiver1 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver1 : &quot; + hello); } } package com.zpc.rabbitmq.topic; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_topic_messages&quot;) public class Receiver2 { @RabbitHandler public void process(String hello) { System.out.println(&quot;Receiver2 : &quot; + hello); } } 3)消息发送者（生产者） package com.zpc.rabbitmq.topic; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSender { @Autowired private AmqpTemplate rabbitTemplate; public void send1() { String context = &quot;hi, i am message 1&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.message&quot;, context); } public void send2() { String context = &quot;hi, i am messages 2&quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootexchange&quot;, &quot;topic.messages&quot;, context); } } send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。 4)测试 package com.zpc.rabbitmq.topic; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitTopicTest { @Autowired private MsgSender msgSender; @Test public void send1() throws Exception { msgSender.send1(); } @Test public void send2() throws Exception { msgSender.send2(); } } 5.4.Fanout Exchange（订阅模式） Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 1)配置队列，绑定交换机 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanoutRabbitConfig { @Bean public Queue aMessage() { return new Queue(&quot;q_fanout_A&quot;); } @Bean public Queue bMessage() { return new Queue(&quot;q_fanout_B&quot;); } @Bean public Queue cMessage() { return new Queue(&quot;q_fanout_C&quot;); } @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(&quot;mybootfanoutExchange&quot;); } @Bean Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(aMessage).to(fanoutExchange); } @Bean Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(bMessage).to(fanoutExchange); } @Bean Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) { return BindingBuilder.bind(cMessage).to(fanoutExchange); } } 2）创建3个消费者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_A&quot;) public class ReceiverA { @RabbitHandler public void process(String hello) { System.out.println(&quot;AReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_B&quot;) public class ReceiverB { @RabbitHandler public void process(String hello) { System.out.println(&quot;BReceiver : &quot; + hello + &quot;/n&quot;); } } package com.zpc.rabbitmq.fanout; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;q_fanout_C&quot;) public class ReceiverC { @RabbitHandler public void process(String hello) { System.out.println(&quot;CReceiver : &quot; + hello + &quot;/n&quot;); } } 3）生产者 package com.zpc.rabbitmq.fanout; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MsgSenderFanout { @Autowired private AmqpTemplate rabbitTemplate; public void send() { String context = &quot;hi, fanout msg &quot;; System.out.println(&quot;Sender : &quot; + context); this.rabbitTemplate.convertAndSend(&quot;mybootfanoutExchange&quot;,&quot;&quot;, context); } } 4）测试 package com.zpc.rabbitmq.fanout; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitFanoutTest { @Autowired private MsgSenderFanout msgSender; @Test public void send1() throws Exception { msgSender.send(); } } 结果如下，三个消费者都收到消息： AReceiver : hi, fanout msg CReceiver : hi, fanout msg BReceiver : hi, fanout msg 6.总结 使用MQ实现商品数据的同步优势： 1、降低系统间耦合度 2、便于管理数据的同步（数据一致性） 推荐阅读 《RabbitMQ详解》 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-wu/"},{"title":"RabbitMQ使用教程(四)","content":"4.4.消息的确认模式 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？ 模式1：自动确认 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。 模式2：手动确认 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。 手动模式： 自动模式： 4.5.订阅模式 4.5.1.图示 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费 4.5.2.消息的生产者（看作是后台系统） 向交换机中发送消息。 package com.zpc.rabbitmq.subscribe; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明exchange channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); channel.close(); connection.close(); } } 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。 4.5.3.消费者1（看作是前台系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work1&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.4.消费者2（看作是搜索系统） package com.zpc.rabbitmq.subscribe; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work2&quot;; private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;); // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, false, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [Recv2] Received '&quot; + message + &quot;'&quot;); Thread.sleep(10); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.5.5.测试 测试结果： 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。 在管理工具中查看队列和交换机的绑定关系： 4.6.路由模式 4.6.1.图示 4.6.2.生产者 4.6.3.消费者1(假设是前台系统) 4.6.4.消费2（假设是搜索系统） ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-si/"},{"title":"RabbitMQ使用教程(三)","content":"4、学习五种队列 4.1 简单队列 4.1.1.图示 P：消息的生产者 C：消息的消费者 红色：队列 生产者将消息发送到队列，消费者从队列中获取消息。 4.1.2.导入RabbitMQ的客户端依赖 com.rabbitmq amqp-client 3.4.1 4.1.3.获取MQ的连接 package com.zpc.rabbitmq.util; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; public class ConnectionUtil { public static Connection getConnection() throws Exception { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost(&quot;localhost&quot;); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost(&quot;testhost&quot;); factory.setUsername(&quot;admin&quot;); factory.setPassword(&quot;admin&quot;); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 4.1.4.生产者发送消息到队列 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明（创建）队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); //关闭通道和连接 channel.close(); connection.close(); } } 4.1.5.管理工具中查看消息 点击上面的队列名称，查询具体的队列中的信息： 4.1.6.消费者从队列中获取消息 package com.zpc.rabbitmq.simple; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; public class Recv { private final static String QUEUE_NAME = &quot;q_test_01&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); } } } 4.2.Work模式 4.2.1.图示 一个生产者、2个消费者。 一个消息只能被一个消费者获取。 4.2.2.消费者1 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [y] Received '&quot; + message + &quot;'&quot;); //休眠 Thread.sleep(10); // 返回确认状态，注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false)； } } } 4.2.3.消费者2 package com.zpc.rabbitmq.work; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.QueueingConsumer; import com.zpc.rabbitmq.util.ConnectionUtil; public class Recv2 { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 同一时刻服务器只会发一条消息给消费者 //channel.basicQos(1); // 定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, true, consumer); // 获取消息 while (true) { QueueingConsumer.Delivery delivery = consumer.nextDelivery(); String message = new String(delivery.getBody()); System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;); // 休眠1秒 Thread.sleep(1000); //下面这行注释掉表示使用自动确认模式 //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } } } 4.2.4.生产者 向队列中发送100条消息。 package com.zpc.rabbitmq.work; import com.zpc.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; public class Send { private final static String QUEUE_NAME = &quot;test_queue_work&quot;; public static void main(String[] argv) throws Exception { // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); for (int i = 0; i &lt; 100; i++) { // 消息内容 String message = &quot;&quot; + i; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;); Thread.sleep(i * 10); } channel.close(); connection.close(); } } 4.2.5.测试 测试结果： 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。 RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。 basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。 2个概念 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。 4.3.Work模式的“能者多劳” 打开上述代码的注释： // 同一时刻服务器只会发一条消息给消费者 channel.basicQos(1); //开启这行 表示使用手动确认模式 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 同时改为手动确认： // 监听队列，false表示手动返回完成状态，true表示自动 channel.basicConsume(QUEUE_NAME, false, consumer); 测试： 消费者1比消费者2获取的消息更多。 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-san/"},{"title":"RabbitMQ使用教程(二)","content":"2.4.学习5种队列 2.5.安装文档 3.搭建RabbitMQ环境 3.1.下载 下载地址：http://www.rabbitmq.com/download.html 3.2.windows下安装 3.2.1.安装Erlang 下载：http://www.erlang.org/download/otp_win64_17.3.exe 后 安装 3.2.2.安装RabbitMQ 3.2.3.启用管理工具 1、双击 2、进入C:\\Program Files (x86)\\RabbitMQ Server\\rabbitmq_server-3.4.1\\sbin输入命令： rabbitmq-plugins enable rabbitmq_management 这样就启动了管理工具，可以试一下命令： 停止：net stop RabbitMQ 启动：net start RabbitMQ 3、在浏览器中输入地址查看：http://127.0.0.1:15672/ 4、使用默认账号登录：guest/ guest 3.3.Linux下安装 3.3.1.安装Erlang 3.3.2.添加yum支持 cd /usr/local/src/ mkdir rabbitmq cd rabbitmq wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc 使用yum安装： sudo yum install erlang 3.3.3.安装RabbitMQ 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/ 安装： rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 3.3.4.启动、停止 service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 3.3.5.设置开机启动 chkconfig rabbitmq-server on 3.3.6.设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 3.3.7.开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 注意要去掉后面的逗号。 3.3.8.开启web界面管理工具 rabbitmq-plugins enable rabbitmq_management service rabbitmq-server restart 3.3.9.防火墙开放15672端口 /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT /etc/rc.d/init.d/iptables save 3.4.安装的注意事项 1、推荐使用默认的安装路径 2、系统用户名必须是英文 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-er/"},{"title":"RabbitMQ使用教程(一)","content":"1.什么是MQ 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。 其主要用途：不同进程Process/线程Thread之间通信。 为什么会产生消息队列？有几个原因： 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列； 关于消息队列的详细介绍请参阅： 《Java帝国之消息队列》 《一个故事告诉你什么是消息队列》 《到底什么时候该使用MQ》 MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。 2.RabbitMQ 2.1.RabbitMQ的简介 开发语言：Erlang – 面向并发的编程语言。 2.1.1.AMQP AMQP是消息队列的一个协议。 2.2.官网 2.3.MQ的其他产品 ","link":"https://kangjn.github.io/post/rabbitmq-shi-yong-jiao-cheng-yi/"},{"title":"前端面试题目（二）","content":"解决HTML5新标签的兼容性： &lt;![if lt IE 9]&gt; //解决IE6-8支持HTML5新元素 //解决IE6-8对css Media Query//媒体查询 &lt;![endif]&gt; a:hover，a:active失效的问题？(lvha) 现象： a标签的伪类选择器，在点击之后，一直保持为a:visited的样式。a:hover，a:active的css失效了。 解决方式： a:link {color:black} a:visited{color:pink} a:hover {color: blue} a:active {color: green} 将a:visited样式写在前面，一种顺序为：a:link{} a:visited{} a:hover{} a:active{}。 如果写成这样：a:link{} a:hover{} a:active{} a:visited{} 可能是a:visited{}将a:hover{} a:active{}的样式给覆盖了。 为了产生预期的效果，在CSS定义中，a:hover必须位于a:link和a:visited之后，a:active必须位于a:hover之后。 选择器优先级？ 内联样式&gt;内部样式&gt;外部样式 ！important&gt;内联样式（1000）&gt;id(100)&gt;class(10)&gt;标签》继承样式 注意： 1、!important声明的样式优先级最高，如果冲突再进行计算。 2、如果优先级相同，则选择最后出现的样式。 3、继承得到的样式的优先级最低。 文本怎么自动换行？ word-wrap:允许对长的不可分割的单词进行分割并换行到下一行。 word-wrap:normal word-wrap:break-word box-sizing模型？ content-box:默认 padding和border不包含在元素的宽度内，元素的实际宽度为：width+border+padding border-box: padding和border包含在元素的宽度内，元素的实际宽度为：width js中创建自定义对象 ? var f=function(){} new Object() function f() this? 指向调用它的对象，如果没有，就指window HTML5表单新元素？ date time color number range email url search 5种常见的HTTP状态码及意义？ 200:请求成功 301、302：永久重定向/暂时重定向 400：请求格式错误 404：找不到资源 500：服务器内部错误 怎么让一个图片在一个DIV中垂直居中对齐？ 父元素使用相对定位 子元素使用绝对定位 怎么让文字垂直居中对齐？ 一行文字父元素不固定：padding:20px 父元素固定，多行文字：父元素：width:200px display:table 子元素:vertical-align:middle display:table-cell 如何让图片跟文字在居中显示： 父元素设置为vertical-align:middle 浏览器兼容？ 1、不同的浏览器默认样式不一样：padding margin 2、IE6低版本中，元素的调试包含内容，其他浏览器如果内容超出高度就会显示，可以设置overflow:hidden 3、子元素设置上外边距的时候，父元素需要设置边框或者上外边距，IE显示正常，其他浏览器就会变成父元素的外边距 页面优化/站点优化？ 1、CSS sprites:将多个背景图合并到一个图片上，再通过background-image 和background-position进行调整//会减少HTTP请求，加快页面显示速度 2、代码压缩/css/js yui compressor 数组的方法： join concat push pop unshift shift slice splice 正则表达式： \\d数字 \\s空白字符 \\w数字、字母、下划线 ？ 0-1 或 改为懒惰模式 0-n 1-n ^ 开关 $ 结尾 \\b 边界 new 一个对象具体干了什么？ 第一步是建立一个新对象； 第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象； 第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。 如何判断一个对象是否为数组？ typeof &quot;sflkj&quot; typeof无法判断数组跟对象 [] instanceof Array Array.prototype.isPrototypeOf([]) Array.isArray([]) 获取一个选项卡的值？ aa bb function showinfo(){ var sel=document.getElementById(\"s1\"); var i=sel.selectedIndex; var result=sel.options[i].value; } 浏览器对象有哪些？ navigator history window location screen event document window对象的常用方法？ alert confirm prompt close js绑定事件： btnObj.addEventListener(&quot;click&quot;,function(){}) jquery 把变量$的控制权交给其他JS库 jQuery.noConflict(); jQuery(function($){}) jQuery 遍历？（$.each()方法） asdf luili 234 var m=$(\"ul li\"); m.each(function(i){ if(i==0){ $(this).css(\"font-size\",\"18px\") } }) 怎么把一个JSON字符串转换成一个js对象？ var jt='{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' var jsObj=JSON.parse(jt)//{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} 把一个js对象转换成一个josn字符吕？ var jt={&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40} var jsObj=JSON.stringify(jt)//'{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:40}' 表单序列化成字符串：serialize（） 序列化成json对象：serializeArray() 手机端头部怎么写？ 不通过插件实现自响应布局？ CSS＋宽度百分比＋浮动＋媒体查询技术就可以手动实现响应式布局 CSS的媒体查询？ @media screen and(min-width:990px){//(一个css文件内) #id{ float:left } } @media screen and(min-width:700px) and (max-width:989px){ #id{ float:left } @media screen and(max-width:699px){ } angularjs？ 采用MVC模式 数据绑定 依赖注入 模块化设计 初始化一个模型数据 ng-bind=&quot;name&quot; ng-repeat=&quot;data in array&quot; angular.module(&quot;myApp&quot;,[&quot;ng&quot;]){ .controller(&quot;myCtrl&quot;,function($scope){ $scope.newsTitle=&quot;hello&quot; }) } 什么是高内聚，低耦合？ 高内聚：一个模块内的元素的关系赵紧密越好 低耦合：不同模块间的关系尽量不要有关联 ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-er/"},{"title":"前端面试题目（一）","content":"什么是闭包？ 指有权访问另一个函数作用域中变量的函数 null 和undefined的区别？ 共同点：都是原始类型，保存在栈中变量本地 不同点： undefined:表示变量声明但示被赋值。是所有未赋值变量的默认值，不主动使用 null:表示一个变量不再指向任何对象地址 表示变量可能指向一个对象，但目前暂时什么也没指向，一般用来主动释放指向对象的引用 常见行内元素和块级元素有哪些，他们有什么区别？ 行内元素：span img a u s i input select 块级元素：div ul ol li dt dd h1-h6 块级元素会单独占一行，行内元素会在一行显示。 什么是ajax？ ajax是一种在不需要重新加载页面的情况下与服务器进行数据交换、实现页面局部更新的一种技术。 实质是使用核心对象XMLHttpRequest异步向服务器发送请求，实现页面局部数据刷新： 如何创建XMLHttpRequest请求步骤： 1、获取ajax对象 var xhr=new XMLHttpRequest(); 2、创建请求:调用XMLHttpRequest对象的open方法 xhr.open(&quot;get/post&quot;,&quot;xx.php&quot;,true[是否为异步]) 3、回调函数的处理 xhr.onreadystatechange=function(){ if(xhr.readyState4){ if(xhr.status200){ var txt=xhr.responseText/responseXML } } } 4、发送请求 xhr.send(&quot;name=value$pwd=value&quot;); readyState属性： 0=未初始化 1=正在加载 2=以加载 3=交互中 4=加载完成 Ajax异步请求？ .ajax( { url:&quot;destination.php&quot;, type:&quot;post&quot;, data:(&quot;#id&quot;).val(), dataType:&quot;json&quot;, success:function(data){ console.log(data) } error:function(){ window.alert(&quot;error&quot;) } } ) AJAX的优缺点？ 优点： 页面局部刷新，提高用户体验 减轻服务器负担 具有更迅速的响应能力 能被广泛支持 缺点： 不支持浏览器后退按钮 安全问题 对搜索引擎支持比较弱 html中有哪些定位？ static:默认规则定位。 absolute:绝对定位 ，如果他的父级设置成了除static之外的定位方式，就会相对于他的父级定位，如果都没有，会相对于body定位、不占页面空间 relative:相对定位，相对于初始位置定位/占页面空间 fixed:固定定位，相对于浏览器窗口 http 建立TCP连接 发送请求命令 发送请求头部 服务器应答 服务器发送应答头部 服务器发送应答具体信息 关闭连接 如何居中DIV？ 给DIV设置一个宽度，再设置margin为:0 auto; 如何居中一个浮动元素？ 使用一个居中显示的DIV包含些浮动元素。 position:fixed;//固定定位 width: 200px; height: 200px; background: red; margin-left:-100px; margin-top: -100px; left: 50%; top: 50%; 纯CSS实现一个三角形？ width: 0; height: 0; border:25px solid transparent; border-top-color: red; 重写trim()方法 if(String.prototype.trim===undefined){ String.prototype.trim=function () { return this.replace(/^\\s+|\\s+$/g) } } var str=&quot; helloworld &quot;; document.write(&quot;|&quot;+str+&quot;| &quot;); str=str.trim(); document.write(&quot;|&quot;+str+&quot;|&quot;); function trim(str){//同时去掉开头和结尾的空字符 var reg=/^\\s+|\\s+$/g; return str.replace(reg,&quot;&quot;); } var str=&quot; zhang dong &quot;; console.log(ltrim(str));//&quot;zhang dong &quot; console.log(rtrim(str));//&quot; zhang dong&quot; console.log(trim(str));//&quot;zhang dong&quot; 水仙花数 var a,b,c for(var i=100;i&lt;1000;i++){ a=parseInt(i%10); b=parseInt((i/10)%10); c=parseInt(i/100); if(iaaa+bbb+ccc){ console.log(i); } } 判断某一年是不是闰年 function isLeap(year){ console.log(year%40&amp;&amp;year%100!=0||year%400==0?&quot;闰年&quot;:&quot;平年&quot;); } isLeap(prompt(&quot;主输入年份&quot;)); 在单词后面加上数字 var str=&quot;one two three four&quot;; var i=4; var reg=/\\b[a-z]+\\b/g; str=str.replace(reg,function(kw){ return kw+i++; }) console.log(str); 判断是不是数组 var str=[] Array.prototype.isPrototypeOf(str);//true Object.prototype.toString.call(str);//[Object Array]; str instanceof Array; Array.isArray([]) 什么是继承？ 父对象已有的成员，子对象不用重复定义，就可以直接使用 什么是原型？ 每个函数都有一个prototype属性，该属性引用的就是原型对象， 原型对象就是保存共有属性和方法的对象 window窗口的全局对象？ history navigator screen location event 动态加载Dom? var frg=document.createDocumentFragment(); var m=document.createElement(&quot;div&quot;); m.innerHTML=&quot;this is first page&quot;; frg.appendChild(m); document.body.appendChild(frg); 数组去重？ var arr=[1,2,3,3,4,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] function unique(arr){ for(var i=0,arr2={};i&lt;arr.length;i++){ arr2[arr[i]]===undefined&amp;&amp;(arr2[arr[i]]=1); } var arr=[]; for(var key in arr2){ arr.push(key) } return arr; } console.log(unique(arr)); var arr1=[2,5,9,1,7] function sort(arr){ for(var i=0;iarr[j+1]]){ var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } sort(arr1); console.log(arr1) 数组降维 var arr=[[1,2,3],[1,3,2]]; var res=Array.prototype.concat.apply([],arr) console.log(res); 如何理解HTML语义化？ 可以让页面内容结构化，便于浏览器解析，提高代码的可维护度和可重用性 常用的语义化标签： 哪些属性可以继承？ font-size font-family color display:none和visibility:hidden的区别？ display不占据页面空间 visibility仍然占据空间 css3伪类选择器 :enabled :disabled :checked :firtt-child :last-child 为什么建议在设置背景图像的同时还设置背景颜色？ 如果因为各种原因图片无法加载的时候，页面会显示背景颜色。 CSS sprite的优缺点？ 把网页中的一些背景图片整合到一张图片中，再利用background-image/repeat/position进行图片定位 优点： 减少网页的http请求，提高性能 减少图片的大小 维护更方便，只需要在一张图片上修改就可以。 缺点： 图片合成比较麻烦 背景设置时需要得到每一个图片的精确位置 CSS3新特性 box-shadow border-radius text-shadow ","link":"https://kangjn.github.io/post/qian-duan-mian-shi-ti-mu-yi/"}]}